
grbl-v9.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00012404  00080000  00080000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00092404  00092404  0001a404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000008c8  20000000  0009240c  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000e20  200008c8  00092cd4  000208c8  2**2
                  ALLOC
  4 .stack        00000400  200016e8  00093af4  000208c8  2**0
                  ALLOC
  5 .heap         00002000  20001ae8  00093ef4  000208c8  2**0
                  ALLOC
  6 .ARM.attributes 00000029  00000000  00000000  000208c8  2**0
                  CONTENTS, READONLY
  7 .comment      0000005b  00000000  00000000  000208f1  2**0
                  CONTENTS, READONLY
  8 .debug_info   00017e7a  00000000  00000000  0002094c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000356a  00000000  00000000  000387c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0001020a  00000000  00000000  0003bd30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000ca8  00000000  00000000  0004bf3a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cd0  00000000  00000000  0004cbe2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0001a2b4  00000000  00000000  0004d8b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00010b52  00000000  00000000  00067b66  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0005be51  00000000  00000000  000786b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000034fc  00000000  00000000  000d450c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	20001ae8 	.word	0x20001ae8
   80004:	000801c9 	.word	0x000801c9
   80008:	000801c5 	.word	0x000801c5
   8000c:	000801c5 	.word	0x000801c5
   80010:	000801c5 	.word	0x000801c5
   80014:	000801c5 	.word	0x000801c5
   80018:	000801c5 	.word	0x000801c5
	...
   8002c:	000801c5 	.word	0x000801c5
   80030:	000801c5 	.word	0x000801c5
   80034:	00000000 	.word	0x00000000
   80038:	000801c5 	.word	0x000801c5
   8003c:	000801c5 	.word	0x000801c5
   80040:	000801c5 	.word	0x000801c5
   80044:	000801c5 	.word	0x000801c5
   80048:	000801c5 	.word	0x000801c5
   8004c:	000801c5 	.word	0x000801c5
   80050:	000801c5 	.word	0x000801c5
   80054:	000801c5 	.word	0x000801c5
   80058:	000801c5 	.word	0x000801c5
   8005c:	000801c5 	.word	0x000801c5
   80060:	000801c5 	.word	0x000801c5
   80064:	000801c5 	.word	0x000801c5
   80068:	00000000 	.word	0x00000000
   8006c:	000801c5 	.word	0x000801c5
   80070:	000801c5 	.word	0x000801c5
   80074:	000801c5 	.word	0x000801c5
   80078:	000801c5 	.word	0x000801c5
	...
   80084:	000801c5 	.word	0x000801c5
   80088:	000801c5 	.word	0x000801c5
   8008c:	000801c5 	.word	0x000801c5
   80090:	000801c5 	.word	0x000801c5
   80094:	000801c5 	.word	0x000801c5
   80098:	000801c5 	.word	0x000801c5
   8009c:	000801c5 	.word	0x000801c5
   800a0:	000801c5 	.word	0x000801c5
   800a4:	00000000 	.word	0x00000000
   800a8:	000801c5 	.word	0x000801c5
   800ac:	00086a69 	.word	0x00086a69
   800b0:	000801c5 	.word	0x000801c5
   800b4:	000887f5 	.word	0x000887f5
   800b8:	000885f1 	.word	0x000885f1
   800bc:	000801c5 	.word	0x000801c5
   800c0:	000801c5 	.word	0x000801c5
   800c4:	000801c5 	.word	0x000801c5
   800c8:	000801c5 	.word	0x000801c5
   800cc:	000801c5 	.word	0x000801c5
   800d0:	000801c5 	.word	0x000801c5
   800d4:	000801c5 	.word	0x000801c5
   800d8:	000801c5 	.word	0x000801c5
   800dc:	000801c5 	.word	0x000801c5
   800e0:	000801c5 	.word	0x000801c5
   800e4:	000801c5 	.word	0x000801c5
   800e8:	000801c5 	.word	0x000801c5
   800ec:	000801c5 	.word	0x000801c5
   800f0:	000801c5 	.word	0x000801c5

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	200008c8 	.word	0x200008c8
   80110:	00000000 	.word	0x00000000
   80114:	0009240c 	.word	0x0009240c

00080118 <frame_dummy>:
   80118:	4b08      	ldr	r3, [pc, #32]	; (8013c <frame_dummy+0x24>)
   8011a:	b510      	push	{r4, lr}
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4808      	ldr	r0, [pc, #32]	; (80140 <frame_dummy+0x28>)
   80120:	4908      	ldr	r1, [pc, #32]	; (80144 <frame_dummy+0x2c>)
   80122:	f3af 8000 	nop.w
   80126:	4808      	ldr	r0, [pc, #32]	; (80148 <frame_dummy+0x30>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b903      	cbnz	r3, 8012e <frame_dummy+0x16>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	4b07      	ldr	r3, [pc, #28]	; (8014c <frame_dummy+0x34>)
   80130:	2b00      	cmp	r3, #0
   80132:	d0fb      	beq.n	8012c <frame_dummy+0x14>
   80134:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80138:	4718      	bx	r3
   8013a:	bf00      	nop
   8013c:	00000000 	.word	0x00000000
   80140:	0009240c 	.word	0x0009240c
   80144:	200008cc 	.word	0x200008cc
   80148:	0009240c 	.word	0x0009240c
   8014c:	00000000 	.word	0x00000000

00080150 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
   80150:	4a02      	ldr	r2, [pc, #8]	; (8015c <coolant_stop+0xc>)
   80152:	6b93      	ldr	r3, [r2, #56]	; 0x38
   80154:	f023 0308 	bic.w	r3, r3, #8
   80158:	6393      	str	r3, [r2, #56]	; 0x38
   8015a:	4770      	bx	lr
   8015c:	400e0e00 	.word	0x400e0e00

00080160 <coolant_init>:

#include "grbl.h"


void coolant_init()
{
   80160:	b508      	push	{r3, lr}
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
   80162:	4a04      	ldr	r2, [pc, #16]	; (80174 <coolant_init+0x14>)
   80164:	6b93      	ldr	r3, [r2, #56]	; 0x38
   80166:	f043 0308 	orr.w	r3, r3, #8
   8016a:	6393      	str	r3, [r2, #56]	; 0x38
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
   8016c:	4b02      	ldr	r3, [pc, #8]	; (80178 <coolant_init+0x18>)
   8016e:	4798      	blx	r3
   80170:	bd08      	pop	{r3, pc}
   80172:	bf00      	nop
   80174:	400e0e00 	.word	0x400e0e00
   80178:	00080151 	.word	0x00080151

0008017c <coolant_set_state>:
  #endif
}


void coolant_set_state(uint8_t mode)
{
   8017c:	b508      	push	{r3, lr}
  if (mode == COOLANT_FLOOD_ENABLE) {
   8017e:	2802      	cmp	r0, #2
   80180:	d105      	bne.n	8018e <coolant_set_state+0x12>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
   80182:	4a04      	ldr	r2, [pc, #16]	; (80194 <coolant_set_state+0x18>)
   80184:	6b93      	ldr	r3, [r2, #56]	; 0x38
   80186:	f043 0308 	orr.w	r3, r3, #8
   8018a:	6393      	str	r3, [r2, #56]	; 0x38
   8018c:	bd08      	pop	{r3, pc}
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
   8018e:	4b02      	ldr	r3, [pc, #8]	; (80198 <coolant_set_state+0x1c>)
   80190:	4798      	blx	r3
   80192:	bd08      	pop	{r3, pc}
   80194:	400e0e00 	.word	0x400e0e00
   80198:	00080151 	.word	0x00080151

0008019c <coolant_run>:
}


void coolant_run(uint8_t mode)
{
  if (sys.state == STATE_CHECK_MODE) { return; }
   8019c:	4b06      	ldr	r3, [pc, #24]	; (801b8 <coolant_run+0x1c>)
   8019e:	785b      	ldrb	r3, [r3, #1]
   801a0:	2b02      	cmp	r3, #2
   801a2:	d007      	beq.n	801b4 <coolant_run+0x18>
  }
}


void coolant_run(uint8_t mode)
{
   801a4:	b510      	push	{r4, lr}
   801a6:	4604      	mov	r4, r0
  if (sys.state == STATE_CHECK_MODE) { return; }
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
   801a8:	4b04      	ldr	r3, [pc, #16]	; (801bc <coolant_run+0x20>)
   801aa:	4798      	blx	r3
  coolant_set_state(mode);
   801ac:	4620      	mov	r0, r4
   801ae:	4b04      	ldr	r3, [pc, #16]	; (801c0 <coolant_run+0x24>)
   801b0:	4798      	blx	r3
   801b2:	bd10      	pop	{r4, pc}
   801b4:	4770      	bx	lr
   801b6:	bf00      	nop
   801b8:	20001484 	.word	0x20001484
   801bc:	00085369 	.word	0x00085369
   801c0:	0008017d 	.word	0x0008017d

000801c4 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
   801c4:	e7fe      	b.n	801c4 <Dummy_Handler>
   801c6:	bf00      	nop

000801c8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   801c8:	b508      	push	{r3, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
   801ca:	4b1a      	ldr	r3, [pc, #104]	; (80234 <Reset_Handler+0x6c>)
   801cc:	4a1a      	ldr	r2, [pc, #104]	; (80238 <Reset_Handler+0x70>)
   801ce:	429a      	cmp	r2, r3
   801d0:	d003      	beq.n	801da <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
   801d2:	4b1a      	ldr	r3, [pc, #104]	; (8023c <Reset_Handler+0x74>)
   801d4:	4a17      	ldr	r2, [pc, #92]	; (80234 <Reset_Handler+0x6c>)
   801d6:	429a      	cmp	r2, r3
   801d8:	d304      	bcc.n	801e4 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   801da:	4b19      	ldr	r3, [pc, #100]	; (80240 <Reset_Handler+0x78>)
   801dc:	4a19      	ldr	r2, [pc, #100]	; (80244 <Reset_Handler+0x7c>)
   801de:	429a      	cmp	r2, r3
   801e0:	d310      	bcc.n	80204 <Reset_Handler+0x3c>
   801e2:	e01b      	b.n	8021c <Reset_Handler+0x54>
   801e4:	4913      	ldr	r1, [pc, #76]	; (80234 <Reset_Handler+0x6c>)
   801e6:	1d0a      	adds	r2, r1, #4
   801e8:	4b17      	ldr	r3, [pc, #92]	; (80248 <Reset_Handler+0x80>)
   801ea:	1a9b      	subs	r3, r3, r2
   801ec:	f023 0303 	bic.w	r3, r3, #3
   801f0:	3304      	adds	r3, #4
   801f2:	4a11      	ldr	r2, [pc, #68]	; (80238 <Reset_Handler+0x70>)
   801f4:	4413      	add	r3, r2
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
                        *pDest++ = *pSrc++;
   801f6:	f852 0b04 	ldr.w	r0, [r2], #4
   801fa:	f841 0b04 	str.w	r0, [r1], #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   801fe:	429a      	cmp	r2, r3
   80200:	d1f9      	bne.n	801f6 <Reset_Handler+0x2e>
   80202:	e7ea      	b.n	801da <Reset_Handler+0x12>
   80204:	4b11      	ldr	r3, [pc, #68]	; (8024c <Reset_Handler+0x84>)
   80206:	4a12      	ldr	r2, [pc, #72]	; (80250 <Reset_Handler+0x88>)
   80208:	1ad2      	subs	r2, r2, r3
   8020a:	f022 0203 	bic.w	r2, r2, #3
   8020e:	441a      	add	r2, r3
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   80210:	3b04      	subs	r3, #4
                *pDest++ = 0;
   80212:	2100      	movs	r1, #0
   80214:	f843 1b04 	str.w	r1, [r3], #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   80218:	4293      	cmp	r3, r2
   8021a:	d1fb      	bne.n	80214 <Reset_Handler+0x4c>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   8021c:	4b0d      	ldr	r3, [pc, #52]	; (80254 <Reset_Handler+0x8c>)
   8021e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   80222:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   80226:	4a0c      	ldr	r2, [pc, #48]	; (80258 <Reset_Handler+0x90>)
   80228:	6093      	str	r3, [r2, #8]

        /* Initialize the C library */
        __libc_init_array();
   8022a:	4b0c      	ldr	r3, [pc, #48]	; (8025c <Reset_Handler+0x94>)
   8022c:	4798      	blx	r3

        /* Branch to main function */
        main();
   8022e:	4b0c      	ldr	r3, [pc, #48]	; (80260 <Reset_Handler+0x98>)
   80230:	4798      	blx	r3

        /* Infinite loop */
        while (1);
   80232:	e7fe      	b.n	80232 <Reset_Handler+0x6a>
   80234:	20000000 	.word	0x20000000
   80238:	0009240c 	.word	0x0009240c
   8023c:	200008c8 	.word	0x200008c8
   80240:	200016e8 	.word	0x200016e8
   80244:	200008c8 	.word	0x200008c8
   80248:	200008cb 	.word	0x200008cb
   8024c:	200008cc 	.word	0x200008cc
   80250:	200016eb 	.word	0x200016eb
   80254:	00080000 	.word	0x00080000
   80258:	e000ed00 	.word	0xe000ed00
   8025c:	0008cb61 	.word	0x0008cb61
   80260:	000839d1 	.word	0x000839d1

00080264 <SystemInit>:
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit( void )
{
  /* Set FWS according to SYS_BOARD_MCKR configuration */
  EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   80264:	f44f 6380 	mov.w	r3, #1024	; 0x400
   80268:	4a20      	ldr	r2, [pc, #128]	; (802ec <SystemInit+0x88>)
   8026a:	6013      	str	r3, [r2, #0]
  EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   8026c:	f502 7200 	add.w	r2, r2, #512	; 0x200
   80270:	6013      	str	r3, [r2, #0]

  /* Initialize main oscillator */
  if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
   80272:	4b1f      	ldr	r3, [pc, #124]	; (802f0 <SystemInit+0x8c>)
   80274:	6a1b      	ldr	r3, [r3, #32]
   80276:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   8027a:	d107      	bne.n	8028c <SystemInit+0x28>
  {
    PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
   8027c:	4a1d      	ldr	r2, [pc, #116]	; (802f4 <SystemInit+0x90>)
   8027e:	4b1c      	ldr	r3, [pc, #112]	; (802f0 <SystemInit+0x8c>)
   80280:	621a      	str	r2, [r3, #32]
    while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
   80282:	461a      	mov	r2, r3
   80284:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80286:	f013 0f01 	tst.w	r3, #1
   8028a:	d0fb      	beq.n	80284 <SystemInit+0x20>
    {
    }
  }

  /* Switch to 3-20MHz Xtal oscillator */
  PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;
   8028c:	4a1a      	ldr	r2, [pc, #104]	; (802f8 <SystemInit+0x94>)
   8028e:	4b18      	ldr	r3, [pc, #96]	; (802f0 <SystemInit+0x8c>)
   80290:	621a      	str	r2, [r3, #32]

  while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
   80292:	461a      	mov	r2, r3
   80294:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80296:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   8029a:	d0fb      	beq.n	80294 <SystemInit+0x30>
  {
  }
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   8029c:	4a14      	ldr	r2, [pc, #80]	; (802f0 <SystemInit+0x8c>)
   8029e:	6b13      	ldr	r3, [r2, #48]	; 0x30
   802a0:	f023 0303 	bic.w	r3, r3, #3
   802a4:	f043 0301 	orr.w	r3, r3, #1
   802a8:	6313      	str	r3, [r2, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
   802aa:	6e93      	ldr	r3, [r2, #104]	; 0x68
   802ac:	f013 0f08 	tst.w	r3, #8
   802b0:	d0fb      	beq.n	802aa <SystemInit+0x46>
  {
  }

  /* Initialize PLLA */
  PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
   802b2:	4a12      	ldr	r2, [pc, #72]	; (802fc <SystemInit+0x98>)
   802b4:	4b0e      	ldr	r3, [pc, #56]	; (802f0 <SystemInit+0x8c>)
   802b6:	629a      	str	r2, [r3, #40]	; 0x28
  while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
   802b8:	461a      	mov	r2, r3
   802ba:	6e93      	ldr	r3, [r2, #104]	; 0x68
   802bc:	f013 0f02 	tst.w	r3, #2
   802c0:	d0fb      	beq.n	802ba <SystemInit+0x56>
  {
  }

  /* Switch to main clock */
  PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   802c2:	2211      	movs	r2, #17
   802c4:	4b0a      	ldr	r3, [pc, #40]	; (802f0 <SystemInit+0x8c>)
   802c6:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   802c8:	461a      	mov	r2, r3
   802ca:	6e93      	ldr	r3, [r2, #104]	; 0x68
   802cc:	f013 0f08 	tst.w	r3, #8
   802d0:	d0fb      	beq.n	802ca <SystemInit+0x66>
  {
  }

  /* Switch to PLLA */
  PMC->PMC_MCKR = SYS_BOARD_MCKR;
   802d2:	2212      	movs	r2, #18
   802d4:	4b06      	ldr	r3, [pc, #24]	; (802f0 <SystemInit+0x8c>)
   802d6:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   802d8:	461a      	mov	r2, r3
   802da:	6e93      	ldr	r3, [r2, #104]	; 0x68
   802dc:	f013 0f08 	tst.w	r3, #8
   802e0:	d0fb      	beq.n	802da <SystemInit+0x76>
  {
  }

  SystemCoreClock = CHIP_FREQ_CPU_MAX;
   802e2:	4a07      	ldr	r2, [pc, #28]	; (80300 <SystemInit+0x9c>)
   802e4:	4b07      	ldr	r3, [pc, #28]	; (80304 <SystemInit+0xa0>)
   802e6:	601a      	str	r2, [r3, #0]
   802e8:	4770      	bx	lr
   802ea:	bf00      	nop
   802ec:	400e0a00 	.word	0x400e0a00
   802f0:	400e0600 	.word	0x400e0600
   802f4:	00370809 	.word	0x00370809
   802f8:	01370809 	.word	0x01370809
   802fc:	200d3f01 	.word	0x200d3f01
   80300:	0501bd00 	.word	0x0501bd00
   80304:	20000000 	.word	0x20000000

00080308 <eeprom_get_char>:
//	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
//	EEAR = addr; // Set EEPROM address register.
//	EECR = (1<<EERE); // Start EEPROM read operation.
//	return EEDR; // Return the byte read from EEPROM.
	return 0;
}
   80308:	2000      	movs	r0, #0
   8030a:	4770      	bx	lr

0008030c <eeprom_put_char>:
 *
 *  \param  addr  EEPROM address to write to.
 *  \param  new_value  New EEPROM value.
 */
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
   8030c:	4770      	bx	lr
   8030e:	bf00      	nop

00080310 <memcpy_to_eeprom_with_checksum>:
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
   80310:	b17a      	cbz	r2, 80332 <memcpy_to_eeprom_with_checksum+0x22>
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
   80312:	b410      	push	{r4}
   80314:	188a      	adds	r2, r1, r2
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
   80316:	2300      	movs	r3, #0
    checksum = (checksum << 1) || (checksum >> 7);
   80318:	2401      	movs	r4, #1
   8031a:	b90b      	cbnz	r3, 80320 <memcpy_to_eeprom_with_checksum+0x10>
   8031c:	09db      	lsrs	r3, r3, #7
   8031e:	e000      	b.n	80322 <memcpy_to_eeprom_with_checksum+0x12>
   80320:	4623      	mov	r3, r4
    checksum += *source;
   80322:	f811 0b01 	ldrb.w	r0, [r1], #1
   80326:	4403      	add	r3, r0
   80328:	b2db      	uxtb	r3, r3
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
   8032a:	4291      	cmp	r1, r2
   8032c:	d1f5      	bne.n	8031a <memcpy_to_eeprom_with_checksum+0xa>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
}
   8032e:	f85d 4b04 	ldr.w	r4, [sp], #4
   80332:	4770      	bx	lr

00080334 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
   80334:	b12a      	cbz	r2, 80342 <memcpy_from_eeprom_with_checksum+0xe>
   80336:	1882      	adds	r2, r0, r2
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
   80338:	2300      	movs	r3, #0
   8033a:	f800 3b01 	strb.w	r3, [r0], #1
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
   8033e:	4290      	cmp	r0, r2
   80340:	d1fb      	bne.n	8033a <memcpy_from_eeprom_with_checksum+0x6>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
}
   80342:	2001      	movs	r0, #1
   80344:	4770      	bx	lr
   80346:	bf00      	nop

00080348 <efc_init>:
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
   80348:	0212      	lsls	r2, r2, #8
   8034a:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
   8034e:	4311      	orrs	r1, r2
 * \param ul_fmr Value of mode register
 */
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
   80350:	6001      	str	r1, [r0, #0]
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
	return EFC_RC_OK;
}
   80352:	2000      	movs	r0, #0
   80354:	4770      	bx	lr
   80356:	bf00      	nop

00080358 <efc_set_wait_state>:
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
   80358:	6803      	ldr	r3, [r0, #0]

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
   8035a:	0209      	lsls	r1, r1, #8
   8035c:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
   80360:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
   80364:	430b      	orrs	r3, r1
 * \param ul_fmr Value of mode register
 */
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
   80366:	6003      	str	r3, [r0, #0]
   80368:	4770      	bx	lr
   8036a:	bf00      	nop

0008036c <efc_get_wait_state>:
 *
 * \return The number of wait states in cycle (no shift).
 */
uint32_t efc_get_wait_state(Efc *p_efc)
{
	return ((p_efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos);
   8036c:	6800      	ldr	r0, [r0, #0]
}
   8036e:	f3c0 2003 	ubfx	r0, r0, #8, #4
   80372:	4770      	bx	lr

00080374 <efc_perform_command>:
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
   80374:	f1a1 030e 	sub.w	r3, r1, #14
   80378:	2b01      	cmp	r3, #1
   8037a:	d917      	bls.n	803ac <efc_perform_command+0x38>
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
   8037c:	b510      	push	{r4, lr}
   8037e:	4604      	mov	r4, r0
	static uint32_t(*iap_perform_command) (uint32_t, uint32_t);
	uint32_t ul_efc_nb = (p_efc == EFC0) ? 0 : 1;

	iap_perform_command =
			(uint32_t(*)(uint32_t, uint32_t))
			*((uint32_t *) CHIP_FLASH_IAP_ADDRESS);
   80380:	4b0c      	ldr	r3, [pc, #48]	; (803b4 <efc_perform_command+0x40>)
	/* Use IAP function with 2 parameters in ROM. */
	static uint32_t(*iap_perform_command) (uint32_t, uint32_t);
	uint32_t ul_efc_nb = (p_efc == EFC0) ? 0 : 1;

	iap_perform_command =
			(uint32_t(*)(uint32_t, uint32_t))
   80382:	681b      	ldr	r3, [r3, #0]

	/* Use IAP function with 2 parameters in ROM. */
	static uint32_t(*iap_perform_command) (uint32_t, uint32_t);
	uint32_t ul_efc_nb = (p_efc == EFC0) ? 0 : 1;

	iap_perform_command =
   80384:	480c      	ldr	r0, [pc, #48]	; (803b8 <efc_perform_command+0x44>)
   80386:	6003      	str	r3, [r0, #0]
			(uint32_t(*)(uint32_t, uint32_t))
			*((uint32_t *) CHIP_FLASH_IAP_ADDRESS);
	iap_perform_command(ul_efc_nb,
			EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(ul_argument) |
   80388:	0212      	lsls	r2, r2, #8
   8038a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   8038e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   80392:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
   80396:	b2c9      	uxtb	r1, r1
	uint32_t ul_efc_nb = (p_efc == EFC0) ? 0 : 1;

	iap_perform_command =
			(uint32_t(*)(uint32_t, uint32_t))
			*((uint32_t *) CHIP_FLASH_IAP_ADDRESS);
	iap_perform_command(ul_efc_nb,
   80398:	4808      	ldr	r0, [pc, #32]	; (803bc <efc_perform_command+0x48>)
   8039a:	1a20      	subs	r0, r4, r0
   8039c:	bf18      	it	ne
   8039e:	2001      	movne	r0, #1
   803a0:	4311      	orrs	r1, r2
   803a2:	4798      	blx	r3
			EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
	return (p_efc->EEFC_FSR & EEFC_ERROR_FLAGS);
   803a4:	68a0      	ldr	r0, [r4, #8]
   803a6:	f000 0006 	and.w	r0, r0, #6
   803aa:	bd10      	pop	{r4, pc}
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
   803ac:	f04f 30ff 	mov.w	r0, #4294967295
   803b0:	4770      	bx	lr
   803b2:	bf00      	nop
   803b4:	00100008 	.word	0x00100008
   803b8:	200008e4 	.word	0x200008e4
   803bc:	400e0a00 	.word	0x400e0a00

000803c0 <crc7_one>:
static U8 crc7_one(U8 t, U8 data)
{
	int i;
	const U8 g = 0x89;

	t ^= data;
   803c0:	4048      	eors	r0, r1
   803c2:	2308      	movs	r3, #8
	for (i=0; i<8; i++) {
		if (t & 0x80)
   803c4:	f010 0f80 	tst.w	r0, #128	; 0x80
		t ^= g;
   803c8:	bf18      	it	ne
   803ca:	f080 0089 	eorne.w	r0, r0, #137	; 0x89
		t <<= 1;
   803ce:	0040      	lsls	r0, r0, #1
   803d0:	b2c0      	uxtb	r0, r0
{
	int i;
	const U8 g = 0x89;

	t ^= data;
	for (i=0; i<8; i++) {
   803d2:	3b01      	subs	r3, #1
   803d4:	d1f6      	bne.n	803c4 <crc7_one+0x4>
		if (t & 0x80)
		t ^= g;
		t <<= 1;
	}
	return t;
}
   803d6:	4770      	bx	lr

000803d8 <SPIWrite>:
//	spi_set_speed(SD_SPEED_400KHZ);
}
U8 SPIWrite(uint8_t val)
{
	//Wait for previous transfer to complete
	while ((SPI0->SPI_SR & SPI_SR_TXEMPTY) == 0);
   803d8:	4a0a      	ldr	r2, [pc, #40]	; (80404 <SPIWrite+0x2c>)
   803da:	6913      	ldr	r3, [r2, #16]
   803dc:	f413 7f00 	tst.w	r3, #512	; 0x200
   803e0:	d0fb      	beq.n	803da <SPIWrite+0x2>
	
	//load the Transmit Data Register with the value to transmit
	SPI0->SPI_TDR = val;
   803e2:	4b08      	ldr	r3, [pc, #32]	; (80404 <SPIWrite+0x2c>)
   803e4:	60d8      	str	r0, [r3, #12]
	
	//Wait for data to be transferred to serializer
	while ((SPI0->SPI_SR & SPI_SR_TDRE) == 0);
   803e6:	461a      	mov	r2, r3
   803e8:	6913      	ldr	r3, [r2, #16]
   803ea:	f013 0f02 	tst.w	r3, #2
   803ee:	d0fb      	beq.n	803e8 <SPIWrite+0x10>
    
	while ( (SPI0->SPI_SR & SPI_SR_RDRF) == 0 ) ;
   803f0:	4a04      	ldr	r2, [pc, #16]	; (80404 <SPIWrite+0x2c>)
   803f2:	6913      	ldr	r3, [r2, #16]
   803f4:	f013 0f01 	tst.w	r3, #1
   803f8:	d0fb      	beq.n	803f2 <SPIWrite+0x1a>

    return SPI0->SPI_RDR & 0x00FF ;	
   803fa:	4b02      	ldr	r3, [pc, #8]	; (80404 <SPIWrite+0x2c>)
   803fc:	6898      	ldr	r0, [r3, #8]
}
   803fe:	b2c0      	uxtb	r0, r0
   80400:	4770      	bx	lr
   80402:	bf00      	nop
   80404:	40008000 	.word	0x40008000

00080408 <sd_cmd>:

static void sd_cmd(U8 cmd, U32 arg)
{
   80408:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8040c:	460c      	mov	r4, r1
	U8 crc = 0;
	SPIWrite(0x40 | cmd);
   8040e:	f040 0640 	orr.w	r6, r0, #64	; 0x40
   80412:	4630      	mov	r0, r6
   80414:	4d14      	ldr	r5, [pc, #80]	; (80468 <sd_cmd+0x60>)
   80416:	47a8      	blx	r5
	crc = crc7_one(crc, 0x40 | cmd);
   80418:	2000      	movs	r0, #0
   8041a:	4631      	mov	r1, r6
   8041c:	4e13      	ldr	r6, [pc, #76]	; (8046c <sd_cmd+0x64>)
   8041e:	47b0      	blx	r6
   80420:	4680      	mov	r8, r0
	SPIWrite(arg >> 24);
   80422:	0e27      	lsrs	r7, r4, #24
   80424:	4638      	mov	r0, r7
   80426:	47a8      	blx	r5
	crc = crc7_one(crc, arg >> 24);
   80428:	4640      	mov	r0, r8
   8042a:	4639      	mov	r1, r7
   8042c:	47b0      	blx	r6
   8042e:	4680      	mov	r8, r0
	SPIWrite(arg >> 16);
   80430:	f3c4 4707 	ubfx	r7, r4, #16, #8
   80434:	4638      	mov	r0, r7
   80436:	47a8      	blx	r5
	crc = crc7_one(crc, arg >> 16);
   80438:	4640      	mov	r0, r8
   8043a:	4639      	mov	r1, r7
   8043c:	47b0      	blx	r6
   8043e:	4680      	mov	r8, r0
	SPIWrite(arg >> 8);
   80440:	f3c4 2707 	ubfx	r7, r4, #8, #8
   80444:	4638      	mov	r0, r7
   80446:	47a8      	blx	r5
	crc = crc7_one(crc, arg >> 8);
   80448:	4640      	mov	r0, r8
   8044a:	4639      	mov	r1, r7
   8044c:	47b0      	blx	r6
   8044e:	4607      	mov	r7, r0
	SPIWrite(arg);
   80450:	b2e4      	uxtb	r4, r4
   80452:	4620      	mov	r0, r4
   80454:	47a8      	blx	r5
	crc = crc7_one(crc, arg);
   80456:	4638      	mov	r0, r7
   80458:	4621      	mov	r1, r4
   8045a:	47b0      	blx	r6
	//SPIWrite(0x95);	/* crc7, for cmd0 */
	SPIWrite(crc | 0x1);	/* crc7, for cmd0 */
   8045c:	f040 0001 	orr.w	r0, r0, #1
   80460:	b2c0      	uxtb	r0, r0
   80462:	47a8      	blx	r5
   80464:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80468:	000803d9 	.word	0x000803d9
   8046c:	000803c1 	.word	0x000803c1

00080470 <sd_get_r1>:
	return crc>>1;
}


static U8 sd_get_r1()
{
   80470:	b570      	push	{r4, r5, r6, lr}
   80472:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
	int tries = 1000;
	U8 r;

	while (tries--) 
	{
		r = SPIWrite(0xff);
   80476:	26ff      	movs	r6, #255	; 0xff
   80478:	4d04      	ldr	r5, [pc, #16]	; (8048c <sd_get_r1+0x1c>)
   8047a:	4630      	mov	r0, r6
   8047c:	47a8      	blx	r5
		if ((r & 0x80) == 0)
   8047e:	f010 0f80 	tst.w	r0, #128	; 0x80
   80482:	d002      	beq.n	8048a <sd_get_r1+0x1a>
static U8 sd_get_r1()
{
	int tries = 1000;
	U8 r;

	while (tries--) 
   80484:	3c01      	subs	r4, #1
   80486:	d1f8      	bne.n	8047a <sd_get_r1+0xa>
	{
		r = SPIWrite(0xff);
		if ((r & 0x80) == 0)
			return r;
	}
	return 0xff;
   80488:	20ff      	movs	r0, #255	; 0xff
}
   8048a:	bd70      	pop	{r4, r5, r6, pc}
   8048c:	000803d9 	.word	0x000803d9

00080490 <sd_get_r7>:

/*
 * r1, then 32-bit reply... same format as r3
 */
static U8 sd_get_r7(U32 *r7)
{
   80490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80494:	4606      	mov	r6, r0
	U32 r;
	r = sd_get_r1();
   80496:	4b0d      	ldr	r3, [pc, #52]	; (804cc <sd_get_r7+0x3c>)
   80498:	4798      	blx	r3
   8049a:	4604      	mov	r4, r0
	if (r != 0x01)
   8049c:	2801      	cmp	r0, #1
   8049e:	d111      	bne.n	804c4 <sd_get_r7+0x34>
		return r;

	r = SPIWrite(0xff) << 24;
   804a0:	20ff      	movs	r0, #255	; 0xff
   804a2:	4f0b      	ldr	r7, [pc, #44]	; (804d0 <sd_get_r7+0x40>)
   804a4:	47b8      	blx	r7
   804a6:	4605      	mov	r5, r0
	r |= SPIWrite(0xff) << 16;
   804a8:	20ff      	movs	r0, #255	; 0xff
   804aa:	47b8      	blx	r7
   804ac:	0400      	lsls	r0, r0, #16
   804ae:	ea40 6505 	orr.w	r5, r0, r5, lsl #24
	r |= SPIWrite(0xff) << 8;
   804b2:	20ff      	movs	r0, #255	; 0xff
   804b4:	47b8      	blx	r7
   804b6:	4680      	mov	r8, r0
	r |= SPIWrite(0xff);
   804b8:	20ff      	movs	r0, #255	; 0xff
   804ba:	47b8      	blx	r7
   804bc:	4328      	orrs	r0, r5
   804be:	ea40 2008 	orr.w	r0, r0, r8, lsl #8

	*r7 = r;
   804c2:	6030      	str	r0, [r6, #0]
	return 0x01;
}
   804c4:	4620      	mov	r0, r4
   804c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   804ca:	bf00      	nop
   804cc:	00080471 	.word	0x00080471
   804d0:	000803d9 	.word	0x000803d9

000804d4 <sd_nec>:
}*/

/* Nec (=Ncr? which is limited to [0,8]) dummy bytes before lowering CS,
 * as described in sandisk doc, 5.4. */
static void sd_nec()
{
   804d4:	b570      	push	{r4, r5, r6, lr}
   804d6:	2408      	movs	r4, #8
	int i;
	for (i=0; i<8; i++)
		SPIWrite(0xff);
   804d8:	26ff      	movs	r6, #255	; 0xff
   804da:	4d03      	ldr	r5, [pc, #12]	; (804e8 <sd_nec+0x14>)
   804dc:	4630      	mov	r0, r6
   804de:	47a8      	blx	r5
/* Nec (=Ncr? which is limited to [0,8]) dummy bytes before lowering CS,
 * as described in sandisk doc, 5.4. */
static void sd_nec()
{
	int i;
	for (i=0; i<8; i++)
   804e0:	3c01      	subs	r4, #1
   804e2:	d1fb      	bne.n	804dc <sd_nec+0x8>
		SPIWrite(0xff);
}
   804e4:	bd70      	pop	{r4, r5, r6, pc}
   804e6:	bf00      	nop
   804e8:	000803d9 	.word	0x000803d9

000804ec <sd_init>:

static int sd_init(hwif *hw)
{
   804ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   804f0:	b082      	sub	sp, #8
   804f2:	4606      	mov	r6, r0
	U32 r7;
	U32 r3;
	int tries;
	U32 hcs = 0;

	hw->capabilities = 0;
   804f4:	2300      	movs	r3, #0
   804f6:	60c3      	str	r3, [r0, #12]

	/* start with 100-400 kHz clock */
//	spi_set_speed(SD_SPEED_400KHZ);
	spi_cs_high();
   804f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   804fc:	4bb1      	ldr	r3, [pc, #708]	; (807c4 <sd_init+0x2d8>)
   804fe:	631a      	str	r2, [r3, #48]	; 0x30
   80500:	240a      	movs	r4, #10
	/* 74+ clocks with CS high */
	for (i=0; i<10; i++)
		SPIWrite(0xFF);
   80502:	27ff      	movs	r7, #255	; 0xff
   80504:	4db0      	ldr	r5, [pc, #704]	; (807c8 <sd_init+0x2dc>)
   80506:	4638      	mov	r0, r7
   80508:	47a8      	blx	r5

	/* start with 100-400 kHz clock */
//	spi_set_speed(SD_SPEED_400KHZ);
	spi_cs_high();
	/* 74+ clocks with CS high */
	for (i=0; i<10; i++)
   8050a:	3c01      	subs	r4, #1
   8050c:	d1fb      	bne.n	80506 <sd_init+0x1a>
		SPIWrite(0xFF);

	/* reset */
	spi_cs_low();
   8050e:	4aaf      	ldr	r2, [pc, #700]	; (807cc <sd_init+0x2e0>)
   80510:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80512:	f413 7f80 	tst.w	r3, #256	; 0x100
   80516:	d0fb      	beq.n	80510 <sd_init+0x24>
   80518:	4daa      	ldr	r5, [pc, #680]	; (807c4 <sd_init+0x2d8>)
   8051a:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
   8051e:	636f      	str	r7, [r5, #52]	; 0x34
	sd_cmd(0, 0);
   80520:	2000      	movs	r0, #0
   80522:	4601      	mov	r1, r0
   80524:	4baa      	ldr	r3, [pc, #680]	; (807d0 <sd_init+0x2e4>)
   80526:	4798      	blx	r3
	r = sd_get_r1();
   80528:	4baa      	ldr	r3, [pc, #680]	; (807d4 <sd_init+0x2e8>)
   8052a:	4798      	blx	r3
   8052c:	4604      	mov	r4, r0
	sd_nec();
   8052e:	4baa      	ldr	r3, [pc, #680]	; (807d8 <sd_init+0x2ec>)
   80530:	4798      	blx	r3
	spi_cs_high();
   80532:	632f      	str	r7, [r5, #48]	; 0x30
	if (r == 0xff)
   80534:	2cff      	cmp	r4, #255	; 0xff
   80536:	f000 8117 	beq.w	80768 <sd_init+0x27c>
		goto err_spi;
	if (r != 0x01) {
   8053a:	2c01      	cmp	r4, #1
   8053c:	f040 8117 	bne.w	8076e <sd_init+0x282>
//	printf("success\n");


//	printf("cmd8 - voltage.. ");
	/* ask about voltage supply */
	spi_cs_low();
   80540:	4aa2      	ldr	r2, [pc, #648]	; (807cc <sd_init+0x2e0>)
   80542:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80544:	f413 7f80 	tst.w	r3, #256	; 0x100
   80548:	d0fb      	beq.n	80542 <sd_init+0x56>
   8054a:	4d9e      	ldr	r5, [pc, #632]	; (807c4 <sd_init+0x2d8>)
   8054c:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
   80550:	636f      	str	r7, [r5, #52]	; 0x34
	sd_cmd(8, 0x1aa /* VHS = 1 */);
   80552:	2008      	movs	r0, #8
   80554:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   80558:	4b9d      	ldr	r3, [pc, #628]	; (807d0 <sd_init+0x2e4>)
   8055a:	4798      	blx	r3
	r = sd_get_r7(&r7);
   8055c:	a801      	add	r0, sp, #4
   8055e:	4b9f      	ldr	r3, [pc, #636]	; (807dc <sd_init+0x2f0>)
   80560:	4798      	blx	r3
   80562:	4604      	mov	r4, r0
	sd_nec();
   80564:	4b9c      	ldr	r3, [pc, #624]	; (807d8 <sd_init+0x2ec>)
   80566:	4798      	blx	r3
	spi_cs_high();
   80568:	632f      	str	r7, [r5, #48]	; 0x30
	hw->capabilities |= CAP_VER2_00;
   8056a:	68f3      	ldr	r3, [r6, #12]
   8056c:	f043 0201 	orr.w	r2, r3, #1
   80570:	60f2      	str	r2, [r6, #12]
	if (r == 0xff)
   80572:	2cff      	cmp	r4, #255	; 0xff
   80574:	f000 80fe 	beq.w	80774 <sd_init+0x288>
		goto err_spi;
	if (r == 0x01)
   80578:	2c01      	cmp	r4, #1
   8057a:	d006      	beq.n	8058a <sd_init+0x9e>
	{
//		printf("success, SD v2.x\n");
	}else if (r & 0x4) {
   8057c:	f014 0f04 	tst.w	r4, #4
   80580:	f000 80fb 	beq.w	8077a <sd_init+0x28e>
		hw->capabilities &= ~CAP_VER2_00;
   80584:	f023 0301 	bic.w	r3, r3, #1
   80588:	60f3      	str	r3, [r6, #12]
	}


//	printf("cmd58 - ocr.. ");
	/* ask about voltage supply */
	spi_cs_low();
   8058a:	4a90      	ldr	r2, [pc, #576]	; (807cc <sd_init+0x2e0>)
   8058c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8058e:	f413 7f80 	tst.w	r3, #256	; 0x100
   80592:	d0fb      	beq.n	8058c <sd_init+0xa0>
   80594:	4d8b      	ldr	r5, [pc, #556]	; (807c4 <sd_init+0x2d8>)
   80596:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
   8059a:	636f      	str	r7, [r5, #52]	; 0x34
	sd_cmd(58, 0);
   8059c:	203a      	movs	r0, #58	; 0x3a
   8059e:	2100      	movs	r1, #0
   805a0:	4b8b      	ldr	r3, [pc, #556]	; (807d0 <sd_init+0x2e4>)
   805a2:	4798      	blx	r3
	r = sd_get_r3(&r3);
   805a4:	4668      	mov	r0, sp
   805a6:	4b8d      	ldr	r3, [pc, #564]	; (807dc <sd_init+0x2f0>)
   805a8:	4798      	blx	r3
   805aa:	4604      	mov	r4, r0
	sd_nec();
   805ac:	4b8a      	ldr	r3, [pc, #552]	; (807d8 <sd_init+0x2ec>)
   805ae:	4798      	blx	r3
	spi_cs_high();
   805b0:	632f      	str	r7, [r5, #48]	; 0x30
	if (r == 0xff)
   805b2:	2cff      	cmp	r4, #255	; 0xff
   805b4:	f000 80e4 	beq.w	80780 <sd_init+0x294>
		goto err_spi;
	if (r != 0x01 && !(r & 0x4)) { /* allow it to not be implemented - old cards */
   805b8:	2c01      	cmp	r4, #1
   805ba:	f000 8114 	beq.w	807e6 <sd_init+0x2fa>
   805be:	f014 0f04 	tst.w	r4, #4
   805c2:	f040 8110 	bne.w	807e6 <sd_init+0x2fa>
   805c6:	e0de      	b.n	80786 <sd_init+0x29a>
		return -2;
	}
	else {
		int i1;
		for (i1=4; i1<=23; i1++)
			if (r3 & 1<<i1)
   805c8:	2305      	movs	r3, #5
   805ca:	2001      	movs	r0, #1
   805cc:	fa00 f103 	lsl.w	r1, r0, r3
   805d0:	4211      	tst	r1, r2
   805d2:	f040 810d 	bne.w	807f0 <sd_init+0x304>
//		print_r1(r);
		return -2;
	}
	else {
		int i1;
		for (i1=4; i1<=23; i1++)
   805d6:	3301      	adds	r3, #1
   805d8:	2b18      	cmp	r3, #24
   805da:	d1f7      	bne.n	805cc <sd_init+0xe0>
   805dc:	e108      	b.n	807f0 <sd_init+0x304>
			if (r3 & 1<<i1)
				break;
//		printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
		for (i1=23; i1>=4; i1--)
			if (r3 & 1<<i1)
   805de:	fa00 f103 	lsl.w	r1, r0, r3
   805e2:	4211      	tst	r1, r2
   805e4:	d102      	bne.n	805ec <sd_init+0x100>
		int i1;
		for (i1=4; i1<=23; i1++)
			if (r3 & 1<<i1)
				break;
//		printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
		for (i1=23; i1>=4; i1--)
   805e6:	3b01      	subs	r3, #1
   805e8:	2b03      	cmp	r3, #3
   805ea:	d1f8      	bne.n	805de <sd_init+0xf2>


//	printf("acmd41 - hcs.. ");
	tries = 1000;
	/* say we support SDHC */
	if (hw->capabilities & CAP_VER2_00)
   805ec:	68f3      	ldr	r3, [r6, #12]
   805ee:	f003 0301 	and.w	r3, r3, #1
		hcs = 1<<30;
   805f2:	ea4f 7983 	mov.w	r9, r3, lsl #30
	int i;
	int r;
	U32 r7;
	U32 r3;
	int tries;
	U32 hcs = 0;
   805f6:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
		hcs = 1<<30;

	/* needs to be polled until in_idle_state becomes 0 */
	do {
		/* send we don't support SDHC */
		spi_cs_low();
   805fa:	4c74      	ldr	r4, [pc, #464]	; (807cc <sd_init+0x2e0>)
   805fc:	4d71      	ldr	r5, [pc, #452]	; (807c4 <sd_init+0x2d8>)
   805fe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   80600:	f413 7f80 	tst.w	r3, #256	; 0x100
   80604:	d0fb      	beq.n	805fe <sd_init+0x112>
   80606:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
   8060a:	636f      	str	r7, [r5, #52]	; 0x34
		/* next cmd is ACMD */
		sd_cmd(55, 0);
   8060c:	2037      	movs	r0, #55	; 0x37
   8060e:	2100      	movs	r1, #0
   80610:	4b6f      	ldr	r3, [pc, #444]	; (807d0 <sd_init+0x2e4>)
   80612:	4798      	blx	r3
		r = sd_get_r1();
   80614:	4b6f      	ldr	r3, [pc, #444]	; (807d4 <sd_init+0x2e8>)
   80616:	4798      	blx	r3
   80618:	4682      	mov	sl, r0
		sd_nec();
   8061a:	4b6f      	ldr	r3, [pc, #444]	; (807d8 <sd_init+0x2ec>)
   8061c:	4798      	blx	r3
		spi_cs_high();
   8061e:	632f      	str	r7, [r5, #48]	; 0x30
		if (r == 0xff)
   80620:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   80624:	f000 80b2 	beq.w	8078c <sd_init+0x2a0>
			goto err_spi;
		/* well... it's probably not idle here, but specs aren't clear */
		if (r & 0xfe) {
   80628:	f01a 0ffe 	tst.w	sl, #254	; 0xfe
   8062c:	f040 80b1 	bne.w	80792 <sd_init+0x2a6>
//			printf("fail\n");
//			print_r1(r);
			goto err;
		}

		spi_cs_low();
   80630:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   80632:	f413 7f80 	tst.w	r3, #256	; 0x100
   80636:	d0fb      	beq.n	80630 <sd_init+0x144>
   80638:	f04f 5a80 	mov.w	sl, #268435456	; 0x10000000
   8063c:	f8c5 a034 	str.w	sl, [r5, #52]	; 0x34
		sd_cmd(41, hcs);
   80640:	2029      	movs	r0, #41	; 0x29
   80642:	4649      	mov	r1, r9
   80644:	4b62      	ldr	r3, [pc, #392]	; (807d0 <sd_init+0x2e4>)
   80646:	4798      	blx	r3
		r = sd_get_r1();
   80648:	4b62      	ldr	r3, [pc, #392]	; (807d4 <sd_init+0x2e8>)
   8064a:	4798      	blx	r3
   8064c:	4607      	mov	r7, r0
		sd_nec();
   8064e:	4b62      	ldr	r3, [pc, #392]	; (807d8 <sd_init+0x2ec>)
   80650:	4798      	blx	r3
		spi_cs_high();
   80652:	f8c5 a030 	str.w	sl, [r5, #48]	; 0x30
		if (r == 0xff)
   80656:	2fff      	cmp	r7, #255	; 0xff
   80658:	f000 809e 	beq.w	80798 <sd_init+0x2ac>
			goto err_spi;
		if (r & 0xfe) {
   8065c:	f017 0ffe 	tst.w	r7, #254	; 0xfe
   80660:	f040 809d 	bne.w	8079e <sd_init+0x2b2>
//			printf("fail\n");
//			print_r1(r);
			goto err;
		}
	} while (r != 0 && tries--);
   80664:	b13f      	cbz	r7, 80676 <sd_init+0x18a>
   80666:	f108 38ff 	add.w	r8, r8, #4294967295
   8066a:	f1b8 3fff 	cmp.w	r8, #4294967295
   8066e:	d1c6      	bne.n	805fe <sd_init+0x112>

 err_spi:
//	printf("fail spi\n");
	return -1;
 err:
	return -2;
   80670:	f06f 0001 	mvn.w	r0, #1
   80674:	e0ca      	b.n	8080c <sd_init+0x320>
//			printf("fail\n");
//			print_r1(r);
			goto err;
		}
	} while (r != 0 && tries--);
	if (tries == -1) {
   80676:	f1b8 3fff 	cmp.w	r8, #4294967295
   8067a:	f000 8093 	beq.w	807a4 <sd_init+0x2b8>

	/* Seems after this card is initialized which means bit 0 of R1
	 * will be cleared. Not too sure. */


	if (hw->capabilities & CAP_VER2_00) {
   8067e:	68f3      	ldr	r3, [r6, #12]
   80680:	f013 0f01 	tst.w	r3, #1
   80684:	d036      	beq.n	806f4 <sd_init+0x208>
//		printf("cmd58 - ocr, 2nd time.. ");
		/* ask about voltage supply */
		spi_cs_low();
   80686:	4a51      	ldr	r2, [pc, #324]	; (807cc <sd_init+0x2e0>)
   80688:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8068a:	f413 7f80 	tst.w	r3, #256	; 0x100
   8068e:	d0fb      	beq.n	80688 <sd_init+0x19c>
   80690:	4d4c      	ldr	r5, [pc, #304]	; (807c4 <sd_init+0x2d8>)
   80692:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
   80696:	636f      	str	r7, [r5, #52]	; 0x34
		sd_cmd(58, 0);
   80698:	203a      	movs	r0, #58	; 0x3a
   8069a:	2100      	movs	r1, #0
   8069c:	4b4c      	ldr	r3, [pc, #304]	; (807d0 <sd_init+0x2e4>)
   8069e:	4798      	blx	r3
		r = sd_get_r3(&r3);
   806a0:	4668      	mov	r0, sp
   806a2:	4b4e      	ldr	r3, [pc, #312]	; (807dc <sd_init+0x2f0>)
   806a4:	4798      	blx	r3
   806a6:	4604      	mov	r4, r0
		sd_nec();
   806a8:	4b4b      	ldr	r3, [pc, #300]	; (807d8 <sd_init+0x2ec>)
   806aa:	4798      	blx	r3
		spi_cs_high();
   806ac:	632f      	str	r7, [r5, #48]	; 0x30
		if (r == 0xff)
   806ae:	2cff      	cmp	r4, #255	; 0xff
   806b0:	d07b      	beq.n	807aa <sd_init+0x2be>
			goto err_spi;
		if (r & 0xfe) {
   806b2:	f014 0ffe 	tst.w	r4, #254	; 0xfe
   806b6:	d17b      	bne.n	807b0 <sd_init+0x2c4>
		}
		else {
#if 1
			int i1;
			for (i1=4; i1<=23; i1++)
				if (r3 & 1<<i1)
   806b8:	9a00      	ldr	r2, [sp, #0]
   806ba:	f012 0f10 	tst.w	r2, #16
   806be:	f040 809e 	bne.w	807fe <sd_init+0x312>
   806c2:	2305      	movs	r3, #5
   806c4:	2001      	movs	r0, #1
   806c6:	fa00 f103 	lsl.w	r1, r0, r3
   806ca:	4211      	tst	r1, r2
   806cc:	f040 8097 	bne.w	807fe <sd_init+0x312>
			return -2;
		}
		else {
#if 1
			int i1;
			for (i1=4; i1<=23; i1++)
   806d0:	3301      	adds	r3, #1
   806d2:	2b18      	cmp	r3, #24
   806d4:	d1f7      	bne.n	806c6 <sd_init+0x1da>
   806d6:	e092      	b.n	807fe <sd_init+0x312>
				if (r3 & 1<<i1)
					break;
//			printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
			for (i1=23; i1>=4; i1--)
				if (r3 & 1<<i1)
   806d8:	fa00 f103 	lsl.w	r1, r0, r3
   806dc:	4211      	tst	r1, r2
   806de:	d102      	bne.n	806e6 <sd_init+0x1fa>
			int i1;
			for (i1=4; i1<=23; i1++)
				if (r3 & 1<<i1)
					break;
//			printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
			for (i1=23; i1>=4; i1--)
   806e0:	3b01      	subs	r3, #1
   806e2:	2b03      	cmp	r3, #3
   806e4:	d1f8      	bne.n	806d8 <sd_init+0x1ec>
			/* CCS shouldn't be valid here yet */
//			printf("%i.%iV, CCS:%li, power up status:%li\n",					(13+i)/10, (13+i)%10,					r3>>30 & 1, r3>>31);
			// XXX power up status should be 1 here, since we're finished initializing, but it's not. WHY?
			// that means CCS is invalid, so we'll set CAP_SDHC later
#endif
			if (r3>>30 & 1) {
   806e6:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
   806ea:	d003      	beq.n	806f4 <sd_init+0x208>
				hw->capabilities |= CAP_SDHC;
   806ec:	68f3      	ldr	r3, [r6, #12]
   806ee:	f043 0302 	orr.w	r3, r3, #2
   806f2:	60f3      	str	r3, [r6, #12]
		}
	}


	/* with SDHC block length is fixed to 1024 */
	if ((hw->capabilities & CAP_SDHC) == 0) {
   806f4:	68f3      	ldr	r3, [r6, #12]
   806f6:	f013 0f02 	tst.w	r3, #2
   806fa:	d118      	bne.n	8072e <sd_init+0x242>
//		printf("cmd16 - block length.. ");
		spi_cs_low();
   806fc:	4a33      	ldr	r2, [pc, #204]	; (807cc <sd_init+0x2e0>)
   806fe:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80700:	f413 7f80 	tst.w	r3, #256	; 0x100
   80704:	d0fb      	beq.n	806fe <sd_init+0x212>
   80706:	4d2f      	ldr	r5, [pc, #188]	; (807c4 <sd_init+0x2d8>)
   80708:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
   8070c:	636e      	str	r6, [r5, #52]	; 0x34
		sd_cmd(16, 512);
   8070e:	2010      	movs	r0, #16
   80710:	f44f 7100 	mov.w	r1, #512	; 0x200
   80714:	4b2e      	ldr	r3, [pc, #184]	; (807d0 <sd_init+0x2e4>)
   80716:	4798      	blx	r3
		r = sd_get_r1();
   80718:	4b2e      	ldr	r3, [pc, #184]	; (807d4 <sd_init+0x2e8>)
   8071a:	4798      	blx	r3
   8071c:	4604      	mov	r4, r0
		sd_nec();
   8071e:	4b2e      	ldr	r3, [pc, #184]	; (807d8 <sd_init+0x2ec>)
   80720:	4798      	blx	r3
		spi_cs_high();
   80722:	632e      	str	r6, [r5, #48]	; 0x30
		if (r == 0xff)
   80724:	2cff      	cmp	r4, #255	; 0xff
   80726:	d046      	beq.n	807b6 <sd_init+0x2ca>
			goto err_spi;
		if (r & 0xfe) {
   80728:	f014 0ffe 	tst.w	r4, #254	; 0xfe
   8072c:	d146      	bne.n	807bc <sd_init+0x2d0>
	}


//	printf("cmd59 - enable crc.. ");
	/* crc on */
	spi_cs_low();
   8072e:	4a27      	ldr	r2, [pc, #156]	; (807cc <sd_init+0x2e0>)
   80730:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80732:	f413 7f80 	tst.w	r3, #256	; 0x100
   80736:	d0fb      	beq.n	80730 <sd_init+0x244>
   80738:	4d22      	ldr	r5, [pc, #136]	; (807c4 <sd_init+0x2d8>)
   8073a:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
   8073e:	636e      	str	r6, [r5, #52]	; 0x34
	sd_cmd(59, 0);
   80740:	203b      	movs	r0, #59	; 0x3b
   80742:	2100      	movs	r1, #0
   80744:	4b22      	ldr	r3, [pc, #136]	; (807d0 <sd_init+0x2e4>)
   80746:	4798      	blx	r3
	r = sd_get_r1();
   80748:	4b22      	ldr	r3, [pc, #136]	; (807d4 <sd_init+0x2e8>)
   8074a:	4798      	blx	r3
   8074c:	4604      	mov	r4, r0
	sd_nec();
   8074e:	4b22      	ldr	r3, [pc, #136]	; (807d8 <sd_init+0x2ec>)
   80750:	4798      	blx	r3
	spi_cs_high();
   80752:	632e      	str	r6, [r5, #48]	; 0x30
	if (r == 0xff)
   80754:	2cff      	cmp	r4, #255	; 0xff
   80756:	d043      	beq.n	807e0 <sd_init+0x2f4>
		goto err_spi;
	if (r & 0xfe) {
   80758:	f004 04fe 	and.w	r4, r4, #254	; 0xfe

 err_spi:
//	printf("fail spi\n");
	return -1;
 err:
	return -2;
   8075c:	2c00      	cmp	r4, #0
   8075e:	bf0c      	ite	eq
   80760:	2000      	moveq	r0, #0
   80762:	f06f 0001 	mvnne.w	r0, #1
   80766:	e051      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   80768:	f04f 30ff 	mov.w	r0, #4294967295
   8076c:	e04e      	b.n	8080c <sd_init+0x320>
 err:
	return -2;
   8076e:	f06f 0001 	mvn.w	r0, #1
   80772:	e04b      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   80774:	f04f 30ff 	mov.w	r0, #4294967295
   80778:	e048      	b.n	8080c <sd_init+0x320>
		hw->capabilities &= ~CAP_VER2_00;
//		printf("not implemented, SD v1.x\n");
	} else {
//		printf("fail\n");
//		print_r1(r);
		return -2;
   8077a:	f06f 0001 	mvn.w	r0, #1
   8077e:	e045      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   80780:	f04f 30ff 	mov.w	r0, #4294967295
   80784:	e042      	b.n	8080c <sd_init+0x320>
	if (r == 0xff)
		goto err_spi;
	if (r != 0x01 && !(r & 0x4)) { /* allow it to not be implemented - old cards */
//		printf("fail\n");
//		print_r1(r);
		return -2;
   80786:	f06f 0001 	mvn.w	r0, #1
   8078a:	e03f      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   8078c:	f04f 30ff 	mov.w	r0, #4294967295
   80790:	e03c      	b.n	8080c <sd_init+0x320>
 err:
	return -2;
   80792:	f06f 0001 	mvn.w	r0, #1
   80796:	e039      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   80798:	f04f 30ff 	mov.w	r0, #4294967295
   8079c:	e036      	b.n	8080c <sd_init+0x320>
 err:
	return -2;
   8079e:	f06f 0001 	mvn.w	r0, #1
   807a2:	e033      	b.n	8080c <sd_init+0x320>
   807a4:	f06f 0001 	mvn.w	r0, #1
   807a8:	e030      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   807aa:	f04f 30ff 	mov.w	r0, #4294967295
   807ae:	e02d      	b.n	8080c <sd_init+0x320>
		if (r == 0xff)
			goto err_spi;
		if (r & 0xfe) {
//			printf("fail\n");
//			print_r1(r);
			return -2;
   807b0:	f06f 0001 	mvn.w	r0, #1
   807b4:	e02a      	b.n	8080c <sd_init+0x320>

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   807b6:	f04f 30ff 	mov.w	r0, #4294967295
   807ba:	e027      	b.n	8080c <sd_init+0x320>
 err:
	return -2;
   807bc:	f06f 0001 	mvn.w	r0, #1
   807c0:	e024      	b.n	8080c <sd_init+0x320>
   807c2:	bf00      	nop
   807c4:	400e0e00 	.word	0x400e0e00
   807c8:	000803d9 	.word	0x000803d9
   807cc:	400e1400 	.word	0x400e1400
   807d0:	00080409 	.word	0x00080409
   807d4:	00080471 	.word	0x00080471
   807d8:	000804d5 	.word	0x000804d5
   807dc:	00080491 	.word	0x00080491

	return 0;

 err_spi:
//	printf("fail spi\n");
	return -1;
   807e0:	f04f 30ff 	mov.w	r0, #4294967295
   807e4:	e012      	b.n	8080c <sd_init+0x320>
		return -2;
	}
	else {
		int i1;
		for (i1=4; i1<=23; i1++)
			if (r3 & 1<<i1)
   807e6:	9a00      	ldr	r2, [sp, #0]
   807e8:	f012 0f10 	tst.w	r2, #16
   807ec:	f43f aeec 	beq.w	805c8 <sd_init+0xdc>
				break;
//		printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
		for (i1=23; i1>=4; i1--)
			if (r3 & 1<<i1)
   807f0:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
   807f4:	f47f aefa 	bne.w	805ec <sd_init+0x100>
   807f8:	2316      	movs	r3, #22
   807fa:	2001      	movs	r0, #1
   807fc:	e6ef      	b.n	805de <sd_init+0xf2>
			for (i1=4; i1<=23; i1++)
				if (r3 & 1<<i1)
					break;
//			printf("Vdd voltage window: %i.%i-", (12+i)/10, (12+i)%10);
			for (i1=23; i1>=4; i1--)
				if (r3 & 1<<i1)
   807fe:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
   80802:	f47f af70 	bne.w	806e6 <sd_init+0x1fa>
   80806:	2316      	movs	r3, #22
   80808:	2001      	movs	r0, #1
   8080a:	e765      	b.n	806d8 <sd_init+0x1ec>
 err_spi:
//	printf("fail spi\n");
	return -1;
 err:
	return -2;
}
   8080c:	b002      	add	sp, #8
   8080e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   80812:	bf00      	nop

00080814 <sd_read_status>:

static int sd_read_status(hwif *hw)
{
   80814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	U16 r2;

	spi_cs_low();
   80816:	4a18      	ldr	r2, [pc, #96]	; (80878 <sd_read_status+0x64>)
   80818:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8081a:	f413 7f80 	tst.w	r3, #256	; 0x100
   8081e:	d0fb      	beq.n	80818 <sd_read_status+0x4>
   80820:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80824:	4b15      	ldr	r3, [pc, #84]	; (8087c <sd_read_status+0x68>)
   80826:	635a      	str	r2, [r3, #52]	; 0x34
	sd_cmd(13, 0);
   80828:	200d      	movs	r0, #13
   8082a:	2100      	movs	r1, #0
   8082c:	4b14      	ldr	r3, [pc, #80]	; (80880 <sd_read_status+0x6c>)
   8082e:	4798      	blx	r3
static U16 sd_get_r2()
{
	int tries = 1000;
	U16 r;

	while (tries--) {
   80830:	f240 34e7 	movw	r4, #999	; 0x3e7
		r = SPIWrite(0xff);
   80834:	27ff      	movs	r7, #255	; 0xff
   80836:	4e13      	ldr	r6, [pc, #76]	; (80884 <sd_read_status+0x70>)
   80838:	4638      	mov	r0, r7
   8083a:	47b0      	blx	r6
   8083c:	b285      	uxth	r5, r0
		if ((r & 0x80) == 0)
   8083e:	f010 0f80 	tst.w	r0, #128	; 0x80
   80842:	d005      	beq.n	80850 <sd_read_status+0x3c>
static U16 sd_get_r2()
{
	int tries = 1000;
	U16 r;

	while (tries--) {
   80844:	3c01      	subs	r4, #1
   80846:	f1b4 3fff 	cmp.w	r4, #4294967295
   8084a:	d1f5      	bne.n	80838 <sd_read_status+0x24>
		r = SPIWrite(0xff);
		if ((r & 0x80) == 0)
			break;
	}
	if (tries < 0)
		return 0xff;
   8084c:	25ff      	movs	r5, #255	; 0xff
   8084e:	e009      	b.n	80864 <sd_read_status+0x50>
	while (tries--) {
		r = SPIWrite(0xff);
		if ((r & 0x80) == 0)
			break;
	}
	if (tries < 0)
   80850:	2c00      	cmp	r4, #0
   80852:	db06      	blt.n	80862 <sd_read_status+0x4e>
		return 0xff;
	r = r<<8 | SPIWrite(0xff);
   80854:	20ff      	movs	r0, #255	; 0xff
   80856:	4b0b      	ldr	r3, [pc, #44]	; (80884 <sd_read_status+0x70>)
   80858:	4798      	blx	r3
   8085a:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
   8085e:	b285      	uxth	r5, r0
   80860:	e000      	b.n	80864 <sd_read_status+0x50>
		r = SPIWrite(0xff);
		if ((r & 0x80) == 0)
			break;
	}
	if (tries < 0)
		return 0xff;
   80862:	25ff      	movs	r5, #255	; 0xff
	U16 r2;

	spi_cs_low();
	sd_cmd(13, 0);
	r2 = sd_get_r2();
	sd_nec();
   80864:	4b08      	ldr	r3, [pc, #32]	; (80888 <sd_read_status+0x74>)
   80866:	4798      	blx	r3
	spi_cs_high();
   80868:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   8086c:	4b03      	ldr	r3, [pc, #12]	; (8087c <sd_read_status+0x68>)
   8086e:	631a      	str	r2, [r3, #48]	; 0x30
		return -1;
	//	if (r2)
	//		print_r2(r2);

	return 0;
}
   80870:	f345 30c0 	sbfx	r0, r5, #15, #1
   80874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80876:	bf00      	nop
   80878:	400e1400 	.word	0x400e1400
   8087c:	400e0e00 	.word	0x400e0e00
   80880:	00080409 	.word	0x00080409
   80884:	000803d9 	.word	0x000803d9
   80888:	000804d5 	.word	0x000804d5

0008088c <crc16>:
U16 crc16(const U8 *p, int len)
{
	int i;
	U16 crc = 0;

	for (i=0; i<len; i++)
   8088c:	2900      	cmp	r1, #0
   8088e:	dd16      	ble.n	808be <crc16+0x32>
	crc ^= ((crc & 0xff) << 4) << 1;

	return crc;
}
U16 crc16(const U8 *p, int len)
{
   80890:	b430      	push	{r4, r5}
   80892:	4605      	mov	r5, r0
   80894:	4401      	add	r1, r0
	int i;
	U16 crc = 0;

	for (i=0; i<len; i++)
   80896:	2000      	movs	r0, #0
	crc = crc16_ccitt(crc, p[i]);
   80898:	f815 2b01 	ldrb.w	r2, [r5], #1
	return 0;
}

static U16 crc16_ccitt(U16 crc, U8 ser_data)
{
	crc  = (U8)(crc >> 8) | (crc << 8);
   8089c:	0a04      	lsrs	r4, r0, #8
   8089e:	ea44 2300 	orr.w	r3, r4, r0, lsl #8
   808a2:	b29b      	uxth	r3, r3
	crc ^= ser_data;
   808a4:	4053      	eors	r3, r2
	crc ^= (U8)(crc & 0xff) >> 4;
   808a6:	f3c3 1203 	ubfx	r2, r3, #4, #4
   808aa:	4053      	eors	r3, r2
	crc ^= (crc << 8) << 4;
   808ac:	ea83 3303 	eor.w	r3, r3, r3, lsl #12
   808b0:	b29b      	uxth	r3, r3
	crc ^= ((crc & 0xff) << 4) << 1;
   808b2:	b2d8      	uxtb	r0, r3
   808b4:	ea83 1040 	eor.w	r0, r3, r0, lsl #5
U16 crc16(const U8 *p, int len)
{
	int i;
	U16 crc = 0;

	for (i=0; i<len; i++)
   808b8:	428d      	cmp	r5, r1
   808ba:	d1ed      	bne.n	80898 <crc16+0xc>
   808bc:	e001      	b.n	808c2 <crc16+0x36>
	return crc;
}
U16 crc16(const U8 *p, int len)
{
	int i;
	U16 crc = 0;
   808be:	2000      	movs	r0, #0
   808c0:	4770      	bx	lr

	for (i=0; i<len; i++)
	crc = crc16_ccitt(crc, p[i]);

	return crc;
}
   808c2:	bc30      	pop	{r4, r5}
   808c4:	4770      	bx	lr
   808c6:	bf00      	nop

000808c8 <sd_get_data>:

static int sd_get_data(hwif *hw, U8 *buf, int len)
{
   808c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   808cc:	4688      	mov	r8, r1
   808ce:	4617      	mov	r7, r2
	U8 r;
	U16 _crc16;
	U16 calc_crc;
	int i;

	while (tries--) {
   808d0:	f644 641f 	movw	r4, #19999	; 0x4e1f
		r = SPIWrite(0xff);
   808d4:	26ff      	movs	r6, #255	; 0xff
   808d6:	4d19      	ldr	r5, [pc, #100]	; (8093c <sd_get_data+0x74>)
   808d8:	4630      	mov	r0, r6
   808da:	47a8      	blx	r5
		if (r == 0xfe)
   808dc:	28fe      	cmp	r0, #254	; 0xfe
   808de:	d007      	beq.n	808f0 <sd_get_data+0x28>
	U8 r;
	U16 _crc16;
	U16 calc_crc;
	int i;

	while (tries--) {
   808e0:	3c01      	subs	r4, #1
   808e2:	f1b4 3fff 	cmp.w	r4, #4294967295
   808e6:	d1f7      	bne.n	808d8 <sd_get_data+0x10>
		r = SPIWrite(0xff);
		if (r == 0xfe)
		break;
	}
	if (tries < 0)
	return -1;
   808e8:	f04f 30ff 	mov.w	r0, #4294967295
   808ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	while (tries--) {
		r = SPIWrite(0xff);
		if (r == 0xfe)
		break;
	}
	if (tries < 0)
   808f0:	2c00      	cmp	r4, #0
   808f2:	db1f      	blt.n	80934 <sd_get_data+0x6c>
	return -1;

	for (i=0; i<len; i++)
   808f4:	2f00      	cmp	r7, #0
   808f6:	dd0a      	ble.n	8090e <sd_get_data+0x46>
   808f8:	4644      	mov	r4, r8
   808fa:	eb08 0907 	add.w	r9, r8, r7
	buf[i] = SPIWrite(0xff);
   808fe:	26ff      	movs	r6, #255	; 0xff
   80900:	4d0e      	ldr	r5, [pc, #56]	; (8093c <sd_get_data+0x74>)
   80902:	4630      	mov	r0, r6
   80904:	47a8      	blx	r5
   80906:	f804 0b01 	strb.w	r0, [r4], #1
		break;
	}
	if (tries < 0)
	return -1;

	for (i=0; i<len; i++)
   8090a:	454c      	cmp	r4, r9
   8090c:	d1f9      	bne.n	80902 <sd_get_data+0x3a>
	buf[i] = SPIWrite(0xff);

	_crc16 = SPIWrite(0xff) << 8;
   8090e:	20ff      	movs	r0, #255	; 0xff
   80910:	4d0a      	ldr	r5, [pc, #40]	; (8093c <sd_get_data+0x74>)
   80912:	47a8      	blx	r5
   80914:	0200      	lsls	r0, r0, #8
   80916:	b284      	uxth	r4, r0
	_crc16 |= SPIWrite(0xff);
   80918:	20ff      	movs	r0, #255	; 0xff
   8091a:	47a8      	blx	r5
   8091c:	4320      	orrs	r0, r4
   8091e:	b284      	uxth	r4, r0

	calc_crc = crc16(buf, len);
   80920:	4640      	mov	r0, r8
   80922:	4639      	mov	r1, r7
   80924:	4b06      	ldr	r3, [pc, #24]	; (80940 <sd_get_data+0x78>)
   80926:	4798      	blx	r3
	if (_crc16 != calc_crc) {
   80928:	1a20      	subs	r0, r4, r0
   8092a:	bf18      	it	ne
   8092c:	f04f 30ff 	movne.w	r0, #4294967295
   80930:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		r = SPIWrite(0xff);
		if (r == 0xfe)
		break;
	}
	if (tries < 0)
	return -1;
   80934:	f04f 30ff 	mov.w	r0, #4294967295
		//		printf("%s, crcs differ: %04x vs. %04x, len:%i\n", __func__, _crc16, calc_crc, len);
		return -1;
	}

	return 0;
}
   80938:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8093c:	000803d9 	.word	0x000803d9
   80940:	0008088d 	.word	0x0008088d

00080944 <sd_readsector>:
		return 0;
	return STA_NOINIT;
}

static int sd_readsector(hwif *hw, U32 address, U8 *buf)
{
   80944:	b538      	push	{r3, r4, r5, lr}
   80946:	4604      	mov	r4, r0
   80948:	4615      	mov	r5, r2
	int r;
	spi_cs_low();
   8094a:	4a1d      	ldr	r2, [pc, #116]	; (809c0 <sd_readsector+0x7c>)
   8094c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8094e:	f413 7f80 	tst.w	r3, #256	; 0x100
   80952:	d0fb      	beq.n	8094c <sd_readsector+0x8>
   80954:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80958:	4b1a      	ldr	r3, [pc, #104]	; (809c4 <sd_readsector+0x80>)
   8095a:	635a      	str	r2, [r3, #52]	; 0x34
	if (hw->capabilities & CAP_SDHC)
   8095c:	68e3      	ldr	r3, [r4, #12]
   8095e:	f013 0f02 	tst.w	r3, #2
	sd_cmd(17, address); /* read single block */
   80962:	f04f 0011 	mov.w	r0, #17
	else
	sd_cmd(17, address*512); /* read single block */
   80966:	bf08      	it	eq
   80968:	0249      	lsleq	r1, r1, #9
   8096a:	4b17      	ldr	r3, [pc, #92]	; (809c8 <sd_readsector+0x84>)
   8096c:	4798      	blx	r3

	r = sd_get_r1();
   8096e:	4b17      	ldr	r3, [pc, #92]	; (809cc <sd_readsector+0x88>)
   80970:	4798      	blx	r3
	if (r == 0xff) {
   80972:	28ff      	cmp	r0, #255	; 0xff
   80974:	d106      	bne.n	80984 <sd_readsector+0x40>
		spi_cs_high();
   80976:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   8097a:	4b12      	ldr	r3, [pc, #72]	; (809c4 <sd_readsector+0x80>)
   8097c:	631a      	str	r2, [r3, #48]	; 0x30
		r = -1;
   8097e:	f04f 30ff 	mov.w	r0, #4294967295
		goto fail;
   80982:	bd38      	pop	{r3, r4, r5, pc}
	}
	if (r & 0xfe) {
   80984:	f010 0ffe 	tst.w	r0, #254	; 0xfe
   80988:	d006      	beq.n	80998 <sd_readsector+0x54>
		spi_cs_high();
   8098a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   8098e:	4b0d      	ldr	r3, [pc, #52]	; (809c4 <sd_readsector+0x80>)
   80990:	631a      	str	r2, [r3, #48]	; 0x30
		//		printf("%s\n", __func__);
		//		print_r1(r);
		r = -2;
   80992:	f06f 0001 	mvn.w	r0, #1
		goto fail;
   80996:	bd38      	pop	{r3, r4, r5, pc}
	}

	r = sd_get_data(hw, buf, 512);
   80998:	4620      	mov	r0, r4
   8099a:	4629      	mov	r1, r5
   8099c:	f44f 7200 	mov.w	r2, #512	; 0x200
   809a0:	4b0b      	ldr	r3, [pc, #44]	; (809d0 <sd_readsector+0x8c>)
   809a2:	4798      	blx	r3
   809a4:	4604      	mov	r4, r0
	sd_nec();
   809a6:	4b0b      	ldr	r3, [pc, #44]	; (809d4 <sd_readsector+0x90>)
   809a8:	4798      	blx	r3
	spi_cs_high();
   809aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   809ae:	4b05      	ldr	r3, [pc, #20]	; (809c4 <sd_readsector+0x80>)
   809b0:	631a      	str	r2, [r3, #48]	; 0x30
	if (r == -1) {
		r = -3;
   809b2:	f1b4 3fff 	cmp.w	r4, #4294967295
   809b6:	bf14      	ite	ne
   809b8:	2000      	movne	r0, #0
   809ba:	f06f 0002 	mvneq.w	r0, #2

	return 0;
	fail:
	//	printf("failed to read sector %li, err:%i\n", address, r);
	return r;
}
   809be:	bd38      	pop	{r3, r4, r5, pc}
   809c0:	400e1400 	.word	0x400e1400
   809c4:	400e0e00 	.word	0x400e0e00
   809c8:	00080409 	.word	0x00080409
   809cc:	00080471 	.word	0x00080471
   809d0:	000808c9 	.word	0x000808c9
   809d4:	000804d5 	.word	0x000804d5

000809d8 <sd_writesector>:
	return r;
}


static int sd_writesector(hwif *hw, U32 address, const U8 *buf)
{
   809d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   809da:	4614      	mov	r4, r2
	int r;

	spi_cs_low();
   809dc:	4a3e      	ldr	r2, [pc, #248]	; (80ad8 <sd_writesector+0x100>)
   809de:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   809e0:	f413 7f80 	tst.w	r3, #256	; 0x100
   809e4:	d0fb      	beq.n	809de <sd_writesector+0x6>
   809e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   809ea:	4b3c      	ldr	r3, [pc, #240]	; (80adc <sd_writesector+0x104>)
   809ec:	635a      	str	r2, [r3, #52]	; 0x34
	if (hw->capabilities & CAP_SDHC)
   809ee:	68c3      	ldr	r3, [r0, #12]
   809f0:	f013 0f02 	tst.w	r3, #2
		sd_cmd(24, address); /* write block */
   809f4:	f04f 0018 	mov.w	r0, #24
	else
		sd_cmd(24, address*512); /* write block */
   809f8:	bf08      	it	eq
   809fa:	0249      	lsleq	r1, r1, #9
   809fc:	4b38      	ldr	r3, [pc, #224]	; (80ae0 <sd_writesector+0x108>)
   809fe:	4798      	blx	r3

	r = sd_get_r1();
   80a00:	4b38      	ldr	r3, [pc, #224]	; (80ae4 <sd_writesector+0x10c>)
   80a02:	4798      	blx	r3
	if (r == 0xff) {
   80a04:	28ff      	cmp	r0, #255	; 0xff
   80a06:	d106      	bne.n	80a16 <sd_writesector+0x3e>
		spi_cs_high();
   80a08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80a0c:	4b33      	ldr	r3, [pc, #204]	; (80adc <sd_writesector+0x104>)
   80a0e:	631a      	str	r2, [r3, #48]	; 0x30
		r = -1;
   80a10:	f04f 30ff 	mov.w	r0, #4294967295
		goto fail;
   80a14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (r & 0xfe) {
   80a16:	f010 0ffe 	tst.w	r0, #254	; 0xfe
   80a1a:	d006      	beq.n	80a2a <sd_writesector+0x52>
		spi_cs_high();
   80a1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80a20:	4b2e      	ldr	r3, [pc, #184]	; (80adc <sd_writesector+0x104>)
   80a22:	631a      	str	r2, [r3, #48]	; 0x30
//		printf("%s\n", __func__);
//		print_r1(r);
		r = -2;
   80a24:	f06f 0001 	mvn.w	r0, #1
		goto fail;
   80a28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	SPIWrite(0xff); /* Nwr (>= 1) high bytes */
   80a2a:	20ff      	movs	r0, #255	; 0xff
   80a2c:	4d2e      	ldr	r5, [pc, #184]	; (80ae8 <sd_writesector+0x110>)
   80a2e:	47a8      	blx	r5
{
	U8 r;
	int tries = 10;
	U16 crc;

	SPIWrite(0xfe); /* data start */
   80a30:	20fe      	movs	r0, #254	; 0xfe
   80a32:	47a8      	blx	r5
   80a34:	f504 7500 	add.w	r5, r4, #512	; 0x200

	while (len--)
	SPIWrite(*buf++);
   80a38:	4e2b      	ldr	r6, [pc, #172]	; (80ae8 <sd_writesector+0x110>)
   80a3a:	f814 0b01 	ldrb.w	r0, [r4], #1
   80a3e:	47b0      	blx	r6
	int tries = 10;
	U16 crc;

	SPIWrite(0xfe); /* data start */

	while (len--)
   80a40:	42ac      	cmp	r4, r5
   80a42:	d1fa      	bne.n	80a3a <sd_writesector+0x62>
	SPIWrite(*buf++);

	crc = crc16(buf, len);
   80a44:	4628      	mov	r0, r5
   80a46:	f04f 31ff 	mov.w	r1, #4294967295
   80a4a:	4b28      	ldr	r3, [pc, #160]	; (80aec <sd_writesector+0x114>)
   80a4c:	4798      	blx	r3
   80a4e:	4605      	mov	r5, r0
	/* crc16 */
	SPIWrite(crc>>8);
   80a50:	f3c0 2007 	ubfx	r0, r0, #8, #8
   80a54:	4c24      	ldr	r4, [pc, #144]	; (80ae8 <sd_writesector+0x110>)
   80a56:	47a0      	blx	r4
	SPIWrite(crc);
   80a58:	b2e8      	uxtb	r0, r5
   80a5a:	47a0      	blx	r4

	/* normally just one dummy read in between... specs don't say how many */
	while (tries--) {
   80a5c:	2409      	movs	r4, #9
		r = SPIWrite(0xff);
   80a5e:	26ff      	movs	r6, #255	; 0xff
   80a60:	4d21      	ldr	r5, [pc, #132]	; (80ae8 <sd_writesector+0x110>)
   80a62:	4630      	mov	r0, r6
   80a64:	47a8      	blx	r5
   80a66:	4607      	mov	r7, r0
		if (r != 0xff)
   80a68:	28ff      	cmp	r0, #255	; 0xff
   80a6a:	d104      	bne.n	80a76 <sd_writesector+0x9e>
	/* crc16 */
	SPIWrite(crc>>8);
	SPIWrite(crc);

	/* normally just one dummy read in between... specs don't say how many */
	while (tries--) {
   80a6c:	3c01      	subs	r4, #1
   80a6e:	f1b4 3fff 	cmp.w	r4, #4294967295
   80a72:	d1f6      	bne.n	80a62 <sd_writesector+0x8a>
   80a74:	e01f      	b.n	80ab6 <sd_writesector+0xde>
		r = SPIWrite(0xff);
		if (r != 0xff)
		break;
	}
	if (tries < 0)
   80a76:	2c00      	cmp	r4, #0
   80a78:	db1d      	blt.n	80ab6 <sd_writesector+0xde>
   80a7a:	4c1d      	ldr	r4, [pc, #116]	; (80af0 <sd_writesector+0x118>)
	return -1;

	/* poll busy, about 300 reads for 256 MB card */
	tries = 100000;
	while (tries--) {
		if (SPIWrite(0xff) == 0xff)
   80a7c:	26ff      	movs	r6, #255	; 0xff
   80a7e:	4d1a      	ldr	r5, [pc, #104]	; (80ae8 <sd_writesector+0x110>)
   80a80:	4630      	mov	r0, r6
   80a82:	47a8      	blx	r5
   80a84:	28ff      	cmp	r0, #255	; 0xff
   80a86:	d004      	beq.n	80a92 <sd_writesector+0xba>
	if (tries < 0)
	return -1;

	/* poll busy, about 300 reads for 256 MB card */
	tries = 100000;
	while (tries--) {
   80a88:	3c01      	subs	r4, #1
   80a8a:	f1b4 3fff 	cmp.w	r4, #4294967295
   80a8e:	d1f7      	bne.n	80a80 <sd_writesector+0xa8>
   80a90:	e011      	b.n	80ab6 <sd_writesector+0xde>
		if (SPIWrite(0xff) == 0xff)
		break;
	}
	if (tries < 0)
   80a92:	2c00      	cmp	r4, #0
   80a94:	db0f      	blt.n	80ab6 <sd_writesector+0xde>
	return -2;

	/* data accepted, WIN */
	if ((r & 0x1f) == 0x05)
   80a96:	f007 031f 	and.w	r3, r7, #31
   80a9a:	2b05      	cmp	r3, #5
   80a9c:	d014      	beq.n	80ac8 <sd_writesector+0xf0>
		goto fail;
	}

	SPIWrite(0xff); /* Nwr (>= 1) high bytes */
	r = sd_put_data(hw, buf, 512);
	sd_nec();
   80a9e:	4b15      	ldr	r3, [pc, #84]	; (80af4 <sd_writesector+0x11c>)
   80aa0:	4798      	blx	r3
	spi_cs_high();
   80aa2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80aa6:	4b0d      	ldr	r3, [pc, #52]	; (80adc <sd_writesector+0x104>)
   80aa8:	631a      	str	r2, [r3, #48]	; 0x30
	if (r != 0) {
//		printf("sd_put_data returned: %i\n", r);
		r = -3;
   80aaa:	2f00      	cmp	r7, #0
   80aac:	bf0c      	ite	eq
   80aae:	2000      	moveq	r0, #0
   80ab0:	f06f 0002 	mvnne.w	r0, #2
   80ab4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		goto fail;
	}

	SPIWrite(0xff); /* Nwr (>= 1) high bytes */
	r = sd_put_data(hw, buf, 512);
	sd_nec();
   80ab6:	4b0f      	ldr	r3, [pc, #60]	; (80af4 <sd_writesector+0x11c>)
   80ab8:	4798      	blx	r3
	spi_cs_high();
   80aba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80abe:	4b07      	ldr	r3, [pc, #28]	; (80adc <sd_writesector+0x104>)
   80ac0:	631a      	str	r2, [r3, #48]	; 0x30
	if (r != 0) {
//		printf("sd_put_data returned: %i\n", r);
		r = -3;
   80ac2:	f06f 0002 	mvn.w	r0, #2
   80ac6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		goto fail;
	}

	SPIWrite(0xff); /* Nwr (>= 1) high bytes */
	r = sd_put_data(hw, buf, 512);
	sd_nec();
   80ac8:	4b0a      	ldr	r3, [pc, #40]	; (80af4 <sd_writesector+0x11c>)
   80aca:	4798      	blx	r3
	spi_cs_high();
   80acc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80ad0:	4b02      	ldr	r3, [pc, #8]	; (80adc <sd_writesector+0x104>)
   80ad2:	631a      	str	r2, [r3, #48]	; 0x30
	}

	/* efsl code is weird shit, 0 is error in there?
	 * not that it's properly handled or anything,
	 * and the return type is char, fucking efsl */
	return 0;
   80ad4:	2000      	movs	r0, #0
 fail:
//	printf("failed to write sector %li, err:%i\n", address, r);
	return r;
}
   80ad6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80ad8:	400e1400 	.word	0x400e1400
   80adc:	400e0e00 	.word	0x400e0e00
   80ae0:	00080409 	.word	0x00080409
   80ae4:	00080471 	.word	0x00080471
   80ae8:	000803d9 	.word	0x000803d9
   80aec:	0008088d 	.word	0x0008088d
   80af0:	0001869f 	.word	0x0001869f
   80af4:	000804d5 	.word	0x000804d5

00080af8 <hwif_init>:

	return 0;
}

int hwif_init(hwif* hw)
{
   80af8:	b530      	push	{r4, r5, lr}
   80afa:	b085      	sub	sp, #20
   80afc:	4604      	mov	r4, r0
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
static void spi_init(void)
{
	PMC->PMC_PCER0 |= _BV(ID_PIOA);	//Enable Clock PortA
   80afe:	4a76      	ldr	r2, [pc, #472]	; (80cd8 <hwif_init+0x1e0>)
   80b00:	6913      	ldr	r3, [r2, #16]
   80b02:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   80b06:	6113      	str	r3, [r2, #16]
	
	//configure for input			//MISO
	PIOA->PIO_PDR |= PIO_PA25;
   80b08:	4b74      	ldr	r3, [pc, #464]	; (80cdc <hwif_init+0x1e4>)
   80b0a:	6859      	ldr	r1, [r3, #4]
   80b0c:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   80b10:	6059      	str	r1, [r3, #4]
	PIOA->PIO_ODR |= PIO_PA25;		//Input
   80b12:	6959      	ldr	r1, [r3, #20]
   80b14:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   80b18:	6159      	str	r1, [r3, #20]
	
	PIOA->PIO_PDR |= PIO_PA26;		//MOSI
   80b1a:	6859      	ldr	r1, [r3, #4]
   80b1c:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
   80b20:	6059      	str	r1, [r3, #4]
	PIOA->PIO_OER |= PIO_PA26;		//MOSI	Output
   80b22:	6919      	ldr	r1, [r3, #16]
   80b24:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
   80b28:	6119      	str	r1, [r3, #16]
	PIOA->PIO_ABSR &= ~PIO_PA26;	//Peripheral A
   80b2a:	6f19      	ldr	r1, [r3, #112]	; 0x70
   80b2c:	f021 6180 	bic.w	r1, r1, #67108864	; 0x4000000
   80b30:	6719      	str	r1, [r3, #112]	; 0x70
	
	PIOA->PIO_PDR |= PIO_PA27;		//SPCK
   80b32:	6859      	ldr	r1, [r3, #4]
   80b34:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
   80b38:	6059      	str	r1, [r3, #4]
	PIOA->PIO_OER |= PIO_PA27;		//SPCK	Output
   80b3a:	6919      	ldr	r1, [r3, #16]
   80b3c:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
   80b40:	6119      	str	r1, [r3, #16]
	PIOA->PIO_ABSR &= ~PIO_PA27;	//Peripheral A
   80b42:	6f19      	ldr	r1, [r3, #112]	; 0x70
   80b44:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
   80b48:	6719      	str	r1, [r3, #112]	; 0x70
	
	PIOA->PIO_OER |= PIO_PA28;		//NPCS0	Output
   80b4a:	6919      	ldr	r1, [r3, #16]
   80b4c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
   80b50:	6119      	str	r1, [r3, #16]
/*	PIOA->PIO_ABSR &= ~PIO_PA28;	//Peripheral A
	PIOA->PIO_PUER |= PIO_PA28;		//pull-up*/

	//Enable clock for the SPI0 peripheral
	PMC->PMC_PCER0 |= _BV(ID_SPI0);
   80b52:	6913      	ldr	r3, [r2, #16]
   80b54:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   80b58:	6113      	str	r3, [r2, #16]

	//Disable the SPI0 peripheral so we can configure it.
	SPI0->SPI_CR = SPI_CR_SPIDIS;
   80b5a:	4b61      	ldr	r3, [pc, #388]	; (80ce0 <hwif_init+0x1e8>)
   80b5c:	2202      	movs	r2, #2
   80b5e:	601a      	str	r2, [r3, #0]

	//Set as Master, Fixed Peripheral Select, Mode Fault Detection disabled and
	//	Peripheral Chip Select is PCS = xxx0 NPCS[3:0] = 1110
	SPI0->SPI_MR = SPI_MR_MSTR | SPI_MR_MODFDIS | 0x000e0000;
   80b60:	4a60      	ldr	r2, [pc, #384]	; (80ce4 <hwif_init+0x1ec>)
   80b62:	605a      	str	r2, [r3, #4]
	
	//SPCK baudrate = MCK / SCBR = 84MHz / 128 = 656250Hz
	SPI0->SPI_CSR[0] |= 0x0000FF00  | 1 << 1;
   80b64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   80b66:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
   80b6a:	f042 0202 	orr.w	r2, r2, #2
   80b6e:	631a      	str	r2, [r3, #48]	; 0x30
	
	//Enable the SPI0 unit
	SPI0->SPI_CR = SPI_CR_SPIEN;
   80b70:	2201      	movs	r2, #1
   80b72:	601a      	str	r2, [r3, #0]
	//	Toto som zrusil ja aby sa vzdy inicializoval ked som to chcel
	//	if (hw->initialized)
	//		return 0;
	spi_init();
	while (tries--) {
		if (sd_init(hw) == 0)
   80b74:	4b5c      	ldr	r3, [pc, #368]	; (80ce8 <hwif_init+0x1f0>)
   80b76:	4798      	blx	r3
   80b78:	b128      	cbz	r0, 80b86 <hwif_init+0x8e>
   80b7a:	4620      	mov	r0, r4
   80b7c:	4b5a      	ldr	r3, [pc, #360]	; (80ce8 <hwif_init+0x1f0>)
   80b7e:	4798      	blx	r3
   80b80:	2800      	cmp	r0, #0
   80b82:	f040 809e 	bne.w	80cc2 <hwif_init+0x1ca>
	}
	if (tries == -1)
		return -1;

	/* read status register */
	sd_read_status(hw);
   80b86:	4620      	mov	r0, r4
   80b88:	4b58      	ldr	r3, [pc, #352]	; (80cec <hwif_init+0x1f4>)
   80b8a:	4798      	blx	r3
static int sd_read_cid(hwif *hw)
{
	U8 buf[16];
	int r;

	spi_cs_low();
   80b8c:	4a58      	ldr	r2, [pc, #352]	; (80cf0 <hwif_init+0x1f8>)
   80b8e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80b90:	f413 7f80 	tst.w	r3, #256	; 0x100
   80b94:	d0fb      	beq.n	80b8e <hwif_init+0x96>
   80b96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80b9a:	4b50      	ldr	r3, [pc, #320]	; (80cdc <hwif_init+0x1e4>)
   80b9c:	635a      	str	r2, [r3, #52]	; 0x34
	sd_cmd(10, 0);
   80b9e:	200a      	movs	r0, #10
   80ba0:	2100      	movs	r1, #0
   80ba2:	4b54      	ldr	r3, [pc, #336]	; (80cf4 <hwif_init+0x1fc>)
   80ba4:	4798      	blx	r3
	r = sd_get_r1();
   80ba6:	4b54      	ldr	r3, [pc, #336]	; (80cf8 <hwif_init+0x200>)
   80ba8:	4798      	blx	r3
	if (r == 0xff) {
   80baa:	28ff      	cmp	r0, #255	; 0xff
   80bac:	d104      	bne.n	80bb8 <hwif_init+0xc0>
		spi_cs_high();
   80bae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80bb2:	4b4a      	ldr	r3, [pc, #296]	; (80cdc <hwif_init+0x1e4>)
   80bb4:	631a      	str	r2, [r3, #48]	; 0x30
   80bb6:	e012      	b.n	80bde <hwif_init+0xe6>
		return -1;
	}
	if (r & 0xfe) {
   80bb8:	f010 0ffe 	tst.w	r0, #254	; 0xfe
   80bbc:	d004      	beq.n	80bc8 <hwif_init+0xd0>
		spi_cs_high();
   80bbe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80bc2:	4b46      	ldr	r3, [pc, #280]	; (80cdc <hwif_init+0x1e4>)
   80bc4:	631a      	str	r2, [r3, #48]	; 0x30
   80bc6:	e00a      	b.n	80bde <hwif_init+0xe6>
//		printf("%s ", __func__);
//		print_r1(r);
		return -2;
	}

	r = sd_get_data(hw, buf, 16);
   80bc8:	4620      	mov	r0, r4
   80bca:	4669      	mov	r1, sp
   80bcc:	2210      	movs	r2, #16
   80bce:	4b4b      	ldr	r3, [pc, #300]	; (80cfc <hwif_init+0x204>)
   80bd0:	4798      	blx	r3
	sd_nec();
   80bd2:	4b4b      	ldr	r3, [pc, #300]	; (80d00 <hwif_init+0x208>)
   80bd4:	4798      	blx	r3
	spi_cs_high();
   80bd6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80bda:	4b40      	ldr	r3, [pc, #256]	; (80cdc <hwif_init+0x1e4>)
   80bdc:	631a      	str	r2, [r3, #48]	; 0x30
{
	U8 buf[16];
	int r;
	int capacity;

	spi_cs_low();
   80bde:	4a44      	ldr	r2, [pc, #272]	; (80cf0 <hwif_init+0x1f8>)
   80be0:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   80be2:	f413 7f80 	tst.w	r3, #256	; 0x100
   80be6:	d0fb      	beq.n	80be0 <hwif_init+0xe8>
   80be8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80bec:	4b3b      	ldr	r3, [pc, #236]	; (80cdc <hwif_init+0x1e4>)
   80bee:	635a      	str	r2, [r3, #52]	; 0x34
	sd_cmd(9, 0);
   80bf0:	2009      	movs	r0, #9
   80bf2:	2100      	movs	r1, #0
   80bf4:	4b3f      	ldr	r3, [pc, #252]	; (80cf4 <hwif_init+0x1fc>)
   80bf6:	4798      	blx	r3
	r = sd_get_r1();
   80bf8:	4b3f      	ldr	r3, [pc, #252]	; (80cf8 <hwif_init+0x200>)
   80bfa:	4798      	blx	r3
	if (r == 0xff) {
   80bfc:	28ff      	cmp	r0, #255	; 0xff
   80bfe:	d104      	bne.n	80c0a <hwif_init+0x112>
		spi_cs_high();
   80c00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80c04:	4b35      	ldr	r3, [pc, #212]	; (80cdc <hwif_init+0x1e4>)
   80c06:	631a      	str	r2, [r3, #48]	; 0x30
   80c08:	e062      	b.n	80cd0 <hwif_init+0x1d8>
		return -1;
	}
	if (r & 0xfe) {
   80c0a:	f010 0ffe 	tst.w	r0, #254	; 0xfe
   80c0e:	d004      	beq.n	80c1a <hwif_init+0x122>
		spi_cs_high();
   80c10:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80c14:	4b31      	ldr	r3, [pc, #196]	; (80cdc <hwif_init+0x1e4>)
   80c16:	631a      	str	r2, [r3, #48]	; 0x30
   80c18:	e05a      	b.n	80cd0 <hwif_init+0x1d8>
//		printf("%s ", __func__);
//		print_r1(r);
		return -2;
	}

	r = sd_get_data(hw, buf, 16);
   80c1a:	4620      	mov	r0, r4
   80c1c:	4669      	mov	r1, sp
   80c1e:	2210      	movs	r2, #16
   80c20:	4b36      	ldr	r3, [pc, #216]	; (80cfc <hwif_init+0x204>)
   80c22:	4798      	blx	r3
   80c24:	4605      	mov	r5, r0
	sd_nec();
   80c26:	4b36      	ldr	r3, [pc, #216]	; (80d00 <hwif_init+0x208>)
   80c28:	4798      	blx	r3
	spi_cs_high();
   80c2a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80c2e:	4b2b      	ldr	r3, [pc, #172]	; (80cdc <hwif_init+0x1e4>)
   80c30:	631a      	str	r2, [r3, #48]	; 0x30
	if (r == -1) {
   80c32:	f1b5 3fff 	cmp.w	r5, #4294967295
   80c36:	d04b      	beq.n	80cd0 <hwif_init+0x1d8>
//		printf("failed to get csd\n");
		return -3;
	}

	if ((buf[0] >> 6) + 1 == 1) {
   80c38:	f89d 3000 	ldrb.w	r3, [sp]
   80c3c:	099b      	lsrs	r3, r3, #6
   80c3e:	d11f      	bne.n	80c80 <hwif_init+0x188>
			1<<((buf[12]&3)<<2 | buf[13]>>6), // write_bl_len 
			(buf[13]>>5)&1,
			buf[14]>>7, (buf[14]>>6)&1, (buf[14]>>5)&1, (buf[14]>>4)&1,
			(buf[14]>>2)&3 // file format );*/

	capacity = (((buf[6]&0x3)<<10 | buf[7]<<2 | buf[8]>>6)+1) << (2+(((buf[9]&3) << 1) | buf[10]>>7)) << ((buf[5] & 0xf) - 9);
   80c40:	f89d 1008 	ldrb.w	r1, [sp, #8]
   80c44:	f89d 2007 	ldrb.w	r2, [sp, #7]
   80c48:	0093      	lsls	r3, r2, #2
   80c4a:	ea43 1291 	orr.w	r2, r3, r1, lsr #6
   80c4e:	f89d 3006 	ldrb.w	r3, [sp, #6]
   80c52:	f003 0303 	and.w	r3, r3, #3
   80c56:	ea42 2383 	orr.w	r3, r2, r3, lsl #10
   80c5a:	3301      	adds	r3, #1
   80c5c:	f89d 2009 	ldrb.w	r2, [sp, #9]
   80c60:	f002 0103 	and.w	r1, r2, #3
   80c64:	f89d 200a 	ldrb.w	r2, [sp, #10]
   80c68:	09d2      	lsrs	r2, r2, #7
   80c6a:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
   80c6e:	3202      	adds	r2, #2
   80c70:	4093      	lsls	r3, r2
   80c72:	f89d 2005 	ldrb.w	r2, [sp, #5]
   80c76:	f002 020f 	and.w	r2, r2, #15
   80c7a:	3a09      	subs	r2, #9
   80c7c:	4093      	lsls	r3, r2
   80c7e:	e00e      	b.n	80c9e <hwif_init+0x1a6>
	/* ^ = (c_size+1) * 2**(c_size_mult+2) * 2**(read_bl_len-9) */

	} else {
	/* CSD v2 */
		/* this means the card is HC */
		hw->capabilities |= CAP_SDHC;
   80c80:	68e3      	ldr	r3, [r4, #12]
   80c82:	f043 0302 	orr.w	r3, r3, #2
   80c86:	60e3      	str	r3, [r4, #12]
			1<<((buf[12]&3)<<2 | buf[13]>>6), // write_bl_len
			(buf[13]>>5)&1,
			buf[14]>>7, (buf[14]>>6)&1, (buf[14]>>5)&1, (buf[14]>>4)&1,
			(buf[14]>>2)&3 // file format ); */

	capacity = buf[7]<<16 | buf[8]<<8 | buf[9]; /* in 512 kB */
   80c88:	f89d 1007 	ldrb.w	r1, [sp, #7]
   80c8c:	f89d 2008 	ldrb.w	r2, [sp, #8]
   80c90:	0213      	lsls	r3, r2, #8
   80c92:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
   80c96:	f89d 3009 	ldrb.w	r3, [sp, #9]
   80c9a:	4313      	orrs	r3, r2
	capacity *= 1024; /* in 512 B sectors */
   80c9c:	029b      	lsls	r3, r3, #10

	}

//	printf("capacity = %i kB\n", capacity/2);
	hw->sectors = capacity;
   80c9e:	6063      	str	r3, [r4, #4]

	/* if erase_blk_en = 0, then only this many sectors can be erased at once
	 * this is NOT yet tested */
	hw->erase_sectors = 1;
   80ca0:	2301      	movs	r3, #1
   80ca2:	60a3      	str	r3, [r4, #8]
	if (((buf[10]>>6)&1) == 0)
   80ca4:	f89d 300a 	ldrb.w	r3, [sp, #10]
   80ca8:	f013 0f40 	tst.w	r3, #64	; 0x40
   80cac:	d10c      	bne.n	80cc8 <hwif_init+0x1d0>
		hw->erase_sectors = ((buf[10]&0x3f)<<1 | buf[11]>>7) + 1;
   80cae:	f003 023f 	and.w	r2, r3, #63	; 0x3f
   80cb2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   80cb6:	09db      	lsrs	r3, r3, #7
   80cb8:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
   80cbc:	3301      	adds	r3, #1
   80cbe:	60a3      	str	r3, [r4, #8]
   80cc0:	e002      	b.n	80cc8 <hwif_init+0x1d0>
	while (tries--) {
		if (sd_init(hw) == 0)
		break;
	}
	if (tries == -1)
		return -1;
   80cc2:	f04f 30ff 	mov.w	r0, #4294967295
   80cc6:	e005      	b.n	80cd4 <hwif_init+0x1dc>
	/* read status register */
	sd_read_status(hw);
	sd_read_cid(hw);
	if (sd_read_csd(hw) != 0)
	return -1;
	hw->initialized = 1;
   80cc8:	2301      	movs	r3, #1
   80cca:	6023      	str	r3, [r4, #0]
	return 0;
   80ccc:	2000      	movs	r0, #0
   80cce:	e001      	b.n	80cd4 <hwif_init+0x1dc>

	/* read status register */
	sd_read_status(hw);
	sd_read_cid(hw);
	if (sd_read_csd(hw) != 0)
	return -1;
   80cd0:	f04f 30ff 	mov.w	r0, #4294967295
	hw->initialized = 1;
	return 0;
}
   80cd4:	b005      	add	sp, #20
   80cd6:	bd30      	pop	{r4, r5, pc}
   80cd8:	400e0600 	.word	0x400e0600
   80cdc:	400e0e00 	.word	0x400e0e00
   80ce0:	40008000 	.word	0x40008000
   80ce4:	000e0011 	.word	0x000e0011
   80ce8:	000804ed 	.word	0x000804ed
   80cec:	00080815 	.word	0x00080815
   80cf0:	400e1400 	.word	0x400e1400
   80cf4:	00080409 	.word	0x00080409
   80cf8:	00080471 	.word	0x00080471
   80cfc:	000808c9 	.word	0x000808c9
   80d00:	000804d5 	.word	0x000804d5

00080d04 <disk_initialize>:
}



DSTATUS disk_initialize(BYTE drv)
{
   80d04:	b508      	push	{r3, lr}
	if (hwif_init(&hw1) == 0)
   80d06:	4803      	ldr	r0, [pc, #12]	; (80d14 <disk_initialize+0x10>)
   80d08:	4b03      	ldr	r3, [pc, #12]	; (80d18 <disk_initialize+0x14>)
   80d0a:	4798      	blx	r3
		return 0;
	return STA_NOINIT;
}
   80d0c:	3000      	adds	r0, #0
   80d0e:	bf18      	it	ne
   80d10:	2001      	movne	r0, #1
   80d12:	bd08      	pop	{r3, pc}
   80d14:	200011b8 	.word	0x200011b8
   80d18:	00080af9 	.word	0x00080af9

00080d1c <disk_status>:
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
	if (hw1.initialized)
   80d1c:	4b02      	ldr	r3, [pc, #8]	; (80d28 <disk_status+0xc>)
   80d1e:	6818      	ldr	r0, [r3, #0]
		return 0;
	return STA_NOINIT;
}
   80d20:	fab0 f080 	clz	r0, r0
   80d24:	0940      	lsrs	r0, r0, #5
   80d26:	4770      	bx	lr
   80d28:	200011b8 	.word	0x200011b8

00080d2c <sd_read>:
	return r;
}


int sd_read(hwif* hw, U32 address, U8 *buf)
{
   80d2c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80d30:	4605      	mov	r5, r0
   80d32:	4688      	mov	r8, r1
   80d34:	4691      	mov	r9, r2
	int r;
	int tries = 10;

	r = sd_readsector(hw, address, buf);
   80d36:	4b0d      	ldr	r3, [pc, #52]	; (80d6c <sd_read+0x40>)
   80d38:	4798      	blx	r3

	while (r < 0 && tries--) {
   80d3a:	1e06      	subs	r6, r0, #0
   80d3c:	da13      	bge.n	80d66 <sd_read+0x3a>
   80d3e:	240a      	movs	r4, #10
		if (sd_init(hw) != 0)
   80d40:	4f0b      	ldr	r7, [pc, #44]	; (80d70 <sd_read+0x44>)
		continue;

		/* read status register */
		sd_read_status(hw);
   80d42:	f8df b030 	ldr.w	fp, [pc, #48]	; 80d74 <sd_read+0x48>

		r = sd_readsector(hw, address, buf);
   80d46:	f8df a024 	ldr.w	sl, [pc, #36]	; 80d6c <sd_read+0x40>
	int tries = 10;

	r = sd_readsector(hw, address, buf);

	while (r < 0 && tries--) {
		if (sd_init(hw) != 0)
   80d4a:	4628      	mov	r0, r5
   80d4c:	47b8      	blx	r7
   80d4e:	b930      	cbnz	r0, 80d5e <sd_read+0x32>
		continue;

		/* read status register */
		sd_read_status(hw);
   80d50:	4628      	mov	r0, r5
   80d52:	47d8      	blx	fp

		r = sd_readsector(hw, address, buf);
   80d54:	4628      	mov	r0, r5
   80d56:	4641      	mov	r1, r8
   80d58:	464a      	mov	r2, r9
   80d5a:	47d0      	blx	sl
   80d5c:	4606      	mov	r6, r0
	int r;
	int tries = 10;

	r = sd_readsector(hw, address, buf);

	while (r < 0 && tries--) {
   80d5e:	2e00      	cmp	r6, #0
   80d60:	da01      	bge.n	80d66 <sd_read+0x3a>
   80d62:	3c01      	subs	r4, #1
   80d64:	d1f1      	bne.n	80d4a <sd_read+0x1e>
	}
	//	if (tries == -1)
	//		printf("%s: couldn't read sector %li\n", __func__, address);

	return r;
}
   80d66:	4630      	mov	r0, r6
   80d68:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   80d6c:	00080945 	.word	0x00080945
   80d70:	000804ed 	.word	0x000804ed
   80d74:	00080815 	.word	0x00080815

00080d78 <disk_read>:

DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
	int i;

	for (i=0; i<count; i++)
   80d78:	b1a3      	cbz	r3, 80da4 <disk_read+0x2c>
 * \return RES_OK for success, otherwise DRESULT error code.
 */


DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
   80d7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80d7e:	461e      	mov	r6, r3
   80d80:	4614      	mov	r4, r2
   80d82:	460d      	mov	r5, r1
   80d84:	4416      	add	r6, r2
	int i;

	for (i=0; i<count; i++)
	if (sd_read(&hw1, sector+i, buff+512*i) != 0)
   80d86:	f8df 802c 	ldr.w	r8, [pc, #44]	; 80db4 <disk_read+0x3c>
   80d8a:	4f09      	ldr	r7, [pc, #36]	; (80db0 <disk_read+0x38>)
   80d8c:	4640      	mov	r0, r8
   80d8e:	4621      	mov	r1, r4
   80d90:	462a      	mov	r2, r5
   80d92:	47b8      	blx	r7
   80d94:	b940      	cbnz	r0, 80da8 <disk_read+0x30>
   80d96:	3401      	adds	r4, #1
   80d98:	f505 7500 	add.w	r5, r5, #512	; 0x200

DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
	int i;

	for (i=0; i<count; i++)
   80d9c:	42b4      	cmp	r4, r6
   80d9e:	d1f5      	bne.n	80d8c <disk_read+0x14>
   80da0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (sd_read(&hw1, sector+i, buff+512*i) != 0)
		return RES_ERROR;
	return RES_OK;
   80da4:	2000      	movs	r0, #0
}
   80da6:	4770      	bx	lr
{
	int i;

	for (i=0; i<count; i++)
	if (sd_read(&hw1, sector+i, buff+512*i) != 0)
		return RES_ERROR;
   80da8:	2001      	movs	r0, #1
	return RES_OK;
}
   80daa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80dae:	bf00      	nop
   80db0:	00080d2d 	.word	0x00080d2d
   80db4:	200011b8 	.word	0x200011b8

00080db8 <sd_write>:
 fail:
//	printf("failed to write sector %li, err:%i\n", address, r);
	return r;
}
int sd_write(hwif* hw, U32 address,const U8 *buf)
{
   80db8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80dbc:	4605      	mov	r5, r0
   80dbe:	4688      	mov	r8, r1
   80dc0:	4691      	mov	r9, r2
	int r;
	int tries = 10;

	r = sd_writesector(hw, address, buf);
   80dc2:	4b0d      	ldr	r3, [pc, #52]	; (80df8 <sd_write+0x40>)
   80dc4:	4798      	blx	r3

	while (r < 0 && tries--) {
   80dc6:	1e06      	subs	r6, r0, #0
   80dc8:	da13      	bge.n	80df2 <sd_write+0x3a>
   80dca:	240a      	movs	r4, #10
		if (sd_init(hw) != 0)
   80dcc:	4f0b      	ldr	r7, [pc, #44]	; (80dfc <sd_write+0x44>)
		continue;

		/* read status register */
		sd_read_status(hw);
   80dce:	f8df b030 	ldr.w	fp, [pc, #48]	; 80e00 <sd_write+0x48>

		r = sd_writesector(hw, address, buf);
   80dd2:	f8df a024 	ldr.w	sl, [pc, #36]	; 80df8 <sd_write+0x40>
	int tries = 10;

	r = sd_writesector(hw, address, buf);

	while (r < 0 && tries--) {
		if (sd_init(hw) != 0)
   80dd6:	4628      	mov	r0, r5
   80dd8:	47b8      	blx	r7
   80dda:	b930      	cbnz	r0, 80dea <sd_write+0x32>
		continue;

		/* read status register */
		sd_read_status(hw);
   80ddc:	4628      	mov	r0, r5
   80dde:	47d8      	blx	fp

		r = sd_writesector(hw, address, buf);
   80de0:	4628      	mov	r0, r5
   80de2:	4641      	mov	r1, r8
   80de4:	464a      	mov	r2, r9
   80de6:	47d0      	blx	sl
   80de8:	4606      	mov	r6, r0
	int r;
	int tries = 10;

	r = sd_writesector(hw, address, buf);

	while (r < 0 && tries--) {
   80dea:	2e00      	cmp	r6, #0
   80dec:	da01      	bge.n	80df2 <sd_write+0x3a>
   80dee:	3c01      	subs	r4, #1
   80df0:	d1f1      	bne.n	80dd6 <sd_write+0x1e>
	}
	//	if (tries == -1)
	//		printf("%s: couldn't write sector %li\n", __func__, address);

	return r;
}
   80df2:	4630      	mov	r0, r6
   80df4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   80df8:	000809d9 	.word	0x000809d9
   80dfc:	000804ed 	.word	0x000804ed
   80e00:	00080815 	.word	0x00080815

00080e04 <disk_write>:
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
	int i;

	for (i=0; i<count; i++)
   80e04:	b1a3      	cbz	r3, 80e30 <disk_write+0x2c>



#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
   80e06:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80e0a:	461e      	mov	r6, r3
   80e0c:	4614      	mov	r4, r2
   80e0e:	460d      	mov	r5, r1
   80e10:	4416      	add	r6, r2
	int i;

	for (i=0; i<count; i++)
	if (sd_write(&hw1, sector+i, buff+512*i) != 0)
   80e12:	f8df 802c 	ldr.w	r8, [pc, #44]	; 80e40 <disk_write+0x3c>
   80e16:	4f09      	ldr	r7, [pc, #36]	; (80e3c <disk_write+0x38>)
   80e18:	4640      	mov	r0, r8
   80e1a:	4621      	mov	r1, r4
   80e1c:	462a      	mov	r2, r5
   80e1e:	47b8      	blx	r7
   80e20:	b940      	cbnz	r0, 80e34 <disk_write+0x30>
   80e22:	3401      	adds	r4, #1
   80e24:	f505 7500 	add.w	r5, r5, #512	; 0x200
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
	int i;

	for (i=0; i<count; i++)
   80e28:	42b4      	cmp	r4, r6
   80e2a:	d1f5      	bne.n	80e18 <disk_write+0x14>
   80e2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (sd_write(&hw1, sector+i, buff+512*i) != 0)
	return RES_ERROR;

	return RES_OK;
   80e30:	2000      	movs	r0, #0
}
   80e32:	4770      	bx	lr
{
	int i;

	for (i=0; i<count; i++)
	if (sd_write(&hw1, sector+i, buff+512*i) != 0)
	return RES_ERROR;
   80e34:	2001      	movs	r0, #1

	return RES_OK;
}
   80e36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80e3a:	bf00      	nop
   80e3c:	00080db9 	.word	0x00080db9
   80e40:	200011b8 	.word	0x200011b8

00080e44 <clust2sect>:
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
   80e44:	3902      	subs	r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   80e46:	6983      	ldr	r3, [r0, #24]
   80e48:	3b02      	subs	r3, #2
   80e4a:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
   80e4c:	bf3d      	ittte	cc
   80e4e:	7882      	ldrbcc	r2, [r0, #2]
   80e50:	6a83      	ldrcc	r3, [r0, #40]	; 0x28
   80e52:	fb02 3001 	mlacc	r0, r2, r1, r3
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   80e56:	2000      	movcs	r0, #0
	return clst * fs->csize + fs->database;
}
   80e58:	4770      	bx	lr
   80e5a:	bf00      	nop

00080e5c <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
   80e5c:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
   80e60:	2300      	movs	r3, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   80e62:	01da      	lsls	r2, r3, #7
   80e64:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
   80e68:	f810 2b01 	ldrb.w	r2, [r0], #1
   80e6c:	4413      	add	r3, r2
   80e6e:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   80e72:	4288      	cmp	r0, r1
   80e74:	d1f5      	bne.n	80e62 <sum_sfn+0x6>
	return sum;
}
   80e76:	4618      	mov	r0, r3
   80e78:	4770      	bx	lr
   80e7a:	bf00      	nop

00080e7c <validate>:
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
   80e7c:	b178      	cbz	r0, 80e9e <validate+0x22>
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
   80e7e:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
   80e80:	7802      	ldrb	r2, [r0, #0]
   80e82:	b172      	cbz	r2, 80ea2 <validate+0x26>
   80e84:	88c2      	ldrh	r2, [r0, #6]
   80e86:	428a      	cmp	r2, r1
   80e88:	d10d      	bne.n	80ea6 <validate+0x2a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
   80e8a:	7840      	ldrb	r0, [r0, #1]
   80e8c:	4b07      	ldr	r3, [pc, #28]	; (80eac <validate+0x30>)
   80e8e:	4798      	blx	r3
   80e90:	f000 0001 	and.w	r0, r0, #1
		return FR_NOT_READY;

	return FR_OK;
   80e94:	2800      	cmp	r0, #0
   80e96:	bf14      	ite	ne
   80e98:	2003      	movne	r0, #3
   80e9a:	2000      	moveq	r0, #0
   80e9c:	bd08      	pop	{r3, pc}
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
   80e9e:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
   80ea0:	4770      	bx	lr
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
   80ea2:	2009      	movs	r0, #9
   80ea4:	bd08      	pop	{r3, pc}
   80ea6:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
   80ea8:	bd08      	pop	{r3, pc}
   80eaa:	bf00      	nop
   80eac:	00080d1d 	.word	0x00080d1d

00080eb0 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
   80eb0:	b538      	push	{r3, r4, r5, lr}
   80eb2:	4604      	mov	r4, r0
   80eb4:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   80eb6:	7840      	ldrb	r0, [r0, #1]
   80eb8:	f104 0130 	add.w	r1, r4, #48	; 0x30
   80ebc:	2301      	movs	r3, #1
   80ebe:	4d1d      	ldr	r5, [pc, #116]	; (80f34 <check_fs+0x84>)
   80ec0:	47a8      	blx	r5
   80ec2:	bb80      	cbnz	r0, 80f26 <check_fs+0x76>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   80ec4:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
   80ec8:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
   80ecc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   80ed0:	b21b      	sxth	r3, r3
   80ed2:	4a19      	ldr	r2, [pc, #100]	; (80f38 <check_fs+0x88>)
   80ed4:	4293      	cmp	r3, r2
   80ed6:	d128      	bne.n	80f2a <check_fs+0x7a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   80ed8:	f894 1069 	ldrb.w	r1, [r4, #105]	; 0x69
   80edc:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
   80ee0:	0413      	lsls	r3, r2, #16
   80ee2:	ea43 6201 	orr.w	r2, r3, r1, lsl #24
   80ee6:	f894 3066 	ldrb.w	r3, [r4, #102]	; 0x66
   80eea:	4313      	orrs	r3, r2
   80eec:	f894 2067 	ldrb.w	r2, [r4, #103]	; 0x67
   80ef0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   80ef4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   80ef8:	4a10      	ldr	r2, [pc, #64]	; (80f3c <check_fs+0x8c>)
   80efa:	4293      	cmp	r3, r2
   80efc:	d017      	beq.n	80f2e <check_fs+0x7e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   80efe:	f894 0085 	ldrb.w	r0, [r4, #133]	; 0x85
   80f02:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
   80f06:	041b      	lsls	r3, r3, #16
   80f08:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
   80f0c:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
   80f10:	4303      	orrs	r3, r0
   80f12:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
   80f16:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   80f1a:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
   80f1e:	1a98      	subs	r0, r3, r2
   80f20:	bf18      	it	ne
   80f22:	2001      	movne	r0, #1
   80f24:	bd38      	pop	{r3, r4, r5, pc}
   80f26:	2003      	movs	r0, #3
   80f28:	bd38      	pop	{r3, r4, r5, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
   80f2a:	2002      	movs	r0, #2
   80f2c:	bd38      	pop	{r3, r4, r5, pc}

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
   80f2e:	2000      	movs	r0, #0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
   80f30:	bd38      	pop	{r3, r4, r5, pc}
   80f32:	bf00      	nop
   80f34:	00080d79 	.word	0x00080d79
   80f38:	ffffaa55 	.word	0xffffaa55
   80f3c:	00544146 	.word	0x00544146

00080f40 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
   80f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
   80f42:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
   80f44:	781c      	ldrb	r4, [r3, #0]
   80f46:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   80f48:	2c09      	cmp	r4, #9
   80f4a:	d808      	bhi.n	80f5e <chk_mounted+0x1e>
   80f4c:	785d      	ldrb	r5, [r3, #1]
   80f4e:	2d3a      	cmp	r5, #58	; 0x3a
   80f50:	d107      	bne.n	80f62 <chk_mounted+0x22>
		p += 2; *path = p;				/* Return pointer to the path name */
   80f52:	3302      	adds	r3, #2
   80f54:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   80f56:	2c04      	cmp	r4, #4
   80f58:	f200 8149 	bhi.w	811ee <chk_mounted+0x2ae>
   80f5c:	e002      	b.n	80f64 <chk_mounted+0x24>
   80f5e:	2400      	movs	r4, #0
   80f60:	e000      	b.n	80f64 <chk_mounted+0x24>
   80f62:	2400      	movs	r4, #0
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   80f64:	4bc0      	ldr	r3, [pc, #768]	; (81268 <chk_mounted+0x328>)
   80f66:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
   80f6a:	600d      	str	r5, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   80f6c:	2d00      	cmp	r5, #0
   80f6e:	f000 8140 	beq.w	811f2 <chk_mounted+0x2b2>
   80f72:	4616      	mov	r6, r2

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
   80f74:	782b      	ldrb	r3, [r5, #0]
   80f76:	b183      	cbz	r3, 80f9a <chk_mounted+0x5a>
		stat = disk_status(fs->drv);
   80f78:	7868      	ldrb	r0, [r5, #1]
   80f7a:	4bbc      	ldr	r3, [pc, #752]	; (8126c <chk_mounted+0x32c>)
   80f7c:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   80f7e:	f010 0f01 	tst.w	r0, #1
   80f82:	d10a      	bne.n	80f9a <chk_mounted+0x5a>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   80f84:	2e00      	cmp	r6, #0
   80f86:	f000 8136 	beq.w	811f6 <chk_mounted+0x2b6>
   80f8a:	f000 0004 	and.w	r0, r0, #4
   80f8e:	b2c0      	uxtb	r0, r0
				return FR_WRITE_PROTECTED;
   80f90:	2800      	cmp	r0, #0
   80f92:	bf0c      	ite	eq
   80f94:	2000      	moveq	r0, #0
   80f96:	200a      	movne	r0, #10
   80f98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
   80f9a:	2300      	movs	r3, #0
   80f9c:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   80f9e:	b2e0      	uxtb	r0, r4
   80fa0:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
   80fa2:	4bb3      	ldr	r3, [pc, #716]	; (81270 <chk_mounted+0x330>)
   80fa4:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   80fa6:	f010 0f01 	tst.w	r0, #1
   80faa:	f040 8126 	bne.w	811fa <chk_mounted+0x2ba>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   80fae:	b11e      	cbz	r6, 80fb8 <chk_mounted+0x78>
   80fb0:	f010 0f04 	tst.w	r0, #4
   80fb4:	f040 8123 	bne.w	811fe <chk_mounted+0x2be>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   80fb8:	4628      	mov	r0, r5
   80fba:	2100      	movs	r1, #0
   80fbc:	4bad      	ldr	r3, [pc, #692]	; (81274 <chk_mounted+0x334>)
   80fbe:	4798      	blx	r3
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   80fc0:	2801      	cmp	r0, #1
   80fc2:	d117      	bne.n	80ff4 <chk_mounted+0xb4>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
   80fc4:	f895 31f2 	ldrb.w	r3, [r5, #498]	; 0x1f2
   80fc8:	2b00      	cmp	r3, #0
   80fca:	f000 811a 	beq.w	81202 <chk_mounted+0x2c2>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   80fce:	f895 21f9 	ldrb.w	r2, [r5, #505]	; 0x1f9
   80fd2:	f895 31f8 	ldrb.w	r3, [r5, #504]	; 0x1f8
   80fd6:	041b      	lsls	r3, r3, #16
   80fd8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   80fdc:	f895 41f6 	ldrb.w	r4, [r5, #502]	; 0x1f6
   80fe0:	4323      	orrs	r3, r4
   80fe2:	f895 41f7 	ldrb.w	r4, [r5, #503]	; 0x1f7
   80fe6:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
   80fea:	4628      	mov	r0, r5
   80fec:	4621      	mov	r1, r4
   80fee:	4ba1      	ldr	r3, [pc, #644]	; (81274 <chk_mounted+0x334>)
   80ff0:	4798      	blx	r3
   80ff2:	e000      	b.n	80ff6 <chk_mounted+0xb6>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   80ff4:	2400      	movs	r4, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
   80ff6:	2803      	cmp	r0, #3
   80ff8:	f000 8105 	beq.w	81206 <chk_mounted+0x2c6>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   80ffc:	2800      	cmp	r0, #0
   80ffe:	f040 8104 	bne.w	8120a <chk_mounted+0x2ca>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   81002:	f895 203c 	ldrb.w	r2, [r5, #60]	; 0x3c
   81006:	f895 303b 	ldrb.w	r3, [r5, #59]	; 0x3b
   8100a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   8100e:	b21b      	sxth	r3, r3
   81010:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   81014:	f040 80fb 	bne.w	8120e <chk_mounted+0x2ce>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   81018:	f895 1047 	ldrb.w	r1, [r5, #71]	; 0x47
   8101c:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   81020:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
   81024:	d10d      	bne.n	81042 <chk_mounted+0x102>
   81026:	f895 2057 	ldrb.w	r2, [r5, #87]	; 0x57
   8102a:	f895 3056 	ldrb.w	r3, [r5, #86]	; 0x56
   8102e:	041b      	lsls	r3, r3, #16
   81030:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   81034:	f895 1054 	ldrb.w	r1, [r5, #84]	; 0x54
   81038:	430b      	orrs	r3, r1
   8103a:	f895 1055 	ldrb.w	r1, [r5, #85]	; 0x55
   8103e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;
   81042:	61e9      	str	r1, [r5, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   81044:	f895 e040 	ldrb.w	lr, [r5, #64]	; 0x40
   81048:	f885 e003 	strb.w	lr, [r5, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   8104c:	f10e 33ff 	add.w	r3, lr, #4294967295
   81050:	b2db      	uxtb	r3, r3
   81052:	2b01      	cmp	r3, #1
   81054:	f200 80dd 	bhi.w	81212 <chk_mounted+0x2d2>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   81058:	f895 303d 	ldrb.w	r3, [r5, #61]	; 0x3d
   8105c:	70ab      	strb	r3, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   8105e:	2b00      	cmp	r3, #0
   81060:	f000 80d9 	beq.w	81216 <chk_mounted+0x2d6>
   81064:	1e5a      	subs	r2, r3, #1
   81066:	421a      	tst	r2, r3
   81068:	f040 80d7 	bne.w	8121a <chk_mounted+0x2da>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   8106c:	f895 7042 	ldrb.w	r7, [r5, #66]	; 0x42
   81070:	f895 2041 	ldrb.w	r2, [r5, #65]	; 0x41
   81074:	ea42 2707 	orr.w	r7, r2, r7, lsl #8
   81078:	812f      	strh	r7, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   8107a:	f017 0f0f 	tst.w	r7, #15
   8107e:	f040 80ce 	bne.w	8121e <chk_mounted+0x2de>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   81082:	f895 0044 	ldrb.w	r0, [r5, #68]	; 0x44
   81086:	f895 2043 	ldrb.w	r2, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   8108a:	ea52 2200 	orrs.w	r2, r2, r0, lsl #8
   8108e:	d10d      	bne.n	810ac <chk_mounted+0x16c>
   81090:	f895 6053 	ldrb.w	r6, [r5, #83]	; 0x53
   81094:	f895 2052 	ldrb.w	r2, [r5, #82]	; 0x52
   81098:	0412      	lsls	r2, r2, #16
   8109a:	ea42 6606 	orr.w	r6, r2, r6, lsl #24
   8109e:	f895 2050 	ldrb.w	r2, [r5, #80]	; 0x50
   810a2:	4332      	orrs	r2, r6
   810a4:	f895 0051 	ldrb.w	r0, [r5, #81]	; 0x51
   810a8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   810ac:	f895 603f 	ldrb.w	r6, [r5, #63]	; 0x3f
   810b0:	f895 003e 	ldrb.w	r0, [r5, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   810b4:	ea50 2006 	orrs.w	r0, r0, r6, lsl #8
   810b8:	f000 80b3 	beq.w	81222 <chk_mounted+0x2e2>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
   810bc:	fb0e fe01 	mul.w	lr, lr, r1
   810c0:	eb00 1617 	add.w	r6, r0, r7, lsr #4

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   810c4:	4476      	add	r6, lr
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   810c6:	42b2      	cmp	r2, r6
   810c8:	f0c0 80ad 	bcc.w	81226 <chk_mounted+0x2e6>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   810cc:	1b92      	subs	r2, r2, r6
   810ce:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   810d2:	2b00      	cmp	r3, #0
   810d4:	f000 80a9 	beq.w	8122a <chk_mounted+0x2ea>
	fmt = FS_FAT12;
   810d8:	f640 72f5 	movw	r2, #4085	; 0xff5
   810dc:	4293      	cmp	r3, r2
   810de:	bf8c      	ite	hi
   810e0:	2202      	movhi	r2, #2
   810e2:	2201      	movls	r2, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   810e4:	f64f 7cf5 	movw	ip, #65525	; 0xfff5
   810e8:	4563      	cmp	r3, ip
   810ea:	f200 80a8 	bhi.w	8123e <chk_mounted+0x2fe>
   810ee:	e0e2      	b.n	812b6 <chk_mounted+0x376>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   810f0:	f895 005f 	ldrb.w	r0, [r5, #95]	; 0x5f
   810f4:	f895 205e 	ldrb.w	r2, [r5, #94]	; 0x5e
   810f8:	0412      	lsls	r2, r2, #16
   810fa:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
   810fe:	f895 205c 	ldrb.w	r2, [r5, #92]	; 0x5c
   81102:	4302      	orrs	r2, r0
   81104:	f895 005d 	ldrb.w	r0, [r5, #93]	; 0x5d
   81108:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
   8110c:	626a      	str	r2, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   8110e:	009b      	lsls	r3, r3, #2
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   81110:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
   81114:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
   81118:	f0c0 8089 	bcc.w	8122e <chk_mounted+0x2ee>
   8111c:	e0b2      	b.n	81284 <chk_mounted+0x344>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   8111e:	4470      	add	r0, lr
   81120:	6268      	str	r0, [r5, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   81122:	2a02      	cmp	r2, #2
   81124:	bf0f      	iteee	eq
   81126:	005b      	lsleq	r3, r3, #1
   81128:	eb03 0043 	addne.w	r0, r3, r3, lsl #1
   8112c:	f003 0301 	andne.w	r3, r3, #1
   81130:	eb03 0350 	addne.w	r3, r3, r0, lsr #1
   81134:	e092      	b.n	8125c <chk_mounted+0x31c>
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   81136:	f895 222f 	ldrb.w	r2, [r5, #559]	; 0x22f
   8113a:	f895 322e 	ldrb.w	r3, [r5, #558]	; 0x22e
   8113e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   81142:	b21b      	sxth	r3, r3
   81144:	4a4c      	ldr	r2, [pc, #304]	; (81278 <chk_mounted+0x338>)
   81146:	4293      	cmp	r3, r2
   81148:	d141      	bne.n	811ce <chk_mounted+0x28e>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   8114a:	f895 2033 	ldrb.w	r2, [r5, #51]	; 0x33
   8114e:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
   81152:	041b      	lsls	r3, r3, #16
   81154:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
   81158:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   8115c:	4313      	orrs	r3, r2
   8115e:	f895 2031 	ldrb.w	r2, [r5, #49]	; 0x31
   81162:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   81166:	4a45      	ldr	r2, [pc, #276]	; (8127c <chk_mounted+0x33c>)
   81168:	4293      	cmp	r3, r2
   8116a:	d132      	bne.n	811d2 <chk_mounted+0x292>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   8116c:	f895 2217 	ldrb.w	r2, [r5, #535]	; 0x217
   81170:	f895 3216 	ldrb.w	r3, [r5, #534]	; 0x216
   81174:	041b      	lsls	r3, r3, #16
   81176:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
   8117a:	f895 3214 	ldrb.w	r3, [r5, #532]	; 0x214
   8117e:	4313      	orrs	r3, r2
   81180:	f895 2215 	ldrb.w	r2, [r5, #533]	; 0x215
   81184:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   81188:	4a3d      	ldr	r2, [pc, #244]	; (81280 <chk_mounted+0x340>)
   8118a:	4293      	cmp	r3, r2
   8118c:	d123      	bne.n	811d6 <chk_mounted+0x296>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   8118e:	f895 221f 	ldrb.w	r2, [r5, #543]	; 0x21f
   81192:	f895 321e 	ldrb.w	r3, [r5, #542]	; 0x21e
   81196:	041b      	lsls	r3, r3, #16
   81198:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
   8119c:	f895 321c 	ldrb.w	r3, [r5, #540]	; 0x21c
   811a0:	4313      	orrs	r3, r2
   811a2:	f895 221d 	ldrb.w	r2, [r5, #541]	; 0x21d
   811a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   811aa:	60eb      	str	r3, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   811ac:	f895 221b 	ldrb.w	r2, [r5, #539]	; 0x21b
   811b0:	f895 321a 	ldrb.w	r3, [r5, #538]	; 0x21a
   811b4:	041b      	lsls	r3, r3, #16
   811b6:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
   811ba:	f895 3218 	ldrb.w	r3, [r5, #536]	; 0x218
   811be:	4313      	orrs	r3, r2
   811c0:	f895 2219 	ldrb.w	r2, [r5, #537]	; 0x219
   811c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   811c8:	612b      	str	r3, [r5, #16]
   811ca:	2203      	movs	r2, #3
   811cc:	e004      	b.n	811d8 <chk_mounted+0x298>
   811ce:	2203      	movs	r2, #3
   811d0:	e002      	b.n	811d8 <chk_mounted+0x298>
   811d2:	2203      	movs	r2, #3
   811d4:	e000      	b.n	811d8 <chk_mounted+0x298>
   811d6:	2203      	movs	r2, #3
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
   811d8:	702a      	strb	r2, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
   811da:	4a23      	ldr	r2, [pc, #140]	; (81268 <chk_mounted+0x328>)
   811dc:	8a93      	ldrh	r3, [r2, #20]
   811de:	3301      	adds	r3, #1
   811e0:	b29b      	uxth	r3, r3
   811e2:	8293      	strh	r3, [r2, #20]
   811e4:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
   811e6:	2000      	movs	r0, #0
   811e8:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->wflag = 0;
   811ea:	7128      	strb	r0, [r5, #4]
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
   811ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
   811ee:	200b      	movs	r0, #11
   811f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   811f2:	200c      	movs	r0, #12
   811f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
   811f6:	2000      	movs	r0, #0
   811f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
   811fa:	2003      	movs	r0, #3
   811fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
   811fe:	200a      	movs	r0, #10
   81200:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   81202:	200d      	movs	r0, #13
   81204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
   81206:	2001      	movs	r0, #1
   81208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   8120a:	200d      	movs	r0, #13
   8120c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
   8120e:	200d      	movs	r0, #13
   81210:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   81212:	200d      	movs	r0, #13
   81214:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   81216:	200d      	movs	r0, #13
   81218:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8121a:	200d      	movs	r0, #13
   8121c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   8121e:	200d      	movs	r0, #13
   81220:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   81222:	200d      	movs	r0, #13
   81224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   81226:	200d      	movs	r0, #13
   81228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   8122a:	200d      	movs	r0, #13
   8122c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
   8122e:	200d      	movs	r0, #13
   81230:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   81232:	200d      	movs	r0, #13
   81234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
   81236:	200d      	movs	r0, #13
   81238:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   8123a:	200d      	movs	r0, #13
   8123c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   8123e:	3302      	adds	r3, #2
   81240:	61ab      	str	r3, [r5, #24]
	fs->database = bsect + sysect;						/* Data start sector */
   81242:	4426      	add	r6, r4
   81244:	62ae      	str	r6, [r5, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   81246:	4420      	add	r0, r4
   81248:	6228      	str	r0, [r5, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   8124a:	2f00      	cmp	r7, #0
   8124c:	d1f1      	bne.n	81232 <chk_mounted+0x2f2>
   8124e:	e74f      	b.n	810f0 <chk_mounted+0x1b0>
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
   81250:	f04f 33ff 	mov.w	r3, #4294967295
   81254:	612b      	str	r3, [r5, #16]
	fs->last_clust = 0;
   81256:	2300      	movs	r3, #0
   81258:	60eb      	str	r3, [r5, #12]
   8125a:	e7bd      	b.n	811d8 <chk_mounted+0x298>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   8125c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
   81260:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
   81264:	d3e7      	bcc.n	81236 <chk_mounted+0x2f6>
   81266:	e7f3      	b.n	81250 <chk_mounted+0x310>
   81268:	200008e8 	.word	0x200008e8
   8126c:	00080d1d 	.word	0x00080d1d
   81270:	00080d05 	.word	0x00080d05
   81274:	00080eb1 	.word	0x00080eb1
   81278:	ffffaa55 	.word	0xffffaa55
   8127c:	41615252 	.word	0x41615252
   81280:	61417272 	.word	0x61417272
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
   81284:	f04f 33ff 	mov.w	r3, #4294967295
   81288:	612b      	str	r3, [r5, #16]
	fs->last_clust = 0;
   8128a:	2300      	movs	r3, #0
   8128c:	60eb      	str	r3, [r5, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
   8128e:	716b      	strb	r3, [r5, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   81290:	f895 2061 	ldrb.w	r2, [r5, #97]	; 0x61
   81294:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
   81298:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
   8129c:	4422      	add	r2, r4
   8129e:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   812a0:	7868      	ldrb	r0, [r5, #1]
   812a2:	f105 0130 	add.w	r1, r5, #48	; 0x30
   812a6:	2301      	movs	r3, #1
   812a8:	4c07      	ldr	r4, [pc, #28]	; (812c8 <chk_mounted+0x388>)
   812aa:	47a0      	blx	r4
   812ac:	2800      	cmp	r0, #0
   812ae:	f43f af42 	beq.w	81136 <chk_mounted+0x1f6>
   812b2:	2203      	movs	r2, #3
   812b4:	e790      	b.n	811d8 <chk_mounted+0x298>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   812b6:	3302      	adds	r3, #2
   812b8:	61ab      	str	r3, [r5, #24]
	fs->database = bsect + sysect;						/* Data start sector */
   812ba:	4426      	add	r6, r4
   812bc:	62ae      	str	r6, [r5, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   812be:	4420      	add	r0, r4
   812c0:	6228      	str	r0, [r5, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   812c2:	2f00      	cmp	r7, #0
   812c4:	d0b9      	beq.n	8123a <chk_mounted+0x2fa>
   812c6:	e72a      	b.n	8111e <chk_mounted+0x1de>
   812c8:	00080d79 	.word	0x00080d79

000812cc <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
   812cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	DWORD wsect;


	wsect = fs->winsect;
   812d0:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
   812d2:	428f      	cmp	r7, r1
   812d4:	d031      	beq.n	8133a <move_window+0x6e>
   812d6:	460e      	mov	r6, r1
   812d8:	4604      	mov	r4, r0
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
   812da:	7903      	ldrb	r3, [r0, #4]
   812dc:	b30b      	cbz	r3, 81322 <move_window+0x56>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   812de:	f100 0830 	add.w	r8, r0, #48	; 0x30
   812e2:	7840      	ldrb	r0, [r0, #1]
   812e4:	4641      	mov	r1, r8
   812e6:	463a      	mov	r2, r7
   812e8:	2301      	movs	r3, #1
   812ea:	4d1a      	ldr	r5, [pc, #104]	; (81354 <move_window+0x88>)
   812ec:	47a8      	blx	r5
   812ee:	bb38      	cbnz	r0, 81340 <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
   812f0:	2300      	movs	r3, #0
   812f2:	7123      	strb	r3, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   812f4:	69e2      	ldr	r2, [r4, #28]
   812f6:	6a23      	ldr	r3, [r4, #32]
   812f8:	4413      	add	r3, r2
   812fa:	429f      	cmp	r7, r3
   812fc:	d211      	bcs.n	81322 <move_window+0x56>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   812fe:	78e5      	ldrb	r5, [r4, #3]
   81300:	2d01      	cmp	r5, #1
   81302:	d90e      	bls.n	81322 <move_window+0x56>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
   81304:	f04f 0a01 	mov.w	sl, #1
   81308:	f8df 9048 	ldr.w	r9, [pc, #72]	; 81354 <move_window+0x88>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
   8130c:	69e3      	ldr	r3, [r4, #28]
   8130e:	441f      	add	r7, r3
					disk_write(fs->drv, fs->win, wsect, 1);
   81310:	7860      	ldrb	r0, [r4, #1]
   81312:	4641      	mov	r1, r8
   81314:	463a      	mov	r2, r7
   81316:	4653      	mov	r3, sl
   81318:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   8131a:	3d01      	subs	r5, #1
   8131c:	b2ed      	uxtb	r5, r5
   8131e:	2d01      	cmp	r5, #1
   81320:	d1f4      	bne.n	8130c <move_window+0x40>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
   81322:	b186      	cbz	r6, 81346 <move_window+0x7a>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   81324:	7860      	ldrb	r0, [r4, #1]
   81326:	f104 0130 	add.w	r1, r4, #48	; 0x30
   8132a:	4632      	mov	r2, r6
   8132c:	2301      	movs	r3, #1
   8132e:	4d0a      	ldr	r5, [pc, #40]	; (81358 <move_window+0x8c>)
   81330:	47a8      	blx	r5
   81332:	b958      	cbnz	r0, 8134c <move_window+0x80>
				return FR_DISK_ERR;
			fs->winsect = sector;
   81334:	62e6      	str	r6, [r4, #44]	; 0x2c
   81336:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
	}

	return FR_OK;
   8133a:	2000      	movs	r0, #0
   8133c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
   81340:	2001      	movs	r0, #1
   81342:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
   81346:	2000      	movs	r0, #0
   81348:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
   8134c:	2001      	movs	r0, #1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
   8134e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   81352:	bf00      	nop
   81354:	00080e05 	.word	0x00080e05
   81358:	00080d79 	.word	0x00080d79

0008135c <get_fat>:
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   8135c:	2901      	cmp	r1, #1
   8135e:	d95f      	bls.n	81420 <get_fat+0xc4>

static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
   81360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   81362:	6983      	ldr	r3, [r0, #24]
   81364:	4299      	cmp	r1, r3
   81366:	d25d      	bcs.n	81424 <get_fat+0xc8>
   81368:	460c      	mov	r4, r1
   8136a:	4606      	mov	r6, r0
		return 1;

	switch (fs->fs_type) {
   8136c:	7803      	ldrb	r3, [r0, #0]
   8136e:	2b02      	cmp	r3, #2
   81370:	d028      	beq.n	813c4 <get_fat+0x68>
   81372:	2b03      	cmp	r3, #3
   81374:	d039      	beq.n	813ea <get_fat+0x8e>
   81376:	2b01      	cmp	r3, #1
   81378:	d156      	bne.n	81428 <get_fat+0xcc>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
   8137a:	eb01 0751 	add.w	r7, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   8137e:	6a01      	ldr	r1, [r0, #32]
   81380:	eb01 2157 	add.w	r1, r1, r7, lsr #9
   81384:	4b30      	ldr	r3, [pc, #192]	; (81448 <get_fat+0xec>)
   81386:	4798      	blx	r3
   81388:	2800      	cmp	r0, #0
   8138a:	d150      	bne.n	8142e <get_fat+0xd2>
		wc = fs->win[bc % SS(fs)]; bc++;
   8138c:	f3c7 0308 	ubfx	r3, r7, #0, #9
   81390:	4433      	add	r3, r6
   81392:	f893 5030 	ldrb.w	r5, [r3, #48]	; 0x30
   81396:	3701      	adds	r7, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   81398:	6a31      	ldr	r1, [r6, #32]
   8139a:	4630      	mov	r0, r6
   8139c:	eb01 2157 	add.w	r1, r1, r7, lsr #9
   813a0:	4b29      	ldr	r3, [pc, #164]	; (81448 <get_fat+0xec>)
   813a2:	4798      	blx	r3
   813a4:	2800      	cmp	r0, #0
   813a6:	d145      	bne.n	81434 <get_fat+0xd8>
		wc |= fs->win[bc % SS(fs)] << 8;
   813a8:	f3c7 0708 	ubfx	r7, r7, #0, #9
   813ac:	19f1      	adds	r1, r6, r7
   813ae:	f891 0030 	ldrb.w	r0, [r1, #48]	; 0x30
   813b2:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   813b6:	f014 0f01 	tst.w	r4, #1
   813ba:	bf14      	ite	ne
   813bc:	0900      	lsrne	r0, r0, #4
   813be:	f3c0 000b 	ubfxeq	r0, r0, #0, #12
   813c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   813c4:	6a01      	ldr	r1, [r0, #32]
   813c6:	eb01 2114 	add.w	r1, r1, r4, lsr #8
   813ca:	4b1f      	ldr	r3, [pc, #124]	; (81448 <get_fat+0xec>)
   813cc:	4798      	blx	r3
   813ce:	2800      	cmp	r0, #0
   813d0:	d133      	bne.n	8143a <get_fat+0xde>
		p = &fs->win[clst * 2 % SS(fs)];
   813d2:	0061      	lsls	r1, r4, #1
   813d4:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
		return LD_WORD(p);
   813d8:	1873      	adds	r3, r6, r1
   813da:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   813de:	4431      	add	r1, r6
   813e0:	f891 0031 	ldrb.w	r0, [r1, #49]	; 0x31
   813e4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   813e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   813ea:	6a01      	ldr	r1, [r0, #32]
   813ec:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
   813f0:	4b15      	ldr	r3, [pc, #84]	; (81448 <get_fat+0xec>)
   813f2:	4798      	blx	r3
   813f4:	bb20      	cbnz	r0, 81440 <get_fat+0xe4>
		p = &fs->win[clst * 4 % SS(fs)];
   813f6:	00a1      	lsls	r1, r4, #2
   813f8:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
   813fc:	f101 0230 	add.w	r2, r1, #48	; 0x30
   81400:	4432      	add	r2, r6
		return LD_DWORD(p) & 0x0FFFFFFF;
   81402:	7890      	ldrb	r0, [r2, #2]
   81404:	78d3      	ldrb	r3, [r2, #3]
   81406:	061b      	lsls	r3, r3, #24
   81408:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   8140c:	7850      	ldrb	r0, [r2, #1]
   8140e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   81412:	4431      	add	r1, r6
   81414:	f891 3030 	ldrb.w	r3, [r1, #48]	; 0x30
   81418:	4318      	orrs	r0, r3
   8141a:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
   8141e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;
   81420:	2001      	movs	r0, #1
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
   81422:	4770      	bx	lr
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;
   81424:	2001      	movs	r0, #1
   81426:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   81428:	f04f 30ff 	mov.w	r0, #4294967295
   8142c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8142e:	f04f 30ff 	mov.w	r0, #4294967295
   81432:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   81434:	f04f 30ff 	mov.w	r0, #4294967295
   81438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8143a:	f04f 30ff 	mov.w	r0, #4294967295
   8143e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   81440:	f04f 30ff 	mov.w	r0, #4294967295
}
   81444:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   81446:	bf00      	nop
   81448:	000812cd 	.word	0x000812cd

0008144c <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
   8144c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8144e:	4605      	mov	r5, r0
   81450:	460c      	mov	r4, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
   81452:	80e9      	strh	r1, [r5, #6]
	clst = dj->sclust;
   81454:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   81456:	2901      	cmp	r1, #1
   81458:	d038      	beq.n	814cc <dir_sdi+0x80>
   8145a:	6803      	ldr	r3, [r0, #0]
   8145c:	699a      	ldr	r2, [r3, #24]
   8145e:	4291      	cmp	r1, r2
   81460:	d236      	bcs.n	814d0 <dir_sdi+0x84>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   81462:	b971      	cbnz	r1, 81482 <dir_sdi+0x36>
   81464:	781a      	ldrb	r2, [r3, #0]
   81466:	2a03      	cmp	r2, #3
   81468:	d101      	bne.n	8146e <dir_sdi+0x22>
		clst = dj->fs->dirbase;
   8146a:	6a59      	ldr	r1, [r3, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   8146c:	b949      	cbnz	r1, 81482 <dir_sdi+0x36>
		dj->clust = clst;
   8146e:	2200      	movs	r2, #0
   81470:	60ea      	str	r2, [r5, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   81472:	891a      	ldrh	r2, [r3, #8]
   81474:	42a2      	cmp	r2, r4
   81476:	d92d      	bls.n	814d4 <dir_sdi+0x88>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   81478:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8147a:	eb03 1314 	add.w	r3, r3, r4, lsr #4
   8147e:	612b      	str	r3, [r5, #16]
   81480:	e01b      	b.n	814ba <dir_sdi+0x6e>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   81482:	789e      	ldrb	r6, [r3, #2]
   81484:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
   81486:	42b4      	cmp	r4, r6
   81488:	d310      	bcc.n	814ac <dir_sdi+0x60>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   8148a:	4f16      	ldr	r7, [pc, #88]	; (814e4 <dir_sdi+0x98>)
   8148c:	6828      	ldr	r0, [r5, #0]
   8148e:	47b8      	blx	r7
   81490:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   81492:	f1b0 3fff 	cmp.w	r0, #4294967295
   81496:	d01f      	beq.n	814d8 <dir_sdi+0x8c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   81498:	2801      	cmp	r0, #1
   8149a:	d91f      	bls.n	814dc <dir_sdi+0x90>
   8149c:	682b      	ldr	r3, [r5, #0]
   8149e:	699b      	ldr	r3, [r3, #24]
   814a0:	4298      	cmp	r0, r3
   814a2:	d21d      	bcs.n	814e0 <dir_sdi+0x94>
				return FR_INT_ERR;
			idx -= ic;
   814a4:	1ba4      	subs	r4, r4, r6
   814a6:	b2a4      	uxth	r4, r4
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
   814a8:	42a6      	cmp	r6, r4
   814aa:	d9ef      	bls.n	8148c <dir_sdi+0x40>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
   814ac:	60e9      	str	r1, [r5, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   814ae:	6828      	ldr	r0, [r5, #0]
   814b0:	4b0d      	ldr	r3, [pc, #52]	; (814e8 <dir_sdi+0x9c>)
   814b2:	4798      	blx	r3
   814b4:	eb00 1014 	add.w	r0, r0, r4, lsr #4
   814b8:	6128      	str	r0, [r5, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   814ba:	f004 030f 	and.w	r3, r4, #15
   814be:	015b      	lsls	r3, r3, #5
   814c0:	3330      	adds	r3, #48	; 0x30
   814c2:	682a      	ldr	r2, [r5, #0]
   814c4:	4413      	add	r3, r2
   814c6:	616b      	str	r3, [r5, #20]

	return FR_OK;	/* Seek succeeded */
   814c8:	2000      	movs	r0, #0
   814ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
   814cc:	2002      	movs	r0, #2
   814ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   814d0:	2002      	movs	r0, #2
   814d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
   814d4:	2002      	movs	r0, #2
   814d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   814d8:	2001      	movs	r0, #1
   814da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
   814dc:	2002      	movs	r0, #2
   814de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   814e0:	2002      	movs	r0, #2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
   814e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   814e4:	0008135d 	.word	0x0008135d
   814e8:	00080e45 	.word	0x00080e45

000814ec <put_fat>:
static FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
   814ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   814f0:	460c      	mov	r4, r1
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   814f2:	2901      	cmp	r1, #1
   814f4:	d97c      	bls.n	815f0 <put_fat+0x104>
   814f6:	4605      	mov	r5, r0
   814f8:	4617      	mov	r7, r2
   814fa:	6983      	ldr	r3, [r0, #24]
   814fc:	4299      	cmp	r1, r3
   814fe:	d279      	bcs.n	815f4 <put_fat+0x108>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
   81500:	7803      	ldrb	r3, [r0, #0]
   81502:	2b02      	cmp	r3, #2
   81504:	d03d      	beq.n	81582 <put_fat+0x96>
   81506:	2b03      	cmp	r3, #3
   81508:	d04d      	beq.n	815a6 <put_fat+0xba>
   8150a:	2b01      	cmp	r3, #1
   8150c:	d168      	bne.n	815e0 <put_fat+0xf4>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
   8150e:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   81512:	6a01      	ldr	r1, [r0, #32]
   81514:	eb01 2158 	add.w	r1, r1, r8, lsr #9
   81518:	4b41      	ldr	r3, [pc, #260]	; (81620 <put_fat+0x134>)
   8151a:	4798      	blx	r3
			if (res != FR_OK) break;
   8151c:	4606      	mov	r6, r0
   8151e:	2800      	cmp	r0, #0
   81520:	d163      	bne.n	815ea <put_fat+0xfe>
			p = &fs->win[bc % SS(fs)];
   81522:	f3c8 0308 	ubfx	r3, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   81526:	f014 0f01 	tst.w	r4, #1
   8152a:	d016      	beq.n	8155a <put_fat+0x6e>
   8152c:	442b      	add	r3, r5
   8152e:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   81532:	f002 020f 	and.w	r2, r2, #15
   81536:	b2f9      	uxtb	r1, r7
   81538:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
   8153c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
   81540:	f108 0801 	add.w	r8, r8, #1
			fs->wflag = 1;
   81544:	2301      	movs	r3, #1
   81546:	712b      	strb	r3, [r5, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   81548:	6a29      	ldr	r1, [r5, #32]
   8154a:	4628      	mov	r0, r5
   8154c:	eb01 2158 	add.w	r1, r1, r8, lsr #9
   81550:	4b33      	ldr	r3, [pc, #204]	; (81620 <put_fat+0x134>)
   81552:	4798      	blx	r3
			if (res != FR_OK) break;
   81554:	2800      	cmp	r0, #0
   81556:	d145      	bne.n	815e4 <put_fat+0xf8>
   81558:	e04e      	b.n	815f8 <put_fat+0x10c>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   8155a:	442b      	add	r3, r5
   8155c:	f883 7030 	strb.w	r7, [r3, #48]	; 0x30
			bc++;
   81560:	f108 0801 	add.w	r8, r8, #1
			fs->wflag = 1;
   81564:	2301      	movs	r3, #1
   81566:	712b      	strb	r3, [r5, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   81568:	6a29      	ldr	r1, [r5, #32]
   8156a:	4628      	mov	r0, r5
   8156c:	eb01 2158 	add.w	r1, r1, r8, lsr #9
   81570:	4b2b      	ldr	r3, [pc, #172]	; (81620 <put_fat+0x134>)
   81572:	4798      	blx	r3
			if (res != FR_OK) break;
   81574:	bbc0      	cbnz	r0, 815e8 <put_fat+0xfc>
   81576:	e044      	b.n	81602 <put_fat+0x116>
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   81578:	eb05 0308 	add.w	r3, r5, r8
   8157c:	f883 7030 	strb.w	r7, [r3, #48]	; 0x30
			break;
   81580:	e033      	b.n	815ea <put_fat+0xfe>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   81582:	6a01      	ldr	r1, [r0, #32]
   81584:	eb01 2114 	add.w	r1, r1, r4, lsr #8
   81588:	4b25      	ldr	r3, [pc, #148]	; (81620 <put_fat+0x134>)
   8158a:	4798      	blx	r3
			if (res != FR_OK) break;
   8158c:	4606      	mov	r6, r0
   8158e:	bb60      	cbnz	r0, 815ea <put_fat+0xfe>
			p = &fs->win[clst * 2 % SS(fs)];
   81590:	0064      	lsls	r4, r4, #1
   81592:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
   81596:	192b      	adds	r3, r5, r4
   81598:	f883 7030 	strb.w	r7, [r3, #48]	; 0x30
   8159c:	f3c7 2707 	ubfx	r7, r7, #8, #8
   815a0:	f883 7031 	strb.w	r7, [r3, #49]	; 0x31
			break;
   815a4:	e021      	b.n	815ea <put_fat+0xfe>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   815a6:	6a01      	ldr	r1, [r0, #32]
   815a8:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
   815ac:	4b1c      	ldr	r3, [pc, #112]	; (81620 <put_fat+0x134>)
   815ae:	4798      	blx	r3
			if (res != FR_OK) break;
   815b0:	4606      	mov	r6, r0
   815b2:	b9d0      	cbnz	r0, 815ea <put_fat+0xfe>
			p = &fs->win[clst * 4 % SS(fs)];
   815b4:	00a4      	lsls	r4, r4, #2
   815b6:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
   815ba:	f104 0230 	add.w	r2, r4, #48	; 0x30
   815be:	442a      	add	r2, r5
			val |= LD_DWORD(p) & 0xF0000000;
   815c0:	78d3      	ldrb	r3, [r2, #3]
   815c2:	061b      	lsls	r3, r3, #24
   815c4:	442c      	add	r4, r5
   815c6:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
   815ca:	431f      	orrs	r7, r3
			ST_DWORD(p, val);
   815cc:	f884 7030 	strb.w	r7, [r4, #48]	; 0x30
   815d0:	f3c7 2307 	ubfx	r3, r7, #8, #8
   815d4:	7053      	strb	r3, [r2, #1]
   815d6:	0c3b      	lsrs	r3, r7, #16
   815d8:	7093      	strb	r3, [r2, #2]
   815da:	0e3f      	lsrs	r7, r7, #24
   815dc:	70d7      	strb	r7, [r2, #3]
			break;
   815de:	e004      	b.n	815ea <put_fat+0xfe>

		default :
			res = FR_INT_ERR;
   815e0:	2602      	movs	r6, #2
   815e2:	e002      	b.n	815ea <put_fat+0xfe>
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   815e4:	4606      	mov	r6, r0
   815e6:	e000      	b.n	815ea <put_fat+0xfe>
   815e8:	4606      	mov	r6, r0
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
   815ea:	2301      	movs	r3, #1
   815ec:	712b      	strb	r3, [r5, #4]
   815ee:	e014      	b.n	8161a <put_fat+0x12e>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
   815f0:	2602      	movs	r6, #2
   815f2:	e012      	b.n	8161a <put_fat+0x12e>
   815f4:	2602      	movs	r6, #2
   815f6:	e010      	b.n	8161a <put_fat+0x12e>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
   815f8:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   815fc:	f3c7 1707 	ubfx	r7, r7, #4, #8
   81600:	e7ba      	b.n	81578 <put_fat+0x8c>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
   81602:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   81606:	eb05 0308 	add.w	r3, r5, r8
   8160a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   8160e:	f023 030f 	bic.w	r3, r3, #15
   81612:	f3c7 2703 	ubfx	r7, r7, #8, #4
   81616:	431f      	orrs	r7, r3
   81618:	e7ae      	b.n	81578 <put_fat+0x8c>
		}
		fs->wflag = 1;
	}

	return res;
}
   8161a:	4630      	mov	r0, r6
   8161c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81620:	000812cd 	.word	0x000812cd

00081624 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
   81624:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   81628:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
   8162a:	4688      	mov	r8, r1
   8162c:	b931      	cbnz	r1, 8163c <create_chain+0x18>
		scl = fs->last_clust;			/* Get suggested start point */
   8162e:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
   81630:	b16e      	cbz	r6, 8164e <create_chain+0x2a>
   81632:	6983      	ldr	r3, [r0, #24]
   81634:	429e      	cmp	r6, r3
   81636:	bf28      	it	cs
   81638:	2601      	movcs	r6, #1
   8163a:	e009      	b.n	81650 <create_chain+0x2c>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
   8163c:	4b2c      	ldr	r3, [pc, #176]	; (816f0 <create_chain+0xcc>)
   8163e:	4798      	blx	r3
		if (cs < 2) return 1;			/* It is an invalid cluster */
   81640:	2801      	cmp	r0, #1
   81642:	d942      	bls.n	816ca <create_chain+0xa6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   81644:	69ab      	ldr	r3, [r5, #24]
   81646:	4298      	cmp	r0, r3
   81648:	d350      	bcc.n	816ec <create_chain+0xc8>
		scl = clst;
   8164a:	4646      	mov	r6, r8
   8164c:	e000      	b.n	81650 <create_chain+0x2c>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
   8164e:	2601      	movs	r6, #1
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
   81650:	4634      	mov	r4, r6
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
   81652:	f04f 0902 	mov.w	r9, #2
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   81656:	4f26      	ldr	r7, [pc, #152]	; (816f0 <create_chain+0xcc>)
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
   81658:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
   8165a:	69ab      	ldr	r3, [r5, #24]
   8165c:	429c      	cmp	r4, r3
   8165e:	d302      	bcc.n	81666 <create_chain+0x42>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
   81660:	2e01      	cmp	r6, #1
   81662:	d935      	bls.n	816d0 <create_chain+0xac>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
   81664:	464c      	mov	r4, r9
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   81666:	4628      	mov	r0, r5
   81668:	4621      	mov	r1, r4
   8166a:	47b8      	blx	r7
		if (cs == 0) break;				/* Found a free cluster */
   8166c:	b138      	cbz	r0, 8167e <create_chain+0x5a>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   8166e:	f1b0 3fff 	cmp.w	r0, #4294967295
   81672:	d030      	beq.n	816d6 <create_chain+0xb2>
   81674:	2801      	cmp	r0, #1
   81676:	d032      	beq.n	816de <create_chain+0xba>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
   81678:	42b4      	cmp	r4, r6
   8167a:	d1ed      	bne.n	81658 <create_chain+0x34>
   8167c:	e032      	b.n	816e4 <create_chain+0xc0>
   8167e:	4626      	mov	r6, r4
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   81680:	4628      	mov	r0, r5
   81682:	4621      	mov	r1, r4
   81684:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
   81688:	4b1a      	ldr	r3, [pc, #104]	; (816f4 <create_chain+0xd0>)
   8168a:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
   8168c:	4603      	mov	r3, r0
   8168e:	b9a8      	cbnz	r0, 816bc <create_chain+0x98>
   81690:	f1b8 0f00 	cmp.w	r8, #0
   81694:	d006      	beq.n	816a4 <create_chain+0x80>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   81696:	4628      	mov	r0, r5
   81698:	4641      	mov	r1, r8
   8169a:	4622      	mov	r2, r4
   8169c:	4b15      	ldr	r3, [pc, #84]	; (816f4 <create_chain+0xd0>)
   8169e:	4798      	blx	r3
	}
	if (res == FR_OK) {
   816a0:	4603      	mov	r3, r0
   816a2:	b958      	cbnz	r0, 816bc <create_chain+0x98>
		fs->last_clust = ncl;			/* Update FSINFO */
   816a4:	60ee      	str	r6, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
   816a6:	692b      	ldr	r3, [r5, #16]
   816a8:	f1b3 3fff 	cmp.w	r3, #4294967295
   816ac:	d01d      	beq.n	816ea <create_chain+0xc6>
			fs->free_clust--;
   816ae:	3b01      	subs	r3, #1
   816b0:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
   816b2:	2301      	movs	r3, #1
   816b4:	716b      	strb	r3, [r5, #5]
   816b6:	4620      	mov	r0, r4
   816b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   816bc:	2b01      	cmp	r3, #1
   816be:	bf0c      	ite	eq
   816c0:	f04f 30ff 	moveq.w	r0, #4294967295
   816c4:	2001      	movne	r0, #1
   816c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
   816ca:	2001      	movs	r0, #1
   816cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
   816d0:	2000      	movs	r0, #0
   816d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   816d6:	f04f 30ff 	mov.w	r0, #4294967295
   816da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   816de:	2001      	movs	r0, #1
   816e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
   816e4:	2000      	movs	r0, #0
   816e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   816ea:	4620      	mov	r0, r4
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
	}

	return ncl;		/* Return new cluster number or error code */
}
   816ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   816f0:	0008135d 	.word	0x0008135d
   816f4:	000814ed 	.word	0x000814ed

000816f8 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
   816f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
   816fc:	88c4      	ldrh	r4, [r0, #6]
   816fe:	3401      	adds	r4, #1
   81700:	b2a4      	uxth	r4, r4
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   81702:	2c00      	cmp	r4, #0
   81704:	d070      	beq.n	817e8 <dir_next+0xf0>
   81706:	6903      	ldr	r3, [r0, #16]
   81708:	2b00      	cmp	r3, #0
   8170a:	d070      	beq.n	817ee <dir_next+0xf6>
   8170c:	460e      	mov	r6, r1
   8170e:	4605      	mov	r5, r0
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   81710:	f014 070f 	ands.w	r7, r4, #15
   81714:	d15f      	bne.n	817d6 <dir_next+0xde>
		dj->sect++;					/* Next sector */
   81716:	3301      	adds	r3, #1
   81718:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
   8171a:	68c1      	ldr	r1, [r0, #12]
   8171c:	b921      	cbnz	r1, 81728 <dir_next+0x30>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   8171e:	6803      	ldr	r3, [r0, #0]
   81720:	891b      	ldrh	r3, [r3, #8]
   81722:	42a3      	cmp	r3, r4
   81724:	d966      	bls.n	817f4 <dir_next+0xfc>
   81726:	e056      	b.n	817d6 <dir_next+0xde>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   81728:	6800      	ldr	r0, [r0, #0]
   8172a:	7883      	ldrb	r3, [r0, #2]
   8172c:	3b01      	subs	r3, #1
   8172e:	ea13 1314 	ands.w	r3, r3, r4, lsr #4
   81732:	d150      	bne.n	817d6 <dir_next+0xde>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   81734:	4b3d      	ldr	r3, [pc, #244]	; (8182c <dir_next+0x134>)
   81736:	4798      	blx	r3
   81738:	4680      	mov	r8, r0
				if (clst <= 1) return FR_INT_ERR;
   8173a:	2801      	cmp	r0, #1
   8173c:	d95d      	bls.n	817fa <dir_next+0x102>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   8173e:	f1b0 3fff 	cmp.w	r0, #4294967295
   81742:	d05d      	beq.n	81800 <dir_next+0x108>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   81744:	6828      	ldr	r0, [r5, #0]
   81746:	6983      	ldr	r3, [r0, #24]
   81748:	4598      	cmp	r8, r3
   8174a:	d33d      	bcc.n	817c8 <dir_next+0xd0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   8174c:	2e00      	cmp	r6, #0
   8174e:	d05a      	beq.n	81806 <dir_next+0x10e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   81750:	68e9      	ldr	r1, [r5, #12]
   81752:	4b37      	ldr	r3, [pc, #220]	; (81830 <dir_next+0x138>)
   81754:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   81756:	4680      	mov	r8, r0
   81758:	2800      	cmp	r0, #0
   8175a:	d057      	beq.n	8180c <dir_next+0x114>
					if (clst == 1) return FR_INT_ERR;
   8175c:	2801      	cmp	r0, #1
   8175e:	d058      	beq.n	81812 <dir_next+0x11a>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   81760:	f1b0 3fff 	cmp.w	r0, #4294967295
   81764:	d058      	beq.n	81818 <dir_next+0x120>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   81766:	6828      	ldr	r0, [r5, #0]
   81768:	2100      	movs	r1, #0
   8176a:	4b32      	ldr	r3, [pc, #200]	; (81834 <dir_next+0x13c>)
   8176c:	4798      	blx	r3
   8176e:	2800      	cmp	r0, #0
   81770:	d155      	bne.n	8181e <dir_next+0x126>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   81772:	682b      	ldr	r3, [r5, #0]
   81774:	f103 0230 	add.w	r2, r3, #48	; 0x30
   81778:	f503 730c 	add.w	r3, r3, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
   8177c:	2100      	movs	r1, #0
   8177e:	f802 1b01 	strb.w	r1, [r2], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
   81782:	429a      	cmp	r2, r3
   81784:	d1fb      	bne.n	8177e <dir_next+0x86>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   81786:	682e      	ldr	r6, [r5, #0]
   81788:	4630      	mov	r0, r6
   8178a:	4641      	mov	r1, r8
   8178c:	4b2a      	ldr	r3, [pc, #168]	; (81838 <dir_next+0x140>)
   8178e:	4798      	blx	r3
   81790:	62f0      	str	r0, [r6, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   81792:	2600      	movs	r6, #0
						dj->fs->wflag = 1;
   81794:	f04f 0b01 	mov.w	fp, #1
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   81798:	46b2      	mov	sl, r6
   8179a:	f8df 9098 	ldr.w	r9, [pc, #152]	; 81834 <dir_next+0x13c>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   8179e:	e00b      	b.n	817b8 <dir_next+0xc0>
						dj->fs->wflag = 1;
   817a0:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   817a4:	6828      	ldr	r0, [r5, #0]
   817a6:	4651      	mov	r1, sl
   817a8:	47c8      	blx	r9
   817aa:	3601      	adds	r6, #1
   817ac:	2800      	cmp	r0, #0
   817ae:	d139      	bne.n	81824 <dir_next+0x12c>
						dj->fs->winsect++;
   817b0:	682a      	ldr	r2, [r5, #0]
   817b2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   817b4:	3301      	adds	r3, #1
   817b6:	62d3      	str	r3, [r2, #44]	; 0x2c
   817b8:	b2f1      	uxtb	r1, r6
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   817ba:	682b      	ldr	r3, [r5, #0]
   817bc:	789a      	ldrb	r2, [r3, #2]
   817be:	428a      	cmp	r2, r1
   817c0:	d8ee      	bhi.n	817a0 <dir_next+0xa8>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
   817c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   817c4:	1a52      	subs	r2, r2, r1
   817c6:	62da      	str	r2, [r3, #44]	; 0x2c
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
   817c8:	f8c5 800c 	str.w	r8, [r5, #12]
				dj->sect = clust2sect(dj->fs, clst);
   817cc:	6828      	ldr	r0, [r5, #0]
   817ce:	4641      	mov	r1, r8
   817d0:	4b19      	ldr	r3, [pc, #100]	; (81838 <dir_next+0x140>)
   817d2:	4798      	blx	r3
   817d4:	6128      	str	r0, [r5, #16]
			}
		}
	}

	dj->index = i;
   817d6:	80ec      	strh	r4, [r5, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   817d8:	017f      	lsls	r7, r7, #5
   817da:	3730      	adds	r7, #48	; 0x30
   817dc:	682b      	ldr	r3, [r5, #0]
   817de:	441f      	add	r7, r3
   817e0:	616f      	str	r7, [r5, #20]

	return FR_OK;
   817e2:	2000      	movs	r0, #0
   817e4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
   817e8:	2004      	movs	r0, #4
   817ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   817ee:	2004      	movs	r0, #4
   817f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
   817f4:	2004      	movs	r0, #4
   817f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
   817fa:	2002      	movs	r0, #2
   817fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   81800:	2001      	movs	r0, #1
   81802:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   81806:	2004      	movs	r0, #4
   81808:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   8180c:	2007      	movs	r0, #7
   8180e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 1) return FR_INT_ERR;
   81812:	2002      	movs	r0, #2
   81814:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   81818:	2001      	movs	r0, #1
   8181a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   8181e:	2001      	movs	r0, #1
   81820:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   81824:	2001      	movs	r0, #1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
   81826:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8182a:	bf00      	nop
   8182c:	0008135d 	.word	0x0008135d
   81830:	00081625 	.word	0x00081625
   81834:	000812cd 	.word	0x000812cd
   81838:	00080e45 	.word	0x00080e45

0008183c <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
   8183c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   81840:	4604      	mov	r4, r0
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
   81842:	f04f 0aff 	mov.w	sl, #255	; 0xff
   81846:	4655      	mov	r5, sl
#endif

	res = FR_NO_FILE;
   81848:	2304      	movs	r3, #4
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
   8184a:	4f45      	ldr	r7, [pc, #276]	; (81960 <dir_read+0x124>)
   8184c:	f8df 911c 	ldr.w	r9, [pc, #284]	; 8196c <dir_read+0x130>
   81850:	f109 080d 	add.w	r8, r9, #13
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
   81854:	e06e      	b.n	81934 <dir_read+0xf8>
		res = move_window(dj->fs, dj->sect);
   81856:	6820      	ldr	r0, [r4, #0]
   81858:	47b8      	blx	r7
		if (res != FR_OK) break;
   8185a:	4606      	mov	r6, r0
   8185c:	2800      	cmp	r0, #0
   8185e:	d16e      	bne.n	8193e <dir_read+0x102>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
   81860:	6960      	ldr	r0, [r4, #20]
		c = dir[DIR_Name];
   81862:	7803      	ldrb	r3, [r0, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   81864:	2b00      	cmp	r3, #0
   81866:	d074      	beq.n	81952 <dir_read+0x116>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
   81868:	7ac2      	ldrb	r2, [r0, #11]
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   8186a:	2be5      	cmp	r3, #229	; 0xe5
   8186c:	d055      	beq.n	8191a <dir_read+0xde>
   8186e:	2b2e      	cmp	r3, #46	; 0x2e
   81870:	d055      	beq.n	8191e <dir_read+0xe2>
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
   81872:	f002 013f 	and.w	r1, r2, #63	; 0x3f
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   81876:	f012 0f08 	tst.w	r2, #8
   8187a:	d002      	beq.n	81882 <dir_read+0x46>
   8187c:	290f      	cmp	r1, #15
   8187e:	d150      	bne.n	81922 <dir_read+0xe6>
   81880:	e001      	b.n	81886 <dir_read+0x4a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
   81882:	290f      	cmp	r1, #15
   81884:	d140      	bne.n	81908 <dir_read+0xcc>
				if (c & LLE) {			/* Is it start of LFN sequence? */
   81886:	f013 0f40 	tst.w	r3, #64	; 0x40
   8188a:	d006      	beq.n	8189a <dir_read+0x5e>
					sum = dir[LDIR_Chksum];
   8188c:	f890 a00d 	ldrb.w	sl, [r0, #13]
					c &= ~LLE; ord = c;
   81890:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
					dj->lfn_idx = dj->index;
   81894:	88e2      	ldrh	r2, [r4, #6]
   81896:	8422      	strh	r2, [r4, #32]
   81898:	e003      	b.n	818a2 <dir_read+0x66>
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   8189a:	429d      	cmp	r5, r3
   8189c:	bf18      	it	ne
   8189e:	25ff      	movne	r5, #255	; 0xff
   818a0:	d142      	bne.n	81928 <dir_read+0xec>
   818a2:	7b46      	ldrb	r6, [r0, #13]
   818a4:	4556      	cmp	r6, sl
   818a6:	d13e      	bne.n	81926 <dir_read+0xea>
   818a8:	f8d4 c01c 	ldr.w	ip, [r4, #28]
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   818ac:	7802      	ldrb	r2, [r0, #0]
   818ae:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   818b2:	3a01      	subs	r2, #1
   818b4:	eb02 0542 	add.w	r5, r2, r2, lsl #1
   818b8:	eb02 0585 	add.w	r5, r2, r5, lsl #2
   818bc:	4649      	mov	r1, r9

	s = 0; wc = 1;
   818be:	f04f 0e01 	mov.w	lr, #1
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
   818c2:	f64f 7aff 	movw	sl, #65535	; 0xffff

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   818c6:	f811 2b01 	ldrb.w	r2, [r1], #1
   818ca:	eb00 0b02 	add.w	fp, r0, r2
   818ce:	f89b b001 	ldrb.w	fp, [fp, #1]
   818d2:	5c82      	ldrb	r2, [r0, r2]
   818d4:	ea42 220b 	orr.w	r2, r2, fp, lsl #8
		if (wc) {	/* Last char has not been processed */
   818d8:	f1be 0f00 	cmp.w	lr, #0
   818dc:	d006      	beq.n	818ec <dir_read+0xb0>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   818de:	2dfe      	cmp	r5, #254	; 0xfe
   818e0:	d830      	bhi.n	81944 <dir_read+0x108>
			lfnbuf[i++] = wc = uc;			/* Store it */
   818e2:	f82c 2015 	strh.w	r2, [ip, r5, lsl #1]
   818e6:	4696      	mov	lr, r2
   818e8:	3501      	adds	r5, #1
   818ea:	e001      	b.n	818f0 <dir_read+0xb4>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
   818ec:	4552      	cmp	r2, sl
   818ee:	d129      	bne.n	81944 <dir_read+0x108>
		}
	} while (++s < 13);						/* Read all character in the entry */
   818f0:	4541      	cmp	r1, r8
   818f2:	d1e8      	bne.n	818c6 <dir_read+0x8a>

	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   818f4:	7802      	ldrb	r2, [r0, #0]
   818f6:	f012 0f40 	tst.w	r2, #64	; 0x40
   818fa:	d026      	beq.n	8194a <dir_read+0x10e>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   818fc:	2dfe      	cmp	r5, #254	; 0xfe
   818fe:	d821      	bhi.n	81944 <dir_read+0x108>
		lfnbuf[i] = 0;
   81900:	2200      	movs	r2, #0
   81902:	f82c 2015 	strh.w	r2, [ip, r5, lsl #1]
   81906:	e020      	b.n	8194a <dir_read+0x10e>
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   81908:	b91d      	cbnz	r5, 81912 <dir_read+0xd6>
   8190a:	4b16      	ldr	r3, [pc, #88]	; (81964 <dir_read+0x128>)
   8190c:	4798      	blx	r3
   8190e:	4550      	cmp	r0, sl
   81910:	d023      	beq.n	8195a <dir_read+0x11e>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   81912:	f64f 73ff 	movw	r3, #65535	; 0xffff
   81916:	8423      	strh	r3, [r4, #32]
   81918:	e01f      	b.n	8195a <dir_read+0x11e>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
   8191a:	25ff      	movs	r5, #255	; 0xff
   8191c:	e004      	b.n	81928 <dir_read+0xec>
   8191e:	25ff      	movs	r5, #255	; 0xff
   81920:	e002      	b.n	81928 <dir_read+0xec>
   81922:	25ff      	movs	r5, #255	; 0xff
   81924:	e000      	b.n	81928 <dir_read+0xec>
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81926:	25ff      	movs	r5, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
   81928:	4620      	mov	r0, r4
   8192a:	2100      	movs	r1, #0
   8192c:	4b0e      	ldr	r3, [pc, #56]	; (81968 <dir_read+0x12c>)
   8192e:	4798      	blx	r3
		if (res != FR_OK) break;
   81930:	4603      	mov	r3, r0
   81932:	b980      	cbnz	r0, 81956 <dir_read+0x11a>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
   81934:	6921      	ldr	r1, [r4, #16]
   81936:	2900      	cmp	r1, #0
   81938:	d18d      	bne.n	81856 <dir_read+0x1a>
   8193a:	461e      	mov	r6, r3
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
   8193c:	b16b      	cbz	r3, 8195a <dir_read+0x11e>
   8193e:	2300      	movs	r3, #0
   81940:	6123      	str	r3, [r4, #16]
   81942:	e00a      	b.n	8195a <dir_read+0x11e>
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81944:	46b2      	mov	sl, r6
   81946:	25ff      	movs	r5, #255	; 0xff
   81948:	e7ee      	b.n	81928 <dir_read+0xec>
   8194a:	3b01      	subs	r3, #1
   8194c:	b2dd      	uxtb	r5, r3
   8194e:	46b2      	mov	sl, r6
   81950:	e7ea      	b.n	81928 <dir_read+0xec>
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   81952:	2604      	movs	r6, #4
   81954:	e7f3      	b.n	8193e <dir_read+0x102>
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
   81956:	4606      	mov	r6, r0
   81958:	e7f1      	b.n	8193e <dir_read+0x102>
	}

	if (res != FR_OK) dj->sect = 0;

	return res;
}
   8195a:	4630      	mov	r0, r6
   8195c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   81960:	000812cd 	.word	0x000812cd
   81964:	00080e5d 	.word	0x00080e5d
   81968:	000816f9 	.word	0x000816f9
   8196c:	00091014 	.word	0x00091014

00081970 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
   81970:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   81974:	4686      	mov	lr, r0
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
   81976:	f101 0209 	add.w	r2, r1, #9
	if (dj->sect) {
   8197a:	6903      	ldr	r3, [r0, #16]
   8197c:	2b00      	cmp	r3, #0
   8197e:	d064      	beq.n	81a4a <get_fileinfo+0xda>
		dir = dj->dir;
   81980:	6944      	ldr	r4, [r0, #20]
		nt = dir[DIR_NTres];		/* NT flag */
   81982:	f894 c00c 	ldrb.w	ip, [r4, #12]
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
   81986:	7823      	ldrb	r3, [r4, #0]
			if (c == ' ') break;
   81988:	2b20      	cmp	r3, #32
   8198a:	d01d      	beq.n	819c8 <get_fileinfo+0x58>
   8198c:	4626      	mov	r6, r4
   8198e:	f101 0711 	add.w	r7, r1, #17
			if (c == NDDE) c = (TCHAR)DDE;
   81992:	f04f 08e5 	mov.w	r8, #229	; 0xe5
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   81996:	f00c 0008 	and.w	r0, ip, #8
   8199a:	b2c0      	uxtb	r0, r0
   8199c:	e003      	b.n	819a6 <get_fileinfo+0x36>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
   8199e:	f816 3f01 	ldrb.w	r3, [r6, #1]!
			if (c == ' ') break;
   819a2:	2b20      	cmp	r3, #32
   819a4:	d012      	beq.n	819cc <get_fileinfo+0x5c>
			if (c == NDDE) c = (TCHAR)DDE;
   819a6:	2b05      	cmp	r3, #5
   819a8:	d008      	beq.n	819bc <get_fileinfo+0x4c>
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   819aa:	b140      	cbz	r0, 819be <get_fileinfo+0x4e>
   819ac:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
   819b0:	b2ed      	uxtb	r5, r5
   819b2:	2d19      	cmp	r5, #25
   819b4:	d803      	bhi.n	819be <get_fileinfo+0x4e>
   819b6:	3320      	adds	r3, #32
   819b8:	b2db      	uxtb	r3, r3
   819ba:	e000      	b.n	819be <get_fileinfo+0x4e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
   819bc:	4643      	mov	r3, r8
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
   819be:	f802 3b01 	strb.w	r3, [r2], #1

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
   819c2:	42ba      	cmp	r2, r7
   819c4:	d1eb      	bne.n	8199e <get_fileinfo+0x2e>
   819c6:	e002      	b.n	819ce <get_fileinfo+0x5e>
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
   819c8:	4617      	mov	r7, r2
   819ca:	e000      	b.n	819ce <get_fileinfo+0x5e>
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
   819cc:	4617      	mov	r7, r2
		}
		if (dir[8] != ' ') {		/* Copy name extension */
   819ce:	7a23      	ldrb	r3, [r4, #8]
   819d0:	2b20      	cmp	r3, #32
   819d2:	d01e      	beq.n	81a12 <get_fileinfo+0xa2>
			*p++ = '.';
   819d4:	1c7d      	adds	r5, r7, #1
   819d6:	232e      	movs	r3, #46	; 0x2e
   819d8:	703b      	strb	r3, [r7, #0]
			for (i = 8; i < 11; i++) {
				c = dir[i];
   819da:	7a23      	ldrb	r3, [r4, #8]
				if (c == ' ') break;
   819dc:	2b20      	cmp	r3, #32
   819de:	d01a      	beq.n	81a16 <get_fileinfo+0xa6>
   819e0:	f104 0808 	add.w	r8, r4, #8
   819e4:	1d3a      	adds	r2, r7, #4
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   819e6:	f00c 0c10 	and.w	ip, ip, #16
   819ea:	fa5f f08c 	uxtb.w	r0, ip
   819ee:	e003      	b.n	819f8 <get_fileinfo+0x88>
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
   819f0:	f818 3f01 	ldrb.w	r3, [r8, #1]!
				if (c == ' ') break;
   819f4:	2b20      	cmp	r3, #32
   819f6:	d010      	beq.n	81a1a <get_fileinfo+0xaa>
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   819f8:	b130      	cbz	r0, 81a08 <get_fileinfo+0x98>
   819fa:	f1a3 0641 	sub.w	r6, r3, #65	; 0x41
   819fe:	b2f6      	uxtb	r6, r6
   81a00:	2e19      	cmp	r6, #25
   81a02:	bf9c      	itt	ls
   81a04:	3320      	addls	r3, #32
   81a06:	b2db      	uxtbls	r3, r3
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
   81a08:	f805 3b01 	strb.w	r3, [r5], #1
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
   81a0c:	4295      	cmp	r5, r2
   81a0e:	d1ef      	bne.n	819f0 <get_fileinfo+0x80>
   81a10:	e004      	b.n	81a1c <get_fileinfo+0xac>
   81a12:	463a      	mov	r2, r7
   81a14:	e002      	b.n	81a1c <get_fileinfo+0xac>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
   81a16:	462a      	mov	r2, r5
   81a18:	e000      	b.n	81a1c <get_fileinfo+0xac>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
   81a1a:	462a      	mov	r2, r5
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   81a1c:	7ae3      	ldrb	r3, [r4, #11]
   81a1e:	720b      	strb	r3, [r1, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   81a20:	7fe5      	ldrb	r5, [r4, #31]
   81a22:	7fa0      	ldrb	r0, [r4, #30]
   81a24:	0403      	lsls	r3, r0, #16
   81a26:	ea43 6005 	orr.w	r0, r3, r5, lsl #24
   81a2a:	7f23      	ldrb	r3, [r4, #28]
   81a2c:	4303      	orrs	r3, r0
   81a2e:	7f60      	ldrb	r0, [r4, #29]
   81a30:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   81a34:	600b      	str	r3, [r1, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   81a36:	7e60      	ldrb	r0, [r4, #25]
   81a38:	7e23      	ldrb	r3, [r4, #24]
   81a3a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   81a3e:	808b      	strh	r3, [r1, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   81a40:	7de0      	ldrb	r0, [r4, #23]
   81a42:	7da3      	ldrb	r3, [r4, #22]
   81a44:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   81a48:	80cb      	strh	r3, [r1, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
   81a4a:	2300      	movs	r3, #0
   81a4c:	7013      	strb	r3, [r2, #0]

#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
   81a4e:	698e      	ldr	r6, [r1, #24]
   81a50:	b35e      	cbz	r6, 81aaa <get_fileinfo+0x13a>
   81a52:	69cb      	ldr	r3, [r1, #28]
   81a54:	b34b      	cbz	r3, 81aaa <get_fileinfo+0x13a>
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   81a56:	f8de 2010 	ldr.w	r2, [lr, #16]
   81a5a:	b1da      	cbz	r2, 81a94 <get_fileinfo+0x124>
   81a5c:	f8be 0020 	ldrh.w	r0, [lr, #32]
   81a60:	f64f 72ff 	movw	r2, #65535	; 0xffff
   81a64:	4290      	cmp	r0, r2
   81a66:	d017      	beq.n	81a98 <get_fileinfo+0x128>
			lfn = dj->lfn;
   81a68:	f8de 201c 	ldr.w	r2, [lr, #28]
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   81a6c:	1c94      	adds	r4, r2, #2
   81a6e:	8810      	ldrh	r0, [r2, #0]
   81a70:	b1a0      	cbz	r0, 81a9c <get_fileinfo+0x12c>
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   81a72:	2b01      	cmp	r3, #1
   81a74:	d014      	beq.n	81aa0 <get_fileinfo+0x130>
   81a76:	1e75      	subs	r5, r6, #1
   81a78:	2200      	movs	r2, #0
   81a7a:	e003      	b.n	81a84 <get_fileinfo+0x114>
   81a7c:	69cb      	ldr	r3, [r1, #28]
   81a7e:	3b01      	subs	r3, #1
   81a80:	4293      	cmp	r3, r2
   81a82:	d90f      	bls.n	81aa4 <get_fileinfo+0x134>
				tp[i++] = (TCHAR)w;
   81a84:	3201      	adds	r2, #1
   81a86:	f805 0f01 	strb.w	r0, [r5, #1]!
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   81a8a:	f834 0b02 	ldrh.w	r0, [r4], #2
   81a8e:	2800      	cmp	r0, #0
   81a90:	d1f4      	bne.n	81a7c <get_fileinfo+0x10c>
   81a92:	e008      	b.n	81aa6 <get_fileinfo+0x136>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
   81a94:	2200      	movs	r2, #0
   81a96:	e006      	b.n	81aa6 <get_fileinfo+0x136>
   81a98:	2200      	movs	r2, #0
   81a9a:	e004      	b.n	81aa6 <get_fileinfo+0x136>
   81a9c:	2200      	movs	r2, #0
   81a9e:	e002      	b.n	81aa6 <get_fileinfo+0x136>
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   81aa0:	2200      	movs	r2, #0
   81aa2:	e000      	b.n	81aa6 <get_fileinfo+0x136>
   81aa4:	2200      	movs	r2, #0
				tp[i++] = (TCHAR)w;
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   81aa6:	2300      	movs	r3, #0
   81aa8:	54b3      	strb	r3, [r6, r2]
   81aaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81aae:	bf00      	nop

00081ab0 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
   81ab0:	2861      	cmp	r0, #97	; 0x61
   81ab2:	d009      	beq.n	81ac8 <ff_wtoupper+0x18>
   81ab4:	4909      	ldr	r1, [pc, #36]	; (81adc <ff_wtoupper+0x2c>)
   81ab6:	2200      	movs	r2, #0
   81ab8:	3201      	adds	r2, #1
   81aba:	f831 3f02 	ldrh.w	r3, [r1, #2]!
   81abe:	b15b      	cbz	r3, 81ad8 <ff_wtoupper+0x28>
   81ac0:	4283      	cmp	r3, r0
   81ac2:	d1f9      	bne.n	81ab8 <ff_wtoupper+0x8>

	return tbl_lower[i] ? tbl_upper[i] : chr;
   81ac4:	b908      	cbnz	r0, 81aca <ff_wtoupper+0x1a>
   81ac6:	e006      	b.n	81ad6 <ff_wtoupper+0x26>
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
   81ac8:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
   81aca:	4b05      	ldr	r3, [pc, #20]	; (81ae0 <ff_wtoupper+0x30>)
   81acc:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   81ad0:	f8b2 01f0 	ldrh.w	r0, [r2, #496]	; 0x1f0
   81ad4:	4770      	bx	lr
   81ad6:	2000      	movs	r0, #0
}
   81ad8:	4770      	bx	lr
   81ada:	bf00      	nop
   81adc:	00091024 	.word	0x00091024
   81ae0:	00091014 	.word	0x00091014

00081ae4 <dir_find>:

static
FRESULT dir_find (
	DIR *dj			/* Pointer to the directory object linked to the file name */
)
{
   81ae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   81ae8:	b087      	sub	sp, #28
   81aea:	4605      	mov	r5, r0
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
   81aec:	2100      	movs	r1, #0
   81aee:	4b6a      	ldr	r3, [pc, #424]	; (81c98 <dir_find+0x1b4>)
   81af0:	4798      	blx	r3
	if (res != FR_OK) return res;
   81af2:	2800      	cmp	r0, #0
   81af4:	f040 80be 	bne.w	81c74 <dir_find+0x190>
   81af8:	f04f 09ff 	mov.w	r9, #255	; 0xff
   81afc:	46c8      	mov	r8, r9

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
   81afe:	4f67      	ldr	r7, [pc, #412]	; (81c9c <dir_find+0x1b8>)
   81b00:	4b67      	ldr	r3, [pc, #412]	; (81ca0 <dir_find+0x1bc>)
   81b02:	330d      	adds	r3, #13
   81b04:	9301      	str	r3, [sp, #4]
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   81b06:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 81cac <dir_find+0x1c8>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
   81b0a:	6828      	ldr	r0, [r5, #0]
   81b0c:	6929      	ldr	r1, [r5, #16]
   81b0e:	47b8      	blx	r7
		if (res != FR_OK) break;
   81b10:	2800      	cmp	r0, #0
   81b12:	f040 80b0 	bne.w	81c76 <dir_find+0x192>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
   81b16:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
   81b18:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   81b1a:	2e00      	cmp	r6, #0
   81b1c:	f000 80ac 	beq.w	81c78 <dir_find+0x194>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
   81b20:	7ae3      	ldrb	r3, [r4, #11]
   81b22:	f003 023f 	and.w	r2, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   81b26:	2ee5      	cmp	r6, #229	; 0xe5
   81b28:	d07a      	beq.n	81c20 <dir_find+0x13c>
   81b2a:	f013 0f08 	tst.w	r3, #8
   81b2e:	d002      	beq.n	81b36 <dir_find+0x52>
   81b30:	2a0f      	cmp	r2, #15
   81b32:	d178      	bne.n	81c26 <dir_find+0x142>
   81b34:	e001      	b.n	81b3a <dir_find+0x56>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
   81b36:	2a0f      	cmp	r2, #15
   81b38:	d155      	bne.n	81be6 <dir_find+0x102>
				if (dj->lfn) {
   81b3a:	f8d5 b01c 	ldr.w	fp, [r5, #28]
   81b3e:	f1bb 0f00 	cmp.w	fp, #0
   81b42:	f000 808f 	beq.w	81c64 <dir_find+0x180>
					if (c & LLE) {		/* Is it start of LFN sequence? */
   81b46:	f016 0f40 	tst.w	r6, #64	; 0x40
   81b4a:	d006      	beq.n	81b5a <dir_find+0x76>
						sum = dir[LDIR_Chksum];
   81b4c:	f894 900d 	ldrb.w	r9, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
   81b50:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
						dj->lfn_idx = dj->index;
   81b54:	88eb      	ldrh	r3, [r5, #6]
   81b56:	842b      	strh	r3, [r5, #32]
   81b58:	e004      	b.n	81b64 <dir_find+0x80>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81b5a:	45b0      	cmp	r8, r6
   81b5c:	bf18      	it	ne
   81b5e:	f04f 08ff 	movne.w	r8, #255	; 0xff
   81b62:	d17f      	bne.n	81c64 <dir_find+0x180>
   81b64:	7b63      	ldrb	r3, [r4, #13]
   81b66:	9302      	str	r3, [sp, #8]
   81b68:	454b      	cmp	r3, r9
   81b6a:	d15f      	bne.n	81c2c <dir_find+0x148>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   81b6c:	7823      	ldrb	r3, [r4, #0]
   81b6e:	9304      	str	r3, [sp, #16]
   81b70:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   81b74:	3b01      	subs	r3, #1
   81b76:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   81b7a:	eb03 0982 	add.w	r9, r3, r2, lsl #2
   81b7e:	f8df 8120 	ldr.w	r8, [pc, #288]	; 81ca0 <dir_find+0x1bc>
	s = 0; wc = 1;
   81b82:	2101      	movs	r1, #1
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
   81b84:	9605      	str	r6, [sp, #20]
   81b86:	9503      	str	r5, [sp, #12]
   81b88:	9e01      	ldr	r6, [sp, #4]


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   81b8a:	f818 3b01 	ldrb.w	r3, [r8], #1
   81b8e:	18e2      	adds	r2, r4, r3
   81b90:	7852      	ldrb	r2, [r2, #1]
   81b92:	5ce3      	ldrb	r3, [r4, r3]
   81b94:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
		if (wc) {	/* Last char has not been processed */
   81b98:	b191      	cbz	r1, 81bc0 <dir_find+0xdc>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   81b9a:	4b42      	ldr	r3, [pc, #264]	; (81ca4 <dir_find+0x1c0>)
   81b9c:	4798      	blx	r3
   81b9e:	4605      	mov	r5, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   81ba0:	f1b9 0ffe 	cmp.w	r9, #254	; 0xfe
   81ba4:	d845      	bhi.n	81c32 <dir_find+0x14e>
   81ba6:	f109 0301 	add.w	r3, r9, #1
   81baa:	9300      	str	r3, [sp, #0]
   81bac:	f83b 0019 	ldrh.w	r0, [fp, r9, lsl #1]
   81bb0:	4a3c      	ldr	r2, [pc, #240]	; (81ca4 <dir_find+0x1c0>)
   81bb2:	4790      	blx	r2
   81bb4:	4601      	mov	r1, r0
   81bb6:	4285      	cmp	r5, r0
   81bb8:	d141      	bne.n	81c3e <dir_find+0x15a>
   81bba:	f8dd 9000 	ldr.w	r9, [sp]
   81bbe:	e003      	b.n	81bc8 <dir_find+0xe4>
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
   81bc0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   81bc4:	4298      	cmp	r0, r3
   81bc6:	d140      	bne.n	81c4a <dir_find+0x166>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   81bc8:	45b0      	cmp	r8, r6
   81bca:	d1de      	bne.n	81b8a <dir_find+0xa6>
   81bcc:	9e05      	ldr	r6, [sp, #20]
   81bce:	9d03      	ldr	r5, [sp, #12]

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   81bd0:	9b04      	ldr	r3, [sp, #16]
   81bd2:	f013 0f40 	tst.w	r3, #64	; 0x40
   81bd6:	d055      	beq.n	81c84 <dir_find+0x1a0>
   81bd8:	2900      	cmp	r1, #0
   81bda:	d053      	beq.n	81c84 <dir_find+0x1a0>
   81bdc:	f83b 3019 	ldrh.w	r3, [fp, r9, lsl #1]
   81be0:	2b00      	cmp	r3, #0
   81be2:	d04f      	beq.n	81c84 <dir_find+0x1a0>
   81be4:	e037      	b.n	81c56 <dir_find+0x172>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   81be6:	f1b8 0f00 	cmp.w	r8, #0
   81bea:	d103      	bne.n	81bf4 <dir_find+0x110>
   81bec:	4620      	mov	r0, r4
   81bee:	47d0      	blx	sl
   81bf0:	4548      	cmp	r0, r9
   81bf2:	d043      	beq.n	81c7c <dir_find+0x198>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   81bf4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   81bf8:	842b      	strh	r3, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   81bfa:	69ab      	ldr	r3, [r5, #24]
   81bfc:	7ada      	ldrb	r2, [r3, #11]
   81bfe:	f012 0f01 	tst.w	r2, #1
   81c02:	d12d      	bne.n	81c60 <dir_find+0x17c>
   81c04:	f104 000b 	add.w	r0, r4, #11
   81c08:	e001      	b.n	81c0e <dir_find+0x12a>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
   81c0a:	4284      	cmp	r4, r0
   81c0c:	d038      	beq.n	81c80 <dir_find+0x19c>
   81c0e:	f814 1b01 	ldrb.w	r1, [r4], #1
   81c12:	f813 2b01 	ldrb.w	r2, [r3], #1
   81c16:	4291      	cmp	r1, r2
   81c18:	d0f7      	beq.n	81c0a <dir_find+0x126>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   81c1a:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c1e:	e021      	b.n	81c64 <dir_find+0x180>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
   81c20:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c24:	e01e      	b.n	81c64 <dir_find+0x180>
   81c26:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c2a:	e01b      	b.n	81c64 <dir_find+0x180>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c2c:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c30:	e018      	b.n	81c64 <dir_find+0x180>
   81c32:	9d03      	ldr	r5, [sp, #12]
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   81c34:	f8dd 9008 	ldr.w	r9, [sp, #8]
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c38:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c3c:	e012      	b.n	81c64 <dir_find+0x180>
   81c3e:	9d03      	ldr	r5, [sp, #12]
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   81c40:	f8dd 9008 	ldr.w	r9, [sp, #8]
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c44:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c48:	e00c      	b.n	81c64 <dir_find+0x180>
   81c4a:	9d03      	ldr	r5, [sp, #12]
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
   81c4c:	f8dd 9008 	ldr.w	r9, [sp, #8]
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c50:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c54:	e006      	b.n	81c64 <dir_find+0x180>
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   81c56:	f8dd 9008 	ldr.w	r9, [sp, #8]
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c5a:	f04f 08ff 	mov.w	r8, #255	; 0xff
   81c5e:	e001      	b.n	81c64 <dir_find+0x180>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   81c60:	f04f 08ff 	mov.w	r8, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
   81c64:	4628      	mov	r0, r5
   81c66:	2100      	movs	r1, #0
   81c68:	4b0f      	ldr	r3, [pc, #60]	; (81ca8 <dir_find+0x1c4>)
   81c6a:	4798      	blx	r3
	} while (res == FR_OK);
   81c6c:	2800      	cmp	r0, #0
   81c6e:	f43f af4c 	beq.w	81b0a <dir_find+0x26>
   81c72:	e00d      	b.n	81c90 <dir_find+0x1ac>
   81c74:	e00c      	b.n	81c90 <dir_find+0x1ac>
   81c76:	e00b      	b.n	81c90 <dir_find+0x1ac>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   81c78:	2004      	movs	r0, #4
   81c7a:	e009      	b.n	81c90 <dir_find+0x1ac>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
   81c7c:	2000      	movs	r0, #0
   81c7e:	e007      	b.n	81c90 <dir_find+0x1ac>
   81c80:	2000      	movs	r0, #0
   81c82:	e005      	b.n	81c90 <dir_find+0x1ac>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   81c84:	3e01      	subs	r6, #1
   81c86:	fa5f f886 	uxtb.w	r8, r6
   81c8a:	f8dd 9008 	ldr.w	r9, [sp, #8]
   81c8e:	e7e9      	b.n	81c64 <dir_find+0x180>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
   81c90:	b007      	add	sp, #28
   81c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   81c96:	bf00      	nop
   81c98:	0008144d 	.word	0x0008144d
   81c9c:	000812cd 	.word	0x000812cd
   81ca0:	00091014 	.word	0x00091014
   81ca4:	00081ab1 	.word	0x00081ab1
   81ca8:	000816f9 	.word	0x000816f9
   81cac:	00080e5d 	.word	0x00080e5d

00081cb0 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
   81cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   81cb4:	b083      	sub	sp, #12
   81cb6:	4682      	mov	sl, r0
   81cb8:	4688      	mov	r8, r1
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   81cba:	780b      	ldrb	r3, [r1, #0]
   81cbc:	2b2f      	cmp	r3, #47	; 0x2f
   81cbe:	d001      	beq.n	81cc4 <follow_path+0x14>
   81cc0:	2b5c      	cmp	r3, #92	; 0x5c
   81cc2:	d101      	bne.n	81cc8 <follow_path+0x18>
		path++;
   81cc4:	f108 0801 	add.w	r8, r8, #1
	dj->sclust = 0;						/* Start from the root dir */
   81cc8:	2300      	movs	r3, #0
   81cca:	f8ca 3008 	str.w	r3, [sl, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   81cce:	f898 3000 	ldrb.w	r3, [r8]
   81cd2:	2b1f      	cmp	r3, #31
   81cd4:	d808      	bhi.n	81ce8 <follow_path+0x38>
		res = dir_sdi(dj, 0);
   81cd6:	4650      	mov	r0, sl
   81cd8:	2100      	movs	r1, #0
   81cda:	4bb0      	ldr	r3, [pc, #704]	; (81f9c <follow_path+0x2ec>)
   81cdc:	4798      	blx	r3
   81cde:	4603      	mov	r3, r0
		dj->dir = 0;
   81ce0:	2200      	movs	r2, #0
   81ce2:	f8ca 2014 	str.w	r2, [sl, #20]
   81ce6:	e155      	b.n	81f94 <follow_path+0x2e4>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
   81ce8:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 81fa8 <follow_path+0x2f8>
   81cec:	46c6      	mov	lr, r8
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   81cee:	f818 3b01 	ldrb.w	r3, [r8], #1
   81cf2:	2b2f      	cmp	r3, #47	; 0x2f
   81cf4:	d0fa      	beq.n	81cec <follow_path+0x3c>
   81cf6:	2b5c      	cmp	r3, #92	; 0x5c
   81cf8:	d0f8      	beq.n	81cec <follow_path+0x3c>
	lfn = dj->lfn;
   81cfa:	f8da 201c 	ldr.w	r2, [sl, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
   81cfe:	f89e 5000 	ldrb.w	r5, [lr]
   81d02:	b2a8      	uxth	r0, r5
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   81d04:	281f      	cmp	r0, #31
   81d06:	f240 811f 	bls.w	81f48 <follow_path+0x298>
   81d0a:	282f      	cmp	r0, #47	; 0x2f
   81d0c:	f000 8122 	beq.w	81f54 <follow_path+0x2a4>
   81d10:	285c      	cmp	r0, #92	; 0x5c
   81d12:	f000 8122 	beq.w	81f5a <follow_path+0x2aa>
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   81d16:	2800      	cmp	r0, #0
   81d18:	f000 8135 	beq.w	81f86 <follow_path+0x2d6>
   81d1c:	1e97      	subs	r7, r2, #2
   81d1e:	4676      	mov	r6, lr
   81d20:	2301      	movs	r3, #1
   81d22:	e00d      	b.n	81d40 <follow_path+0x90>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   81d24:	282f      	cmp	r0, #47	; 0x2f
   81d26:	f000 811a 	beq.w	81f5e <follow_path+0x2ae>
   81d2a:	285c      	cmp	r0, #92	; 0x5c
   81d2c:	f000 8117 	beq.w	81f5e <follow_path+0x2ae>
		if (di >= _MAX_LFN)				/* Reject too long name */
   81d30:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   81d34:	f000 8127 	beq.w	81f86 <follow_path+0x2d6>
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   81d38:	2800      	cmp	r0, #0
   81d3a:	f000 8124 	beq.w	81f86 <follow_path+0x2d6>
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
   81d3e:	460b      	mov	r3, r1
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   81d40:	287f      	cmp	r0, #127	; 0x7f
   81d42:	d809      	bhi.n	81d58 <follow_path+0xa8>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
   81d44:	2d22      	cmp	r5, #34	; 0x22
   81d46:	f000 80db 	beq.w	81f00 <follow_path+0x250>
   81d4a:	464c      	mov	r4, r9
   81d4c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   81d50:	b111      	cbz	r1, 81d58 <follow_path+0xa8>
   81d52:	428d      	cmp	r5, r1
   81d54:	d1fa      	bne.n	81d4c <follow_path+0x9c>
   81d56:	e0d3      	b.n	81f00 <follow_path+0x250>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
   81d58:	f827 0f02 	strh.w	r0, [r7, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
   81d5c:	1c59      	adds	r1, r3, #1
   81d5e:	f816 5f01 	ldrb.w	r5, [r6, #1]!
   81d62:	b2a8      	uxth	r0, r5
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   81d64:	281f      	cmp	r0, #31
   81d66:	d8dd      	bhi.n	81d24 <follow_path+0x74>
   81d68:	e0f0      	b.n	81f4c <follow_path+0x29c>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
   81d6a:	2b00      	cmp	r3, #0
   81d6c:	f000 80c8 	beq.w	81f00 <follow_path+0x250>
   81d70:	eb02 0443 	add.w	r4, r2, r3, lsl #1
		w = lfn[di-1];
   81d74:	f834 1d02 	ldrh.w	r1, [r4, #-2]!
		if (w != ' ' && w != '.') break;
   81d78:	2920      	cmp	r1, #32
   81d7a:	d001      	beq.n	81d80 <follow_path+0xd0>
   81d7c:	292e      	cmp	r1, #46	; 0x2e
   81d7e:	d102      	bne.n	81d86 <follow_path+0xd6>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
   81d80:	3b01      	subs	r3, #1
   81d82:	d1f7      	bne.n	81d74 <follow_path+0xc4>
   81d84:	e0bc      	b.n	81f00 <follow_path+0x250>
		w = lfn[di-1];
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   81d86:	2b00      	cmp	r3, #0
   81d88:	f000 80fd 	beq.w	81f86 <follow_path+0x2d6>

	lfn[di] = 0;						/* LFN is created */
   81d8c:	005e      	lsls	r6, r3, #1
   81d8e:	2100      	movs	r1, #0
   81d90:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
   81d94:	f8da 1018 	ldr.w	r1, [sl, #24]
   81d98:	f101 050b 	add.w	r5, r1, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
   81d9c:	2420      	movs	r4, #32
   81d9e:	f801 4b01 	strb.w	r4, [r1], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
   81da2:	42a9      	cmp	r1, r5
   81da4:	d1fb      	bne.n	81d9e <follow_path+0xee>
   81da6:	1e95      	subs	r5, r2, #2
   81da8:	2100      	movs	r1, #0
   81daa:	e000      	b.n	81dae <follow_path+0xfe>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   81dac:	3101      	adds	r1, #1
   81dae:	f835 4f02 	ldrh.w	r4, [r5, #2]!
   81db2:	2c20      	cmp	r4, #32
   81db4:	d0fa      	beq.n	81dac <follow_path+0xfc>
   81db6:	2c2e      	cmp	r4, #46	; 0x2e
   81db8:	d0f8      	beq.n	81dac <follow_path+0xfc>
	if (si) cf |= NS_LOSS | NS_LFN;
   81dba:	2900      	cmp	r1, #0
   81dbc:	f000 80d3 	beq.w	81f66 <follow_path+0x2b6>
   81dc0:	f040 0003 	orr.w	r0, r0, #3
   81dc4:	e0cf      	b.n	81f66 <follow_path+0x2b6>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   81dc6:	3b01      	subs	r3, #1
   81dc8:	d105      	bne.n	81dd6 <follow_path+0x126>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
   81dca:	f04f 0e08 	mov.w	lr, #8
   81dce:	2700      	movs	r7, #0
   81dd0:	463e      	mov	r6, r7
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
   81dd2:	9301      	str	r3, [sp, #4]
   81dd4:	e004      	b.n	81de0 <follow_path+0x130>

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   81dd6:	f834 5d02 	ldrh.w	r5, [r4, #-2]!
   81dda:	2d2e      	cmp	r5, #46	; 0x2e
   81ddc:	d1f3      	bne.n	81dc6 <follow_path+0x116>
   81dde:	e7f4      	b.n	81dca <follow_path+0x11a>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
   81de0:	1c4c      	adds	r4, r1, #1
   81de2:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
		if (!w) break;					/* Break on end of the LFN */
   81de6:	2900      	cmp	r1, #0
   81de8:	d055      	beq.n	81e96 <follow_path+0x1e6>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   81dea:	2920      	cmp	r1, #32
   81dec:	d004      	beq.n	81df8 <follow_path+0x148>
   81dee:	292e      	cmp	r1, #46	; 0x2e
   81df0:	d106      	bne.n	81e00 <follow_path+0x150>
   81df2:	42a3      	cmp	r3, r4
   81df4:	f000 80c9 	beq.w	81f8a <follow_path+0x2da>
			cf |= NS_LOSS | NS_LFN; continue;
   81df8:	f040 0003 	orr.w	r0, r0, #3
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
   81dfc:	4621      	mov	r1, r4
   81dfe:	e7ef      	b.n	81de0 <follow_path+0x130>
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
   81e00:	4577      	cmp	r7, lr
   81e02:	d202      	bcs.n	81e0a <follow_path+0x15a>
   81e04:	42a3      	cmp	r3, r4
   81e06:	d118      	bne.n	81e3a <follow_path+0x18a>
   81e08:	e0bf      	b.n	81f8a <follow_path+0x2da>
			if (ni == 11) {				/* Long extension */
   81e0a:	f1be 0f0b 	cmp.w	lr, #11
   81e0e:	d107      	bne.n	81e20 <follow_path+0x170>
				cf |= NS_LOSS | NS_LFN; break;
   81e10:	f040 0003 	orr.w	r0, r0, #3
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   81e14:	f8da 3018 	ldr.w	r3, [sl, #24]
   81e18:	781a      	ldrb	r2, [r3, #0]
   81e1a:	2ae5      	cmp	r2, #229	; 0xe5
   81e1c:	d14d      	bne.n	81eba <follow_path+0x20a>
   81e1e:	e040      	b.n	81ea2 <follow_path+0x1f2>

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   81e20:	42a3      	cmp	r3, r4
   81e22:	d003      	beq.n	81e2c <follow_path+0x17c>
   81e24:	f040 0003 	orr.w	r0, r0, #3
			if (si > di) break;			/* No extension */
   81e28:	429c      	cmp	r4, r3
   81e2a:	d834      	bhi.n	81e96 <follow_path+0x1e6>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
   81e2c:	00b6      	lsls	r6, r6, #2
   81e2e:	b2f6      	uxtb	r6, r6
   81e30:	9901      	ldr	r1, [sp, #4]
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
   81e32:	f04f 0e0b 	mov.w	lr, #11
   81e36:	2708      	movs	r7, #8
   81e38:	e7d2      	b.n	81de0 <follow_path+0x130>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
   81e3a:	297f      	cmp	r1, #127	; 0x7f
   81e3c:	f240 809a 	bls.w	81f74 <follow_path+0x2c4>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   81e40:	4d57      	ldr	r5, [pc, #348]	; (81fa0 <follow_path+0x2f0>)
   81e42:	4429      	add	r1, r5
   81e44:	f891 b350 	ldrb.w	fp, [r1, #848]	; 0x350
   81e48:	fa1f f18b 	uxth.w	r1, fp
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
   81e4c:	f040 0002 	orr.w	r0, r0, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   81e50:	b159      	cbz	r1, 81e6a <follow_path+0x1ba>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
   81e52:	f1bb 0f2b 	cmp.w	fp, #43	; 0x2b
   81e56:	d008      	beq.n	81e6a <follow_path+0x1ba>
   81e58:	f8df c150 	ldr.w	ip, [pc, #336]	; 81fac <follow_path+0x2fc>
   81e5c:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
   81e60:	2d00      	cmp	r5, #0
   81e62:	f000 8089 	beq.w	81f78 <follow_path+0x2c8>
   81e66:	45ab      	cmp	fp, r5
   81e68:	d1f8      	bne.n	81e5c <follow_path+0x1ac>
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   81e6a:	f040 0003 	orr.w	r0, r0, #3
   81e6e:	215f      	movs	r1, #95	; 0x5f
   81e70:	e00b      	b.n	81e8a <follow_path+0x1da>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
   81e72:	f046 0602 	orr.w	r6, r6, #2
   81e76:	e008      	b.n	81e8a <follow_path+0x1da>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
   81e78:	f1a1 0561 	sub.w	r5, r1, #97	; 0x61
   81e7c:	b2ad      	uxth	r5, r5
   81e7e:	2d19      	cmp	r5, #25
   81e80:	d803      	bhi.n	81e8a <follow_path+0x1da>
						b |= 1; w -= 0x20;
   81e82:	f046 0601 	orr.w	r6, r6, #1
   81e86:	3920      	subs	r1, #32
   81e88:	b289      	uxth	r1, r1
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
   81e8a:	f8da 5018 	ldr.w	r5, [sl, #24]
   81e8e:	55e9      	strb	r1, [r5, r7]
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
   81e90:	4621      	mov	r1, r4
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
   81e92:	3701      	adds	r7, #1
   81e94:	e7a4      	b.n	81de0 <follow_path+0x130>
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   81e96:	f8da 3018 	ldr.w	r3, [sl, #24]
   81e9a:	781a      	ldrb	r2, [r3, #0]
   81e9c:	2ae5      	cmp	r2, #229	; 0xe5
   81e9e:	d106      	bne.n	81eae <follow_path+0x1fe>
   81ea0:	e001      	b.n	81ea6 <follow_path+0x1f6>
   81ea2:	f04f 0e0b 	mov.w	lr, #11
   81ea6:	2205      	movs	r2, #5
   81ea8:	701a      	strb	r2, [r3, #0]
   81eaa:	4633      	mov	r3, r6
   81eac:	e000      	b.n	81eb0 <follow_path+0x200>
   81eae:	4633      	mov	r3, r6

	if (ni == 8) b <<= 2;
   81eb0:	f1be 0f08 	cmp.w	lr, #8
   81eb4:	bf04      	itt	eq
   81eb6:	009b      	lsleq	r3, r3, #2
   81eb8:	b2de      	uxtbeq	r6, r3
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   81eba:	f006 030c 	and.w	r3, r6, #12
   81ebe:	2b0c      	cmp	r3, #12
   81ec0:	d003      	beq.n	81eca <follow_path+0x21a>
   81ec2:	f006 0203 	and.w	r2, r6, #3
   81ec6:	2a03      	cmp	r2, #3
   81ec8:	d101      	bne.n	81ece <follow_path+0x21e>
		cf |= NS_LFN;
   81eca:	f040 0002 	orr.w	r0, r0, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   81ece:	f010 0f02 	tst.w	r0, #2
   81ed2:	d109      	bne.n	81ee8 <follow_path+0x238>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   81ed4:	f006 0603 	and.w	r6, r6, #3
   81ed8:	2e01      	cmp	r6, #1
   81eda:	bf08      	it	eq
   81edc:	f040 0010 	orreq.w	r0, r0, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   81ee0:	2b04      	cmp	r3, #4
   81ee2:	bf08      	it	eq
   81ee4:	f040 0008 	orreq.w	r0, r0, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
   81ee8:	f8da 3018 	ldr.w	r3, [sl, #24]
   81eec:	72d8      	strb	r0, [r3, #11]

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
   81eee:	4650      	mov	r0, sl
   81ef0:	4b2c      	ldr	r3, [pc, #176]	; (81fa4 <follow_path+0x2f4>)
   81ef2:	4798      	blx	r3
			ns = *(dj->fn+NS);
   81ef4:	f8da 3018 	ldr.w	r3, [sl, #24]
   81ef8:	7ada      	ldrb	r2, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
   81efa:	4603      	mov	r3, r0
   81efc:	b160      	cbz	r0, 81f18 <follow_path+0x268>
   81efe:	e001      	b.n	81f04 <follow_path+0x254>
   81f00:	2306      	movs	r3, #6
   81f02:	e047      	b.n	81f94 <follow_path+0x2e4>
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
   81f04:	2804      	cmp	r0, #4
   81f06:	d145      	bne.n	81f94 <follow_path+0x2e4>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   81f08:	f002 0304 	and.w	r3, r2, #4
   81f0c:	b2db      	uxtb	r3, r3
   81f0e:	2b00      	cmp	r3, #0
   81f10:	bf14      	ite	ne
   81f12:	4603      	movne	r3, r0
   81f14:	2305      	moveq	r3, #5
   81f16:	e03d      	b.n	81f94 <follow_path+0x2e4>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   81f18:	f012 0f04 	tst.w	r2, #4
   81f1c:	d13a      	bne.n	81f94 <follow_path+0x2e4>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   81f1e:	f8da 2014 	ldr.w	r2, [sl, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   81f22:	7ad3      	ldrb	r3, [r2, #11]
   81f24:	f013 0f10 	tst.w	r3, #16
   81f28:	d00c      	beq.n	81f44 <follow_path+0x294>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
   81f2a:	7d51      	ldrb	r1, [r2, #21]
   81f2c:	7d13      	ldrb	r3, [r2, #20]
   81f2e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
   81f32:	7ed3      	ldrb	r3, [r2, #27]
   81f34:	7e92      	ldrb	r2, [r2, #26]
   81f36:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   81f3a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   81f3e:	f8ca 3008 	str.w	r3, [sl, #8]
		}
   81f42:	e6d3      	b.n	81cec <follow_path+0x3c>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
   81f44:	2305      	movs	r3, #5
   81f46:	e025      	b.n	81f94 <follow_path+0x2e4>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
   81f48:	2300      	movs	r3, #0
	for (;;) {
		w = p[si++];					/* Get a character */
   81f4a:	2101      	movs	r1, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
   81f4c:	eb0e 0801 	add.w	r8, lr, r1
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   81f50:	2004      	movs	r0, #4
   81f52:	e70a      	b.n	81d6a <follow_path+0xba>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
   81f54:	2300      	movs	r3, #0
	for (;;) {
		w = p[si++];					/* Get a character */
   81f56:	2101      	movs	r1, #1
   81f58:	e001      	b.n	81f5e <follow_path+0x2ae>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
   81f5a:	2300      	movs	r3, #0
	for (;;) {
		w = p[si++];					/* Get a character */
   81f5c:	2101      	movs	r1, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
   81f5e:	eb0e 0801 	add.w	r8, lr, r1
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   81f62:	2000      	movs	r0, #0
   81f64:	e701      	b.n	81d6a <follow_path+0xba>

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   81f66:	1eb5      	subs	r5, r6, #2
   81f68:	1954      	adds	r4, r2, r5
   81f6a:	5b55      	ldrh	r5, [r2, r5]
   81f6c:	2d2e      	cmp	r5, #46	; 0x2e
   81f6e:	f43f af2c 	beq.w	81dca <follow_path+0x11a>
   81f72:	e728      	b.n	81dc6 <follow_path+0x116>
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   81f74:	468b      	mov	fp, r1
   81f76:	e76c      	b.n	81e52 <follow_path+0x1a2>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
   81f78:	f1a1 0541 	sub.w	r5, r1, #65	; 0x41
   81f7c:	b2ad      	uxth	r5, r5
   81f7e:	2d19      	cmp	r5, #25
   81f80:	f67f af77 	bls.w	81e72 <follow_path+0x1c2>
   81f84:	e778      	b.n	81e78 <follow_path+0x1c8>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   81f86:	2306      	movs	r3, #6
   81f88:	e004      	b.n	81f94 <follow_path+0x2e4>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
   81f8a:	f1be 0f0b 	cmp.w	lr, #11
   81f8e:	f47f af4d 	bne.w	81e2c <follow_path+0x17c>
   81f92:	e73d      	b.n	81e10 <follow_path+0x160>
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
   81f94:	4618      	mov	r0, r3
   81f96:	b003      	add	sp, #12
   81f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   81f9c:	0008144d 	.word	0x0008144d
   81fa0:	00091014 	.word	0x00091014
   81fa4:	00081ae5 	.word	0x00081ae5
   81fa8:	00091464 	.word	0x00091464
   81fac:	00091470 	.word	0x00091470

00081fb0 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   81fb0:	2804      	cmp	r0, #4
   81fb2:	d80d      	bhi.n	81fd0 <f_mount+0x20>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
   81fb4:	4b07      	ldr	r3, [pc, #28]	; (81fd4 <f_mount+0x24>)
   81fb6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]

	if (rfs) {
   81fba:	b10b      	cbz	r3, 81fc0 <f_mount+0x10>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
   81fbc:	2200      	movs	r2, #0
   81fbe:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
   81fc0:	b109      	cbz	r1, 81fc6 <f_mount+0x16>
		fs->fs_type = 0;		/* Clear new fs object */
   81fc2:	2300      	movs	r3, #0
   81fc4:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
   81fc6:	4b03      	ldr	r3, [pc, #12]	; (81fd4 <f_mount+0x24>)
   81fc8:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

	return FR_OK;
   81fcc:	2000      	movs	r0, #0
   81fce:	4770      	bx	lr
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
   81fd0:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
   81fd2:	4770      	bx	lr
   81fd4:	200008e8 	.word	0x200008e8

00081fd8 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
   81fd8:	b510      	push	{r4, lr}
   81fda:	b086      	sub	sp, #24
   81fdc:	4604      	mov	r4, r0
   81fde:	a806      	add	r0, sp, #24
   81fe0:	f840 1d14 	str.w	r1, [r0, #-20]!
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
   81fe4:	4621      	mov	r1, r4
   81fe6:	2200      	movs	r2, #0
   81fe8:	4b18      	ldr	r3, [pc, #96]	; (8204c <f_opendir+0x74>)
   81fea:	4798      	blx	r3
	if (res == FR_OK) {
   81fec:	4603      	mov	r3, r0
   81fee:	bb50      	cbnz	r0, 82046 <f_opendir+0x6e>
		INIT_BUF(*dj);
   81ff0:	ab03      	add	r3, sp, #12
   81ff2:	61a3      	str	r3, [r4, #24]
   81ff4:	4b16      	ldr	r3, [pc, #88]	; (82050 <f_opendir+0x78>)
   81ff6:	61e3      	str	r3, [r4, #28]
		res = follow_path(dj, path);			/* Follow the path to the directory */
   81ff8:	4620      	mov	r0, r4
   81ffa:	9901      	ldr	r1, [sp, #4]
   81ffc:	4b15      	ldr	r3, [pc, #84]	; (82054 <f_opendir+0x7c>)
   81ffe:	4798      	blx	r3
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
   82000:	4603      	mov	r3, r0
   82002:	b988      	cbnz	r0, 82028 <f_opendir+0x50>
			if (dj->dir) {						/* It is not the root dir */
   82004:	6963      	ldr	r3, [r4, #20]
   82006:	b1ab      	cbz	r3, 82034 <f_opendir+0x5c>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   82008:	7ada      	ldrb	r2, [r3, #11]
   8200a:	f012 0f10 	tst.w	r2, #16
   8200e:	d00f      	beq.n	82030 <f_opendir+0x58>
					dj->sclust = LD_CLUST(dj->dir);
   82010:	7d59      	ldrb	r1, [r3, #21]
   82012:	7d1a      	ldrb	r2, [r3, #20]
   82014:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
   82018:	7ed8      	ldrb	r0, [r3, #27]
   8201a:	7e9a      	ldrb	r2, [r3, #26]
   8201c:	ea42 2300 	orr.w	r3, r2, r0, lsl #8
   82020:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   82024:	60a3      	str	r3, [r4, #8]
   82026:	e005      	b.n	82034 <f_opendir+0x5c>
			if (res == FR_OK) {
				dj->id = dj->fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
   82028:	2b04      	cmp	r3, #4
   8202a:	bf08      	it	eq
   8202c:	2305      	moveq	r3, #5
   8202e:	e00a      	b.n	82046 <f_opendir+0x6e>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = LD_CLUST(dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
   82030:	2305      	movs	r3, #5
   82032:	e008      	b.n	82046 <f_opendir+0x6e>
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
   82034:	6823      	ldr	r3, [r4, #0]
   82036:	88db      	ldrh	r3, [r3, #6]
   82038:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
   8203a:	4620      	mov	r0, r4
   8203c:	2100      	movs	r1, #0
   8203e:	4b06      	ldr	r3, [pc, #24]	; (82058 <f_opendir+0x80>)
   82040:	4798      	blx	r3
   82042:	4603      	mov	r3, r0
   82044:	e7f0      	b.n	82028 <f_opendir+0x50>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
   82046:	4618      	mov	r0, r3
   82048:	b006      	add	sp, #24
   8204a:	bd10      	pop	{r4, pc}
   8204c:	00080f41 	.word	0x00080f41
   82050:	20000900 	.word	0x20000900
   82054:	00081cb1 	.word	0x00081cb1
   82058:	0008144d 	.word	0x0008144d

0008205c <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
   8205c:	b570      	push	{r4, r5, r6, lr}
   8205e:	b084      	sub	sp, #16
   82060:	4604      	mov	r4, r0
   82062:	460e      	mov	r6, r1
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   82064:	6800      	ldr	r0, [r0, #0]
   82066:	88a1      	ldrh	r1, [r4, #4]
   82068:	4b15      	ldr	r3, [pc, #84]	; (820c0 <f_readdir+0x64>)
   8206a:	4798      	blx	r3
	if (res == FR_OK) {
   8206c:	4605      	mov	r5, r0
   8206e:	bb18      	cbnz	r0, 820b8 <f_readdir+0x5c>
		if (!fno) {
   82070:	b92e      	cbnz	r6, 8207e <f_readdir+0x22>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   82072:	4620      	mov	r0, r4
   82074:	2100      	movs	r1, #0
   82076:	4b13      	ldr	r3, [pc, #76]	; (820c4 <f_readdir+0x68>)
   82078:	4798      	blx	r3
   8207a:	4605      	mov	r5, r0
   8207c:	e01c      	b.n	820b8 <f_readdir+0x5c>
		} else {
			INIT_BUF(*dj);
   8207e:	ab01      	add	r3, sp, #4
   82080:	61a3      	str	r3, [r4, #24]
   82082:	4b11      	ldr	r3, [pc, #68]	; (820c8 <f_readdir+0x6c>)
   82084:	61e3      	str	r3, [r4, #28]
			res = dir_read(dj);				/* Read an directory item */
   82086:	4620      	mov	r0, r4
   82088:	4b10      	ldr	r3, [pc, #64]	; (820cc <f_readdir+0x70>)
   8208a:	4798      	blx	r3
			if (res == FR_NO_FILE) {		/* Reached end of dir */
   8208c:	2804      	cmp	r0, #4
   8208e:	d102      	bne.n	82096 <f_readdir+0x3a>
				dj->sect = 0;
   82090:	2300      	movs	r3, #0
   82092:	6123      	str	r3, [r4, #16]
   82094:	e000      	b.n	82098 <f_readdir+0x3c>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
   82096:	b960      	cbnz	r0, 820b2 <f_readdir+0x56>
				get_fileinfo(dj, fno);		/* Get the object information */
   82098:	4620      	mov	r0, r4
   8209a:	4631      	mov	r1, r6
   8209c:	4b0c      	ldr	r3, [pc, #48]	; (820d0 <f_readdir+0x74>)
   8209e:	4798      	blx	r3
				res = dir_next(dj, 0);		/* Increment index for next */
   820a0:	4620      	mov	r0, r4
   820a2:	2100      	movs	r1, #0
   820a4:	4b0b      	ldr	r3, [pc, #44]	; (820d4 <f_readdir+0x78>)
   820a6:	4798      	blx	r3
				if (res == FR_NO_FILE) {
   820a8:	2804      	cmp	r0, #4
   820aa:	d104      	bne.n	820b6 <f_readdir+0x5a>
					dj->sect = 0;
   820ac:	2300      	movs	r3, #0
   820ae:	6123      	str	r3, [r4, #16]
   820b0:	e002      	b.n	820b8 <f_readdir+0x5c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
   820b2:	4605      	mov	r5, r0
   820b4:	e000      	b.n	820b8 <f_readdir+0x5c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
   820b6:	4605      	mov	r5, r0
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
   820b8:	4628      	mov	r0, r5
   820ba:	b004      	add	sp, #16
   820bc:	bd70      	pop	{r4, r5, r6, pc}
   820be:	bf00      	nop
   820c0:	00080e7d 	.word	0x00080e7d
   820c4:	0008144d 	.word	0x0008144d
   820c8:	20000900 	.word	0x20000900
   820cc:	0008183d 	.word	0x0008183d
   820d0:	00081971 	.word	0x00081971
   820d4:	000816f9 	.word	0x000816f9

000820d8 <ll_add_ABC>:
	novy->next = llEnd;
	llEnd->prev = novy;
	llCount++;
}
void ll_add_ABC(char *text)	//	Pridam podla abecedy
{
   820d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   820dc:	4605      	mov	r5, r0
	struct TString *novy,*aktualny;
	novy = (struct TString*)malloc(sizeof(struct TString));
   820de:	2010      	movs	r0, #16
   820e0:	4c29      	ldr	r4, [pc, #164]	; (82188 <ll_add_ABC+0xb0>)
   820e2:	47a0      	blx	r4
   820e4:	4680      	mov	r8, r0
	novy->text = (char*)malloc(strlen(text) + 1);
   820e6:	4628      	mov	r0, r5
   820e8:	4e28      	ldr	r6, [pc, #160]	; (8218c <ll_add_ABC+0xb4>)
   820ea:	47b0      	blx	r6
   820ec:	3001      	adds	r0, #1
   820ee:	47a0      	blx	r4
   820f0:	4604      	mov	r4, r0
   820f2:	f8c8 000c 	str.w	r0, [r8, #12]
	memcpy(novy->text,text,strlen(text) + 1);
   820f6:	4628      	mov	r0, r5
   820f8:	47b0      	blx	r6
   820fa:	1c42      	adds	r2, r0, #1
   820fc:	4620      	mov	r0, r4
   820fe:	4629      	mov	r1, r5
   82100:	4b23      	ldr	r3, [pc, #140]	; (82190 <ll_add_ABC+0xb8>)
   82102:	4798      	blx	r3
//	debugprintf(300,"vkladam",text);
	llCount++;
   82104:	4b23      	ldr	r3, [pc, #140]	; (82194 <ll_add_ABC+0xbc>)
   82106:	881a      	ldrh	r2, [r3, #0]
   82108:	3201      	adds	r2, #1
   8210a:	801a      	strh	r2, [r3, #0]
	if(llStart == NULL)	//	Prazdny zaciatok, takze aj koniec
   8210c:	f8d3 9004 	ldr.w	r9, [r3, #4]
   82110:	f1b9 0f00 	cmp.w	r9, #0
   82114:	d10a      	bne.n	8212c <ll_add_ABC+0x54>
	{
		llStart = novy;
   82116:	f8c3 8004 	str.w	r8, [r3, #4]
		llStart->prev = NULL;
		llEnd = novy;
   8211a:	f8c3 8008 	str.w	r8, [r3, #8]
		llEnd->next = NULL;
   8211e:	2300      	movs	r3, #0
   82120:	f8c8 3004 	str.w	r3, [r8, #4]
		llEnd->prev = novy;
		novy->next = NULL;
		novy->prev = NULL;
   82124:	f8c8 3008 	str.w	r3, [r8, #8]
		return;
   82128:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		aktualny = llStart;	//	Najdem zaciatok zoznamu
		while(true)
		{
//			debugprintf(300,"Nasiel som ",aktualny->text);
			if(strncmp(aktualny->text,text,strlen(text)) < 0)
   8212c:	4628      	mov	r0, r5
   8212e:	4b17      	ldr	r3, [pc, #92]	; (8218c <ll_add_ABC+0xb4>)
   82130:	4798      	blx	r3
   82132:	4607      	mov	r7, r0
   82134:	464c      	mov	r4, r9
   82136:	4e18      	ldr	r6, [pc, #96]	; (82198 <ll_add_ABC+0xc0>)
   82138:	e000      	b.n	8213c <ll_add_ABC+0x64>
					novy->prev = aktualny;
					novy->next = NULL;
					llEnd = novy;
					return;
				}
				aktualny = aktualny->next;
   8213a:	461c      	mov	r4, r3
	{
		aktualny = llStart;	//	Najdem zaciatok zoznamu
		while(true)
		{
//			debugprintf(300,"Nasiel som ",aktualny->text);
			if(strncmp(aktualny->text,text,strlen(text)) < 0)
   8213c:	68e0      	ldr	r0, [r4, #12]
   8213e:	4629      	mov	r1, r5
   82140:	463a      	mov	r2, r7
   82142:	47b0      	blx	r6
   82144:	2800      	cmp	r0, #0
   82146:	da0d      	bge.n	82164 <ll_add_ABC+0x8c>
			{	
				if(aktualny->next == NULL)	//	Toto je posledny zaznam v zozname, pridam teda novy zaznam na koniec
   82148:	6863      	ldr	r3, [r4, #4]
   8214a:	2b00      	cmp	r3, #0
   8214c:	d1f5      	bne.n	8213a <ll_add_ABC+0x62>
				{
					aktualny->next = novy;
   8214e:	f8c4 8004 	str.w	r8, [r4, #4]
					novy->prev = aktualny;
   82152:	f8c8 4008 	str.w	r4, [r8, #8]
					novy->next = NULL;
   82156:	f8c8 3004 	str.w	r3, [r8, #4]
					llEnd = novy;
   8215a:	4b0e      	ldr	r3, [pc, #56]	; (82194 <ll_add_ABC+0xbc>)
   8215c:	f8c3 8008 	str.w	r8, [r3, #8]
					return;
   82160:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				llEnd = novy;
				return;
			}
		}
	}
	if(aktualny == llStart)
   82164:	454c      	cmp	r4, r9
		llStart = novy;
   82166:	bf04      	itt	eq
   82168:	4b0a      	ldreq	r3, [pc, #40]	; (82194 <ll_add_ABC+0xbc>)
   8216a:	f8c3 8004 	streq.w	r8, [r3, #4]
	novy->prev = aktualny->prev;
   8216e:	68a3      	ldr	r3, [r4, #8]
   82170:	f8c8 3008 	str.w	r3, [r8, #8]
	(aktualny->prev)->next = novy;	//	Predosly bude ukazovat na novo vzniknuty
   82174:	68a3      	ldr	r3, [r4, #8]
   82176:	f8c3 8004 	str.w	r8, [r3, #4]
	aktualny->prev = novy;
   8217a:	f8c4 8008 	str.w	r8, [r4, #8]
	novy->next = aktualny;			//	Za novym bude aktualny
   8217e:	f8c8 4004 	str.w	r4, [r8, #4]
   82182:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   82186:	bf00      	nop
   82188:	0008cbb1 	.word	0x0008cbb1
   8218c:	0008d399 	.word	0x0008d399
   82190:	0008d0dd 	.word	0x0008d0dd
   82194:	20000b00 	.word	0x20000b00
   82198:	0008d3f5 	.word	0x0008d3f5

0008219c <ll_count>:
}

uint16_t ll_count(void)
{
	return llCount;		
}
   8219c:	4b01      	ldr	r3, [pc, #4]	; (821a4 <ll_count+0x8>)
   8219e:	8818      	ldrh	r0, [r3, #0]
   821a0:	4770      	bx	lr
   821a2:	bf00      	nop
   821a4:	20000b00 	.word	0x20000b00

000821a8 <ll_item>:


char* ll_item(uint16_t index)
{
	struct TString *aktualny;
	if(index > (llCount - 1)) return NULL;
   821a8:	4b08      	ldr	r3, [pc, #32]	; (821cc <ll_item+0x24>)
   821aa:	881b      	ldrh	r3, [r3, #0]
   821ac:	3b01      	subs	r3, #1
   821ae:	4298      	cmp	r0, r3
   821b0:	dc0a      	bgt.n	821c8 <ll_item+0x20>
	aktualny = llStart;	//	Najdem zaciatok zoznamu
   821b2:	4b06      	ldr	r3, [pc, #24]	; (821cc <ll_item+0x24>)
   821b4:	685b      	ldr	r3, [r3, #4]
	while(true)
	{
		if(!index)
   821b6:	b908      	cbnz	r0, 821bc <ll_item+0x14>
		{
			return(aktualny->text);
   821b8:	68d8      	ldr	r0, [r3, #12]
   821ba:	4770      	bx	lr
		}
		aktualny = aktualny->next;
   821bc:	685b      	ldr	r3, [r3, #4]
		index--;
   821be:	3801      	subs	r0, #1
   821c0:	b280      	uxth	r0, r0
	struct TString *aktualny;
	if(index > (llCount - 1)) return NULL;
	aktualny = llStart;	//	Najdem zaciatok zoznamu
	while(true)
	{
		if(!index)
   821c2:	2800      	cmp	r0, #0
   821c4:	d1fa      	bne.n	821bc <ll_item+0x14>
   821c6:	e7f7      	b.n	821b8 <ll_item+0x10>


char* ll_item(uint16_t index)
{
	struct TString *aktualny;
	if(index > (llCount - 1)) return NULL;
   821c8:	2000      	movs	r0, #0
			return(aktualny->text);
		}
		aktualny = aktualny->next;
		index--;
	}
}
   821ca:	4770      	bx	lr
   821cc:	20000b00 	.word	0x20000b00

000821d0 <ll_clear>:

void ll_clear(void)
{
   821d0:	b538      	push	{r3, r4, r5, lr}
	struct TString *aktualny = llStart;
   821d2:	4b0c      	ldr	r3, [pc, #48]	; (82204 <ll_clear+0x34>)
   821d4:	6858      	ldr	r0, [r3, #4]
	struct TString *next;
	if(!llStart) return;	//	Zoznam je prazdny
   821d6:	b1a0      	cbz	r0, 82202 <ll_clear+0x32>

	while(aktualny->next)
   821d8:	6844      	ldr	r4, [r0, #4]
   821da:	b14c      	cbz	r4, 821f0 <ll_clear+0x20>
	{
		next = aktualny->next;
		free(aktualny);
   821dc:	4d0a      	ldr	r5, [pc, #40]	; (82208 <ll_clear+0x38>)
   821de:	e000      	b.n	821e2 <ll_clear+0x12>
{
	struct TString *aktualny = llStart;
	struct TString *next;
	if(!llStart) return;	//	Zoznam je prazdny

	while(aktualny->next)
   821e0:	461c      	mov	r4, r3
	{
		next = aktualny->next;
		free(aktualny);
   821e2:	47a8      	blx	r5
{
	struct TString *aktualny = llStart;
	struct TString *next;
	if(!llStart) return;	//	Zoznam je prazdny

	while(aktualny->next)
   821e4:	6863      	ldr	r3, [r4, #4]
   821e6:	4620      	mov	r0, r4
   821e8:	2b00      	cmp	r3, #0
   821ea:	d1f9      	bne.n	821e0 <ll_clear+0x10>
	{
		next = aktualny->next;
		free(aktualny);
		aktualny = next;
	}
	if(aktualny)
   821ec:	b90c      	cbnz	r4, 821f2 <ll_clear+0x22>
   821ee:	e003      	b.n	821f8 <ll_clear+0x28>
{
	struct TString *aktualny = llStart;
	struct TString *next;
	if(!llStart) return;	//	Zoznam je prazdny

	while(aktualny->next)
   821f0:	4604      	mov	r4, r0
		next = aktualny->next;
		free(aktualny);
		aktualny = next;
	}
	if(aktualny)
		free(aktualny);
   821f2:	4620      	mov	r0, r4
   821f4:	4b04      	ldr	r3, [pc, #16]	; (82208 <ll_clear+0x38>)
   821f6:	4798      	blx	r3
	llStart = NULL;
   821f8:	4b02      	ldr	r3, [pc, #8]	; (82204 <ll_clear+0x34>)
   821fa:	2200      	movs	r2, #0
   821fc:	605a      	str	r2, [r3, #4]
	llEnd = NULL;
   821fe:	609a      	str	r2, [r3, #8]
	llCount = 0;	
   82200:	801a      	strh	r2, [r3, #0]
   82202:	bd38      	pop	{r3, r4, r5, pc}
   82204:	20000b00 	.word	0x20000b00
   82208:	0008cbc1 	.word	0x0008cbc1

0008220c <translate_address>:
 * \param pus_page The first page accessed.
 * \param pus_offset Byte offset in the first page.
 */
static void translate_address(Efc **pp_efc, uint32_t ul_addr,
		uint16_t *pus_page, uint16_t *pus_offset)
{
   8220c:	b430      	push	{r4, r5}
	Efc *p_efc;
	uint16_t us_page;
	uint16_t us_offset;

	if (ul_addr >= IFLASH1_ADDR) {
   8220e:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
   82212:	d306      	bcc.n	82222 <translate_address+0x16>
		p_efc = EFC1;
		us_page = (ul_addr - IFLASH1_ADDR) / IFLASH1_PAGE_SIZE;
   82214:	f5a1 2440 	sub.w	r4, r1, #786432	; 0xc0000
   82218:	f3c4 240f 	ubfx	r4, r4, #8, #16
		us_offset = (ul_addr - IFLASH1_ADDR) % IFLASH1_PAGE_SIZE;
   8221c:	b2c9      	uxtb	r1, r1
	Efc *p_efc;
	uint16_t us_page;
	uint16_t us_offset;

	if (ul_addr >= IFLASH1_ADDR) {
		p_efc = EFC1;
   8221e:	4d08      	ldr	r5, [pc, #32]	; (82240 <translate_address+0x34>)
   82220:	e005      	b.n	8222e <translate_address+0x22>
		us_page = (ul_addr - IFLASH1_ADDR) / IFLASH1_PAGE_SIZE;
		us_offset = (ul_addr - IFLASH1_ADDR) % IFLASH1_PAGE_SIZE;
	} else {
		p_efc = EFC0;
		us_page = (ul_addr - IFLASH0_ADDR) / IFLASH0_PAGE_SIZE;
   82222:	f5a1 2400 	sub.w	r4, r1, #524288	; 0x80000
   82226:	f3c4 240f 	ubfx	r4, r4, #8, #16
		us_offset = (ul_addr - IFLASH0_ADDR) % IFLASH0_PAGE_SIZE;
   8222a:	b2c9      	uxtb	r1, r1
	if (ul_addr >= IFLASH1_ADDR) {
		p_efc = EFC1;
		us_page = (ul_addr - IFLASH1_ADDR) / IFLASH1_PAGE_SIZE;
		us_offset = (ul_addr - IFLASH1_ADDR) % IFLASH1_PAGE_SIZE;
	} else {
		p_efc = EFC0;
   8222c:	4d05      	ldr	r5, [pc, #20]	; (82244 <translate_address+0x38>)
		us_page = (ul_addr - IFLASH0_ADDR) / IFLASH0_PAGE_SIZE;
		us_offset = (ul_addr - IFLASH0_ADDR) % IFLASH0_PAGE_SIZE;
	}

	/* Store values */
	if (pp_efc) {
   8222e:	b100      	cbz	r0, 82232 <translate_address+0x26>
		*pp_efc = p_efc;
   82230:	6005      	str	r5, [r0, #0]
	}

	if (pus_page) {
   82232:	b102      	cbz	r2, 82236 <translate_address+0x2a>
		*pus_page = us_page;
   82234:	8014      	strh	r4, [r2, #0]
	}

	if (pus_offset) {
   82236:	b103      	cbz	r3, 8223a <translate_address+0x2e>
		*pus_offset = us_offset;
   82238:	8019      	strh	r1, [r3, #0]
	}
}
   8223a:	bc30      	pop	{r4, r5}
   8223c:	4770      	bx	lr
   8223e:	bf00      	nop
   82240:	400e0c00 	.word	0x400e0c00
   82244:	400e0a00 	.word	0x400e0a00

00082248 <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
   82248:	b570      	push	{r4, r5, r6, lr}
   8224a:	4606      	mov	r6, r0
   8224c:	460d      	mov	r5, r1
	efc_init(EFC, ul_mode, ul_fws);
   8224e:	4805      	ldr	r0, [pc, #20]	; (82264 <flash_init+0x1c>)
   82250:	4631      	mov	r1, r6
   82252:	462a      	mov	r2, r5
   82254:	4c04      	ldr	r4, [pc, #16]	; (82268 <flash_init+0x20>)
   82256:	47a0      	blx	r4

#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
   82258:	4804      	ldr	r0, [pc, #16]	; (8226c <flash_init+0x24>)
   8225a:	4631      	mov	r1, r6
   8225c:	462a      	mov	r2, r5
   8225e:	47a0      	blx	r4
#endif

	return FLASH_RC_OK;
}
   82260:	2000      	movs	r0, #0
   82262:	bd70      	pop	{r4, r5, r6, pc}
   82264:	400e0a00 	.word	0x400e0a00
   82268:	00080349 	.word	0x00080349
   8226c:	400e0c00 	.word	0x400e0c00

00082270 <flash_write>:
 * \return 0 if successful, otherwise returns an error code.
 */
#define MIN(a,b) (((a)<(b))?(a):(b))
uint32_t flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
   82270:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   82274:	b085      	sub	sp, #20
   82276:	4604      	mov	r4, r0
   82278:	468b      	mov	fp, r1
   8227a:	4692      	mov	sl, r2
   8227c:	9300      	str	r3, [sp, #0]
	uint32_t ul_error;
	uint32_t ul_idx;
	uint32_t *p_aligned_dest;
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);
   8227e:	a803      	add	r0, sp, #12
   82280:	4621      	mov	r1, r4
   82282:	f10d 020a 	add.w	r2, sp, #10
   82286:	ab02      	add	r3, sp, #8
   82288:	4c31      	ldr	r4, [pc, #196]	; (82350 <flash_write+0xe0>)
   8228a:	47a0      	blx	r4

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
   8228c:	9803      	ldr	r0, [sp, #12]
   8228e:	4b31      	ldr	r3, [pc, #196]	; (82354 <flash_write+0xe4>)
   82290:	4798      	blx	r3
   82292:	9001      	str	r0, [sp, #4]
	efc_set_wait_state(p_efc, 6);
   82294:	9803      	ldr	r0, [sp, #12]
   82296:	2106      	movs	r1, #6
   82298:	4b2f      	ldr	r3, [pc, #188]	; (82358 <flash_write+0xe8>)
   8229a:	4798      	blx	r3

	/* Write all pages */
	while (ul_size > 0) {
   8229c:	f1ba 0f00 	cmp.w	sl, #0
   822a0:	d04e      	beq.n	82340 <flash_write+0xd0>
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
   822a2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 82364 <flash_write+0xf4>
   822a6:	f108 05fc 	add.w	r5, r8, #252	; 0xfc
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = MIN((uint32_t) IFLASH_PAGE_SIZE - us_offset,
   822aa:	f8bd 6008 	ldrh.w	r6, [sp, #8]
   822ae:	f5c6 7780 	rsb	r7, r6, #256	; 0x100
   822b2:	4557      	cmp	r7, sl
   822b4:	bf28      	it	cs
   822b6:	4657      	movcs	r7, sl
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
   822b8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
	uint32_t ul_addr;

/* Dual bank flash */
#ifdef EFC1
	/* Compute address */
	ul_addr = (p_efc == EFC0) ?
   822bc:	9a03      	ldr	r2, [sp, #12]
   822be:	4927      	ldr	r1, [pc, #156]	; (8235c <flash_write+0xec>)
   822c0:	428a      	cmp	r2, r1
			IFLASH0_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset :
   822c2:	bf0c      	ite	eq
   822c4:	f503 6300 	addeq.w	r3, r3, #2048	; 0x800
			IFLASH1_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
   822c8:	f503 6340 	addne.w	r3, r3, #3072	; 0xc00
   822cc:	021c      	lsls	r4, r3, #8
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
   822ce:	4640      	mov	r0, r8
   822d0:	4621      	mov	r1, r4
   822d2:	4632      	mov	r2, r6
   822d4:	f8df 9090 	ldr.w	r9, [pc, #144]	; 82368 <flash_write+0xf8>
   822d8:	47c8      	blx	r9

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);
   822da:	eb08 0006 	add.w	r0, r8, r6
   822de:	4659      	mov	r1, fp
   822e0:	463a      	mov	r2, r7
   822e2:	47c8      	blx	r9

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
   822e4:	19b9      	adds	r1, r7, r6
   822e6:	f5c6 7280 	rsb	r2, r6, #256	; 0x100
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = MIN((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
   822ea:	1bd2      	subs	r2, r2, r7

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
   822ec:	eb08 0001 	add.w	r0, r8, r1
   822f0:	4421      	add	r1, r4
   822f2:	b292      	uxth	r2, r2
   822f4:	47c8      	blx	r9
   822f6:	f1a8 0304 	sub.w	r3, r8, #4
   822fa:	3c04      	subs	r4, #4
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
   822fc:	f853 2f04 	ldr.w	r2, [r3, #4]!
   82300:	f844 2f04 	str.w	r2, [r4, #4]!
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
   82304:	42ab      	cmp	r3, r5
   82306:	d1f9      	bne.n	822fc <flash_write+0x8c>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
   82308:	9b00      	ldr	r3, [sp, #0]
   8230a:	b133      	cbz	r3, 8231a <flash_write+0xaa>
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
   8230c:	9803      	ldr	r0, [sp, #12]
   8230e:	2103      	movs	r1, #3
   82310:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   82314:	4b12      	ldr	r3, [pc, #72]	; (82360 <flash_write+0xf0>)
   82316:	4798      	blx	r3
   82318:	e005      	b.n	82326 <flash_write+0xb6>
					us_page);
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
   8231a:	9803      	ldr	r0, [sp, #12]
   8231c:	2101      	movs	r1, #1
   8231e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   82322:	4b0f      	ldr	r3, [pc, #60]	; (82360 <flash_write+0xf0>)
   82324:	4798      	blx	r3
					us_page);
		}

		if (ul_error) {
   82326:	b980      	cbnz	r0, 8234a <flash_write+0xda>
			return ul_error;
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
   82328:	44bb      	add	fp, r7
		ul_size -= writeSize;
		us_page++;
   8232a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   8232e:	3301      	adds	r3, #1
   82330:	f8ad 300a 	strh.w	r3, [sp, #10]
		us_offset = 0;
   82334:	2300      	movs	r3, #0
   82336:	f8ad 3008 	strh.w	r3, [sp, #8]
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
   8233a:	ebba 0a07 	subs.w	sl, sl, r7
   8233e:	d1b4      	bne.n	822aa <flash_write+0x3a>
		us_page++;
		us_offset = 0;
	}

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);
   82340:	9803      	ldr	r0, [sp, #12]
   82342:	9901      	ldr	r1, [sp, #4]
   82344:	4b04      	ldr	r3, [pc, #16]	; (82358 <flash_write+0xe8>)
   82346:	4798      	blx	r3

	return FLASH_RC_OK;
   82348:	2000      	movs	r0, #0
}
   8234a:	b005      	add	sp, #20
   8234c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82350:	0008220d 	.word	0x0008220d
   82354:	0008036d 	.word	0x0008036d
   82358:	00080359 	.word	0x00080359
   8235c:	400e0a00 	.word	0x400e0a00
   82360:	00080375 	.word	0x00080375
   82364:	20000b0c 	.word	0x20000b0c
   82368:	0008d0dd 	.word	0x0008d0dd

0008236c <flash_lock>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_lock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
   8236c:	b530      	push	{r4, r5, lr}
   8236e:	b083      	sub	sp, #12
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
   82370:	f420 557f 	bic.w	r5, r0, #16320	; 0x3fc0
   82374:	f025 053f 	bic.w	r5, r5, #63	; 0x3f
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
   82378:	ea6f 3491 	mvn.w	r4, r1, lsr #14
   8237c:	ea6f 3484 	mvn.w	r4, r4, lsl #14
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual lock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);

	if (pul_actual_start != NULL) {
   82380:	b102      	cbz	r2, 82384 <flash_lock+0x18>
		*pul_actual_start = ul_actual_start;
   82382:	6015      	str	r5, [r2, #0]
	}

	if (pul_actual_end != NULL) {
   82384:	b103      	cbz	r3, 82388 <flash_lock+0x1c>
		*pul_actual_end = ul_actual_end;
   82386:	601c      	str	r4, [r3, #0]
	}

	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
   82388:	a801      	add	r0, sp, #4
   8238a:	4629      	mov	r1, r5
   8238c:	f10d 0202 	add.w	r2, sp, #2
   82390:	2300      	movs	r3, #0
   82392:	4d11      	ldr	r5, [pc, #68]	; (823d8 <flash_lock+0x6c>)
   82394:	47a8      	blx	r5
	translate_address(0, ul_actual_end, &us_end_page, 0);
   82396:	2000      	movs	r0, #0
   82398:	4621      	mov	r1, r4
   8239a:	466a      	mov	r2, sp
   8239c:	4603      	mov	r3, r0
   8239e:	47a8      	blx	r5

	/* Lock all pages */
	while (us_start_page < us_end_page) {
   823a0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   823a4:	f8bd 3000 	ldrh.w	r3, [sp]
   823a8:	4293      	cmp	r3, r2
   823aa:	d910      	bls.n	823ce <flash_lock+0x62>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_SLB, us_start_page);
   823ac:	2508      	movs	r5, #8
   823ae:	4c0b      	ldr	r4, [pc, #44]	; (823dc <flash_lock+0x70>)
   823b0:	9801      	ldr	r0, [sp, #4]
   823b2:	4629      	mov	r1, r5
   823b4:	47a0      	blx	r4

		if (ul_error) {
   823b6:	b960      	cbnz	r0, 823d2 <flash_lock+0x66>
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
   823b8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   823bc:	3240      	adds	r2, #64	; 0x40
   823be:	b292      	uxth	r2, r2
   823c0:	f8ad 2002 	strh.w	r2, [sp, #2]
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Lock all pages */
	while (us_start_page < us_end_page) {
   823c4:	f8bd 3000 	ldrh.w	r3, [sp]
   823c8:	4293      	cmp	r3, r2
   823ca:	d8f1      	bhi.n	823b0 <flash_lock+0x44>
   823cc:	e001      	b.n	823d2 <flash_lock+0x66>
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
   823ce:	2000      	movs	r0, #0
   823d0:	e7ff      	b.n	823d2 <flash_lock+0x66>
}
   823d2:	b003      	add	sp, #12
   823d4:	bd30      	pop	{r4, r5, pc}
   823d6:	bf00      	nop
   823d8:	0008220d 	.word	0x0008220d
   823dc:	00080375 	.word	0x00080375

000823e0 <flash_unlock>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_unlock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
   823e0:	b530      	push	{r4, r5, lr}
   823e2:	b083      	sub	sp, #12
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
   823e4:	f420 557f 	bic.w	r5, r0, #16320	; 0x3fc0
   823e8:	f025 053f 	bic.w	r5, r5, #63	; 0x3f
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
   823ec:	ea6f 3491 	mvn.w	r4, r1, lsr #14
   823f0:	ea6f 3484 	mvn.w	r4, r4, lsl #14
	uint16_t us_num_pages_in_region =
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual unlock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);
	if (pul_actual_start != NULL) {
   823f4:	b102      	cbz	r2, 823f8 <flash_unlock+0x18>
		*pul_actual_start = ul_actual_start;
   823f6:	6015      	str	r5, [r2, #0]
	}
	if (pul_actual_end != NULL) {
   823f8:	b103      	cbz	r3, 823fc <flash_unlock+0x1c>
		*pul_actual_end = ul_actual_end;
   823fa:	601c      	str	r4, [r3, #0]
	}

	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
   823fc:	a801      	add	r0, sp, #4
   823fe:	4629      	mov	r1, r5
   82400:	f10d 0202 	add.w	r2, sp, #2
   82404:	2300      	movs	r3, #0
   82406:	4d11      	ldr	r5, [pc, #68]	; (8244c <flash_unlock+0x6c>)
   82408:	47a8      	blx	r5
	translate_address(0, ul_actual_end, &us_end_page, 0);
   8240a:	2000      	movs	r0, #0
   8240c:	4621      	mov	r1, r4
   8240e:	466a      	mov	r2, sp
   82410:	4603      	mov	r3, r0
   82412:	47a8      	blx	r5

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
   82414:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   82418:	f8bd 3000 	ldrh.w	r3, [sp]
   8241c:	4293      	cmp	r3, r2
   8241e:	d910      	bls.n	82442 <flash_unlock+0x62>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
   82420:	2509      	movs	r5, #9
   82422:	4c0b      	ldr	r4, [pc, #44]	; (82450 <flash_unlock+0x70>)
   82424:	9801      	ldr	r0, [sp, #4]
   82426:	4629      	mov	r1, r5
   82428:	47a0      	blx	r4
				us_start_page);
		if (ul_error) {
   8242a:	b960      	cbnz	r0, 82446 <flash_unlock+0x66>
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
   8242c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   82430:	3240      	adds	r2, #64	; 0x40
   82432:	b292      	uxth	r2, r2
   82434:	f8ad 2002 	strh.w	r2, [sp, #2]
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
   82438:	f8bd 3000 	ldrh.w	r3, [sp]
   8243c:	4293      	cmp	r3, r2
   8243e:	d8f1      	bhi.n	82424 <flash_unlock+0x44>
   82440:	e001      	b.n	82446 <flash_unlock+0x66>
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
   82442:	2000      	movs	r0, #0
   82444:	e7ff      	b.n	82446 <flash_unlock+0x66>
}
   82446:	b003      	add	sp, #12
   82448:	bd30      	pop	{r4, r5, pc}
   8244a:	bf00      	nop
   8244c:	0008220d 	.word	0x0008220d
   82450:	00080375 	.word	0x00080375

00082454 <my_flash_init>:
#include "Flash_Storage.h"

void my_flash_init() 
{
   82454:	b508      	push	{r3, lr}
	uint32_t retCode;

	/* Initialize flash: 6 wait states for flash writing. */
	retCode = flash_init(FLASH_ACCESS_MODE_128, 6);
   82456:	2000      	movs	r0, #0
   82458:	2106      	movs	r1, #6
   8245a:	4b01      	ldr	r3, [pc, #4]	; (82460 <my_flash_init+0xc>)
   8245c:	4798      	blx	r3
   8245e:	bd08      	pop	{r3, pc}
   82460:	00082249 	.word	0x00082249

00082464 <flash_read_8>:
		_FLASH_DEBUG("Flash init failed\n");
	}
}

uint8_t flash_read_8(uint32_t address) {
	return FLASH_START[address];
   82464:	f500 2040 	add.w	r0, r0, #786432	; 0xc0000
}
   82468:	7800      	ldrb	r0, [r0, #0]
   8246a:	4770      	bx	lr

0008246c <flash_write_buffer>:
	if ((uint32_t)FLASH_START+address < IFLASH1_ADDR) {
		_FLASH_DEBUG("Flash write address too low\n");
		return false;
	}

	if ((uint32_t)FLASH_START+address >= (IFLASH1_ADDR + IFLASH1_SIZE)) {
   8246c:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
   82470:	d226      	bcs.n	824c0 <flash_write_buffer+0x54>
		_FLASH_DEBUG("Flash write address too high\n");
		return false;
	}

	if ((((uint32_t)FLASH_START+address) & 3) != 0) {
   82472:	f010 0f03 	tst.w	r0, #3
   82476:	d125      	bne.n	824c4 <flash_write_buffer+0x58>
		return false;
	}
	return true;
}

bool flash_write_buffer(uint32_t address, uint8_t *data, uint32_t dataLength) {
   82478:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8247c:	4616      	mov	r6, r2
   8247e:	4688      	mov	r8, r1
	uint32_t retCode;

	if ((uint32_t)FLASH_START+address < IFLASH1_ADDR) {
   82480:	f500 2740 	add.w	r7, r0, #786432	; 0xc0000
   82484:	f502 243f 	add.w	r4, r2, #782336	; 0xbf000
   82488:	f604 74ff 	addw	r4, r4, #4095	; 0xfff
		_FLASH_DEBUG("Flash start address must be on four uint8_t boundary\n");
		return false;
	}

	// Unlock page
	retCode = flash_unlock((uint32_t)FLASH_START+address, (uint32_t)FLASH_START+address + dataLength - 1, 0, 0);
   8248c:	4404      	add	r4, r0
   8248e:	4638      	mov	r0, r7
   82490:	4621      	mov	r1, r4
   82492:	2200      	movs	r2, #0
   82494:	4613      	mov	r3, r2
   82496:	4d0f      	ldr	r5, [pc, #60]	; (824d4 <flash_write_buffer+0x68>)
   82498:	47a8      	blx	r5
	if (retCode != FLASH_RC_OK) {
   8249a:	b9a8      	cbnz	r0, 824c8 <flash_write_buffer+0x5c>
		_FLASH_DEBUG("Failed to unlock flash for write\n");
		return false;
	}

	// write data
	retCode = flash_write((uint32_t)FLASH_START+address, data, dataLength, 1);
   8249c:	4638      	mov	r0, r7
   8249e:	4641      	mov	r1, r8
   824a0:	4632      	mov	r2, r6
   824a2:	2301      	movs	r3, #1
   824a4:	4d0c      	ldr	r5, [pc, #48]	; (824d8 <flash_write_buffer+0x6c>)
   824a6:	47a8      	blx	r5

	if (retCode != FLASH_RC_OK) {
   824a8:	b988      	cbnz	r0, 824ce <flash_write_buffer+0x62>
		_FLASH_DEBUG("Flash write failed\n");
		return false;
	}

	// Lock page
	retCode = flash_lock((uint32_t)FLASH_START+address, (uint32_t)FLASH_START+address + dataLength - 1, 0, 0);
   824aa:	4638      	mov	r0, r7
   824ac:	4621      	mov	r1, r4
   824ae:	2200      	movs	r2, #0
   824b0:	4613      	mov	r3, r2
   824b2:	4c0a      	ldr	r4, [pc, #40]	; (824dc <flash_write_buffer+0x70>)
   824b4:	47a0      	blx	r4
	if (retCode != FLASH_RC_OK) {
   824b6:	fab0 f080 	clz	r0, r0
   824ba:	0940      	lsrs	r0, r0, #5
   824bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return false;
	}

	if ((uint32_t)FLASH_START+address >= (IFLASH1_ADDR + IFLASH1_SIZE)) {
		_FLASH_DEBUG("Flash write address too high\n");
		return false;
   824c0:	2000      	movs	r0, #0
   824c2:	4770      	bx	lr
	}

	if ((((uint32_t)FLASH_START+address) & 3) != 0) {
		_FLASH_DEBUG("Flash start address must be on four uint8_t boundary\n");
		return false;
   824c4:	2000      	movs	r0, #0
	if (retCode != FLASH_RC_OK) {
		_FLASH_DEBUG("Failed to lock flash page\n");
		return false;
	}
	return true;
}
   824c6:	4770      	bx	lr

	// Unlock page
	retCode = flash_unlock((uint32_t)FLASH_START+address, (uint32_t)FLASH_START+address + dataLength - 1, 0, 0);
	if (retCode != FLASH_RC_OK) {
		_FLASH_DEBUG("Failed to unlock flash for write\n");
		return false;
   824c8:	2000      	movs	r0, #0
   824ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	// write data
	retCode = flash_write((uint32_t)FLASH_START+address, data, dataLength, 1);

	if (retCode != FLASH_RC_OK) {
		_FLASH_DEBUG("Flash write failed\n");
		return false;
   824ce:	2000      	movs	r0, #0
	if (retCode != FLASH_RC_OK) {
		_FLASH_DEBUG("Failed to lock flash page\n");
		return false;
	}
	return true;
}
   824d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   824d4:	000823e1 	.word	0x000823e1
   824d8:	00082271 	.word	0x00082271
   824dc:	0008236d 	.word	0x0008236d

000824e0 <gc_init>:

#define FAIL(status) return(status);


void gc_init() 
{
   824e0:	b510      	push	{r4, lr}
  memset(&gc_state, 0, sizeof(gc_state));
   824e2:	4c08      	ldr	r4, [pc, #32]	; (82504 <gc_init+0x24>)
   824e4:	4620      	mov	r0, r4
   824e6:	2100      	movs	r1, #0
   824e8:	2244      	movs	r2, #68	; 0x44
   824ea:	4b07      	ldr	r3, [pc, #28]	; (82508 <gc_init+0x28>)
   824ec:	4798      	blx	r3
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
   824ee:	2000      	movs	r0, #0
   824f0:	f104 0128 	add.w	r1, r4, #40	; 0x28
   824f4:	4b05      	ldr	r3, [pc, #20]	; (8250c <gc_init+0x2c>)
   824f6:	4798      	blx	r3
   824f8:	b910      	cbnz	r0, 82500 <gc_init+0x20>
    report_status_message(STATUS_SETTING_READ_FAIL); 
   824fa:	2007      	movs	r0, #7
   824fc:	4b04      	ldr	r3, [pc, #16]	; (82510 <gc_init+0x30>)
   824fe:	4798      	blx	r3
   82500:	bd10      	pop	{r4, pc}
   82502:	bf00      	nop
   82504:	200011c8 	.word	0x200011c8
   82508:	0008d1c9 	.word	0x0008d1c9
   8250c:	00088021 	.word	0x00088021
   82510:	000872f1 	.word	0x000872f1

00082514 <gc_sync_position>:


// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
   82514:	b508      	push	{r3, lr}
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
   82516:	4802      	ldr	r0, [pc, #8]	; (82520 <gc_sync_position+0xc>)
   82518:	4902      	ldr	r1, [pc, #8]	; (82524 <gc_sync_position+0x10>)
   8251a:	4b03      	ldr	r3, [pc, #12]	; (82528 <gc_sync_position+0x14>)
   8251c:	4798      	blx	r3
   8251e:	bd08      	pop	{r3, pc}
   82520:	200011e4 	.word	0x200011e4
   82524:	20001488 	.word	0x20001488
   82528:	00089649 	.word	0x00089649
   8252c:	00000000 	.word	0x00000000

00082530 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
   82530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   82534:	b099      	sub	sp, #100	; 0x64
   82536:	4682      	mov	sl, r0
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
   82538:	4c96      	ldr	r4, [pc, #600]	; (82794 <gc_execute_line+0x264>)
   8253a:	4620      	mov	r0, r4
   8253c:	2100      	movs	r1, #0
   8253e:	2240      	movs	r2, #64	; 0x40
   82540:	4b95      	ldr	r3, [pc, #596]	; (82798 <gc_execute_line+0x268>)
   82542:	4798      	blx	r3
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
   82544:	1c62      	adds	r2, r4, #1
   82546:	4b95      	ldr	r3, [pc, #596]	; (8279c <gc_execute_line+0x26c>)
   82548:	cb03      	ldmia	r3!, {r0, r1}
   8254a:	f8c4 0001 	str.w	r0, [r4, #1]
   8254e:	f8c4 1005 	str.w	r1, [r4, #5]
   82552:	881b      	ldrh	r3, [r3, #0]
   82554:	f8a4 3009 	strh.w	r3, [r4, #9]
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
   82558:	2300      	movs	r3, #0
   8255a:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
   8255e:	469b      	mov	fp, r3
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
   82560:	461d      	mov	r5, r3
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
   82562:	930a      	str	r3, [sp, #40]	; 0x28
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
   82564:	9306      	str	r3, [sp, #24]
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
   82566:	9309      	str	r3, [sp, #36]	; 0x24
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
   82568:	e2d1      	b.n	82b0e <gc_execute_line+0x5de>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
   8256a:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
   8256e:	b2d2      	uxtb	r2, r2
   82570:	2a19      	cmp	r2, #25
   82572:	f201 8000 	bhi.w	83576 <gc_execute_line+0x1046>
    char_counter++;
   82576:	3301      	adds	r3, #1
   82578:	a918      	add	r1, sp, #96	; 0x60
   8257a:	f801 3d19 	strb.w	r3, [r1, #-25]!
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
   8257e:	4650      	mov	r0, sl
   82580:	aa10      	add	r2, sp, #64	; 0x40
   82582:	4b87      	ldr	r3, [pc, #540]	; (827a0 <gc_execute_line+0x270>)
   82584:	4798      	blx	r3
   82586:	2800      	cmp	r0, #0
   82588:	f000 87f7 	beq.w	8357a <gc_execute_line+0x104a>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
   8258c:	9f10      	ldr	r7, [sp, #64]	; 0x40
   8258e:	f8df 922c 	ldr.w	r9, [pc, #556]	; 827bc <gc_execute_line+0x28c>
   82592:	4638      	mov	r0, r7
   82594:	47c8      	blx	r9
   82596:	4b83      	ldr	r3, [pc, #524]	; (827a4 <gc_execute_line+0x274>)
   82598:	4798      	blx	r3
   8259a:	f8df 8224 	ldr.w	r8, [pc, #548]	; 827c0 <gc_execute_line+0x290>
   8259e:	47c0      	blx	r8
   825a0:	b2c6      	uxtb	r6, r0
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
   825a2:	4630      	mov	r0, r6
   825a4:	4b80      	ldr	r3, [pc, #512]	; (827a8 <gc_execute_line+0x278>)
   825a6:	4798      	blx	r3
   825a8:	4601      	mov	r1, r0
   825aa:	4638      	mov	r0, r7
   825ac:	4b7f      	ldr	r3, [pc, #508]	; (827ac <gc_execute_line+0x27c>)
   825ae:	4798      	blx	r3
   825b0:	497f      	ldr	r1, [pc, #508]	; (827b0 <gc_execute_line+0x280>)
   825b2:	4b80      	ldr	r3, [pc, #512]	; (827b4 <gc_execute_line+0x284>)
   825b4:	4798      	blx	r3
   825b6:	47c8      	blx	r9
   825b8:	4b7f      	ldr	r3, [pc, #508]	; (827b8 <gc_execute_line+0x288>)
   825ba:	4798      	blx	r3
   825bc:	47c0      	blx	r8
   825be:	b280      	uxth	r0, r0
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
   825c0:	2c47      	cmp	r4, #71	; 0x47
   825c2:	d003      	beq.n	825cc <gc_execute_line+0x9c>
   825c4:	2c4d      	cmp	r4, #77	; 0x4d
   825c6:	f000 81b3 	beq.w	82930 <gc_execute_line+0x400>
   825ca:	e21b      	b.n	82a04 <gc_execute_line+0x4d4>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
   825cc:	2e5e      	cmp	r6, #94	; 0x5e
   825ce:	f200 87d6 	bhi.w	8357e <gc_execute_line+0x104e>
   825d2:	e8df f016 	tbh	[pc, r6, lsl #1]
   825d6:	00c0      	.short	0x00c0
   825d8:	00c000c0 	.word	0x00c000c0
   825dc:	006800c0 	.word	0x006800c0
   825e0:	07d407d4 	.word	0x07d407d4
   825e4:	07d407d4 	.word	0x07d407d4
   825e8:	005f07d4 	.word	0x005f07d4
   825ec:	07d407d4 	.word	0x07d407d4
   825f0:	07d407d4 	.word	0x07d407d4
   825f4:	07d407d4 	.word	0x07d407d4
   825f8:	013f013f 	.word	0x013f013f
   825fc:	016c013f 	.word	0x016c013f
   82600:	07d4016c 	.word	0x07d4016c
   82604:	07d407d4 	.word	0x07d407d4
   82608:	07d407d4 	.word	0x07d407d4
   8260c:	005f07d4 	.word	0x005f07d4
   82610:	005f07d4 	.word	0x005f07d4
   82614:	07d407d4 	.word	0x07d407d4
   82618:	07d407d4 	.word	0x07d407d4
   8261c:	07d407d4 	.word	0x07d407d4
   82620:	00c007d4 	.word	0x00c007d4
   82624:	019507d4 	.word	0x019507d4
   82628:	07d407d4 	.word	0x07d407d4
   8262c:	07d40174 	.word	0x07d40174
   82630:	07d407d4 	.word	0x07d407d4
   82634:	07d407d4 	.word	0x07d407d4
   82638:	07d40174 	.word	0x07d40174
   8263c:	07d407d4 	.word	0x07d407d4
   82640:	018b0068 	.word	0x018b0068
   82644:	018b018b 	.word	0x018b018b
   82648:	018b018b 	.word	0x018b018b
   8264c:	07d4018b 	.word	0x07d4018b
   82650:	07d40190 	.word	0x07d40190
   82654:	07d407d4 	.word	0x07d407d4
   82658:	07d407d4 	.word	0x07d407d4
   8265c:	07d407d4 	.word	0x07d407d4
   82660:	07d407d4 	.word	0x07d407d4
   82664:	07d407d4 	.word	0x07d407d4
   82668:	07d407d4 	.word	0x07d407d4
   8266c:	07d407d4 	.word	0x07d407d4
   82670:	07d407d4 	.word	0x07d407d4
   82674:	00c607d4 	.word	0x00c607d4
   82678:	07d407d4 	.word	0x07d407d4
   8267c:	07d407d4 	.word	0x07d407d4
   82680:	07d407d4 	.word	0x07d407d4
   82684:	07d407d4 	.word	0x07d407d4
   82688:	015307d4 	.word	0x015307d4
   8268c:	005f0153 	.word	0x005f0153
   82690:	01640164 	.word	0x01640164
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
   82694:	2800      	cmp	r0, #0
   82696:	f041 8012 	bne.w	836be <gc_execute_line+0x118e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
   8269a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8269c:	2b00      	cmp	r3, #0
   8269e:	f000 87f7 	beq.w	83690 <gc_execute_line+0x1160>
   826a2:	f000 bf6e 	b.w	83582 <gc_execute_line+0x1052>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
   826a6:	2e1c      	cmp	r6, #28
   826a8:	d01d      	beq.n	826e6 <gc_execute_line+0x1b6>
   826aa:	d804      	bhi.n	826b6 <gc_execute_line+0x186>
   826ac:	2e04      	cmp	r6, #4
   826ae:	d00c      	beq.n	826ca <gc_execute_line+0x19a>
   826b0:	2e0a      	cmp	r6, #10
   826b2:	d011      	beq.n	826d8 <gc_execute_line+0x1a8>
   826b4:	e126      	b.n	82904 <gc_execute_line+0x3d4>
   826b6:	2e35      	cmp	r6, #53	; 0x35
   826b8:	d037      	beq.n	8272a <gc_execute_line+0x1fa>
   826ba:	2e5c      	cmp	r6, #92	; 0x5c
   826bc:	d03c      	beq.n	82738 <gc_execute_line+0x208>
   826be:	2e1e      	cmp	r6, #30
   826c0:	f040 8120 	bne.w	82904 <gc_execute_line+0x3d4>
   826c4:	e020      	b.n	82708 <gc_execute_line+0x1d8>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   826c6:	2301      	movs	r3, #1
   826c8:	9309      	str	r3, [sp, #36]	; 0x24
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
   826ca:	2201      	movs	r2, #1
   826cc:	4b31      	ldr	r3, [pc, #196]	; (82794 <gc_execute_line+0x264>)
   826ce:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   826d0:	2200      	movs	r2, #0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
   826d2:	e11c      	b.n	8290e <gc_execute_line+0x3de>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   826d4:	2301      	movs	r3, #1
   826d6:	9309      	str	r3, [sp, #36]	; 0x24
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
   826d8:	2202      	movs	r2, #2
   826da:	4b2e      	ldr	r3, [pc, #184]	; (82794 <gc_execute_line+0x264>)
   826dc:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   826de:	2200      	movs	r2, #0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
   826e0:	e115      	b.n	8290e <gc_execute_line+0x3de>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   826e2:	2301      	movs	r3, #1
   826e4:	9309      	str	r3, [sp, #36]	; 0x24
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
   826e6:	b118      	cbz	r0, 826f0 <gc_execute_line+0x1c0>
   826e8:	280a      	cmp	r0, #10
   826ea:	d006      	beq.n	826fa <gc_execute_line+0x1ca>
   826ec:	f000 bf4b 	b.w	83586 <gc_execute_line+0x1056>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
   826f0:	2203      	movs	r2, #3
   826f2:	4b28      	ldr	r3, [pc, #160]	; (82794 <gc_execute_line+0x264>)
   826f4:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   826f6:	2200      	movs	r2, #0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
   826f8:	e10f      	b.n	8291a <gc_execute_line+0x3ea>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
   826fa:	2204      	movs	r2, #4
   826fc:	4b25      	ldr	r3, [pc, #148]	; (82794 <gc_execute_line+0x264>)
   826fe:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82700:	2200      	movs	r2, #0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
   82702:	e10a      	b.n	8291a <gc_execute_line+0x3ea>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   82704:	2301      	movs	r3, #1
   82706:	9309      	str	r3, [sp, #36]	; 0x24
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
   82708:	b118      	cbz	r0, 82712 <gc_execute_line+0x1e2>
   8270a:	280a      	cmp	r0, #10
   8270c:	d006      	beq.n	8271c <gc_execute_line+0x1ec>
   8270e:	f000 bf3c 	b.w	8358a <gc_execute_line+0x105a>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
   82712:	2205      	movs	r2, #5
   82714:	4b1f      	ldr	r3, [pc, #124]	; (82794 <gc_execute_line+0x264>)
   82716:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82718:	2200      	movs	r2, #0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
   8271a:	e0fe      	b.n	8291a <gc_execute_line+0x3ea>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
   8271c:	2206      	movs	r2, #6
   8271e:	4b1d      	ldr	r3, [pc, #116]	; (82794 <gc_execute_line+0x264>)
   82720:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82722:	2200      	movs	r2, #0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
   82724:	e0f9      	b.n	8291a <gc_execute_line+0x3ea>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   82726:	2301      	movs	r3, #1
   82728:	9309      	str	r3, [sp, #36]	; 0x24
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
   8272a:	2207      	movs	r2, #7
   8272c:	4b19      	ldr	r3, [pc, #100]	; (82794 <gc_execute_line+0x264>)
   8272e:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82730:	2200      	movs	r2, #0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
   82732:	e0ec      	b.n	8290e <gc_execute_line+0x3de>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   82734:	2301      	movs	r3, #1
   82736:	9309      	str	r3, [sp, #36]	; 0x24
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
   82738:	b118      	cbz	r0, 82742 <gc_execute_line+0x212>
   8273a:	280a      	cmp	r0, #10
   8273c:	d006      	beq.n	8274c <gc_execute_line+0x21c>
   8273e:	f000 bf26 	b.w	8358e <gc_execute_line+0x105e>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
   82742:	2208      	movs	r2, #8
   82744:	4b13      	ldr	r3, [pc, #76]	; (82794 <gc_execute_line+0x264>)
   82746:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82748:	2200      	movs	r2, #0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
   8274a:	e0e6      	b.n	8291a <gc_execute_line+0x3ea>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
   8274c:	2209      	movs	r2, #9
   8274e:	4b11      	ldr	r3, [pc, #68]	; (82794 <gc_execute_line+0x264>)
   82750:	701a      	strb	r2, [r3, #0]
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82752:	2200      	movs	r2, #0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
   82754:	e0e1      	b.n	8291a <gc_execute_line+0x3ea>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
   82756:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82758:	2b00      	cmp	r3, #0
   8275a:	f040 871a 	bne.w	83592 <gc_execute_line+0x1062>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
   8275e:	2302      	movs	r3, #2
   82760:	9309      	str	r3, [sp, #36]	; 0x24
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
   82762:	2e02      	cmp	r6, #2
   82764:	d02e      	beq.n	827c4 <gc_execute_line+0x294>
   82766:	d803      	bhi.n	82770 <gc_execute_line+0x240>
   82768:	b156      	cbz	r6, 82780 <gc_execute_line+0x250>
   8276a:	2e01      	cmp	r6, #1
   8276c:	d00d      	beq.n	8278a <gc_execute_line+0x25a>
   8276e:	e0cb      	b.n	82908 <gc_execute_line+0x3d8>
   82770:	2e26      	cmp	r6, #38	; 0x26
   82772:	d031      	beq.n	827d8 <gc_execute_line+0x2a8>
   82774:	2e50      	cmp	r6, #80	; 0x50
   82776:	d068      	beq.n	8284a <gc_execute_line+0x31a>
   82778:	2e03      	cmp	r6, #3
   8277a:	f040 80c5 	bne.w	82908 <gc_execute_line+0x3d8>
   8277e:	e026      	b.n	827ce <gc_execute_line+0x29e>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
   82780:	2200      	movs	r2, #0
   82782:	4b04      	ldr	r3, [pc, #16]	; (82794 <gc_execute_line+0x264>)
   82784:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82786:	2201      	movs	r2, #1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
   82788:	e0c1      	b.n	8290e <gc_execute_line+0x3de>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
   8278a:	2201      	movs	r2, #1
   8278c:	4b01      	ldr	r3, [pc, #4]	; (82794 <gc_execute_line+0x264>)
   8278e:	705a      	strb	r2, [r3, #1]
   82790:	e0bd      	b.n	8290e <gc_execute_line+0x3de>
   82792:	bf00      	nop
   82794:	2000120c 	.word	0x2000120c
   82798:	0008d1c9 	.word	0x0008d1c9
   8279c:	200011c8 	.word	0x200011c8
   827a0:	000844d1 	.word	0x000844d1
   827a4:	0008a265 	.word	0x0008a265
   827a8:	0008c68d 	.word	0x0008c68d
   827ac:	0008c521 	.word	0x0008c521
   827b0:	42c80000 	.word	0x42c80000
   827b4:	0008c735 	.word	0x0008c735
   827b8:	0008a131 	.word	0x0008a131
   827bc:	0008be0d 	.word	0x0008be0d
   827c0:	0008c439 	.word	0x0008c439
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
   827c4:	2202      	movs	r2, #2
   827c6:	4b9d      	ldr	r3, [pc, #628]	; (82a3c <gc_execute_line+0x50c>)
   827c8:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   827ca:	2201      	movs	r2, #1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
   827cc:	e09f      	b.n	8290e <gc_execute_line+0x3de>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
   827ce:	2203      	movs	r2, #3
   827d0:	4b9a      	ldr	r3, [pc, #616]	; (82a3c <gc_execute_line+0x50c>)
   827d2:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   827d4:	2201      	movs	r2, #1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
   827d6:	e09a      	b.n	8290e <gc_execute_line+0x3de>
              case 38: 
                switch(mantissa) {
   827d8:	3814      	subs	r0, #20
   827da:	281e      	cmp	r0, #30
   827dc:	f200 86db 	bhi.w	83596 <gc_execute_line+0x1066>
   827e0:	e8df f010 	tbh	[pc, r0, lsl #1]
   827e4:	06d9001f 	.word	0x06d9001f
   827e8:	06d906d9 	.word	0x06d906d9
   827ec:	06d906d9 	.word	0x06d906d9
   827f0:	06d906d9 	.word	0x06d906d9
   827f4:	06d906d9 	.word	0x06d906d9
   827f8:	06d90024 	.word	0x06d90024
   827fc:	06d906d9 	.word	0x06d906d9
   82800:	06d906d9 	.word	0x06d906d9
   82804:	06d906d9 	.word	0x06d906d9
   82808:	06d906d9 	.word	0x06d906d9
   8280c:	06d90029 	.word	0x06d90029
   82810:	06d906d9 	.word	0x06d906d9
   82814:	06d906d9 	.word	0x06d906d9
   82818:	06d906d9 	.word	0x06d906d9
   8281c:	06d906d9 	.word	0x06d906d9
   82820:	002e      	.short	0x002e
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
   82822:	2204      	movs	r2, #4
   82824:	4b85      	ldr	r3, [pc, #532]	; (82a3c <gc_execute_line+0x50c>)
   82826:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82828:	2201      	movs	r2, #1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
   8282a:	e076      	b.n	8291a <gc_execute_line+0x3ea>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
   8282c:	2205      	movs	r2, #5
   8282e:	4b83      	ldr	r3, [pc, #524]	; (82a3c <gc_execute_line+0x50c>)
   82830:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82832:	2201      	movs	r2, #1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
   82834:	e071      	b.n	8291a <gc_execute_line+0x3ea>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
   82836:	2206      	movs	r2, #6
   82838:	4b80      	ldr	r3, [pc, #512]	; (82a3c <gc_execute_line+0x50c>)
   8283a:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   8283c:	2201      	movs	r2, #1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
   8283e:	e06c      	b.n	8291a <gc_execute_line+0x3ea>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
   82840:	2207      	movs	r2, #7
   82842:	4b7e      	ldr	r3, [pc, #504]	; (82a3c <gc_execute_line+0x50c>)
   82844:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82846:	2201      	movs	r2, #1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
   82848:	e067      	b.n	8291a <gc_execute_line+0x3ea>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
   8284a:	2208      	movs	r2, #8
   8284c:	4b7b      	ldr	r3, [pc, #492]	; (82a3c <gc_execute_line+0x50c>)
   8284e:	705a      	strb	r2, [r3, #1]
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82850:	2201      	movs	r2, #1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
   82852:	e05c      	b.n	8290e <gc_execute_line+0x3de>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
   82854:	2e12      	cmp	r6, #18
   82856:	d008      	beq.n	8286a <gc_execute_line+0x33a>
   82858:	2e13      	cmp	r6, #19
   8285a:	d00b      	beq.n	82874 <gc_execute_line+0x344>
   8285c:	2e11      	cmp	r6, #17
   8285e:	d155      	bne.n	8290c <gc_execute_line+0x3dc>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
   82860:	2200      	movs	r2, #0
   82862:	4b76      	ldr	r3, [pc, #472]	; (82a3c <gc_execute_line+0x50c>)
   82864:	715a      	strb	r2, [r3, #5]
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
   82866:	2202      	movs	r2, #2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
   82868:	e051      	b.n	8290e <gc_execute_line+0x3de>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
   8286a:	2201      	movs	r2, #1
   8286c:	4b73      	ldr	r3, [pc, #460]	; (82a3c <gc_execute_line+0x50c>)
   8286e:	715a      	strb	r2, [r3, #5]
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
   82870:	2202      	movs	r2, #2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
   82872:	e04c      	b.n	8290e <gc_execute_line+0x3de>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
   82874:	2202      	movs	r2, #2
   82876:	4b71      	ldr	r3, [pc, #452]	; (82a3c <gc_execute_line+0x50c>)
   82878:	715a      	strb	r2, [r3, #5]
   8287a:	e048      	b.n	8290e <gc_execute_line+0x3de>
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
   8287c:	b938      	cbnz	r0, 8288e <gc_execute_line+0x35e>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
   8287e:	2e5a      	cmp	r6, #90	; 0x5a
   82880:	bf0c      	ite	eq
   82882:	2200      	moveq	r2, #0
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
   82884:	2201      	movne	r2, #1
   82886:	4b6d      	ldr	r3, [pc, #436]	; (82a3c <gc_execute_line+0x50c>)
   82888:	711a      	strb	r2, [r3, #4]
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
   8288a:	2203      	movs	r2, #3
   8288c:	e045      	b.n	8291a <gc_execute_line+0x3ea>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
   8288e:	280a      	cmp	r0, #10
   82890:	f040 8683 	bne.w	8359a <gc_execute_line+0x106a>
   82894:	2e5a      	cmp	r6, #90	; 0x5a
   82896:	f000 8682 	beq.w	8359e <gc_execute_line+0x106e>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
   8289a:	2204      	movs	r2, #4
   8289c:	e03d      	b.n	8291a <gc_execute_line+0x3ea>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
   8289e:	2e5d      	cmp	r6, #93	; 0x5d
   828a0:	bf0c      	ite	eq
   828a2:	2201      	moveq	r2, #1
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
   828a4:	2200      	movne	r2, #0
   828a6:	4b65      	ldr	r3, [pc, #404]	; (82a3c <gc_execute_line+0x50c>)
   828a8:	709a      	strb	r2, [r3, #2]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
   828aa:	2205      	movs	r2, #5
   828ac:	e02f      	b.n	8290e <gc_execute_line+0x3de>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
   828ae:	2e14      	cmp	r6, #20
   828b0:	bf0c      	ite	eq
   828b2:	2201      	moveq	r2, #1
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
   828b4:	2200      	movne	r2, #0
   828b6:	4b61      	ldr	r3, [pc, #388]	; (82a3c <gc_execute_line+0x50c>)
   828b8:	70da      	strb	r2, [r3, #3]
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
   828ba:	2206      	movs	r2, #6
   828bc:	e027      	b.n	8290e <gc_execute_line+0x3de>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
   828be:	9b09      	ldr	r3, [sp, #36]	; 0x24
   828c0:	2b00      	cmp	r3, #0
   828c2:	f040 866e 	bne.w	835a2 <gc_execute_line+0x1072>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
   828c6:	2e31      	cmp	r6, #49	; 0x31
   828c8:	d106      	bne.n	828d8 <gc_execute_line+0x3a8>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
   828ca:	2200      	movs	r2, #0
   828cc:	4b5b      	ldr	r3, [pc, #364]	; (82a3c <gc_execute_line+0x50c>)
   828ce:	719a      	strb	r2, [r3, #6]
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
   828d0:	2208      	movs	r2, #8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
   828d2:	2303      	movs	r3, #3
   828d4:	9309      	str	r3, [sp, #36]	; 0x24
   828d6:	e020      	b.n	8291a <gc_execute_line+0x3ea>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
   828d8:	280a      	cmp	r0, #10
   828da:	f040 8664 	bne.w	835a6 <gc_execute_line+0x1076>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
   828de:	2201      	movs	r2, #1
   828e0:	4b56      	ldr	r3, [pc, #344]	; (82a3c <gc_execute_line+0x50c>)
   828e2:	719a      	strb	r2, [r3, #6]
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
   828e4:	2208      	movs	r2, #8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
   828e6:	2303      	movs	r3, #3
   828e8:	9309      	str	r3, [sp, #36]	; 0x24
   828ea:	e016      	b.n	8291a <gc_execute_line+0x3ea>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
   828ec:	3e36      	subs	r6, #54	; 0x36
   828ee:	4b53      	ldr	r3, [pc, #332]	; (82a3c <gc_execute_line+0x50c>)
   828f0:	71de      	strb	r6, [r3, #7]
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
   828f2:	2209      	movs	r2, #9
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
   828f4:	e00b      	b.n	8290e <gc_execute_line+0x3de>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
   828f6:	2800      	cmp	r0, #0
   828f8:	f040 8657 	bne.w	835aa <gc_execute_line+0x107a>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
   828fc:	220a      	movs	r2, #10
   828fe:	e00c      	b.n	8291a <gc_execute_line+0x3ea>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
   82900:	2207      	movs	r2, #7
   82902:	e004      	b.n	8290e <gc_execute_line+0x3de>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82904:	2200      	movs	r2, #0
   82906:	e002      	b.n	8290e <gc_execute_line+0x3de>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
   82908:	2201      	movs	r2, #1
   8290a:	e000      	b.n	8290e <gc_execute_line+0x3de>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
   8290c:	2202      	movs	r2, #2
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
   8290e:	b120      	cbz	r0, 8291a <gc_execute_line+0x3ea>
   82910:	f000 be4d 	b.w	835ae <gc_execute_line+0x107e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
   82914:	2200      	movs	r2, #0
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
   82916:	2301      	movs	r3, #1
   82918:	9309      	str	r3, [sp, #36]	; 0x24
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
   8291a:	fa45 f302 	asr.w	r3, r5, r2
   8291e:	f013 0f01 	tst.w	r3, #1
   82922:	f040 8646 	bne.w	835b2 <gc_execute_line+0x1082>
        command_words |= bit(word_bit);
   82926:	2301      	movs	r3, #1
   82928:	4093      	lsls	r3, r2
   8292a:	431d      	orrs	r5, r3
   8292c:	b2ad      	uxth	r5, r5
        break;
   8292e:	e0ee      	b.n	82b0e <gc_execute_line+0x5de>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
   82930:	2800      	cmp	r0, #0
   82932:	f040 8640 	bne.w	835b6 <gc_execute_line+0x1086>
        switch(int_value) {
   82936:	2e1e      	cmp	r6, #30
   82938:	f200 863f 	bhi.w	835ba <gc_execute_line+0x108a>
   8293c:	e8df f016 	tbh	[pc, r6, lsl #1]
   82940:	001f001f 	.word	0x001f001f
   82944:	002e001f 	.word	0x002e001f
   82948:	002e002e 	.word	0x002e002e
   8294c:	063d063d 	.word	0x063d063d
   82950:	00430043 	.word	0x00430043
   82954:	063d063d 	.word	0x063d063d
   82958:	063d063d 	.word	0x063d063d
   8295c:	063d063d 	.word	0x063d063d
   82960:	063d063d 	.word	0x063d063d
   82964:	063d063d 	.word	0x063d063d
   82968:	063d063d 	.word	0x063d063d
   8296c:	063d063d 	.word	0x063d063d
   82970:	063d063d 	.word	0x063d063d
   82974:	063d063d 	.word	0x063d063d
   82978:	063d063d 	.word	0x063d063d
   8297c:	001f      	.short	0x001f
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
   8297e:	2e02      	cmp	r6, #2
   82980:	d007      	beq.n	82992 <gc_execute_line+0x462>
   82982:	2e1e      	cmp	r6, #30
   82984:	d005      	beq.n	82992 <gc_execute_line+0x462>
   82986:	bb6e      	cbnz	r6, 829e4 <gc_execute_line+0x4b4>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
   82988:	2201      	movs	r2, #1
   8298a:	4b2c      	ldr	r3, [pc, #176]	; (82a3c <gc_execute_line+0x50c>)
   8298c:	721a      	strb	r2, [r3, #8]
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
   8298e:	220b      	movs	r2, #11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
   82990:	e02d      	b.n	829ee <gc_execute_line+0x4be>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
   82992:	2202      	movs	r2, #2
   82994:	4b29      	ldr	r3, [pc, #164]	; (82a3c <gc_execute_line+0x50c>)
   82996:	721a      	strb	r2, [r3, #8]
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
   82998:	220b      	movs	r2, #11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
   8299a:	e028      	b.n	829ee <gc_execute_line+0x4be>
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
   8299c:	2e04      	cmp	r6, #4
   8299e:	d008      	beq.n	829b2 <gc_execute_line+0x482>
   829a0:	2e05      	cmp	r6, #5
   829a2:	d00b      	beq.n	829bc <gc_execute_line+0x48c>
   829a4:	2e03      	cmp	r6, #3
   829a6:	d11f      	bne.n	829e8 <gc_execute_line+0x4b8>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
   829a8:	2201      	movs	r2, #1
   829aa:	4b24      	ldr	r3, [pc, #144]	; (82a3c <gc_execute_line+0x50c>)
   829ac:	729a      	strb	r2, [r3, #10]
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
   829ae:	220c      	movs	r2, #12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
   829b0:	e01d      	b.n	829ee <gc_execute_line+0x4be>
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
   829b2:	2202      	movs	r2, #2
   829b4:	4b21      	ldr	r3, [pc, #132]	; (82a3c <gc_execute_line+0x50c>)
   829b6:	729a      	strb	r2, [r3, #10]
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
   829b8:	220c      	movs	r2, #12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
   829ba:	e018      	b.n	829ee <gc_execute_line+0x4be>
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
   829bc:	2200      	movs	r2, #0
   829be:	4b1f      	ldr	r3, [pc, #124]	; (82a3c <gc_execute_line+0x50c>)
   829c0:	729a      	strb	r2, [r3, #10]
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
   829c2:	220c      	movs	r2, #12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
   829c4:	e013      	b.n	829ee <gc_execute_line+0x4be>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
   829c6:	2e08      	cmp	r6, #8
   829c8:	d002      	beq.n	829d0 <gc_execute_line+0x4a0>
   829ca:	2e09      	cmp	r6, #9
   829cc:	d005      	beq.n	829da <gc_execute_line+0x4aa>
   829ce:	e00d      	b.n	829ec <gc_execute_line+0x4bc>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
   829d0:	2202      	movs	r2, #2
   829d2:	4b1a      	ldr	r3, [pc, #104]	; (82a3c <gc_execute_line+0x50c>)
   829d4:	725a      	strb	r2, [r3, #9]
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
   829d6:	220d      	movs	r2, #13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
   829d8:	e009      	b.n	829ee <gc_execute_line+0x4be>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
   829da:	2200      	movs	r2, #0
   829dc:	4b17      	ldr	r3, [pc, #92]	; (82a3c <gc_execute_line+0x50c>)
   829de:	725a      	strb	r2, [r3, #9]
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
   829e0:	220d      	movs	r2, #13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
   829e2:	e004      	b.n	829ee <gc_execute_line+0x4be>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
   829e4:	220b      	movs	r2, #11
   829e6:	e002      	b.n	829ee <gc_execute_line+0x4be>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
   829e8:	220c      	movs	r2, #12
   829ea:	e000      	b.n	829ee <gc_execute_line+0x4be>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
   829ec:	220d      	movs	r2, #13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
   829ee:	fa45 f302 	asr.w	r3, r5, r2
   829f2:	f013 0f01 	tst.w	r3, #1
   829f6:	f040 85e2 	bne.w	835be <gc_execute_line+0x108e>
        command_words |= bit(word_bit);
   829fa:	2301      	movs	r3, #1
   829fc:	4093      	lsls	r3, r2
   829fe:	431d      	orrs	r5, r3
   82a00:	b2ad      	uxth	r5, r5
        break;
   82a02:	e084      	b.n	82b0e <gc_execute_line+0x5de>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
   82a04:	3c46      	subs	r4, #70	; 0x46
   82a06:	2c14      	cmp	r4, #20
   82a08:	f200 85db 	bhi.w	835c2 <gc_execute_line+0x1092>
   82a0c:	e8df f014 	tbh	[pc, r4, lsl #1]
   82a10:	05d90018 	.word	0x05d90018
   82a14:	001c05d9 	.word	0x001c05d9
   82a18:	002c0024 	.word	0x002c0024
   82a1c:	05d90034 	.word	0x05d90034
   82a20:	05d90038 	.word	0x05d90038
   82a24:	05d9003f 	.word	0x05d9003f
   82a28:	00470043 	.word	0x00470043
   82a2c:	05d90063 	.word	0x05d90063
   82a30:	05d905d9 	.word	0x05d905d9
   82a34:	0053004b 	.word	0x0053004b
   82a38:	005b      	.short	0x005b
   82a3a:	bf00      	nop
   82a3c:	2000120c 	.word	0x2000120c
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
   82a40:	4b97      	ldr	r3, [pc, #604]	; (82ca0 <gc_execute_line+0x770>)
   82a42:	60df      	str	r7, [r3, #12]
   82a44:	2300      	movs	r3, #0
   82a46:	e047      	b.n	82ad8 <gc_execute_line+0x5a8>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
   82a48:	4b95      	ldr	r3, [pc, #596]	; (82ca0 <gc_execute_line+0x770>)
   82a4a:	611f      	str	r7, [r3, #16]
   82a4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   82a4e:	f043 0301 	orr.w	r3, r3, #1
   82a52:	930a      	str	r3, [sp, #40]	; 0x28
   82a54:	2301      	movs	r3, #1
   82a56:	e03f      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
   82a58:	4b91      	ldr	r3, [pc, #580]	; (82ca0 <gc_execute_line+0x770>)
   82a5a:	615f      	str	r7, [r3, #20]
   82a5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   82a5e:	f043 0302 	orr.w	r3, r3, #2
   82a62:	930a      	str	r3, [sp, #40]	; 0x28
   82a64:	2302      	movs	r3, #2
   82a66:	e037      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
   82a68:	4b8d      	ldr	r3, [pc, #564]	; (82ca0 <gc_execute_line+0x770>)
   82a6a:	619f      	str	r7, [r3, #24]
   82a6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   82a6e:	f043 0304 	orr.w	r3, r3, #4
   82a72:	930a      	str	r3, [sp, #40]	; 0x28
   82a74:	2303      	movs	r3, #3
   82a76:	e02f      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
   82a78:	4b89      	ldr	r3, [pc, #548]	; (82ca0 <gc_execute_line+0x770>)
   82a7a:	771e      	strb	r6, [r3, #28]
   82a7c:	2304      	movs	r3, #4
   82a7e:	e02b      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
   82a80:	4638      	mov	r0, r7
   82a82:	4b88      	ldr	r3, [pc, #544]	; (82ca4 <gc_execute_line+0x774>)
   82a84:	4798      	blx	r3
   82a86:	4b86      	ldr	r3, [pc, #536]	; (82ca0 <gc_execute_line+0x770>)
   82a88:	6218      	str	r0, [r3, #32]
   82a8a:	2305      	movs	r3, #5
   82a8c:	e024      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
   82a8e:	4b84      	ldr	r3, [pc, #528]	; (82ca0 <gc_execute_line+0x770>)
   82a90:	625f      	str	r7, [r3, #36]	; 0x24
   82a92:	2306      	movs	r3, #6
   82a94:	e020      	b.n	82ad8 <gc_execute_line+0x5a8>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
   82a96:	4b82      	ldr	r3, [pc, #520]	; (82ca0 <gc_execute_line+0x770>)
   82a98:	629f      	str	r7, [r3, #40]	; 0x28
   82a9a:	2307      	movs	r3, #7
   82a9c:	e01c      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
   82a9e:	4b80      	ldr	r3, [pc, #512]	; (82ca0 <gc_execute_line+0x770>)
   82aa0:	62df      	str	r7, [r3, #44]	; 0x2c
   82aa2:	2308      	movs	r3, #8
   82aa4:	e018      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
   82aa6:	4b7e      	ldr	r3, [pc, #504]	; (82ca0 <gc_execute_line+0x770>)
   82aa8:	635f      	str	r7, [r3, #52]	; 0x34
   82aaa:	9b06      	ldr	r3, [sp, #24]
   82aac:	f043 0301 	orr.w	r3, r3, #1
   82ab0:	9306      	str	r3, [sp, #24]
   82ab2:	230a      	movs	r3, #10
   82ab4:	e010      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
   82ab6:	4b7a      	ldr	r3, [pc, #488]	; (82ca0 <gc_execute_line+0x770>)
   82ab8:	639f      	str	r7, [r3, #56]	; 0x38
   82aba:	9b06      	ldr	r3, [sp, #24]
   82abc:	f043 0302 	orr.w	r3, r3, #2
   82ac0:	9306      	str	r3, [sp, #24]
   82ac2:	230b      	movs	r3, #11
   82ac4:	e008      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
   82ac6:	4b76      	ldr	r3, [pc, #472]	; (82ca0 <gc_execute_line+0x770>)
   82ac8:	63df      	str	r7, [r3, #60]	; 0x3c
   82aca:	9b06      	ldr	r3, [sp, #24]
   82acc:	f043 0304 	orr.w	r3, r3, #4
   82ad0:	9306      	str	r3, [sp, #24]
   82ad2:	230c      	movs	r3, #12
   82ad4:	e000      	b.n	82ad8 <gc_execute_line+0x5a8>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
   82ad6:	2309      	movs	r3, #9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
   82ad8:	461c      	mov	r4, r3
   82ada:	fa4b f203 	asr.w	r2, fp, r3
   82ade:	f012 0f01 	tst.w	r2, #1
   82ae2:	f040 8570 	bne.w	835c6 <gc_execute_line+0x1096>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
   82ae6:	f240 3261 	movw	r2, #865	; 0x361
   82aea:	fa42 f303 	asr.w	r3, r2, r3
   82aee:	f013 0f01 	tst.w	r3, #1
   82af2:	d006      	beq.n	82b02 <gc_execute_line+0x5d2>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
   82af4:	4638      	mov	r0, r7
   82af6:	2100      	movs	r1, #0
   82af8:	4b6b      	ldr	r3, [pc, #428]	; (82ca8 <gc_execute_line+0x778>)
   82afa:	4798      	blx	r3
   82afc:	2800      	cmp	r0, #0
   82afe:	f040 8564 	bne.w	835ca <gc_execute_line+0x109a>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
   82b02:	2301      	movs	r3, #1
   82b04:	40a3      	lsls	r3, r4
   82b06:	ea43 0b0b 	orr.w	fp, r3, fp
   82b0a:	fa1f fb8b 	uxth.w	fp, fp
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
   82b0e:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
   82b12:	f81a 4003 	ldrb.w	r4, [sl, r3]
   82b16:	2c00      	cmp	r4, #0
   82b18:	f47f ad27 	bne.w	8256a <gc_execute_line+0x3a>
   82b1c:	465c      	mov	r4, fp
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
   82b1e:	9b06      	ldr	r3, [sp, #24]
   82b20:	b123      	cbz	r3, 82b2c <gc_execute_line+0x5fc>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
   82b22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82b24:	2b00      	cmp	r3, #0
   82b26:	bf08      	it	eq
   82b28:	2302      	moveq	r3, #2
   82b2a:	9309      	str	r3, [sp, #36]	; 0x24
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
   82b2c:	f004 0320 	and.w	r3, r4, #32
   82b30:	b29b      	uxth	r3, r3
   82b32:	b12b      	cbz	r3, 82b40 <gc_execute_line+0x610>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
   82b34:	4b5a      	ldr	r3, [pc, #360]	; (82ca0 <gc_execute_line+0x770>)
   82b36:	6a1a      	ldr	r2, [r3, #32]
   82b38:	4b5c      	ldr	r3, [pc, #368]	; (82cac <gc_execute_line+0x77c>)
   82b3a:	429a      	cmp	r2, r3
   82b3c:	f300 8547 	bgt.w	835ce <gc_execute_line+0x109e>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
   82b40:	4b57      	ldr	r3, [pc, #348]	; (82ca0 <gc_execute_line+0x770>)
   82b42:	789b      	ldrb	r3, [r3, #2]
   82b44:	2b01      	cmp	r3, #1
   82b46:	d107      	bne.n	82b58 <gc_execute_line+0x628>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
   82b48:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82b4a:	2b02      	cmp	r3, #2
   82b4c:	d11f      	bne.n	82b8e <gc_execute_line+0x65e>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
   82b4e:	f014 0f01 	tst.w	r4, #1
   82b52:	f000 853e 	beq.w	835d2 <gc_execute_line+0x10a2>
   82b56:	e01a      	b.n	82b8e <gc_execute_line+0x65e>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
   82b58:	4b55      	ldr	r3, [pc, #340]	; (82cb0 <gc_execute_line+0x780>)
   82b5a:	785b      	ldrb	r3, [r3, #1]
   82b5c:	b9bb      	cbnz	r3, 82b8e <gc_execute_line+0x65e>
      if (bit_istrue(value_words,bit(WORD_F))) {
   82b5e:	f014 0f01 	tst.w	r4, #1
   82b62:	d010      	beq.n	82b86 <gc_execute_line+0x656>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
   82b64:	4b4e      	ldr	r3, [pc, #312]	; (82ca0 <gc_execute_line+0x770>)
   82b66:	78db      	ldrb	r3, [r3, #3]
   82b68:	2b01      	cmp	r3, #1
   82b6a:	d110      	bne.n	82b8e <gc_execute_line+0x65e>
   82b6c:	4e4c      	ldr	r6, [pc, #304]	; (82ca0 <gc_execute_line+0x770>)
   82b6e:	68f0      	ldr	r0, [r6, #12]
   82b70:	4b50      	ldr	r3, [pc, #320]	; (82cb4 <gc_execute_line+0x784>)
   82b72:	4798      	blx	r3
   82b74:	a348      	add	r3, pc, #288	; (adr r3, 82c98 <gc_execute_line+0x768>)
   82b76:	e9d3 2300 	ldrd	r2, r3, [r3]
   82b7a:	4f4f      	ldr	r7, [pc, #316]	; (82cb8 <gc_execute_line+0x788>)
   82b7c:	47b8      	blx	r7
   82b7e:	4b4f      	ldr	r3, [pc, #316]	; (82cbc <gc_execute_line+0x78c>)
   82b80:	4798      	blx	r3
   82b82:	60f0      	str	r0, [r6, #12]
   82b84:	e003      	b.n	82b8e <gc_execute_line+0x65e>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
   82b86:	4b4a      	ldr	r3, [pc, #296]	; (82cb0 <gc_execute_line+0x780>)
   82b88:	691a      	ldr	r2, [r3, #16]
   82b8a:	4b45      	ldr	r3, [pc, #276]	; (82ca0 <gc_execute_line+0x770>)
   82b8c:	60da      	str	r2, [r3, #12]
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
   82b8e:	f404 7380 	and.w	r3, r4, #256	; 0x100
   82b92:	b29b      	uxth	r3, r3
   82b94:	b91b      	cbnz	r3, 82b9e <gc_execute_line+0x66e>
   82b96:	4b46      	ldr	r3, [pc, #280]	; (82cb0 <gc_execute_line+0x780>)
   82b98:	68da      	ldr	r2, [r3, #12]
   82b9a:	4b41      	ldr	r3, [pc, #260]	; (82ca0 <gc_execute_line+0x770>)
   82b9c:	62da      	str	r2, [r3, #44]	; 0x2c
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
   82b9e:	4b40      	ldr	r3, [pc, #256]	; (82ca0 <gc_execute_line+0x770>)
   82ba0:	781b      	ldrb	r3, [r3, #0]
   82ba2:	2b01      	cmp	r3, #1
   82ba4:	d109      	bne.n	82bba <gc_execute_line+0x68a>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
   82ba6:	f004 0340 	and.w	r3, r4, #64	; 0x40
   82baa:	b29b      	uxth	r3, r3
   82bac:	2b00      	cmp	r3, #0
   82bae:	f000 8512 	beq.w	835d6 <gc_execute_line+0x10a6>
    bit_false(value_words,bit(WORD_P));
   82bb2:	f024 0440 	bic.w	r4, r4, #64	; 0x40
   82bb6:	fa1f fb84 	uxth.w	fp, r4
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
   82bba:	4b39      	ldr	r3, [pc, #228]	; (82ca0 <gc_execute_line+0x770>)
   82bbc:	795b      	ldrb	r3, [r3, #5]
   82bbe:	b193      	cbz	r3, 82be6 <gc_execute_line+0x6b6>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
   82bc0:	2b01      	cmp	r3, #1
   82bc2:	bf0c      	ite	eq
   82bc4:	2201      	moveq	r2, #1
   82bc6:	2200      	movne	r2, #0
   82bc8:	920c      	str	r2, [sp, #48]	; 0x30
   82bca:	bf0b      	itete	eq
   82bcc:	f04f 0a00 	moveq.w	sl, #0
   82bd0:	f04f 0a02 	movne.w	sl, #2
   82bd4:	f04f 0902 	moveq.w	r9, #2
   82bd8:	f04f 0901 	movne.w	r9, #1
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
   82bdc:	4b30      	ldr	r3, [pc, #192]	; (82ca0 <gc_execute_line+0x770>)
   82bde:	78db      	ldrb	r3, [r3, #3]
   82be0:	2b01      	cmp	r3, #1
   82be2:	d12b      	bne.n	82c3c <gc_execute_line+0x70c>
   82be4:	e009      	b.n	82bfa <gc_execute_line+0x6ca>
   82be6:	4b2e      	ldr	r3, [pc, #184]	; (82ca0 <gc_execute_line+0x770>)
   82be8:	78db      	ldrb	r3, [r3, #3]
   82bea:	2b01      	cmp	r3, #1
   82bec:	d120      	bne.n	82c30 <gc_execute_line+0x700>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
   82bee:	2302      	movs	r3, #2
   82bf0:	930c      	str	r3, [sp, #48]	; 0x30
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
   82bf2:	f04f 0a01 	mov.w	sl, #1
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
   82bf6:	f04f 0900 	mov.w	r9, #0
   82bfa:	4e31      	ldr	r6, [pc, #196]	; (82cc0 <gc_execute_line+0x790>)
   82bfc:	2400      	movs	r4, #0
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
        gc_block.values.xyz[idx] *= MM_PER_INCH;
   82bfe:	4f2d      	ldr	r7, [pc, #180]	; (82cb4 <gc_execute_line+0x784>)
   82c00:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 82cb8 <gc_execute_line+0x788>
   82c04:	950d      	str	r5, [sp, #52]	; 0x34
   82c06:	9d06      	ldr	r5, [sp, #24]
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
   82c08:	fa45 f304 	asr.w	r3, r5, r4
   82c0c:	f013 0f01 	tst.w	r3, #1
   82c10:	d008      	beq.n	82c24 <gc_execute_line+0x6f4>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
   82c12:	6830      	ldr	r0, [r6, #0]
   82c14:	47b8      	blx	r7
   82c16:	a320      	add	r3, pc, #128	; (adr r3, 82c98 <gc_execute_line+0x768>)
   82c18:	e9d3 2300 	ldrd	r2, r3, [r3]
   82c1c:	47c0      	blx	r8
   82c1e:	4b27      	ldr	r3, [pc, #156]	; (82cbc <gc_execute_line+0x78c>)
   82c20:	4798      	blx	r3
   82c22:	6030      	str	r0, [r6, #0]
   82c24:	3401      	adds	r4, #1
   82c26:	3604      	adds	r6, #4
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
   82c28:	2c03      	cmp	r4, #3
   82c2a:	d1ed      	bne.n	82c08 <gc_execute_line+0x6d8>
   82c2c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   82c2e:	e005      	b.n	82c3c <gc_execute_line+0x70c>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
   82c30:	2302      	movs	r3, #2
   82c32:	930c      	str	r3, [sp, #48]	; 0x30
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
   82c34:	f04f 0a01 	mov.w	sl, #1
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
   82c38:	f04f 0900 	mov.w	r9, #0
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
   82c3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82c3e:	2b03      	cmp	r3, #3
   82c40:	d107      	bne.n	82c52 <gc_execute_line+0x722>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
   82c42:	4b17      	ldr	r3, [pc, #92]	; (82ca0 <gc_execute_line+0x770>)
   82c44:	799b      	ldrb	r3, [r3, #6]
   82c46:	2b01      	cmp	r3, #1
   82c48:	d103      	bne.n	82c52 <gc_execute_line+0x722>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
   82c4a:	9b06      	ldr	r3, [sp, #24]
   82c4c:	2b04      	cmp	r3, #4
   82c4e:	f040 84c4 	bne.w	835da <gc_execute_line+0x10aa>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
   82c52:	4b1c      	ldr	r3, [pc, #112]	; (82cc4 <gc_execute_line+0x794>)
   82c54:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   82c58:	ab18      	add	r3, sp, #96	; 0x60
   82c5a:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
   82c5e:	f405 7300 	and.w	r3, r5, #512	; 0x200
   82c62:	b29b      	uxth	r3, r3
   82c64:	b173      	cbz	r3, 82c84 <gc_execute_line+0x754>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
   82c66:	4b0e      	ldr	r3, [pc, #56]	; (82ca0 <gc_execute_line+0x770>)
   82c68:	79d8      	ldrb	r0, [r3, #7]
   82c6a:	2806      	cmp	r0, #6
   82c6c:	f200 84b7 	bhi.w	835de <gc_execute_line+0x10ae>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
   82c70:	4b0f      	ldr	r3, [pc, #60]	; (82cb0 <gc_execute_line+0x780>)
   82c72:	799b      	ldrb	r3, [r3, #6]
   82c74:	4283      	cmp	r3, r0
   82c76:	d005      	beq.n	82c84 <gc_execute_line+0x754>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
   82c78:	a915      	add	r1, sp, #84	; 0x54
   82c7a:	4b13      	ldr	r3, [pc, #76]	; (82cc8 <gc_execute_line+0x798>)
   82c7c:	4798      	blx	r3
   82c7e:	2800      	cmp	r0, #0
   82c80:	f000 84af 	beq.w	835e2 <gc_execute_line+0x10b2>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
   82c84:	4b06      	ldr	r3, [pc, #24]	; (82ca0 <gc_execute_line+0x770>)
   82c86:	781c      	ldrb	r4, [r3, #0]
   82c88:	2c02      	cmp	r4, #2
   82c8a:	d01f      	beq.n	82ccc <gc_execute_line+0x79c>
   82c8c:	2c08      	cmp	r4, #8
   82c8e:	d07f      	beq.n	82d90 <gc_execute_line+0x860>
   82c90:	e0ac      	b.n	82dec <gc_execute_line+0x8bc>
   82c92:	bf00      	nop
   82c94:	f3af 8000 	nop.w
   82c98:	66666666 	.word	0x66666666
   82c9c:	40396666 	.word	0x40396666
   82ca0:	2000120c 	.word	0x2000120c
   82ca4:	0008cac1 	.word	0x0008cac1
   82ca8:	0008ca71 	.word	0x0008ca71
   82cac:	0098967f 	.word	0x0098967f
   82cb0:	200011c8 	.word	0x200011c8
   82cb4:	0008be0d 	.word	0x0008be0d
   82cb8:	0008beb5 	.word	0x0008beb5
   82cbc:	0008c479 	.word	0x0008c479
   82cc0:	20001240 	.word	0x20001240
   82cc4:	200011f0 	.word	0x200011f0
   82cc8:	00088021 	.word	0x00088021
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
   82ccc:	9b06      	ldr	r3, [sp, #24]
   82cce:	2b00      	cmp	r3, #0
   82cd0:	f000 8489 	beq.w	835e6 <gc_execute_line+0x10b6>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
   82cd4:	f01b 0f50 	tst.w	fp, #80	; 0x50
   82cd8:	f000 8487 	beq.w	835ea <gc_execute_line+0x10ba>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
   82cdc:	4b91      	ldr	r3, [pc, #580]	; (82f24 <gc_execute_line+0x9f4>)
   82cde:	6a58      	ldr	r0, [r3, #36]	; 0x24
   82ce0:	4b91      	ldr	r3, [pc, #580]	; (82f28 <gc_execute_line+0x9f8>)
   82ce2:	4798      	blx	r3
   82ce4:	4b91      	ldr	r3, [pc, #580]	; (82f2c <gc_execute_line+0x9fc>)
   82ce6:	4798      	blx	r3
   82ce8:	4b91      	ldr	r3, [pc, #580]	; (82f30 <gc_execute_line+0xa00>)
   82cea:	4798      	blx	r3
   82cec:	b2c0      	uxtb	r0, r0
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
   82cee:	2806      	cmp	r0, #6
   82cf0:	f200 847d 	bhi.w	835ee <gc_execute_line+0x10be>
      if (gc_block.values.l != 20) {
   82cf4:	4b8b      	ldr	r3, [pc, #556]	; (82f24 <gc_execute_line+0x9f4>)
   82cf6:	7f1b      	ldrb	r3, [r3, #28]
   82cf8:	2b14      	cmp	r3, #20
   82cfa:	d008      	beq.n	82d0e <gc_execute_line+0x7de>
        if (gc_block.values.l == 2) {
   82cfc:	2b02      	cmp	r3, #2
   82cfe:	f040 8478 	bne.w	835f2 <gc_execute_line+0x10c2>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
   82d02:	f00b 0380 	and.w	r3, fp, #128	; 0x80
   82d06:	b29b      	uxth	r3, r3
   82d08:	2b00      	cmp	r3, #0
   82d0a:	f040 8474 	bne.w	835f6 <gc_execute_line+0x10c6>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
   82d0e:	f02b 0350 	bic.w	r3, fp, #80	; 0x50
   82d12:	fa1f fb83 	uxth.w	fp, r3
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
   82d16:	b118      	cbz	r0, 82d20 <gc_execute_line+0x7f0>
   82d18:	3801      	subs	r0, #1
   82d1a:	fa5f f880 	uxtb.w	r8, r0
   82d1e:	e002      	b.n	82d26 <gc_execute_line+0x7f6>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
   82d20:	4b80      	ldr	r3, [pc, #512]	; (82f24 <gc_execute_line+0x9f4>)
   82d22:	f893 8007 	ldrb.w	r8, [r3, #7]
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
   82d26:	4640      	mov	r0, r8
   82d28:	a912      	add	r1, sp, #72	; 0x48
   82d2a:	4b82      	ldr	r3, [pc, #520]	; (82f34 <gc_execute_line+0xa04>)
   82d2c:	4798      	blx	r3
   82d2e:	2800      	cmp	r0, #0
   82d30:	f000 8463 	beq.w	835fa <gc_execute_line+0x10ca>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
   82d34:	4e7b      	ldr	r6, [pc, #492]	; (82f24 <gc_execute_line+0x9f4>)
   82d36:	7f33      	ldrb	r3, [r6, #28]
   82d38:	930d      	str	r3, [sp, #52]	; 0x34
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
   82d3a:	4d7f      	ldr	r5, [pc, #508]	; (82f38 <gc_execute_line+0xa08>)
   82d3c:	6c2b      	ldr	r3, [r5, #64]	; 0x40
   82d3e:	930e      	str	r3, [sp, #56]	; 0x38
   82d40:	3634      	adds	r6, #52	; 0x34
   82d42:	351c      	adds	r5, #28
   82d44:	2400      	movs	r4, #0
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
   82d46:	4f7d      	ldr	r7, [pc, #500]	; (82f3c <gc_execute_line+0xa0c>)
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
   82d48:	9b06      	ldr	r3, [sp, #24]
   82d4a:	4123      	asrs	r3, r4
   82d4c:	f013 0f01 	tst.w	r3, #1
   82d50:	d017      	beq.n	82d82 <gc_execute_line+0x852>
          if (gc_block.values.l == 20) {
   82d52:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   82d54:	2b14      	cmp	r3, #20
   82d56:	d110      	bne.n	82d7a <gc_execute_line+0x84a>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
   82d58:	6828      	ldr	r0, [r5, #0]
   82d5a:	69a9      	ldr	r1, [r5, #24]
   82d5c:	47b8      	blx	r7
   82d5e:	6831      	ldr	r1, [r6, #0]
   82d60:	47b8      	blx	r7
   82d62:	ab12      	add	r3, sp, #72	; 0x48
   82d64:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
   82d68:	b2e3      	uxtb	r3, r4
   82d6a:	2b02      	cmp	r3, #2
   82d6c:	d109      	bne.n	82d82 <gc_execute_line+0x852>
   82d6e:	990e      	ldr	r1, [sp, #56]	; 0x38
   82d70:	47b8      	blx	r7
   82d72:	ab12      	add	r3, sp, #72	; 0x48
   82d74:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
   82d78:	e003      	b.n	82d82 <gc_execute_line+0x852>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
   82d7a:	6832      	ldr	r2, [r6, #0]
   82d7c:	ab12      	add	r3, sp, #72	; 0x48
   82d7e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   82d82:	3401      	adds	r4, #1
   82d84:	3604      	adds	r6, #4
   82d86:	3504      	adds	r5, #4
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
   82d88:	2c03      	cmp	r4, #3
   82d8a:	d1dd      	bne.n	82d48 <gc_execute_line+0x818>
   82d8c:	f000 bcc2 	b.w	83714 <gc_execute_line+0x11e4>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   82d90:	9b06      	ldr	r3, [sp, #24]
   82d92:	2b00      	cmp	r3, #0
   82d94:	f000 8433 	beq.w	835fe <gc_execute_line+0x10ce>
   82d98:	4e69      	ldr	r6, [pc, #420]	; (82f40 <gc_execute_line+0xa10>)
   82d9a:	4d6a      	ldr	r5, [pc, #424]	; (82f44 <gc_execute_line+0xa14>)
   82d9c:	2400      	movs	r4, #0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
   82d9e:	4f67      	ldr	r7, [pc, #412]	; (82f3c <gc_execute_line+0xa0c>)
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
   82da0:	9b06      	ldr	r3, [sp, #24]
   82da2:	4123      	asrs	r3, r4
   82da4:	f013 0f01 	tst.w	r3, #1
   82da8:	d015      	beq.n	82dd6 <gc_execute_line+0x8a6>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
   82daa:	6830      	ldr	r0, [r6, #0]
   82dac:	ab15      	add	r3, sp, #84	; 0x54
   82dae:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
   82db2:	47b8      	blx	r7
   82db4:	6829      	ldr	r1, [r5, #0]
   82db6:	47b8      	blx	r7
   82db8:	6028      	str	r0, [r5, #0]
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
   82dba:	b2e3      	uxtb	r3, r4
   82dbc:	2b02      	cmp	r3, #2
   82dbe:	d10c      	bne.n	82dda <gc_execute_line+0x8aa>
   82dc0:	f104 080c 	add.w	r8, r4, #12
   82dc4:	4c57      	ldr	r4, [pc, #348]	; (82f24 <gc_execute_line+0x9f4>)
   82dc6:	eb04 0488 	add.w	r4, r4, r8, lsl #2
   82dca:	4b5b      	ldr	r3, [pc, #364]	; (82f38 <gc_execute_line+0xa08>)
   82dcc:	6c19      	ldr	r1, [r3, #64]	; 0x40
   82dce:	4b5b      	ldr	r3, [pc, #364]	; (82f3c <gc_execute_line+0xa0c>)
   82dd0:	4798      	blx	r3
   82dd2:	6060      	str	r0, [r4, #4]
   82dd4:	e071      	b.n	82eba <gc_execute_line+0x98a>
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
   82dd6:	69b3      	ldr	r3, [r6, #24]
   82dd8:	602b      	str	r3, [r5, #0]
   82dda:	3401      	adds	r4, #1
   82ddc:	3604      	adds	r6, #4
   82dde:	3504      	adds	r5, #4
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
   82de0:	2c03      	cmp	r4, #3
   82de2:	d1dd      	bne.n	82da0 <gc_execute_line+0x870>
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
   82de4:	f04f 0800 	mov.w	r8, #0
   82de8:	f000 bc94 	b.w	83714 <gc_execute_line+0x11e4>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
   82dec:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82dee:	2b03      	cmp	r3, #3
   82df0:	d039      	beq.n	82e66 <gc_execute_line+0x936>
        if (axis_words) {
   82df2:	9b06      	ldr	r3, [sp, #24]
   82df4:	2b00      	cmp	r3, #0
   82df6:	f000 8482 	beq.w	836fe <gc_execute_line+0x11ce>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
   82dfa:	4e4a      	ldr	r6, [pc, #296]	; (82f24 <gc_execute_line+0x9f4>)
   82dfc:	7933      	ldrb	r3, [r6, #4]
   82dfe:	930e      	str	r3, [sp, #56]	; 0x38
   82e00:	4f4f      	ldr	r7, [pc, #316]	; (82f40 <gc_execute_line+0xa10>)
   82e02:	3634      	adds	r6, #52	; 0x34
   82e04:	2500      	movs	r5, #0
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
   82e06:	f8df 8140 	ldr.w	r8, [pc, #320]	; 82f48 <gc_execute_line+0xa18>
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
   82e0a:	950d      	str	r5, [sp, #52]	; 0x34
   82e0c:	9b06      	ldr	r3, [sp, #24]
   82e0e:	412b      	asrs	r3, r5
   82e10:	f013 0f01 	tst.w	r3, #1
   82e14:	d102      	bne.n	82e1c <gc_execute_line+0x8ec>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
   82e16:	683b      	ldr	r3, [r7, #0]
   82e18:	6033      	str	r3, [r6, #0]
   82e1a:	e01d      	b.n	82e58 <gc_execute_line+0x928>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
   82e1c:	2c07      	cmp	r4, #7
   82e1e:	d01b      	beq.n	82e58 <gc_execute_line+0x928>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
   82e20:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   82e22:	b9ab      	cbnz	r3, 82e50 <gc_execute_line+0x920>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
   82e24:	ab15      	add	r3, sp, #84	; 0x54
   82e26:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
   82e2a:	69b9      	ldr	r1, [r7, #24]
   82e2c:	47c0      	blx	r8
   82e2e:	6831      	ldr	r1, [r6, #0]
   82e30:	47c0      	blx	r8
   82e32:	6030      	str	r0, [r6, #0]
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
   82e34:	b2eb      	uxtb	r3, r5
   82e36:	2b02      	cmp	r3, #2
   82e38:	d10e      	bne.n	82e58 <gc_execute_line+0x928>
   82e3a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   82e3c:	330c      	adds	r3, #12
   82e3e:	4d39      	ldr	r5, [pc, #228]	; (82f24 <gc_execute_line+0x9f4>)
   82e40:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   82e44:	4b3c      	ldr	r3, [pc, #240]	; (82f38 <gc_execute_line+0xa08>)
   82e46:	6c19      	ldr	r1, [r3, #64]	; 0x40
   82e48:	4b3f      	ldr	r3, [pc, #252]	; (82f48 <gc_execute_line+0xa18>)
   82e4a:	4798      	blx	r3
   82e4c:	6068      	str	r0, [r5, #4]
   82e4e:	e00a      	b.n	82e66 <gc_execute_line+0x936>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
   82e50:	6830      	ldr	r0, [r6, #0]
   82e52:	6839      	ldr	r1, [r7, #0]
   82e54:	47c0      	blx	r8
   82e56:	6030      	str	r0, [r6, #0]
   82e58:	3501      	adds	r5, #1
   82e5a:	3704      	adds	r7, #4
   82e5c:	3604      	adds	r6, #4
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
   82e5e:	2d03      	cmp	r5, #3
   82e60:	d1d3      	bne.n	82e0a <gc_execute_line+0x8da>
   82e62:	f000 bc41 	b.w	836e8 <gc_execute_line+0x11b8>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
   82e66:	2c05      	cmp	r4, #5
   82e68:	d014      	beq.n	82e94 <gc_execute_line+0x964>
   82e6a:	2c07      	cmp	r4, #7
   82e6c:	d020      	beq.n	82eb0 <gc_execute_line+0x980>
   82e6e:	2c03      	cmp	r4, #3
   82e70:	d123      	bne.n	82eba <gc_execute_line+0x98a>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
   82e72:	9b06      	ldr	r3, [sp, #24]
   82e74:	2b00      	cmp	r3, #0
   82e76:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82e78:	bf08      	it	eq
   82e7a:	2300      	moveq	r3, #0
   82e7c:	9309      	str	r3, [sp, #36]	; 0x24
   82e7e:	e001      	b.n	82e84 <gc_execute_line+0x954>
   82e80:	2300      	movs	r3, #0
   82e82:	9309      	str	r3, [sp, #36]	; 0x24
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
   82e84:	2006      	movs	r0, #6
   82e86:	a912      	add	r1, sp, #72	; 0x48
   82e88:	4b2a      	ldr	r3, [pc, #168]	; (82f34 <gc_execute_line+0xa04>)
   82e8a:	4798      	blx	r3
   82e8c:	2800      	cmp	r0, #0
   82e8e:	f000 83b8 	beq.w	83602 <gc_execute_line+0x10d2>
   82e92:	e012      	b.n	82eba <gc_execute_line+0x98a>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
   82e94:	9b06      	ldr	r3, [sp, #24]
   82e96:	2b00      	cmp	r3, #0
   82e98:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82e9a:	bf08      	it	eq
   82e9c:	2300      	moveq	r3, #0
   82e9e:	9309      	str	r3, [sp, #36]	; 0x24
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
   82ea0:	2007      	movs	r0, #7
   82ea2:	a912      	add	r1, sp, #72	; 0x48
   82ea4:	4b23      	ldr	r3, [pc, #140]	; (82f34 <gc_execute_line+0xa04>)
   82ea6:	4798      	blx	r3
   82ea8:	2800      	cmp	r0, #0
   82eaa:	f000 83ac 	beq.w	83606 <gc_execute_line+0x10d6>
   82eae:	e004      	b.n	82eba <gc_execute_line+0x98a>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
   82eb0:	4b1c      	ldr	r3, [pc, #112]	; (82f24 <gc_execute_line+0x9f4>)
   82eb2:	785b      	ldrb	r3, [r3, #1]
   82eb4:	2b01      	cmp	r3, #1
   82eb6:	f200 83a8 	bhi.w	8360a <gc_execute_line+0x10da>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
   82eba:	4b1a      	ldr	r3, [pc, #104]	; (82f24 <gc_execute_line+0x9f4>)
   82ebc:	785c      	ldrb	r4, [r3, #1]
   82ebe:	2c08      	cmp	r4, #8
   82ec0:	d10a      	bne.n	82ed8 <gc_execute_line+0x9a8>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
   82ec2:	9b06      	ldr	r3, [sp, #24]
   82ec4:	2b00      	cmp	r3, #0
   82ec6:	f000 81bc 	beq.w	83242 <gc_execute_line+0xd12>
   82eca:	f04f 0800 	mov.w	r8, #0
   82ece:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82ed0:	2b01      	cmp	r3, #1
   82ed2:	f040 839c 	bne.w	8360e <gc_execute_line+0x10de>
   82ed6:	e1be      	b.n	83256 <gc_execute_line+0xd26>
   82ed8:	f04f 0800 	mov.w	r8, #0
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
   82edc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   82ede:	2b02      	cmp	r3, #2
   82ee0:	f040 81b1 	bne.w	83246 <gc_execute_line+0xd16>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
   82ee4:	b924      	cbnz	r4, 82ef0 <gc_execute_line+0x9c0>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
   82ee6:	9b06      	ldr	r3, [sp, #24]
   82ee8:	2b00      	cmp	r3, #0
   82eea:	f000 8420 	beq.w	8372e <gc_execute_line+0x11fe>
   82eee:	e1b2      	b.n	83256 <gc_execute_line+0xd26>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
   82ef0:	4b0c      	ldr	r3, [pc, #48]	; (82f24 <gc_execute_line+0x9f4>)
   82ef2:	68d8      	ldr	r0, [r3, #12]
   82ef4:	2100      	movs	r1, #0
   82ef6:	4b15      	ldr	r3, [pc, #84]	; (82f4c <gc_execute_line+0xa1c>)
   82ef8:	4798      	blx	r3
   82efa:	2800      	cmp	r0, #0
   82efc:	f040 8389 	bne.w	83612 <gc_execute_line+0x10e2>
     
      switch (gc_block.modal.motion) {
   82f00:	3c01      	subs	r4, #1
   82f02:	2c06      	cmp	r4, #6
   82f04:	f200 819f 	bhi.w	83246 <gc_execute_line+0xd16>
   82f08:	e8df f014 	tbh	[pc, r4, lsl #1]
   82f0c:	00220007 	.word	0x00220007
   82f10:	01800022 	.word	0x01800022
   82f14:	01800180 	.word	0x01800180
   82f18:	0180      	.short	0x0180
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
   82f1a:	9b06      	ldr	r3, [sp, #24]
   82f1c:	2b00      	cmp	r3, #0
   82f1e:	f000 8406 	beq.w	8372e <gc_execute_line+0x11fe>
   82f22:	e198      	b.n	83256 <gc_execute_line+0xd26>
   82f24:	2000120c 	.word	0x2000120c
   82f28:	0008be0d 	.word	0x0008be0d
   82f2c:	0008a265 	.word	0x0008a265
   82f30:	0008c439 	.word	0x0008c439
   82f34:	00088021 	.word	0x00088021
   82f38:	200011c8 	.word	0x200011c8
   82f3c:	0008c521 	.word	0x0008c521
   82f40:	200011e4 	.word	0x200011e4
   82f44:	20001240 	.word	0x20001240
   82f48:	0008c525 	.word	0x0008c525
   82f4c:	0008ca5d 	.word	0x0008ca5d
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   82f50:	9b06      	ldr	r3, [sp, #24]
   82f52:	2b00      	cmp	r3, #0
   82f54:	f000 835f 	beq.w	83616 <gc_execute_line+0x10e6>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
   82f58:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
   82f5c:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
   82f60:	2301      	movs	r3, #1
   82f62:	fa03 f40a 	lsl.w	r4, r3, sl
   82f66:	fa03 f309 	lsl.w	r3, r3, r9
   82f6a:	431c      	orrs	r4, r3
   82f6c:	9b06      	ldr	r3, [sp, #24]
   82f6e:	421c      	tst	r4, r3
   82f70:	f000 8353 	beq.w	8361a <gc_execute_line+0x10ea>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
   82f74:	4e62      	ldr	r6, [pc, #392]	; (83100 <gc_execute_line+0xbd0>)
   82f76:	eb06 0289 	add.w	r2, r6, r9, lsl #2
   82f7a:	4d62      	ldr	r5, [pc, #392]	; (83104 <gc_execute_line+0xbd4>)
   82f7c:	eb05 0389 	add.w	r3, r5, r9, lsl #2
   82f80:	4f61      	ldr	r7, [pc, #388]	; (83108 <gc_execute_line+0xbd8>)
   82f82:	6b50      	ldr	r0, [r2, #52]	; 0x34
   82f84:	69d9      	ldr	r1, [r3, #28]
   82f86:	47b8      	blx	r7
   82f88:	9006      	str	r0, [sp, #24]
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
   82f8a:	eb06 068a 	add.w	r6, r6, sl, lsl #2
   82f8e:	eb05 058a 	add.w	r5, r5, sl, lsl #2
   82f92:	6b70      	ldr	r0, [r6, #52]	; 0x34
   82f94:	69e9      	ldr	r1, [r5, #28]
   82f96:	47b8      	blx	r7
   82f98:	900d      	str	r0, [sp, #52]	; 0x34

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
   82f9a:	f00b 0380 	and.w	r3, fp, #128	; 0x80
   82f9e:	b29b      	uxth	r3, r3
   82fa0:	2b00      	cmp	r3, #0
   82fa2:	f000 80cb 	beq.w	8313c <gc_execute_line+0xc0c>
            bit_false(value_words,bit(WORD_R));
   82fa6:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
   82faa:	fa1f fb83 	uxth.w	fp, r3

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
   82fae:	4b55      	ldr	r3, [pc, #340]	; (83104 <gc_execute_line+0xbd4>)
   82fb0:	69d8      	ldr	r0, [r3, #28]
   82fb2:	4b53      	ldr	r3, [pc, #332]	; (83100 <gc_execute_line+0xbd0>)
   82fb4:	6b59      	ldr	r1, [r3, #52]	; 0x34
   82fb6:	4b55      	ldr	r3, [pc, #340]	; (8310c <gc_execute_line+0xbdc>)
   82fb8:	4798      	blx	r3
   82fba:	2800      	cmp	r0, #0
   82fbc:	f000 83b1 	beq.w	83722 <gc_execute_line+0x11f2>
   82fc0:	4b50      	ldr	r3, [pc, #320]	; (83104 <gc_execute_line+0xbd4>)
   82fc2:	6a18      	ldr	r0, [r3, #32]
   82fc4:	4b4e      	ldr	r3, [pc, #312]	; (83100 <gc_execute_line+0xbd0>)
   82fc6:	6b99      	ldr	r1, [r3, #56]	; 0x38
   82fc8:	4b50      	ldr	r3, [pc, #320]	; (8310c <gc_execute_line+0xbdc>)
   82fca:	4798      	blx	r3
   82fcc:	2800      	cmp	r0, #0
   82fce:	f000 83a8 	beq.w	83722 <gc_execute_line+0x11f2>
   82fd2:	4b4c      	ldr	r3, [pc, #304]	; (83104 <gc_execute_line+0xbd4>)
   82fd4:	6a58      	ldr	r0, [r3, #36]	; 0x24
   82fd6:	4b4a      	ldr	r3, [pc, #296]	; (83100 <gc_execute_line+0xbd0>)
   82fd8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
   82fda:	4b4c      	ldr	r3, [pc, #304]	; (8310c <gc_execute_line+0xbdc>)
   82fdc:	4798      	blx	r3
   82fde:	2800      	cmp	r0, #0
   82fe0:	f000 839f 	beq.w	83722 <gc_execute_line+0x11f2>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
   82fe4:	2021      	movs	r0, #33	; 0x21
   82fe6:	e3aa      	b.n	8373e <gc_execute_line+0x120e>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
   82fe8:	4c45      	ldr	r4, [pc, #276]	; (83100 <gc_execute_line+0xbd0>)
   82fea:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   82fec:	4b48      	ldr	r3, [pc, #288]	; (83110 <gc_execute_line+0xbe0>)
   82fee:	4798      	blx	r3
   82ff0:	a341      	add	r3, pc, #260	; (adr r3, 830f8 <gc_execute_line+0xbc8>)
   82ff2:	e9d3 2300 	ldrd	r2, r3, [r3]
   82ff6:	4d47      	ldr	r5, [pc, #284]	; (83114 <gc_execute_line+0xbe4>)
   82ff8:	47a8      	blx	r5
   82ffa:	4b47      	ldr	r3, [pc, #284]	; (83118 <gc_execute_line+0xbe8>)
   82ffc:	4798      	blx	r3
   82ffe:	62a0      	str	r0, [r4, #40]	; 0x28
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
   83000:	4e43      	ldr	r6, [pc, #268]	; (83110 <gc_execute_line+0xbe0>)
   83002:	4b3f      	ldr	r3, [pc, #252]	; (83100 <gc_execute_line+0xbd0>)
   83004:	6a98      	ldr	r0, [r3, #40]	; 0x28
   83006:	47b0      	blx	r6
   83008:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   8300c:	4c41      	ldr	r4, [pc, #260]	; (83114 <gc_execute_line+0xbe4>)
   8300e:	2200      	movs	r2, #0
   83010:	4b42      	ldr	r3, [pc, #264]	; (8311c <gc_execute_line+0xbec>)
   83012:	47a0      	blx	r4
   83014:	4602      	mov	r2, r0
   83016:	460b      	mov	r3, r1
   83018:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   8301c:	47a0      	blx	r4
   8301e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   83022:	4d3f      	ldr	r5, [pc, #252]	; (83120 <gc_execute_line+0xbf0>)
   83024:	9906      	ldr	r1, [sp, #24]
   83026:	4608      	mov	r0, r1
   83028:	47a8      	blx	r5
   8302a:	47b0      	blx	r6
   8302c:	4602      	mov	r2, r0
   8302e:	460b      	mov	r3, r1
   83030:	4c3c      	ldr	r4, [pc, #240]	; (83124 <gc_execute_line+0xbf4>)
   83032:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   83036:	47a0      	blx	r4
   83038:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   8303c:	990d      	ldr	r1, [sp, #52]	; 0x34
   8303e:	4608      	mov	r0, r1
   83040:	47a8      	blx	r5
   83042:	47b0      	blx	r6
   83044:	4602      	mov	r2, r0
   83046:	460b      	mov	r3, r1
   83048:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   8304c:	47a0      	blx	r4
   8304e:	4b32      	ldr	r3, [pc, #200]	; (83118 <gc_execute_line+0xbe8>)
   83050:	4798      	blx	r3
   83052:	4604      	mov	r4, r0

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
   83054:	2100      	movs	r1, #0
   83056:	4b34      	ldr	r3, [pc, #208]	; (83128 <gc_execute_line+0xbf8>)
   83058:	4798      	blx	r3
   8305a:	2800      	cmp	r0, #0
   8305c:	f040 82df 	bne.w	8361e <gc_execute_line+0x10ee>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
   83060:	4635      	mov	r5, r6
   83062:	4620      	mov	r0, r4
   83064:	47b0      	blx	r6
   83066:	4b31      	ldr	r3, [pc, #196]	; (8312c <gc_execute_line+0xbfc>)
   83068:	4798      	blx	r3
   8306a:	4606      	mov	r6, r0
   8306c:	460c      	mov	r4, r1
   8306e:	9806      	ldr	r0, [sp, #24]
   83070:	990d      	ldr	r1, [sp, #52]	; 0x34
   83072:	4b2f      	ldr	r3, [pc, #188]	; (83130 <gc_execute_line+0xc00>)
   83074:	4798      	blx	r3
   83076:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   8307a:	47a8      	blx	r5
   8307c:	4602      	mov	r2, r0
   8307e:	460b      	mov	r3, r1
   83080:	4630      	mov	r0, r6
   83082:	4621      	mov	r1, r4
   83084:	4c2b      	ldr	r4, [pc, #172]	; (83134 <gc_execute_line+0xc04>)
   83086:	47a0      	blx	r4
   83088:	4b23      	ldr	r3, [pc, #140]	; (83118 <gc_execute_line+0xbe8>)
   8308a:	4798      	blx	r3
   8308c:	4604      	mov	r4, r0
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
   8308e:	4b1c      	ldr	r3, [pc, #112]	; (83100 <gc_execute_line+0xbd0>)
   83090:	785b      	ldrb	r3, [r3, #1]
   83092:	2b03      	cmp	r3, #3
   83094:	bf08      	it	eq
   83096:	f100 4400 	addeq.w	r4, r0, #2147483648	; 0x80000000
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
   8309a:	4b19      	ldr	r3, [pc, #100]	; (83100 <gc_execute_line+0xbd0>)
   8309c:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   8309e:	4628      	mov	r0, r5
   830a0:	2100      	movs	r1, #0
   830a2:	4b21      	ldr	r3, [pc, #132]	; (83128 <gc_execute_line+0xbf8>)
   830a4:	4798      	blx	r3
   830a6:	b128      	cbz	r0, 830b4 <gc_execute_line+0xb84>
                h_x2_div_d = -h_x2_div_d; 
   830a8:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
   830ac:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   830b0:	4b13      	ldr	r3, [pc, #76]	; (83100 <gc_execute_line+0xbd0>)
   830b2:	629d      	str	r5, [r3, #40]	; 0x28
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
   830b4:	4f12      	ldr	r7, [pc, #72]	; (83100 <gc_execute_line+0xbd0>)
   830b6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   830b8:	3602      	adds	r6, #2
   830ba:	eb07 0686 	add.w	r6, r7, r6, lsl #2
   830be:	4d18      	ldr	r5, [pc, #96]	; (83120 <gc_execute_line+0xbf0>)
   830c0:	980d      	ldr	r0, [sp, #52]	; 0x34
   830c2:	4621      	mov	r1, r4
   830c4:	47a8      	blx	r5
   830c6:	4601      	mov	r1, r0
   830c8:	9806      	ldr	r0, [sp, #24]
   830ca:	4b0f      	ldr	r3, [pc, #60]	; (83108 <gc_execute_line+0xbd8>)
   830cc:	4798      	blx	r3
   830ce:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   830d2:	47a8      	blx	r5
   830d4:	60b0      	str	r0, [r6, #8]
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
   830d6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   830d8:	3302      	adds	r3, #2
   830da:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   830de:	9806      	ldr	r0, [sp, #24]
   830e0:	4621      	mov	r1, r4
   830e2:	47a8      	blx	r5
   830e4:	990d      	ldr	r1, [sp, #52]	; 0x34
   830e6:	4b14      	ldr	r3, [pc, #80]	; (83138 <gc_execute_line+0xc08>)
   830e8:	4798      	blx	r3
   830ea:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   830ee:	47a8      	blx	r5
   830f0:	60b8      	str	r0, [r7, #8]
   830f2:	e0b0      	b.n	83256 <gc_execute_line+0xd26>
   830f4:	f3af 8000 	nop.w
   830f8:	66666666 	.word	0x66666666
   830fc:	40396666 	.word	0x40396666
   83100:	2000120c 	.word	0x2000120c
   83104:	200011c8 	.word	0x200011c8
   83108:	0008c521 	.word	0x0008c521
   8310c:	0008ca5d 	.word	0x0008ca5d
   83110:	0008be0d 	.word	0x0008be0d
   83114:	0008beb5 	.word	0x0008beb5
   83118:	0008c479 	.word	0x0008c479
   8311c:	40100000 	.word	0x40100000
   83120:	0008c735 	.word	0x0008c735
   83124:	0008bb4d 	.word	0x0008bb4d
   83128:	0008ca71 	.word	0x0008ca71
   8312c:	0008a2dd 	.word	0x0008a2dd
   83130:	0008461d 	.word	0x0008461d
   83134:	0008c109 	.word	0x0008c109
   83138:	0008c525 	.word	0x0008c525
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
   8313c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8313e:	421c      	tst	r4, r3
   83140:	f000 826f 	beq.w	83622 <gc_execute_line+0x10f2>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
   83144:	f02b 030e 	bic.w	r3, fp, #14
   83148:	fa1f fb83 	uxth.w	fp, r3
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
   8314c:	4b8a      	ldr	r3, [pc, #552]	; (83378 <gc_execute_line+0xe48>)
   8314e:	78db      	ldrb	r3, [r3, #3]
   83150:	2b01      	cmp	r3, #1
   83152:	d115      	bne.n	83180 <gc_execute_line+0xc50>
   83154:	4d89      	ldr	r5, [pc, #548]	; (8337c <gc_execute_line+0xe4c>)
   83156:	2400      	movs	r4, #0
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
   83158:	4e89      	ldr	r6, [pc, #548]	; (83380 <gc_execute_line+0xe50>)
   8315a:	4f8a      	ldr	r7, [pc, #552]	; (83384 <gc_execute_line+0xe54>)
   8315c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8315e:	4123      	asrs	r3, r4
   83160:	f013 0f01 	tst.w	r3, #1
   83164:	d008      	beq.n	83178 <gc_execute_line+0xc48>
   83166:	6828      	ldr	r0, [r5, #0]
   83168:	47b0      	blx	r6
   8316a:	a37d      	add	r3, pc, #500	; (adr r3, 83360 <gc_execute_line+0xe30>)
   8316c:	e9d3 2300 	ldrd	r2, r3, [r3]
   83170:	47b8      	blx	r7
   83172:	4b85      	ldr	r3, [pc, #532]	; (83388 <gc_execute_line+0xe58>)
   83174:	4798      	blx	r3
   83176:	6028      	str	r0, [r5, #0]
   83178:	3401      	adds	r4, #1
   8317a:	3504      	adds	r5, #4
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
   8317c:	2c03      	cmp	r4, #3
   8317e:	d1ed      	bne.n	8315c <gc_execute_line+0xc2c>
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
   83180:	4f7d      	ldr	r7, [pc, #500]	; (83378 <gc_execute_line+0xe48>)
   83182:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   83184:	3502      	adds	r5, #2
   83186:	eb07 0585 	add.w	r5, r7, r5, lsl #2
   8318a:	4e80      	ldr	r6, [pc, #512]	; (8338c <gc_execute_line+0xe5c>)
   8318c:	9806      	ldr	r0, [sp, #24]
   8318e:	68a9      	ldr	r1, [r5, #8]
   83190:	47b0      	blx	r6
   83192:	9006      	str	r0, [sp, #24]
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
   83194:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   83196:	3402      	adds	r4, #2
   83198:	eb07 0484 	add.w	r4, r7, r4, lsl #2
   8319c:	980d      	ldr	r0, [sp, #52]	; 0x34
   8319e:	68a1      	ldr	r1, [r4, #8]
   831a0:	47b0      	blx	r6
   831a2:	4601      	mov	r1, r0
            float target_r = hypot_f(x,y); 
   831a4:	9806      	ldr	r0, [sp, #24]
   831a6:	4b7a      	ldr	r3, [pc, #488]	; (83390 <gc_execute_line+0xe60>)
   831a8:	4798      	blx	r3
   831aa:	9006      	str	r0, [sp, #24]

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
   831ac:	68a8      	ldr	r0, [r5, #8]
   831ae:	68a1      	ldr	r1, [r4, #8]
   831b0:	4b77      	ldr	r3, [pc, #476]	; (83390 <gc_execute_line+0xe60>)
   831b2:	4798      	blx	r3
   831b4:	4604      	mov	r4, r0
   831b6:	62b8      	str	r0, [r7, #40]	; 0x28
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
   831b8:	9806      	ldr	r0, [sp, #24]
   831ba:	4621      	mov	r1, r4
   831bc:	47b0      	blx	r6
   831be:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
            if (delta_r > 0.005) { 
   831c2:	4628      	mov	r0, r5
   831c4:	4b6e      	ldr	r3, [pc, #440]	; (83380 <gc_execute_line+0xe50>)
   831c6:	4798      	blx	r3
   831c8:	e9cd 0106 	strd	r0, r1, [sp, #24]
   831cc:	a366      	add	r3, pc, #408	; (adr r3, 83368 <gc_execute_line+0xe38>)
   831ce:	e9d3 2300 	ldrd	r2, r3, [r3]
   831d2:	4e70      	ldr	r6, [pc, #448]	; (83394 <gc_execute_line+0xe64>)
   831d4:	47b0      	blx	r6
   831d6:	2800      	cmp	r0, #0
   831d8:	d03d      	beq.n	83256 <gc_execute_line+0xd26>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
   831da:	4628      	mov	r0, r5
   831dc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   831e0:	4b6d      	ldr	r3, [pc, #436]	; (83398 <gc_execute_line+0xe68>)
   831e2:	4798      	blx	r3
   831e4:	2800      	cmp	r0, #0
   831e6:	f040 821e 	bne.w	83626 <gc_execute_line+0x10f6>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
   831ea:	4620      	mov	r0, r4
   831ec:	4b64      	ldr	r3, [pc, #400]	; (83380 <gc_execute_line+0xe50>)
   831ee:	4798      	blx	r3
   831f0:	a35f      	add	r3, pc, #380	; (adr r3, 83370 <gc_execute_line+0xe40>)
   831f2:	e9d3 2300 	ldrd	r2, r3, [r3]
   831f6:	4c63      	ldr	r4, [pc, #396]	; (83384 <gc_execute_line+0xe54>)
   831f8:	47a0      	blx	r4
   831fa:	4602      	mov	r2, r0
   831fc:	460b      	mov	r3, r1
   831fe:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   83202:	47b0      	blx	r6
   83204:	2800      	cmp	r0, #0
   83206:	f040 8239 	bne.w	8367c <gc_execute_line+0x114c>
   8320a:	e024      	b.n	83256 <gc_execute_line+0xd26>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   8320c:	9b06      	ldr	r3, [sp, #24]
   8320e:	2b00      	cmp	r3, #0
   83210:	f000 8236 	beq.w	83680 <gc_execute_line+0x1150>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
   83214:	4b61      	ldr	r3, [pc, #388]	; (8339c <gc_execute_line+0xe6c>)
   83216:	69d8      	ldr	r0, [r3, #28]
   83218:	4b57      	ldr	r3, [pc, #348]	; (83378 <gc_execute_line+0xe48>)
   8321a:	6b59      	ldr	r1, [r3, #52]	; 0x34
   8321c:	4b60      	ldr	r3, [pc, #384]	; (833a0 <gc_execute_line+0xe70>)
   8321e:	4798      	blx	r3
   83220:	b1c8      	cbz	r0, 83256 <gc_execute_line+0xd26>
   83222:	4b5e      	ldr	r3, [pc, #376]	; (8339c <gc_execute_line+0xe6c>)
   83224:	6a18      	ldr	r0, [r3, #32]
   83226:	4b54      	ldr	r3, [pc, #336]	; (83378 <gc_execute_line+0xe48>)
   83228:	6b99      	ldr	r1, [r3, #56]	; 0x38
   8322a:	4b5d      	ldr	r3, [pc, #372]	; (833a0 <gc_execute_line+0xe70>)
   8322c:	4798      	blx	r3
   8322e:	b190      	cbz	r0, 83256 <gc_execute_line+0xd26>
   83230:	4b5a      	ldr	r3, [pc, #360]	; (8339c <gc_execute_line+0xe6c>)
   83232:	6a58      	ldr	r0, [r3, #36]	; 0x24
   83234:	4b50      	ldr	r3, [pc, #320]	; (83378 <gc_execute_line+0xe48>)
   83236:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
   83238:	4b59      	ldr	r3, [pc, #356]	; (833a0 <gc_execute_line+0xe70>)
   8323a:	4798      	blx	r3
   8323c:	b158      	cbz	r0, 83256 <gc_execute_line+0xd26>
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
   8323e:	2021      	movs	r0, #33	; 0x21
   83240:	e27d      	b.n	8373e <gc_execute_line+0x120e>
   83242:	f04f 0800 	mov.w	r8, #0
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
   83246:	9b09      	ldr	r3, [sp, #36]	; 0x24
   83248:	b92b      	cbnz	r3, 83256 <gc_execute_line+0xd26>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
   8324a:	f42b 7348 	bic.w	r3, fp, #800	; 0x320
   8324e:	f023 0301 	bic.w	r3, r3, #1
   83252:	b29b      	uxth	r3, r3
   83254:	e004      	b.n	83260 <gc_execute_line+0xd30>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
   83256:	f42b 53f9 	bic.w	r3, fp, #7968	; 0x1f20
   8325a:	f023 0301 	bic.w	r3, r3, #1
   8325e:	b29b      	uxth	r3, r3
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
   83260:	2b00      	cmp	r3, #0
   83262:	f040 820f 	bne.w	83684 <gc_execute_line+0x1154>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
   83266:	4b4d      	ldr	r3, [pc, #308]	; (8339c <gc_execute_line+0xe6c>)
   83268:	4a43      	ldr	r2, [pc, #268]	; (83378 <gc_execute_line+0xe48>)
   8326a:	6a11      	ldr	r1, [r2, #32]
   8326c:	6199      	str	r1, [r3, #24]
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
   8326e:	7891      	ldrb	r1, [r2, #2]
   83270:	7059      	strb	r1, [r3, #1]
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
   83272:	68d1      	ldr	r1, [r2, #12]
   83274:	6119      	str	r1, [r3, #16]

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
   83276:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
   83278:	68d8      	ldr	r0, [r3, #12]
   8327a:	4621      	mov	r1, r4
   8327c:	4b48      	ldr	r3, [pc, #288]	; (833a0 <gc_execute_line+0xe70>)
   8327e:	4798      	blx	r3
   83280:	b948      	cbnz	r0, 83296 <gc_execute_line+0xd66>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
   83282:	4b46      	ldr	r3, [pc, #280]	; (8339c <gc_execute_line+0xe6c>)
   83284:	7a58      	ldrb	r0, [r3, #9]
   83286:	b110      	cbz	r0, 8328e <gc_execute_line+0xd5e>
   83288:	4621      	mov	r1, r4
   8328a:	4b46      	ldr	r3, [pc, #280]	; (833a4 <gc_execute_line+0xe74>)
   8328c:	4798      	blx	r3
    gc_state.spindle_speed = gc_block.values.s; 
   8328e:	4b3a      	ldr	r3, [pc, #232]	; (83378 <gc_execute_line+0xe48>)
   83290:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   83292:	4b42      	ldr	r3, [pc, #264]	; (8339c <gc_execute_line+0xe6c>)
   83294:	60da      	str	r2, [r3, #12]
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
   83296:	4b41      	ldr	r3, [pc, #260]	; (8339c <gc_execute_line+0xe6c>)
   83298:	4a37      	ldr	r2, [pc, #220]	; (83378 <gc_execute_line+0xe48>)
   8329a:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
   8329e:	7519      	strb	r1, [r3, #20]

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
   832a0:	7a90      	ldrb	r0, [r2, #10]
   832a2:	7a5b      	ldrb	r3, [r3, #9]
   832a4:	4283      	cmp	r3, r0
   832a6:	d006      	beq.n	832b6 <gc_execute_line+0xd86>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
   832a8:	4c3c      	ldr	r4, [pc, #240]	; (8339c <gc_execute_line+0xe6c>)
   832aa:	68e1      	ldr	r1, [r4, #12]
   832ac:	4b3d      	ldr	r3, [pc, #244]	; (833a4 <gc_execute_line+0xe74>)
   832ae:	4798      	blx	r3
    gc_state.modal.spindle = gc_block.modal.spindle;    
   832b0:	4b31      	ldr	r3, [pc, #196]	; (83378 <gc_execute_line+0xe48>)
   832b2:	7a9b      	ldrb	r3, [r3, #10]
   832b4:	7263      	strb	r3, [r4, #9]
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
   832b6:	4b30      	ldr	r3, [pc, #192]	; (83378 <gc_execute_line+0xe48>)
   832b8:	7a58      	ldrb	r0, [r3, #9]
   832ba:	4b38      	ldr	r3, [pc, #224]	; (8339c <gc_execute_line+0xe6c>)
   832bc:	7a1b      	ldrb	r3, [r3, #8]
   832be:	4283      	cmp	r3, r0
   832c0:	d005      	beq.n	832ce <gc_execute_line+0xd9e>
    coolant_run(gc_block.modal.coolant);
   832c2:	4b39      	ldr	r3, [pc, #228]	; (833a8 <gc_execute_line+0xe78>)
   832c4:	4798      	blx	r3
    gc_state.modal.coolant = gc_block.modal.coolant;
   832c6:	4b2c      	ldr	r3, [pc, #176]	; (83378 <gc_execute_line+0xe48>)
   832c8:	7a5a      	ldrb	r2, [r3, #9]
   832ca:	4b34      	ldr	r3, [pc, #208]	; (8339c <gc_execute_line+0xe6c>)
   832cc:	721a      	strb	r2, [r3, #8]
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
   832ce:	4b2a      	ldr	r3, [pc, #168]	; (83378 <gc_execute_line+0xe48>)
   832d0:	781b      	ldrb	r3, [r3, #0]
   832d2:	2b01      	cmp	r3, #1
   832d4:	d103      	bne.n	832de <gc_execute_line+0xdae>
   832d6:	4b28      	ldr	r3, [pc, #160]	; (83378 <gc_execute_line+0xe48>)
   832d8:	6a58      	ldr	r0, [r3, #36]	; 0x24
   832da:	4b34      	ldr	r3, [pc, #208]	; (833ac <gc_execute_line+0xe7c>)
   832dc:	4798      	blx	r3
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
   832de:	4b2f      	ldr	r3, [pc, #188]	; (8339c <gc_execute_line+0xe6c>)
   832e0:	4a25      	ldr	r2, [pc, #148]	; (83378 <gc_execute_line+0xe48>)
   832e2:	7951      	ldrb	r1, [r2, #5]
   832e4:	7119      	strb	r1, [r3, #4]

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
   832e6:	78d2      	ldrb	r2, [r2, #3]
   832e8:	709a      	strb	r2, [r3, #2]

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
   832ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
   832ec:	2b03      	cmp	r3, #3
   832ee:	d10a      	bne.n	83306 <gc_execute_line+0xdd6>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
   832f0:	4b21      	ldr	r3, [pc, #132]	; (83378 <gc_execute_line+0xe48>)
   832f2:	799b      	ldrb	r3, [r3, #6]
   832f4:	4a29      	ldr	r2, [pc, #164]	; (8339c <gc_execute_line+0xe6c>)
   832f6:	7153      	strb	r3, [r2, #5]
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
   832f8:	2b01      	cmp	r3, #1
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
   832fa:	bf06      	itte	eq
   832fc:	4b1e      	ldreq	r3, [pc, #120]	; (83378 <gc_execute_line+0xe48>)
   832fe:	6bda      	ldreq	r2, [r3, #60]	; 0x3c
    } else { // G49
      gc_state.tool_length_offset = 0.0;
   83300:	2200      	movne	r2, #0
   83302:	4b26      	ldr	r3, [pc, #152]	; (8339c <gc_execute_line+0xe6c>)
   83304:	641a      	str	r2, [r3, #64]	; 0x40
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
   83306:	4b1c      	ldr	r3, [pc, #112]	; (83378 <gc_execute_line+0xe48>)
   83308:	79da      	ldrb	r2, [r3, #7]
   8330a:	4b24      	ldr	r3, [pc, #144]	; (8339c <gc_execute_line+0xe6c>)
   8330c:	799b      	ldrb	r3, [r3, #6]
   8330e:	4293      	cmp	r3, r2
   83310:	d007      	beq.n	83322 <gc_execute_line+0xdf2>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
   83312:	4b22      	ldr	r3, [pc, #136]	; (8339c <gc_execute_line+0xe6c>)
   83314:	719a      	strb	r2, [r3, #6]
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
   83316:	3328      	adds	r3, #40	; 0x28
   83318:	aa18      	add	r2, sp, #96	; 0x60
   8331a:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   8331e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  
  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
   83322:	4b15      	ldr	r3, [pc, #84]	; (83378 <gc_execute_line+0xe48>)
   83324:	7919      	ldrb	r1, [r3, #4]
   83326:	4a1d      	ldr	r2, [pc, #116]	; (8339c <gc_execute_line+0xe6c>)
   83328:	70d1      	strb	r1, [r2, #3]
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
   8332a:	781b      	ldrb	r3, [r3, #0]
   8332c:	3b02      	subs	r3, #2
   8332e:	2b07      	cmp	r3, #7
   83330:	d86a      	bhi.n	83408 <gc_execute_line+0xed8>
   83332:	e8df f003 	tbb	[pc, r3]
   83336:	4104      	.short	0x4104
   83338:	69594154 	.word	0x69594154
   8333c:	645e      	.short	0x645e
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
   8333e:	4640      	mov	r0, r8
   83340:	a912      	add	r1, sp, #72	; 0x48
   83342:	4b1b      	ldr	r3, [pc, #108]	; (833b0 <gc_execute_line+0xe80>)
   83344:	4798      	blx	r3
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
   83346:	4b15      	ldr	r3, [pc, #84]	; (8339c <gc_execute_line+0xe6c>)
   83348:	799b      	ldrb	r3, [r3, #6]
   8334a:	4543      	cmp	r3, r8
   8334c:	d15c      	bne.n	83408 <gc_execute_line+0xed8>
   8334e:	4b19      	ldr	r3, [pc, #100]	; (833b4 <gc_execute_line+0xe84>)
   83350:	aa12      	add	r2, sp, #72	; 0x48
   83352:	ca07      	ldmia	r2, {r0, r1, r2}
   83354:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   83358:	e056      	b.n	83408 <gc_execute_line+0xed8>
   8335a:	bf00      	nop
   8335c:	f3af 8000 	nop.w
   83360:	66666666 	.word	0x66666666
   83364:	40396666 	.word	0x40396666
   83368:	47ae147b 	.word	0x47ae147b
   8336c:	3f747ae1 	.word	0x3f747ae1
   83370:	d2f1a9fc 	.word	0xd2f1a9fc
   83374:	3f50624d 	.word	0x3f50624d
   83378:	2000120c 	.word	0x2000120c
   8337c:	2000121c 	.word	0x2000121c
   83380:	0008be0d 	.word	0x0008be0d
   83384:	0008beb5 	.word	0x0008beb5
   83388:	0008c479 	.word	0x0008c479
   8338c:	0008c521 	.word	0x0008c521
   83390:	0008461d 	.word	0x0008461d
   83394:	0008c3d5 	.word	0x0008c3d5
   83398:	0008caad 	.word	0x0008caad
   8339c:	200011c8 	.word	0x200011c8
   833a0:	0008ca5d 	.word	0x0008ca5d
   833a4:	000883d1 	.word	0x000883d1
   833a8:	0008019d 	.word	0x0008019d
   833ac:	00084289 	.word	0x00084289
   833b0:	00087e81 	.word	0x00087e81
   833b4:	200011f0 	.word	0x200011f0
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
   833b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   833ba:	b123      	cbz	r3, 833c6 <gc_execute_line+0xe96>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
   833bc:	489b      	ldr	r0, [pc, #620]	; (8362c <gc_execute_line+0x10fc>)
   833be:	499c      	ldr	r1, [pc, #624]	; (83630 <gc_execute_line+0x1100>)
   833c0:	2200      	movs	r2, #0
   833c2:	4b9c      	ldr	r3, [pc, #624]	; (83634 <gc_execute_line+0x1104>)
   833c4:	4798      	blx	r3
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
   833c6:	ac12      	add	r4, sp, #72	; 0x48
   833c8:	4620      	mov	r0, r4
   833ca:	4999      	ldr	r1, [pc, #612]	; (83630 <gc_execute_line+0x1100>)
   833cc:	2200      	movs	r2, #0
   833ce:	4b99      	ldr	r3, [pc, #612]	; (83634 <gc_execute_line+0x1104>)
   833d0:	4798      	blx	r3
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
   833d2:	4b99      	ldr	r3, [pc, #612]	; (83638 <gc_execute_line+0x1108>)
   833d4:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   833d8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
      break;
   833dc:	e014      	b.n	83408 <gc_execute_line+0xed8>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
   833de:	2006      	movs	r0, #6
   833e0:	4995      	ldr	r1, [pc, #596]	; (83638 <gc_execute_line+0x1108>)
   833e2:	4b96      	ldr	r3, [pc, #600]	; (8363c <gc_execute_line+0x110c>)
   833e4:	4798      	blx	r3
      break;
   833e6:	e00f      	b.n	83408 <gc_execute_line+0xed8>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
   833e8:	2007      	movs	r0, #7
   833ea:	4993      	ldr	r1, [pc, #588]	; (83638 <gc_execute_line+0x1108>)
   833ec:	4b93      	ldr	r3, [pc, #588]	; (8363c <gc_execute_line+0x110c>)
   833ee:	4798      	blx	r3
      break;
   833f0:	e00a      	b.n	83408 <gc_execute_line+0xed8>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
   833f2:	4b93      	ldr	r3, [pc, #588]	; (83640 <gc_execute_line+0x1110>)
   833f4:	4a8d      	ldr	r2, [pc, #564]	; (8362c <gc_execute_line+0x10fc>)
   833f6:	ca07      	ldmia	r2, {r0, r1, r2}
   833f8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
      break;
   833fc:	e004      	b.n	83408 <gc_execute_line+0xed8>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
   833fe:	4890      	ldr	r0, [pc, #576]	; (83640 <gc_execute_line+0x1110>)
   83400:	2100      	movs	r1, #0
   83402:	220c      	movs	r2, #12
   83404:	4b8f      	ldr	r3, [pc, #572]	; (83644 <gc_execute_line+0x1114>)
   83406:	4798      	blx	r3

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
   83408:	4b8f      	ldr	r3, [pc, #572]	; (83648 <gc_execute_line+0x1118>)
   8340a:	785b      	ldrb	r3, [r3, #1]
   8340c:	4a8f      	ldr	r2, [pc, #572]	; (8364c <gc_execute_line+0x111c>)
   8340e:	7013      	strb	r3, [r2, #0]
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
   83410:	2b08      	cmp	r3, #8
   83412:	d071      	beq.n	834f8 <gc_execute_line+0xfc8>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
   83414:	9a09      	ldr	r2, [sp, #36]	; 0x24
   83416:	2a02      	cmp	r2, #2
   83418:	d16e      	bne.n	834f8 <gc_execute_line+0xfc8>
      switch (gc_state.modal.motion) {
   8341a:	2b07      	cmp	r3, #7
   8341c:	d867      	bhi.n	834ee <gc_execute_line+0xfbe>
   8341e:	e8df f003 	tbb	[pc, r3]
   83422:	0a04      	.short	0x0a04
   83424:	4a412911 	.word	0x4a412911
   83428:	5e54      	.short	0x5e54
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
   8342a:	4880      	ldr	r0, [pc, #512]	; (8362c <gc_execute_line+0x10fc>)
   8342c:	4980      	ldr	r1, [pc, #512]	; (83630 <gc_execute_line+0x1100>)
   8342e:	2200      	movs	r2, #0
   83430:	4b80      	ldr	r3, [pc, #512]	; (83634 <gc_execute_line+0x1104>)
   83432:	4798      	blx	r3
          #endif
          break;
   83434:	e05b      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
   83436:	4b85      	ldr	r3, [pc, #532]	; (8364c <gc_execute_line+0x111c>)
   83438:	487c      	ldr	r0, [pc, #496]	; (8362c <gc_execute_line+0x10fc>)
   8343a:	6919      	ldr	r1, [r3, #16]
   8343c:	785a      	ldrb	r2, [r3, #1]
   8343e:	4b7d      	ldr	r3, [pc, #500]	; (83634 <gc_execute_line+0x1104>)
   83440:	4798      	blx	r3
          #endif
          break;
   83442:	e054      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
   83444:	487c      	ldr	r0, [pc, #496]	; (83638 <gc_execute_line+0x1108>)
   83446:	4b79      	ldr	r3, [pc, #484]	; (8362c <gc_execute_line+0x10fc>)
   83448:	f850 1c0c 	ldr.w	r1, [r0, #-12]
   8344c:	9100      	str	r1, [sp, #0]
   8344e:	f810 2c1b 	ldrb.w	r2, [r0, #-27]
   83452:	9201      	str	r2, [sp, #4]
   83454:	f8cd 9008 	str.w	r9, [sp, #8]
   83458:	f8cd a00c 	str.w	sl, [sp, #12]
   8345c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   8345e:	9204      	str	r2, [sp, #16]
   83460:	2201      	movs	r2, #1
   83462:	9205      	str	r2, [sp, #20]
   83464:	4619      	mov	r1, r3
   83466:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
   8346a:	f853 3c0c 	ldr.w	r3, [r3, #-12]
   8346e:	4c78      	ldr	r4, [pc, #480]	; (83650 <gc_execute_line+0x1120>)
   83470:	47a0      	blx	r4
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
   83472:	e03c      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
   83474:	4870      	ldr	r0, [pc, #448]	; (83638 <gc_execute_line+0x1108>)
   83476:	4b6d      	ldr	r3, [pc, #436]	; (8362c <gc_execute_line+0x10fc>)
   83478:	f850 1c0c 	ldr.w	r1, [r0, #-12]
   8347c:	9100      	str	r1, [sp, #0]
   8347e:	f810 2c1b 	ldrb.w	r2, [r0, #-27]
   83482:	9201      	str	r2, [sp, #4]
   83484:	f8cd 9008 	str.w	r9, [sp, #8]
   83488:	f8cd a00c 	str.w	sl, [sp, #12]
   8348c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   8348e:	9204      	str	r2, [sp, #16]
   83490:	2200      	movs	r2, #0
   83492:	9205      	str	r2, [sp, #20]
   83494:	4619      	mov	r1, r3
   83496:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
   8349a:	f853 3c0c 	ldr.w	r3, [r3, #-12]
   8349e:	4c6c      	ldr	r4, [pc, #432]	; (83650 <gc_execute_line+0x1120>)
   834a0:	47a0      	blx	r4
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
   834a2:	e024      	b.n	834ee <gc_execute_line+0xfbe>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
   834a4:	4969      	ldr	r1, [pc, #420]	; (8364c <gc_execute_line+0x111c>)
   834a6:	784a      	ldrb	r2, [r1, #1]
   834a8:	2300      	movs	r3, #0
   834aa:	9300      	str	r3, [sp, #0]
   834ac:	485f      	ldr	r0, [pc, #380]	; (8362c <gc_execute_line+0x10fc>)
   834ae:	6909      	ldr	r1, [r1, #16]
   834b0:	4c68      	ldr	r4, [pc, #416]	; (83654 <gc_execute_line+0x1124>)
   834b2:	47a0      	blx	r4
          #endif
          break;
   834b4:	e01b      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
   834b6:	4b65      	ldr	r3, [pc, #404]	; (8364c <gc_execute_line+0x111c>)
   834b8:	785a      	ldrb	r2, [r3, #1]
   834ba:	2101      	movs	r1, #1
   834bc:	9100      	str	r1, [sp, #0]
   834be:	485b      	ldr	r0, [pc, #364]	; (8362c <gc_execute_line+0x10fc>)
   834c0:	6919      	ldr	r1, [r3, #16]
   834c2:	2300      	movs	r3, #0
   834c4:	4c63      	ldr	r4, [pc, #396]	; (83654 <gc_execute_line+0x1124>)
   834c6:	47a0      	blx	r4
          #endif
          break;
   834c8:	e011      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
   834ca:	4b60      	ldr	r3, [pc, #384]	; (8364c <gc_execute_line+0x111c>)
   834cc:	785a      	ldrb	r2, [r3, #1]
   834ce:	2100      	movs	r1, #0
   834d0:	9100      	str	r1, [sp, #0]
   834d2:	4856      	ldr	r0, [pc, #344]	; (8362c <gc_execute_line+0x10fc>)
   834d4:	6919      	ldr	r1, [r3, #16]
   834d6:	2301      	movs	r3, #1
   834d8:	4c5e      	ldr	r4, [pc, #376]	; (83654 <gc_execute_line+0x1124>)
   834da:	47a0      	blx	r4
          #endif
          break;
   834dc:	e007      	b.n	834ee <gc_execute_line+0xfbe>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
   834de:	495b      	ldr	r1, [pc, #364]	; (8364c <gc_execute_line+0x111c>)
   834e0:	784a      	ldrb	r2, [r1, #1]
   834e2:	2301      	movs	r3, #1
   834e4:	9300      	str	r3, [sp, #0]
   834e6:	4851      	ldr	r0, [pc, #324]	; (8362c <gc_execute_line+0x10fc>)
   834e8:	6909      	ldr	r1, [r1, #16]
   834ea:	4c5a      	ldr	r4, [pc, #360]	; (83654 <gc_execute_line+0x1124>)
   834ec:	47a0      	blx	r4
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
   834ee:	4b52      	ldr	r3, [pc, #328]	; (83638 <gc_execute_line+0x1108>)
   834f0:	4a4e      	ldr	r2, [pc, #312]	; (8362c <gc_execute_line+0x10fc>)
   834f2:	ca07      	ldmia	r2, {r0, r1, r2}
   834f4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
   834f8:	4b53      	ldr	r3, [pc, #332]	; (83648 <gc_execute_line+0x1118>)
   834fa:	7a18      	ldrb	r0, [r3, #8]
   834fc:	4b53      	ldr	r3, [pc, #332]	; (8364c <gc_execute_line+0x111c>)
   834fe:	71d8      	strb	r0, [r3, #7]
  if (gc_state.modal.program_flow) { 
   83500:	2800      	cmp	r0, #0
   83502:	f000 811c 	beq.w	8373e <gc_execute_line+0x120e>
	protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
   83506:	4b54      	ldr	r3, [pc, #336]	; (83658 <gc_execute_line+0x1128>)
   83508:	4798      	blx	r3
	if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
   8350a:	4b50      	ldr	r3, [pc, #320]	; (8364c <gc_execute_line+0x111c>)
   8350c:	79db      	ldrb	r3, [r3, #7]
   8350e:	2b01      	cmp	r3, #1
   83510:	d10b      	bne.n	8352a <gc_execute_line+0xffa>
	  if (sys.state != STATE_CHECK_MODE) {
   83512:	4b52      	ldr	r3, [pc, #328]	; (8365c <gc_execute_line+0x112c>)
   83514:	785b      	ldrb	r3, [r3, #1]
   83516:	2b02      	cmp	r3, #2
   83518:	d029      	beq.n	8356e <gc_execute_line+0x103e>
		bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); // Use feed hold for program pause.
   8351a:	4a51      	ldr	r2, [pc, #324]	; (83660 <gc_execute_line+0x1130>)
   8351c:	7813      	ldrb	r3, [r2, #0]
   8351e:	f043 0308 	orr.w	r3, r3, #8
   83522:	7013      	strb	r3, [r2, #0]
		protocol_execute_realtime(); // Execute suspend.
   83524:	4b4f      	ldr	r3, [pc, #316]	; (83664 <gc_execute_line+0x1134>)
   83526:	4798      	blx	r3
   83528:	e021      	b.n	8356e <gc_execute_line+0x103e>
	} else { // == PROGRAM_FLOW_COMPLETED
	  // Upon program complete, only a subset of g-codes reset to certain defaults, according to 
	  // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
	  // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
	  // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
	  gc_state.modal.motion = MOTION_MODE_LINEAR;
   8352a:	4b48      	ldr	r3, [pc, #288]	; (8364c <gc_execute_line+0x111c>)
   8352c:	2201      	movs	r2, #1
   8352e:	701a      	strb	r2, [r3, #0]
	  gc_state.modal.plane_select = PLANE_SELECT_XY;
   83530:	2200      	movs	r2, #0
   83532:	711a      	strb	r2, [r3, #4]
	  gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
   83534:	70da      	strb	r2, [r3, #3]
	  gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
   83536:	705a      	strb	r2, [r3, #1]
	  // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
	  gc_state.modal.coord_select = 0; // G54
   83538:	719a      	strb	r2, [r3, #6]
	  gc_state.modal.spindle = SPINDLE_DISABLE;
   8353a:	725a      	strb	r2, [r3, #9]
	  gc_state.modal.coolant = COOLANT_DISABLE;
   8353c:	721a      	strb	r2, [r3, #8]
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
   8353e:	4b47      	ldr	r3, [pc, #284]	; (8365c <gc_execute_line+0x112c>)
   83540:	785b      	ldrb	r3, [r3, #1]
   83542:	2b02      	cmp	r3, #2
   83544:	d010      	beq.n	83568 <gc_execute_line+0x1038>
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
   83546:	4610      	mov	r0, r2
   83548:	a915      	add	r1, sp, #84	; 0x54
   8354a:	4b47      	ldr	r3, [pc, #284]	; (83668 <gc_execute_line+0x1138>)
   8354c:	4798      	blx	r3
   8354e:	2800      	cmp	r0, #0
   83550:	f000 809a 	beq.w	83688 <gc_execute_line+0x1158>
		memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
   83554:	4b45      	ldr	r3, [pc, #276]	; (8366c <gc_execute_line+0x113c>)
   83556:	aa18      	add	r2, sp, #96	; 0x60
   83558:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   8355c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		spindle_stop();
   83560:	4b43      	ldr	r3, [pc, #268]	; (83670 <gc_execute_line+0x1140>)
   83562:	4798      	blx	r3
		coolant_stop();		
   83564:	4b43      	ldr	r3, [pc, #268]	; (83674 <gc_execute_line+0x1144>)
   83566:	4798      	blx	r3
	  }
	  
	  report_feedback_message(MESSAGE_PROGRAM_END);
   83568:	2007      	movs	r0, #7
   8356a:	4b43      	ldr	r3, [pc, #268]	; (83678 <gc_execute_line+0x1148>)
   8356c:	4798      	blx	r3
	}
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
   8356e:	2000      	movs	r0, #0
   83570:	4b36      	ldr	r3, [pc, #216]	; (8364c <gc_execute_line+0x111c>)
   83572:	71d8      	strb	r0, [r3, #7]
   83574:	e0e3      	b.n	8373e <gc_execute_line+0x120e>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
   83576:	2001      	movs	r0, #1
   83578:	e0e1      	b.n	8373e <gc_execute_line+0x120e>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
   8357a:	2002      	movs	r0, #2
   8357c:	e0df      	b.n	8373e <gc_execute_line+0x120e>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
   8357e:	2014      	movs	r0, #20
   83580:	e0dd      	b.n	8373e <gc_execute_line+0x120e>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
   83582:	2018      	movs	r0, #24
   83584:	e0db      	b.n	8373e <gc_execute_line+0x120e>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
   83586:	2014      	movs	r0, #20
   83588:	e0d9      	b.n	8373e <gc_execute_line+0x120e>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
   8358a:	2014      	movs	r0, #20
   8358c:	e0d7      	b.n	8373e <gc_execute_line+0x120e>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
   8358e:	2014      	movs	r0, #20
   83590:	e0d5      	b.n	8373e <gc_execute_line+0x120e>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
   83592:	2018      	movs	r0, #24
   83594:	e0d3      	b.n	8373e <gc_execute_line+0x120e>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
   83596:	2014      	movs	r0, #20
   83598:	e0d1      	b.n	8373e <gc_execute_line+0x120e>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
   8359a:	2014      	movs	r0, #20
   8359c:	e0cf      	b.n	8373e <gc_execute_line+0x120e>
   8359e:	2014      	movs	r0, #20
   835a0:	e0cd      	b.n	8373e <gc_execute_line+0x120e>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
   835a2:	2018      	movs	r0, #24
   835a4:	e0cb      	b.n	8373e <gc_execute_line+0x120e>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
   835a6:	2014      	movs	r0, #20
   835a8:	e0c9      	b.n	8373e <gc_execute_line+0x120e>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
   835aa:	2014      	movs	r0, #20
   835ac:	e0c7      	b.n	8373e <gc_execute_line+0x120e>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
   835ae:	2017      	movs	r0, #23
   835b0:	e0c5      	b.n	8373e <gc_execute_line+0x120e>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
   835b2:	2015      	movs	r0, #21
   835b4:	e0c3      	b.n	8373e <gc_execute_line+0x120e>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
   835b6:	2017      	movs	r0, #23
   835b8:	e0c1      	b.n	8373e <gc_execute_line+0x120e>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
   835ba:	2014      	movs	r0, #20
   835bc:	e0bf      	b.n	8373e <gc_execute_line+0x120e>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
   835be:	2015      	movs	r0, #21
   835c0:	e0bd      	b.n	8373e <gc_execute_line+0x120e>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
   835c2:	2014      	movs	r0, #20
   835c4:	e0bb      	b.n	8373e <gc_execute_line+0x120e>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
   835c6:	2019      	movs	r0, #25
   835c8:	e0b9      	b.n	8373e <gc_execute_line+0x120e>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
   835ca:	2004      	movs	r0, #4
   835cc:	e0b7      	b.n	8373e <gc_execute_line+0x120e>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
   835ce:	201b      	movs	r0, #27
   835d0:	e0b5      	b.n	8373e <gc_execute_line+0x120e>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
   835d2:	2016      	movs	r0, #22
   835d4:	e0b3      	b.n	8373e <gc_execute_line+0x120e>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
   835d6:	201c      	movs	r0, #28
   835d8:	e0b1      	b.n	8373e <gc_execute_line+0x120e>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
   835da:	2025      	movs	r0, #37	; 0x25
   835dc:	e0af      	b.n	8373e <gc_execute_line+0x120e>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
   835de:	201d      	movs	r0, #29
   835e0:	e0ad      	b.n	8373e <gc_execute_line+0x120e>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
   835e2:	2007      	movs	r0, #7
   835e4:	e0ab      	b.n	8373e <gc_execute_line+0x120e>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
   835e6:	201a      	movs	r0, #26
   835e8:	e0a9      	b.n	8373e <gc_execute_line+0x120e>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
   835ea:	201c      	movs	r0, #28
   835ec:	e0a7      	b.n	8373e <gc_execute_line+0x120e>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
   835ee:	201d      	movs	r0, #29
   835f0:	e0a5      	b.n	8373e <gc_execute_line+0x120e>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
   835f2:	2014      	movs	r0, #20
   835f4:	e0a3      	b.n	8373e <gc_execute_line+0x120e>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
   835f6:	2014      	movs	r0, #20
   835f8:	e0a1      	b.n	8373e <gc_execute_line+0x120e>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
   835fa:	2007      	movs	r0, #7
   835fc:	e09f      	b.n	8373e <gc_execute_line+0x120e>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   835fe:	201a      	movs	r0, #26
   83600:	e09d      	b.n	8373e <gc_execute_line+0x120e>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
   83602:	2007      	movs	r0, #7
   83604:	e09b      	b.n	8373e <gc_execute_line+0x120e>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
   83606:	2007      	movs	r0, #7
   83608:	e099      	b.n	8373e <gc_execute_line+0x120e>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
   8360a:	201e      	movs	r0, #30
   8360c:	e097      	b.n	8373e <gc_execute_line+0x120e>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
   8360e:	201f      	movs	r0, #31
   83610:	e095      	b.n	8373e <gc_execute_line+0x120e>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
   83612:	2016      	movs	r0, #22
   83614:	e093      	b.n	8373e <gc_execute_line+0x120e>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   83616:	201a      	movs	r0, #26
   83618:	e091      	b.n	8373e <gc_execute_line+0x120e>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
   8361a:	2020      	movs	r0, #32
   8361c:	e08f      	b.n	8373e <gc_execute_line+0x120e>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
   8361e:	2022      	movs	r0, #34	; 0x22
   83620:	e08d      	b.n	8373e <gc_execute_line+0x120e>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
   83622:	2023      	movs	r0, #35	; 0x23
   83624:	e08b      	b.n	8373e <gc_execute_line+0x120e>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
   83626:	2021      	movs	r0, #33	; 0x21
   83628:	e089      	b.n	8373e <gc_execute_line+0x120e>
   8362a:	bf00      	nop
   8362c:	20001240 	.word	0x20001240
   83630:	bf800000 	.word	0xbf800000
   83634:	00083e6d 	.word	0x00083e6d
   83638:	200011e4 	.word	0x200011e4
   8363c:	00087e81 	.word	0x00087e81
   83640:	200011fc 	.word	0x200011fc
   83644:	0008d1c9 	.word	0x0008d1c9
   83648:	2000120c 	.word	0x2000120c
   8364c:	200011c8 	.word	0x200011c8
   83650:	00083ed1 	.word	0x00083ed1
   83654:	00084369 	.word	0x00084369
   83658:	00085369 	.word	0x00085369
   8365c:	20001484 	.word	0x20001484
   83660:	200011b4 	.word	0x200011b4
   83664:	00085011 	.word	0x00085011
   83668:	00088021 	.word	0x00088021
   8366c:	200011f0 	.word	0x200011f0
   83670:	0008836d 	.word	0x0008836d
   83674:	00080151 	.word	0x00080151
   83678:	0008746d 	.word	0x0008746d
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
   8367c:	2021      	movs	r0, #33	; 0x21
   8367e:	e05e      	b.n	8373e <gc_execute_line+0x120e>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
   83680:	201a      	movs	r0, #26
   83682:	e05c      	b.n	8373e <gc_execute_line+0x120e>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
   83684:	2024      	movs	r0, #36	; 0x24
   83686:	e05a      	b.n	8373e <gc_execute_line+0x120e>
	  gc_state.modal.coolant = COOLANT_DISABLE;
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
   83688:	2007      	movs	r0, #7
   8368a:	e058      	b.n	8373e <gc_execute_line+0x120e>
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
   8368c:	2017      	movs	r0, #23
   8368e:	e056      	b.n	8373e <gc_execute_line+0x120e>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
   83690:	2e1c      	cmp	r6, #28
   83692:	f43f a826 	beq.w	826e2 <gc_execute_line+0x1b2>
   83696:	d807      	bhi.n	836a8 <gc_execute_line+0x1178>
   83698:	2e04      	cmp	r6, #4
   8369a:	f43f a814 	beq.w	826c6 <gc_execute_line+0x196>
   8369e:	2e0a      	cmp	r6, #10
   836a0:	f43f a818 	beq.w	826d4 <gc_execute_line+0x1a4>
   836a4:	f7ff b936 	b.w	82914 <gc_execute_line+0x3e4>
   836a8:	2e35      	cmp	r6, #53	; 0x35
   836aa:	f43f a83c 	beq.w	82726 <gc_execute_line+0x1f6>
   836ae:	2e5c      	cmp	r6, #92	; 0x5c
   836b0:	f43f a840 	beq.w	82734 <gc_execute_line+0x204>
   836b4:	2e1e      	cmp	r6, #30
   836b6:	f47f a92d 	bne.w	82914 <gc_execute_line+0x3e4>
   836ba:	f7ff b823 	b.w	82704 <gc_execute_line+0x1d4>
   836be:	2e1c      	cmp	r6, #28
   836c0:	f43f a811 	beq.w	826e6 <gc_execute_line+0x1b6>
   836c4:	d806      	bhi.n	836d4 <gc_execute_line+0x11a4>
   836c6:	2e04      	cmp	r6, #4
   836c8:	f43e afff 	beq.w	826ca <gc_execute_line+0x19a>
   836cc:	2e0a      	cmp	r6, #10
   836ce:	f43f a803 	beq.w	826d8 <gc_execute_line+0x1a8>
   836d2:	e7db      	b.n	8368c <gc_execute_line+0x115c>
   836d4:	2e35      	cmp	r6, #53	; 0x35
   836d6:	f43f a828 	beq.w	8272a <gc_execute_line+0x1fa>
   836da:	2e5c      	cmp	r6, #92	; 0x5c
   836dc:	f43f a82c 	beq.w	82738 <gc_execute_line+0x208>
   836e0:	2e1e      	cmp	r6, #30
   836e2:	d1d3      	bne.n	8368c <gc_execute_line+0x115c>
   836e4:	f7ff b810 	b.w	82708 <gc_execute_line+0x1d8>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
   836e8:	2c05      	cmp	r4, #5
   836ea:	f43f abd3 	beq.w	82e94 <gc_execute_line+0x964>
   836ee:	2c07      	cmp	r4, #7
   836f0:	f43f abde 	beq.w	82eb0 <gc_execute_line+0x980>
   836f4:	2c03      	cmp	r4, #3
   836f6:	f47f abe0 	bne.w	82eba <gc_execute_line+0x98a>
   836fa:	f7ff bbc3 	b.w	82e84 <gc_execute_line+0x954>
   836fe:	2c05      	cmp	r4, #5
   83700:	f43f abc8 	beq.w	82e94 <gc_execute_line+0x964>
   83704:	2c07      	cmp	r4, #7
   83706:	f43f abd3 	beq.w	82eb0 <gc_execute_line+0x980>
   8370a:	2c03      	cmp	r4, #3
   8370c:	f47f abd5 	bne.w	82eba <gc_execute_line+0x98a>
   83710:	f7ff bbb6 	b.w	82e80 <gc_execute_line+0x950>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
   83714:	4b0b      	ldr	r3, [pc, #44]	; (83744 <gc_execute_line+0x1214>)
   83716:	785c      	ldrb	r4, [r3, #1]
   83718:	2c08      	cmp	r4, #8
   8371a:	f47f abdf 	bne.w	82edc <gc_execute_line+0x9ac>
   8371e:	f7ff bbd6 	b.w	82ece <gc_execute_line+0x99e>
          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
   83722:	4b08      	ldr	r3, [pc, #32]	; (83744 <gc_execute_line+0x1214>)
   83724:	78db      	ldrb	r3, [r3, #3]
   83726:	2b01      	cmp	r3, #1
   83728:	f47f ac6a 	bne.w	83000 <gc_execute_line+0xad0>
   8372c:	e45c      	b.n	82fe8 <gc_execute_line+0xab8>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
   8372e:	f42b 7348 	bic.w	r3, fp, #800	; 0x320
   83732:	f023 0301 	bic.w	r3, r3, #1
   83736:	b29b      	uxth	r3, r3
   83738:	2200      	movs	r2, #0
   8373a:	9209      	str	r2, [sp, #36]	; 0x24
   8373c:	e590      	b.n	83260 <gc_execute_line+0xd30>
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
}
   8373e:	b019      	add	sp, #100	; 0x64
   83740:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   83744:	2000120c 	.word	0x2000120c

00083748 <limits_init>:
#ifndef HOMING_AXIS_LOCATE_SCALAR
  #define HOMING_AXIS_LOCATE_SCALAR  5.0 // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init() 
{
   83748:	4770      	bx	lr
   8374a:	bf00      	nop

0008374c <limits_disable>:
}


// Disables hard limits.
void limits_disable()
{
   8374c:	4770      	bx	lr
   8374e:	bf00      	nop

00083750 <limits_get_state>:
	}
  }
  return(limit_state);
  */
return 0;
}
   83750:	2000      	movs	r0, #0
   83752:	4770      	bx	lr

00083754 <limits_go_home>:
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
  if (sys.abort) { return; } // Block if system reset has been issued.
   83754:	4b82      	ldr	r3, [pc, #520]	; (83960 <limits_go_home+0x20c>)
   83756:	781b      	ldrb	r3, [r3, #0]
   83758:	2b00      	cmp	r3, #0
   8375a:	f040 80ff 	bne.w	8395c <limits_go_home+0x208>
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
   8375e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83762:	b089      	sub	sp, #36	; 0x24
   83764:	4605      	mov	r5, r0
   83766:	f8df 825c 	ldr.w	r8, [pc, #604]	; 839c4 <limits_go_home+0x270>
  if (sys.abort) { return; } // Block if system reset has been issued.
   8376a:	2400      	movs	r4, #0
   8376c:	2700      	movs	r7, #0
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
   8376e:	f8df a258 	ldr.w	sl, [pc, #600]	; 839c8 <limits_go_home+0x274>
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
   83772:	f8df b214 	ldr.w	fp, [pc, #532]	; 83988 <limits_go_home+0x234>
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
   83776:	b2e0      	uxtb	r0, r4
   83778:	47d0      	blx	sl
   8377a:	ab07      	add	r3, sp, #28
   8377c:	5518      	strb	r0, [r3, r4]
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
   8377e:	46a9      	mov	r9, r5
   83780:	fa45 f304 	asr.w	r3, r5, r4
   83784:	f013 0f01 	tst.w	r3, #1
   83788:	d014      	beq.n	837b4 <limits_go_home+0x60>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
   8378a:	f8d8 0000 	ldr.w	r0, [r8]
   8378e:	47d8      	blx	fp
   83790:	2200      	movs	r2, #0
   83792:	4b74      	ldr	r3, [pc, #464]	; (83964 <limits_go_home+0x210>)
   83794:	4e74      	ldr	r6, [pc, #464]	; (83968 <limits_go_home+0x214>)
   83796:	47b0      	blx	r6
   83798:	e9cd 0100 	strd	r0, r1, [sp]
   8379c:	4638      	mov	r0, r7
   8379e:	47d8      	blx	fp
   837a0:	e9dd 2300 	ldrd	r2, r3, [sp]
   837a4:	4e71      	ldr	r6, [pc, #452]	; (8396c <limits_go_home+0x218>)
   837a6:	47b0      	blx	r6
   837a8:	b920      	cbnz	r0, 837b4 <limits_go_home+0x60>
   837aa:	e9dd 0100 	ldrd	r0, r1, [sp]
   837ae:	4b70      	ldr	r3, [pc, #448]	; (83970 <limits_go_home+0x21c>)
   837b0:	4798      	blx	r3
   837b2:	4607      	mov	r7, r0
   837b4:	3401      	adds	r4, #1
   837b6:	f108 0804 	add.w	r8, r8, #4
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
   837ba:	2c03      	cmp	r4, #3
   837bc:	d1db      	bne.n	83776 <limits_go_home+0x22>
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
   837be:	4b6d      	ldr	r3, [pc, #436]	; (83974 <limits_go_home+0x220>)
   837c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   837c2:	9300      	str	r3, [sp, #0]
   837c4:	f04f 0a04 	mov.w	sl, #4
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
   837c8:	2501      	movs	r5, #1
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    sys.homing_axis_lock = axislock;
   837ca:	f8df 8194 	ldr.w	r8, [pc, #404]	; 83960 <limits_go_home+0x20c>
  float homing_rate = settings.homing_seek_rate;

  uint8_t limit_state, axislock, n_active_axis;
  do {

    system_convert_array_steps_to_mpos(target,sys.position);
   837ce:	a804      	add	r0, sp, #16
   837d0:	4969      	ldr	r1, [pc, #420]	; (83978 <limits_go_home+0x224>)
   837d2:	4b6a      	ldr	r3, [pc, #424]	; (8397c <limits_go_home+0x228>)
   837d4:	4798      	blx	r3
      if (bit_istrue(cycle_mask,bit(idx))) {
        n_active_axis++;
        sys.position[idx] = 0;
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
   837d6:	4b67      	ldr	r3, [pc, #412]	; (83974 <limits_go_home+0x220>)
   837d8:	f893 c041 	ldrb.w	ip, [r3, #65]	; 0x41
   837dc:	aa04      	add	r2, sp, #16
   837de:	4b60      	ldr	r3, [pc, #384]	; (83960 <limits_go_home+0x20c>)
   837e0:	9303      	str	r3, [sp, #12]
   837e2:	4619      	mov	r1, r3
   837e4:	2300      	movs	r3, #0

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
   837e6:	461e      	mov	r6, r3
  do {

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
   837e8:	461c      	mov	r4, r3
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
        n_active_axis++;
        sys.position[idx] = 0;
   837ea:	469e      	mov	lr, r3
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
          if (approach) { target[idx] = -max_travel; }
          else { target[idx] = max_travel; }
        } else { 
          if (approach) { target[idx] = max_travel; }
          else { target[idx] = -max_travel; }
   837ec:	f107 4b00 	add.w	fp, r7, #2147483648	; 0x80000000
    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
   837f0:	fa49 f003 	asr.w	r0, r9, r3
   837f4:	f010 0f01 	tst.w	r0, #1
   837f8:	d016      	beq.n	83828 <limits_go_home+0xd4>
        n_active_axis++;
   837fa:	3601      	adds	r6, #1
   837fc:	b2f6      	uxtb	r6, r6
        sys.position[idx] = 0;
   837fe:	f8c1 e004 	str.w	lr, [r1, #4]
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
   83802:	fa4c f003 	asr.w	r0, ip, r3
   83806:	f010 0f01 	tst.w	r0, #1
   8380a:	d005      	beq.n	83818 <limits_go_home+0xc4>
          if (approach) { target[idx] = -max_travel; }
   8380c:	b115      	cbz	r5, 83814 <limits_go_home+0xc0>
   8380e:	f8c2 b000 	str.w	fp, [r2]
   83812:	e006      	b.n	83822 <limits_go_home+0xce>
          else { target[idx] = max_travel; }
   83814:	6017      	str	r7, [r2, #0]
   83816:	e004      	b.n	83822 <limits_go_home+0xce>
        } else { 
          if (approach) { target[idx] = max_travel; }
   83818:	b10d      	cbz	r5, 8381e <limits_go_home+0xca>
   8381a:	6017      	str	r7, [r2, #0]
   8381c:	e001      	b.n	83822 <limits_go_home+0xce>
          else { target[idx] = -max_travel; }
   8381e:	f8c2 b000 	str.w	fp, [r2]
        }        
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
   83822:	a807      	add	r0, sp, #28
   83824:	5c18      	ldrb	r0, [r3, r0]
   83826:	4304      	orrs	r4, r0
   83828:	3301      	adds	r3, #1
   8382a:	3204      	adds	r2, #4
   8382c:	3104      	adds	r1, #4
    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
   8382e:	2b03      	cmp	r3, #3
   83830:	d1de      	bne.n	837f0 <limits_go_home+0x9c>
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
   83832:	4f53      	ldr	r7, [pc, #332]	; (83980 <limits_go_home+0x22c>)
   83834:	4630      	mov	r0, r6
   83836:	47b8      	blx	r7
   83838:	4b52      	ldr	r3, [pc, #328]	; (83984 <limits_go_home+0x230>)
   8383a:	4798      	blx	r3
   8383c:	4606      	mov	r6, r0
   8383e:	460f      	mov	r7, r1
   83840:	9800      	ldr	r0, [sp, #0]
   83842:	4b51      	ldr	r3, [pc, #324]	; (83988 <limits_go_home+0x234>)
   83844:	4798      	blx	r3
   83846:	4632      	mov	r2, r6
   83848:	463b      	mov	r3, r7
   8384a:	4e47      	ldr	r6, [pc, #284]	; (83968 <limits_go_home+0x214>)
   8384c:	47b0      	blx	r6
   8384e:	4606      	mov	r6, r0
   83850:	460f      	mov	r7, r1
    sys.homing_axis_lock = axislock;
   83852:	f888 401d 	strb.w	r4, [r8, #29]

    plan_sync_position(); // Sync planner position to current machine position.
   83856:	4b4d      	ldr	r3, [pc, #308]	; (8398c <limits_go_home+0x238>)
   83858:	4798      	blx	r3
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
   8385a:	4630      	mov	r0, r6
   8385c:	4639      	mov	r1, r7
   8385e:	4b44      	ldr	r3, [pc, #272]	; (83970 <limits_go_home+0x21c>)
   83860:	4798      	blx	r3
   83862:	4601      	mov	r1, r0
    
    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
   83864:	a804      	add	r0, sp, #16
   83866:	2200      	movs	r2, #0
   83868:	4b49      	ldr	r3, [pc, #292]	; (83990 <limits_go_home+0x23c>)
   8386a:	4798      	blx	r3
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
   8386c:	4b49      	ldr	r3, [pc, #292]	; (83994 <limits_go_home+0x240>)
   8386e:	4798      	blx	r3
    st_wake_up(); // Initiate motion
   83870:	4b49      	ldr	r3, [pc, #292]	; (83998 <limits_go_home+0x244>)
   83872:	4798      	blx	r3
		  }
		}
		sys.homing_axis_lock = axislock;
	  }

	  st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
   83874:	4f47      	ldr	r7, [pc, #284]	; (83994 <limits_go_home+0x240>)

	  // Exit routines: No time to run protocol_execute_realtime() in this loop.
	  if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
   83876:	4e49      	ldr	r6, [pc, #292]	; (8399c <limits_go_home+0x248>)
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    st_wake_up(); // Initiate motion
	do {
	  if (approach) {
   83878:	b10d      	cbz	r5, 8387e <limits_go_home+0x12a>
		for (idx=0; idx<N_AXIS; idx++) {
		  if (axislock & step_pin[idx]) {
			if (limit_state & (1 << idx)) { axislock &= ~(step_pin[idx]); }
		  }
		}
		sys.homing_axis_lock = axislock;
   8387a:	f888 401d 	strb.w	r4, [r8, #29]
	  }

	  st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
   8387e:	47b8      	blx	r7

	  // Exit routines: No time to run protocol_execute_realtime() in this loop.
	  if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
   83880:	7833      	ldrb	r3, [r6, #0]
   83882:	f013 0f34 	tst.w	r3, #52	; 0x34
   83886:	d015      	beq.n	838b4 <limits_go_home+0x160>
	    // Homing failure: Limit switches are still engaged after pull-off motion
		if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
   83888:	4b44      	ldr	r3, [pc, #272]	; (8399c <limits_go_home+0x248>)
   8388a:	781b      	ldrb	r3, [r3, #0]
   8388c:	f013 0f30 	tst.w	r3, #48	; 0x30
   83890:	d105      	bne.n	8389e <limits_go_home+0x14a>
		     (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
   83892:	b14d      	cbz	r5, 838a8 <limits_go_home+0x154>
		     ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
   83894:	4b41      	ldr	r3, [pc, #260]	; (8399c <limits_go_home+0x248>)
   83896:	781b      	ldrb	r3, [r3, #0]
   83898:	f013 0f04 	tst.w	r3, #4
   8389c:	d004      	beq.n	838a8 <limits_go_home+0x154>
     	  mc_reset(); // Stop motors, if they are running.
   8389e:	4b40      	ldr	r3, [pc, #256]	; (839a0 <limits_go_home+0x24c>)
   838a0:	4798      	blx	r3
		  protocol_execute_realtime();
   838a2:	4b40      	ldr	r3, [pc, #256]	; (839a4 <limits_go_home+0x250>)
   838a4:	4798      	blx	r3
		  return;
   838a6:	e056      	b.n	83956 <limits_go_home+0x202>
		} else {
		  // Pull-off motion complete. Disable CYCLE_STOP from executing.
          bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
   838a8:	4a3c      	ldr	r2, [pc, #240]	; (8399c <limits_go_home+0x248>)
   838aa:	7813      	ldrb	r3, [r2, #0]
   838ac:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   838b0:	7013      	strb	r3, [r2, #0]
		  break;
   838b2:	e002      	b.n	838ba <limits_go_home+0x166>
		} 
	  }

	} while (STEP_MASK & axislock);
   838b4:	f014 0f1c 	tst.w	r4, #28
   838b8:	d1de      	bne.n	83878 <limits_go_home+0x124>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
   838ba:	4b3b      	ldr	r3, [pc, #236]	; (839a8 <limits_go_home+0x254>)
   838bc:	4798      	blx	r3
    plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
   838be:	4b3b      	ldr	r3, [pc, #236]	; (839ac <limits_go_home+0x258>)
   838c0:	4798      	blx	r3

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
   838c2:	4b2c      	ldr	r3, [pc, #176]	; (83974 <limits_go_home+0x220>)
   838c4:	f8b3 004c 	ldrh.w	r0, [r3, #76]	; 0x4c
   838c8:	4b39      	ldr	r3, [pc, #228]	; (839b0 <limits_go_home+0x25c>)
   838ca:	4798      	blx	r3

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) { 
   838cc:	f095 0501 	eors.w	r5, r5, #1
   838d0:	d008      	beq.n	838e4 <limits_go_home+0x190>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR; 
   838d2:	4c28      	ldr	r4, [pc, #160]	; (83974 <limits_go_home+0x220>)
   838d4:	6d20      	ldr	r0, [r4, #80]	; 0x50
   838d6:	4937      	ldr	r1, [pc, #220]	; (839b4 <limits_go_home+0x260>)
   838d8:	4b37      	ldr	r3, [pc, #220]	; (839b8 <limits_go_home+0x264>)
   838da:	4798      	blx	r3
   838dc:	4607      	mov	r7, r0
      homing_rate = settings.homing_feed_rate;
   838de:	6c63      	ldr	r3, [r4, #68]	; 0x44
   838e0:	9300      	str	r3, [sp, #0]
   838e2:	e003      	b.n	838ec <limits_go_home+0x198>
    } else {
      max_travel = settings.homing_pulloff;    
   838e4:	4b23      	ldr	r3, [pc, #140]	; (83974 <limits_go_home+0x220>)
   838e6:	6d1f      	ldr	r7, [r3, #80]	; 0x50
      homing_rate = settings.homing_seek_rate;
   838e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   838ea:	9300      	str	r3, [sp, #0]
   838ec:	f10a 3aff 	add.w	sl, sl, #4294967295
    }
    
  } while (n_cycle-- > 0);
   838f0:	f01a 0aff 	ands.w	sl, sl, #255	; 0xff
   838f4:	f47f af6b 	bne.w	837ce <limits_go_home+0x7a>
   838f8:	f8dd b00c 	ldr.w	fp, [sp, #12]
   838fc:	4d1d      	ldr	r5, [pc, #116]	; (83974 <limits_go_home+0x220>)
   838fe:	2400      	movs	r4, #0
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
   83900:	462e      	mov	r6, r5
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
   83902:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 839b8 <limits_go_home+0x264>
   83906:	4f20      	ldr	r7, [pc, #128]	; (83988 <limits_go_home+0x234>)
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
   83908:	fa49 f304 	asr.w	r3, r9, r4
   8390c:	f013 0f01 	tst.w	r3, #1
   83910:	d019      	beq.n	83946 <limits_go_home+0x1f2>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
   83912:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
   83916:	4123      	asrs	r3, r4
   83918:	f013 0f01 	tst.w	r3, #1
   8391c:	d009      	beq.n	83932 <limits_go_home+0x1de>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
   8391e:	6a68      	ldr	r0, [r5, #36]	; 0x24
   83920:	6d31      	ldr	r1, [r6, #80]	; 0x50
   83922:	4b26      	ldr	r3, [pc, #152]	; (839bc <limits_go_home+0x268>)
   83924:	4798      	blx	r3
   83926:	6829      	ldr	r1, [r5, #0]
   83928:	47c0      	blx	r8
   8392a:	47b8      	blx	r7
   8392c:	4b24      	ldr	r3, [pc, #144]	; (839c0 <limits_go_home+0x26c>)
   8392e:	4798      	blx	r3
   83930:	e007      	b.n	83942 <limits_go_home+0x1ee>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
   83932:	6d33      	ldr	r3, [r6, #80]	; 0x50
   83934:	f103 4000 	add.w	r0, r3, #2147483648	; 0x80000000
   83938:	6829      	ldr	r1, [r5, #0]
   8393a:	47c0      	blx	r8
   8393c:	47b8      	blx	r7
   8393e:	4b20      	ldr	r3, [pc, #128]	; (839c0 <limits_go_home+0x26c>)
   83940:	4798      	blx	r3
          sys.position[B_MOTOR] = off_axis_position + set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
   83942:	f8cb 0004 	str.w	r0, [fp, #4]
   83946:	3401      	adds	r4, #1
   83948:	f10b 0b04 	add.w	fp, fp, #4
   8394c:	3504      	adds	r5, #4
  #ifdef COREXY
    int32_t off_axis_position = 0;
  #endif
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
   8394e:	2c03      	cmp	r4, #3
   83950:	d1da      	bne.n	83908 <limits_go_home+0x1b4>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
   83952:	4b0e      	ldr	r3, [pc, #56]	; (8398c <limits_go_home+0x238>)
   83954:	4798      	blx	r3
    
  // sys.state = STATE_HOMING; // Ensure system state set as homing before returning. 
}
   83956:	b009      	add	sp, #36	; 0x24
   83958:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8395c:	4770      	bx	lr
   8395e:	bf00      	nop
   83960:	20001484 	.word	0x20001484
   83964:	bff80000 	.word	0xbff80000
   83968:	0008beb5 	.word	0x0008beb5
   8396c:	0008c3d5 	.word	0x0008c3d5
   83970:	0008c479 	.word	0x0008c479
   83974:	20001510 	.word	0x20001510
   83978:	20001488 	.word	0x20001488
   8397c:	00089649 	.word	0x00089649
   83980:	0008bdc9 	.word	0x0008bdc9
   83984:	0008a2dd 	.word	0x0008a2dd
   83988:	0008be0d 	.word	0x0008be0d
   8398c:	00084cbd 	.word	0x00084cbd
   83990:	00084909 	.word	0x00084909
   83994:	00088a21 	.word	0x00088a21
   83998:	000884dd 	.word	0x000884dd
   8399c:	200011b4 	.word	0x200011b4
   839a0:	0008446d 	.word	0x0008446d
   839a4:	00085011 	.word	0x00085011
   839a8:	00088879 	.word	0x00088879
   839ac:	00084821 	.word	0x00084821
   839b0:	00089689 	.word	0x00089689
   839b4:	40a00000 	.word	0x40a00000
   839b8:	0008c735 	.word	0x0008c735
   839bc:	0008c525 	.word	0x0008c525
   839c0:	0008a0a1 	.word	0x0008a0a1
   839c4:	20001534 	.word	0x20001534
   839c8:	0008834d 	.word	0x0008834d

000839cc <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
   839cc:	4770      	bx	lr
   839ce:	bf00      	nop

000839d0 <main>:
FATFS fs; 
FRESULT res;
DIR dir;

int main(void)
{
   839d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   839d4:	b0a9      	sub	sp, #164	; 0xa4
	int x = 150;
	uint32_t ram;
	int i = 0;
	int accel = 150;
	uint8_t flash;
    SystemInit();
   839d6:	4b1e      	ldr	r3, [pc, #120]	; (83a50 <main+0x80>)
   839d8:	4798      	blx	r3
	WDT->WDT_MR = WDT_MR_WDDIS;	// Disable watchdog
   839da:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   839de:	4b1d      	ldr	r3, [pc, #116]	; (83a54 <main+0x84>)
   839e0:	605a      	str	r2, [r3, #4]
	
	tft_init(); 
   839e2:	4b1d      	ldr	r3, [pc, #116]	; (83a58 <main+0x88>)
   839e4:	4798      	blx	r3
	settings_init(); // Load Grbl settings from EEPROM
   839e6:	4b1d      	ldr	r3, [pc, #116]	; (83a5c <main+0x8c>)
   839e8:	4798      	blx	r3
	stepper_init();  // Configure stepper pins and interrupt timers
   839ea:	4b1d      	ldr	r3, [pc, #116]	; (83a60 <main+0x90>)
   839ec:	4798      	blx	r3
	system_init();   // Configure pinout pins and pin-change interrupt		
   839ee:	4b1d      	ldr	r3, [pc, #116]	; (83a64 <main+0x94>)
   839f0:	4798      	blx	r3
	memset(&sys, 0, sizeof(sys));  // Clear all system variables
   839f2:	4a1d      	ldr	r2, [pc, #116]	; (83a68 <main+0x98>)
   839f4:	2400      	movs	r4, #0
   839f6:	4613      	mov	r3, r2
   839f8:	f843 4b04 	str.w	r4, [r3], #4
   839fc:	6054      	str	r4, [r2, #4]
   839fe:	3304      	adds	r3, #4
   83a00:	f843 4b04 	str.w	r4, [r3], #4
   83a04:	f843 4b04 	str.w	r4, [r3], #4
   83a08:	f843 4b04 	str.w	r4, [r3], #4
   83a0c:	f843 4b04 	str.w	r4, [r3], #4
   83a10:	f843 4b04 	str.w	r4, [r3], #4
   83a14:	601c      	str	r4, [r3, #0]
	sys.abort = true;   // Set abort to complete initialization		
   83a16:	2301      	movs	r3, #1
   83a18:	7013      	strb	r3, [r2, #0]
	init_grbl();
   83a1a:	4b14      	ldr	r3, [pc, #80]	; (83a6c <main+0x9c>)
   83a1c:	4798      	blx	r3
	beep(50);
   83a1e:	2032      	movs	r0, #50	; 0x32
   83a20:	4b13      	ldr	r3, [pc, #76]	; (83a70 <main+0xa0>)
   83a22:	4798      	blx	r3
	tft_draw_press_unpress();
   83a24:	4b13      	ldr	r3, [pc, #76]	; (83a74 <main+0xa4>)
   83a26:	4798      	blx	r3
	my_flash_init();
   83a28:	4b13      	ldr	r3, [pc, #76]	; (83a78 <main+0xa8>)
   83a2a:	4798      	blx	r3
	flash = flash_read_8(0);
   83a2c:	4620      	mov	r0, r4
   83a2e:	4b13      	ldr	r3, [pc, #76]	; (83a7c <main+0xac>)
   83a30:	4798      	blx	r3
   83a32:	f88d 001f 	strb.w	r0, [sp, #31]
	if(flash != 0x55) 
   83a36:	2855      	cmp	r0, #85	; 0x55
   83a38:	d026      	beq.n	83a88 <main+0xb8>
	{
		tft_calibrate_touch();
   83a3a:	4b11      	ldr	r3, [pc, #68]	; (83a80 <main+0xb0>)
   83a3c:	4798      	blx	r3
		flash = 0x55;
   83a3e:	a928      	add	r1, sp, #160	; 0xa0
   83a40:	2355      	movs	r3, #85	; 0x55
   83a42:	f801 3d81 	strb.w	r3, [r1, #-129]!
		flash_write_buffer(0,&flash,1);
   83a46:	4620      	mov	r0, r4
   83a48:	2201      	movs	r2, #1
   83a4a:	4b0e      	ldr	r3, [pc, #56]	; (83a84 <main+0xb4>)
   83a4c:	4798      	blx	r3
   83a4e:	e01d      	b.n	83a8c <main+0xbc>
   83a50:	00080265 	.word	0x00080265
   83a54:	400e1a50 	.word	0x400e1a50
   83a58:	00086ad1 	.word	0x00086ad1
   83a5c:	00088321 	.word	0x00088321
   83a60:	000888f5 	.word	0x000888f5
   83a64:	00089215 	.word	0x00089215
   83a68:	20001484 	.word	0x20001484
   83a6c:	000896f1 	.word	0x000896f1
   83a70:	00086c79 	.word	0x00086c79
   83a74:	00086eb5 	.word	0x00086eb5
   83a78:	00082455 	.word	0x00082455
   83a7c:	00082465 	.word	0x00082465
   83a80:	000871cd 	.word	0x000871cd
   83a84:	0008246d 	.word	0x0008246d
	} else 
		tft_calibrate_load();
   83a88:	4ba2      	ldr	r3, [pc, #648]	; (83d14 <main+0x344>)
   83a8a:	4798      	blx	r3
FATFS fs; 
FRESULT res;
DIR dir;

int main(void)
{
   83a8c:	2396      	movs	r3, #150	; 0x96
   83a8e:	9305      	str	r3, [sp, #20]
   83a90:	469b      	mov	fp, r3
   83a92:	f241 3388 	movw	r3, #5000	; 0x1388
   83a96:	9304      	str	r3, [sp, #16]
	tft_delete_all_objects();
	tft_fillScreen(RA8875_LIME);
	tft_textColor(RA8875_BLACK ,RA8875_LIME);
	ram = get_heap_free_size1();
	sprintf(buffer,"HEAP=%8ld",ram);
	tft_textWrite(10,200,0,0,buffer,ALINE_LEFT);
   83a98:	4d9f      	ldr	r5, [pc, #636]	; (83d18 <main+0x348>)
			sprintf(buffer,"G1X%dF%d",x,speed);
			protocol_execute_line(buffer);
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
			while(sys.state == STATE_CYCLE)
			{
				protocol_execute_realtime();	//	CNC
   83a9a:	4ca0      	ldr	r4, [pc, #640]	; (83d1c <main+0x34c>)
		flash = 0x55;
		flash_write_buffer(0,&flash,1);
	} else 
		tft_calibrate_load();
znovu:
	settings.acceleration[0] = accel * 60 * 60;
   83a9c:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   83aa0:	9b05      	ldr	r3, [sp, #20]
   83aa2:	fb00 f003 	mul.w	r0, r0, r3
   83aa6:	4b9e      	ldr	r3, [pc, #632]	; (83d20 <main+0x350>)
   83aa8:	4798      	blx	r3
   83aaa:	4b9e      	ldr	r3, [pc, #632]	; (83d24 <main+0x354>)
   83aac:	6198      	str	r0, [r3, #24]
	settings.acceleration[1] = accel * 60 * 60;
   83aae:	61d8      	str	r0, [r3, #28]
	settings.acceleration[2] = accel * 60 * 60;
   83ab0:	6218      	str	r0, [r3, #32]
	tft_delete_all_objects();
   83ab2:	4b9d      	ldr	r3, [pc, #628]	; (83d28 <main+0x358>)
   83ab4:	4798      	blx	r3
	tft_fillScreen(RA8875_LIME);
   83ab6:	f64c 70e0 	movw	r0, #53216	; 0xcfe0
   83aba:	4b9c      	ldr	r3, [pc, #624]	; (83d2c <main+0x35c>)
   83abc:	4798      	blx	r3
	tft_textColor(RA8875_BLACK ,RA8875_LIME);
   83abe:	2000      	movs	r0, #0
   83ac0:	f64c 71e0 	movw	r1, #53216	; 0xcfe0
   83ac4:	4b9a      	ldr	r3, [pc, #616]	; (83d30 <main+0x360>)
   83ac6:	4798      	blx	r3
	ram = get_heap_free_size1();
   83ac8:	4b9a      	ldr	r3, [pc, #616]	; (83d34 <main+0x364>)
   83aca:	4798      	blx	r3
   83acc:	4602      	mov	r2, r0
	sprintf(buffer,"HEAP=%8ld",ram);
   83ace:	f10d 0920 	add.w	r9, sp, #32
   83ad2:	4648      	mov	r0, r9
   83ad4:	4998      	ldr	r1, [pc, #608]	; (83d38 <main+0x368>)
   83ad6:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 83d80 <main+0x3b0>
   83ada:	47d0      	blx	sl
	tft_textWrite(10,200,0,0,buffer,ALINE_LEFT);
   83adc:	f8cd 9000 	str.w	r9, [sp]
   83ae0:	2300      	movs	r3, #0
   83ae2:	9301      	str	r3, [sp, #4]
   83ae4:	200a      	movs	r0, #10
   83ae6:	21c8      	movs	r1, #200	; 0xc8
   83ae8:	461a      	mov	r2, r3
   83aea:	47a8      	blx	r5
	sprintf(buffer,"G1X%d",x);
   83aec:	4648      	mov	r0, r9
   83aee:	4993      	ldr	r1, [pc, #588]	; (83d3c <main+0x36c>)
   83af0:	465a      	mov	r2, fp
   83af2:	47d0      	blx	sl
	tft_button(10,CalcY(10,4,4),200,CalcHeight(10,4),buffer,1,RA8875_RED,5);
   83af4:	f8cd 9000 	str.w	r9, [sp]
   83af8:	2301      	movs	r3, #1
   83afa:	9301      	str	r3, [sp, #4]
   83afc:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   83b00:	9302      	str	r3, [sp, #8]
   83b02:	2705      	movs	r7, #5
   83b04:	9703      	str	r7, [sp, #12]
   83b06:	200a      	movs	r0, #10
   83b08:	f240 116d 	movw	r1, #365	; 0x16d
   83b0c:	22c8      	movs	r2, #200	; 0xc8
   83b0e:	236e      	movs	r3, #110	; 0x6e
   83b10:	f8df 8290 	ldr.w	r8, [pc, #656]	; 83da4 <main+0x3d4>
   83b14:	47c0      	blx	r8
	sprintf(buffer,"G1X%d",0);
   83b16:	4648      	mov	r0, r9
   83b18:	4988      	ldr	r1, [pc, #544]	; (83d3c <main+0x36c>)
   83b1a:	2200      	movs	r2, #0
   83b1c:	47d0      	blx	sl
	tft_button(220,CalcY(10,4,4),200,CalcHeight(10,4),buffer,2,RA8875_CYAN,5);
   83b1e:	f8cd 9000 	str.w	r9, [sp]
   83b22:	2302      	movs	r3, #2
   83b24:	9301      	str	r3, [sp, #4]
   83b26:	f240 79ff 	movw	r9, #2047	; 0x7ff
   83b2a:	f8cd 9008 	str.w	r9, [sp, #8]
   83b2e:	9703      	str	r7, [sp, #12]
   83b30:	20dc      	movs	r0, #220	; 0xdc
   83b32:	f240 116d 	movw	r1, #365	; 0x16d
   83b36:	22c8      	movs	r2, #200	; 0xc8
   83b38:	236e      	movs	r3, #110	; 0x6e
   83b3a:	47c0      	blx	r8
	tft_button(640,CalcY(10,4,1),150,CalcHeight(10,4),"while(1)",3,RA8875_CYAN,5);
   83b3c:	4b80      	ldr	r3, [pc, #512]	; (83d40 <main+0x370>)
   83b3e:	9300      	str	r3, [sp, #0]
   83b40:	2303      	movs	r3, #3
   83b42:	9301      	str	r3, [sp, #4]
   83b44:	f8cd 9008 	str.w	r9, [sp, #8]
   83b48:	9703      	str	r7, [sp, #12]
   83b4a:	f44f 7020 	mov.w	r0, #640	; 0x280
   83b4e:	4639      	mov	r1, r7
   83b50:	2296      	movs	r2, #150	; 0x96
   83b52:	236e      	movs	r3, #110	; 0x6e
   83b54:	47c0      	blx	r8
	tft_button(640,CalcY(10,4,2),150,CalcHeight(10,4),"set speed",4,RA8875_CYAN,5);
   83b56:	4b7b      	ldr	r3, [pc, #492]	; (83d44 <main+0x374>)
   83b58:	9300      	str	r3, [sp, #0]
   83b5a:	2304      	movs	r3, #4
   83b5c:	9301      	str	r3, [sp, #4]
   83b5e:	f8cd 9008 	str.w	r9, [sp, #8]
   83b62:	9703      	str	r7, [sp, #12]
   83b64:	f44f 7020 	mov.w	r0, #640	; 0x280
   83b68:	217d      	movs	r1, #125	; 0x7d
   83b6a:	2296      	movs	r2, #150	; 0x96
   83b6c:	236e      	movs	r3, #110	; 0x6e
   83b6e:	47c0      	blx	r8
	tft_button(640,CalcY(10,4,3),150,CalcHeight(10,4),"set X size",5,RA8875_CYAN,5);
   83b70:	4b75      	ldr	r3, [pc, #468]	; (83d48 <main+0x378>)
   83b72:	9300      	str	r3, [sp, #0]
   83b74:	9701      	str	r7, [sp, #4]
   83b76:	f8cd 9008 	str.w	r9, [sp, #8]
   83b7a:	9703      	str	r7, [sp, #12]
   83b7c:	f44f 7020 	mov.w	r0, #640	; 0x280
   83b80:	21f5      	movs	r1, #245	; 0xf5
   83b82:	2296      	movs	r2, #150	; 0x96
   83b84:	236e      	movs	r3, #110	; 0x6e
   83b86:	47c0      	blx	r8
	tft_button(640,CalcY(10,4,4),150,CalcHeight(10,4),"set accel",6,RA8875_CYAN,5);
   83b88:	4b70      	ldr	r3, [pc, #448]	; (83d4c <main+0x37c>)
   83b8a:	9300      	str	r3, [sp, #0]
   83b8c:	2306      	movs	r3, #6
   83b8e:	9301      	str	r3, [sp, #4]
   83b90:	f8cd 9008 	str.w	r9, [sp, #8]
   83b94:	9703      	str	r7, [sp, #12]
   83b96:	f44f 7020 	mov.w	r0, #640	; 0x280
   83b9a:	f240 116d 	movw	r1, #365	; 0x16d
   83b9e:	2296      	movs	r2, #150	; 0x96
   83ba0:	236e      	movs	r3, #110	; 0x6e
   83ba2:	47c0      	blx	r8
	tft_button(10,CalcY(10,4,3),200,CalcHeight(10,4),"Select file",7,RA8875_BLUE,5);
   83ba4:	4b6a      	ldr	r3, [pc, #424]	; (83d50 <main+0x380>)
   83ba6:	9300      	str	r3, [sp, #0]
   83ba8:	2307      	movs	r3, #7
   83baa:	9301      	str	r3, [sp, #4]
   83bac:	231f      	movs	r3, #31
   83bae:	9302      	str	r3, [sp, #8]
   83bb0:	9703      	str	r7, [sp, #12]
   83bb2:	200a      	movs	r0, #10
   83bb4:	21f5      	movs	r1, #245	; 0xf5
   83bb6:	22c8      	movs	r2, #200	; 0xc8
   83bb8:	236e      	movs	r3, #110	; 0x6e
   83bba:	47c0      	blx	r8
	f_mount(0,&fs);
   83bbc:	2000      	movs	r0, #0
   83bbe:	4965      	ldr	r1, [pc, #404]	; (83d54 <main+0x384>)
   83bc0:	4b65      	ldr	r3, [pc, #404]	; (83d58 <main+0x388>)
   83bc2:	4798      	blx	r3
	res = f_opendir(&dir, "/");                       /* Open the directory */
   83bc4:	4865      	ldr	r0, [pc, #404]	; (83d5c <main+0x38c>)
   83bc6:	4966      	ldr	r1, [pc, #408]	; (83d60 <main+0x390>)
   83bc8:	4b66      	ldr	r3, [pc, #408]	; (83d64 <main+0x394>)
   83bca:	4798      	blx	r3
   83bcc:	4b66      	ldr	r3, [pc, #408]	; (83d68 <main+0x398>)
   83bce:	7018      	strb	r0, [r3, #0]
	if(res != FR_OK)
   83bd0:	b138      	cbz	r0, 83be2 <main+0x212>
	{
		tft_textWrite(10,100,0,0,"SD Error",ALINE_LEFT);
   83bd2:	4b66      	ldr	r3, [pc, #408]	; (83d6c <main+0x39c>)
   83bd4:	9300      	str	r3, [sp, #0]
   83bd6:	2300      	movs	r3, #0
   83bd8:	9301      	str	r3, [sp, #4]
   83bda:	200a      	movs	r0, #10
   83bdc:	2164      	movs	r1, #100	; 0x64
   83bde:	461a      	mov	r2, r3
   83be0:	47a8      	blx	r5
   83be2:	f8dd 8010 	ldr.w	r8, [sp, #16]
	}
    while (1) 
    {
		draw_pos();
   83be6:	4b62      	ldr	r3, [pc, #392]	; (83d70 <main+0x3a0>)
   83be8:	4798      	blx	r3
		tft_draw_press_unpress();
   83bea:	4b62      	ldr	r3, [pc, #392]	; (83d74 <main+0x3a4>)
   83bec:	4798      	blx	r3
		i++;
		if(Action1 == 1)
   83bee:	4b62      	ldr	r3, [pc, #392]	; (83d78 <main+0x3a8>)
   83bf0:	681b      	ldr	r3, [r3, #0]
   83bf2:	2b01      	cmp	r3, #1
   83bf4:	d11e      	bne.n	83c34 <main+0x264>
		{
			Action1 = 0;
   83bf6:	2200      	movs	r2, #0
   83bf8:	4b5f      	ldr	r3, [pc, #380]	; (83d78 <main+0x3a8>)
   83bfa:	601a      	str	r2, [r3, #0]
			sprintf(buffer,"G1X%dF%d",x,speed);
   83bfc:	a808      	add	r0, sp, #32
   83bfe:	495f      	ldr	r1, [pc, #380]	; (83d7c <main+0x3ac>)
   83c00:	465a      	mov	r2, fp
   83c02:	4643      	mov	r3, r8
   83c04:	4e5e      	ldr	r6, [pc, #376]	; (83d80 <main+0x3b0>)
   83c06:	47b0      	blx	r6
			protocol_execute_line(buffer);
   83c08:	a808      	add	r0, sp, #32
   83c0a:	4b5e      	ldr	r3, [pc, #376]	; (83d84 <main+0x3b4>)
   83c0c:	4798      	blx	r3
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
   83c0e:	4a5e      	ldr	r2, [pc, #376]	; (83d88 <main+0x3b8>)
   83c10:	7813      	ldrb	r3, [r2, #0]
   83c12:	f043 0302 	orr.w	r3, r3, #2
   83c16:	7013      	strb	r3, [r2, #0]
			while(sys.state == STATE_CYCLE)
   83c18:	4b5c      	ldr	r3, [pc, #368]	; (83d8c <main+0x3bc>)
   83c1a:	785b      	ldrb	r3, [r3, #1]
   83c1c:	2b08      	cmp	r3, #8
   83c1e:	d106      	bne.n	83c2e <main+0x25e>
			{
				protocol_execute_realtime();	//	CNC
				draw_pos();
   83c20:	4f53      	ldr	r7, [pc, #332]	; (83d70 <main+0x3a0>)
		{
			Action1 = 0;
			sprintf(buffer,"G1X%dF%d",x,speed);
			protocol_execute_line(buffer);
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
			while(sys.state == STATE_CYCLE)
   83c22:	4e5a      	ldr	r6, [pc, #360]	; (83d8c <main+0x3bc>)
			{
				protocol_execute_realtime();	//	CNC
   83c24:	47a0      	blx	r4
				draw_pos();
   83c26:	47b8      	blx	r7
		{
			Action1 = 0;
			sprintf(buffer,"G1X%dF%d",x,speed);
			protocol_execute_line(buffer);
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
			while(sys.state == STATE_CYCLE)
   83c28:	7873      	ldrb	r3, [r6, #1]
   83c2a:	2b08      	cmp	r3, #8
   83c2c:	d0fa      	beq.n	83c24 <main+0x254>
			{
				protocol_execute_realtime();	//	CNC
				draw_pos();
				i++;
			}
			beep(10);
   83c2e:	200a      	movs	r0, #10
   83c30:	4b57      	ldr	r3, [pc, #348]	; (83d90 <main+0x3c0>)
   83c32:	4798      	blx	r3
		}
		if(Action1 == 2)
   83c34:	4b50      	ldr	r3, [pc, #320]	; (83d78 <main+0x3a8>)
   83c36:	681b      	ldr	r3, [r3, #0]
   83c38:	2b02      	cmp	r3, #2
   83c3a:	d11d      	bne.n	83c78 <main+0x2a8>
		{
			Action1 = 0;
   83c3c:	2200      	movs	r2, #0
   83c3e:	4b4e      	ldr	r3, [pc, #312]	; (83d78 <main+0x3a8>)
   83c40:	601a      	str	r2, [r3, #0]
			sprintf(buffer,"G1X00F%d",speed);
   83c42:	a808      	add	r0, sp, #32
   83c44:	4953      	ldr	r1, [pc, #332]	; (83d94 <main+0x3c4>)
   83c46:	4642      	mov	r2, r8
   83c48:	4b4d      	ldr	r3, [pc, #308]	; (83d80 <main+0x3b0>)
   83c4a:	4798      	blx	r3
			protocol_execute_line(buffer);
   83c4c:	a808      	add	r0, sp, #32
   83c4e:	4b4d      	ldr	r3, [pc, #308]	; (83d84 <main+0x3b4>)
   83c50:	4798      	blx	r3
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
   83c52:	4a4d      	ldr	r2, [pc, #308]	; (83d88 <main+0x3b8>)
   83c54:	7813      	ldrb	r3, [r2, #0]
   83c56:	f043 0302 	orr.w	r3, r3, #2
   83c5a:	7013      	strb	r3, [r2, #0]
			while(sys.state == STATE_CYCLE)
   83c5c:	4b4b      	ldr	r3, [pc, #300]	; (83d8c <main+0x3bc>)
   83c5e:	785b      	ldrb	r3, [r3, #1]
   83c60:	2b08      	cmp	r3, #8
   83c62:	d106      	bne.n	83c72 <main+0x2a2>
			{
				protocol_execute_realtime();	//	CNC
				draw_pos();
   83c64:	4f42      	ldr	r7, [pc, #264]	; (83d70 <main+0x3a0>)
		{
			Action1 = 0;
			sprintf(buffer,"G1X00F%d",speed);
			protocol_execute_line(buffer);
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
			while(sys.state == STATE_CYCLE)
   83c66:	4e49      	ldr	r6, [pc, #292]	; (83d8c <main+0x3bc>)
			{
				protocol_execute_realtime();	//	CNC
   83c68:	47a0      	blx	r4
				draw_pos();
   83c6a:	47b8      	blx	r7
		{
			Action1 = 0;
			sprintf(buffer,"G1X00F%d",speed);
			protocol_execute_line(buffer);
			bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
			while(sys.state == STATE_CYCLE)
   83c6c:	7873      	ldrb	r3, [r6, #1]
   83c6e:	2b08      	cmp	r3, #8
   83c70:	d0fa      	beq.n	83c68 <main+0x298>
			{
				protocol_execute_realtime();	//	CNC
				draw_pos();
				i++;
			}
			beep(10);
   83c72:	200a      	movs	r0, #10
   83c74:	4b46      	ldr	r3, [pc, #280]	; (83d90 <main+0x3c0>)
   83c76:	4798      	blx	r3
		}
		if(Action == 3)
   83c78:	4b47      	ldr	r3, [pc, #284]	; (83d98 <main+0x3c8>)
   83c7a:	681b      	ldr	r3, [r3, #0]
   83c7c:	2b03      	cmp	r3, #3
   83c7e:	f040 80a7 	bne.w	83dd0 <main+0x400>
		{
			Action = 0;
   83c82:	2200      	movs	r2, #0
   83c84:	4b44      	ldr	r3, [pc, #272]	; (83d98 <main+0x3c8>)
   83c86:	601a      	str	r2, [r3, #0]
			while(1)	
			{
				sprintf(buffer,"G1X%dF%d",x,speed);
   83c88:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 83d7c <main+0x3ac>
   83c8c:	4f3c      	ldr	r7, [pc, #240]	; (83d80 <main+0x3b0>)
   83c8e:	a808      	add	r0, sp, #32
   83c90:	4649      	mov	r1, r9
   83c92:	465a      	mov	r2, fp
   83c94:	4643      	mov	r3, r8
   83c96:	47b8      	blx	r7
				protocol_execute_line(buffer);
   83c98:	a808      	add	r0, sp, #32
   83c9a:	4b3a      	ldr	r3, [pc, #232]	; (83d84 <main+0x3b4>)
   83c9c:	4798      	blx	r3
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
   83c9e:	4a3a      	ldr	r2, [pc, #232]	; (83d88 <main+0x3b8>)
   83ca0:	7813      	ldrb	r3, [r2, #0]
   83ca2:	f043 0302 	orr.w	r3, r3, #2
   83ca6:	7013      	strb	r3, [r2, #0]
				while(sys.state == STATE_CYCLE)
   83ca8:	4b38      	ldr	r3, [pc, #224]	; (83d8c <main+0x3bc>)
   83caa:	785b      	ldrb	r3, [r3, #1]
   83cac:	2b08      	cmp	r3, #8
   83cae:	d116      	bne.n	83cde <main+0x30e>
				{
					protocol_execute_realtime();	//	CNC
					tft_textWrite(10,300,0,0,buffer,ALINE_LEFT);
					if(needtouch)
   83cb0:	4e3a      	ldr	r6, [pc, #232]	; (83d9c <main+0x3cc>)
				sprintf(buffer,"G1X%dF%d",x,speed);
				protocol_execute_line(buffer);
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
				while(sys.state == STATE_CYCLE)
				{
					protocol_execute_realtime();	//	CNC
   83cb2:	47a0      	blx	r4
					tft_textWrite(10,300,0,0,buffer,ALINE_LEFT);
   83cb4:	ab08      	add	r3, sp, #32
   83cb6:	9300      	str	r3, [sp, #0]
   83cb8:	2300      	movs	r3, #0
   83cba:	9301      	str	r3, [sp, #4]
   83cbc:	200a      	movs	r0, #10
   83cbe:	f44f 7196 	mov.w	r1, #300	; 0x12c
   83cc2:	461a      	mov	r2, r3
   83cc4:	47a8      	blx	r5
					if(needtouch)
   83cc6:	7833      	ldrb	r3, [r6, #0]
   83cc8:	b11b      	cbz	r3, 83cd2 <main+0x302>
					{
						needtouch = false;
   83cca:	2300      	movs	r3, #0
   83ccc:	7033      	strb	r3, [r6, #0]
						draw_pos();
   83cce:	4b28      	ldr	r3, [pc, #160]	; (83d70 <main+0x3a0>)
   83cd0:	4798      	blx	r3
					}
					tft_draw_press_unpress();
   83cd2:	4b28      	ldr	r3, [pc, #160]	; (83d74 <main+0x3a4>)
   83cd4:	4798      	blx	r3
			while(1)	
			{
				sprintf(buffer,"G1X%dF%d",x,speed);
				protocol_execute_line(buffer);
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
				while(sys.state == STATE_CYCLE)
   83cd6:	4b2d      	ldr	r3, [pc, #180]	; (83d8c <main+0x3bc>)
   83cd8:	785b      	ldrb	r3, [r3, #1]
   83cda:	2b08      	cmp	r3, #8
   83cdc:	d0e9      	beq.n	83cb2 <main+0x2e2>
						draw_pos();
					}
					tft_draw_press_unpress();
					i++;
				}
				if(Action1 == 4) break;
   83cde:	4b26      	ldr	r3, [pc, #152]	; (83d78 <main+0x3a8>)
   83ce0:	681b      	ldr	r3, [r3, #0]
   83ce2:	2b04      	cmp	r3, #4
   83ce4:	d074      	beq.n	83dd0 <main+0x400>
				beep(10);
   83ce6:	200a      	movs	r0, #10
   83ce8:	4b29      	ldr	r3, [pc, #164]	; (83d90 <main+0x3c0>)
   83cea:	4798      	blx	r3
				sprintf(buffer,"G1X0F%d",speed);
   83cec:	a808      	add	r0, sp, #32
   83cee:	492c      	ldr	r1, [pc, #176]	; (83da0 <main+0x3d0>)
   83cf0:	4642      	mov	r2, r8
   83cf2:	47b8      	blx	r7
				protocol_execute_line(buffer);
   83cf4:	a808      	add	r0, sp, #32
   83cf6:	4b23      	ldr	r3, [pc, #140]	; (83d84 <main+0x3b4>)
   83cf8:	4798      	blx	r3
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
   83cfa:	4a23      	ldr	r2, [pc, #140]	; (83d88 <main+0x3b8>)
   83cfc:	7813      	ldrb	r3, [r2, #0]
   83cfe:	f043 0302 	orr.w	r3, r3, #2
   83d02:	7013      	strb	r3, [r2, #0]
				while(sys.state == STATE_CYCLE)
   83d04:	4b21      	ldr	r3, [pc, #132]	; (83d8c <main+0x3bc>)
   83d06:	785b      	ldrb	r3, [r3, #1]
   83d08:	2b08      	cmp	r3, #8
   83d0a:	d159      	bne.n	83dc0 <main+0x3f0>
				{
					protocol_execute_realtime();	//	CNC
					if(needtouch)
   83d0c:	4e23      	ldr	r6, [pc, #140]	; (83d9c <main+0x3cc>)
					{
						needtouch = false;
						draw_pos();
   83d0e:	f8df a060 	ldr.w	sl, [pc, #96]	; 83d70 <main+0x3a0>
   83d12:	e049      	b.n	83da8 <main+0x3d8>
   83d14:	00086c3d 	.word	0x00086c3d
   83d18:	00085679 	.word	0x00085679
   83d1c:	00085011 	.word	0x00085011
   83d20:	0008c68d 	.word	0x0008c68d
   83d24:	20001510 	.word	0x20001510
   83d28:	00086769 	.word	0x00086769
   83d2c:	00085e2d 	.word	0x00085e2d
   83d30:	00085551 	.word	0x00085551
   83d34:	000896b1 	.word	0x000896b1
   83d38:	00091478 	.word	0x00091478
   83d3c:	00091484 	.word	0x00091484
   83d40:	0009148c 	.word	0x0009148c
   83d44:	00091498 	.word	0x00091498
   83d48:	000914a4 	.word	0x000914a4
   83d4c:	000914b0 	.word	0x000914b0
   83d50:	000914bc 	.word	0x000914bc
   83d54:	20001250 	.word	0x20001250
   83d58:	00081fb1 	.word	0x00081fb1
   83d5c:	200014a8 	.word	0x200014a8
   83d60:	000914c8 	.word	0x000914c8
   83d64:	00081fd9 	.word	0x00081fd9
   83d68:	200014cc 	.word	0x200014cc
   83d6c:	000914cc 	.word	0x000914cc
   83d70:	00089761 	.word	0x00089761
   83d74:	00086eb5 	.word	0x00086eb5
   83d78:	200014fc 	.word	0x200014fc
   83d7c:	000914d8 	.word	0x000914d8
   83d80:	0008d291 	.word	0x0008d291
   83d84:	000852fd 	.word	0x000852fd
   83d88:	200011b4 	.word	0x200011b4
   83d8c:	20001484 	.word	0x20001484
   83d90:	00086c79 	.word	0x00086c79
   83d94:	000914e4 	.word	0x000914e4
   83d98:	20001500 	.word	0x20001500
   83d9c:	20000f4a 	.word	0x20000f4a
   83da0:	000914f0 	.word	0x000914f0
   83da4:	0008688d 	.word	0x0008688d
				sprintf(buffer,"G1X0F%d",speed);
				protocol_execute_line(buffer);
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
				while(sys.state == STATE_CYCLE)
				{
					protocol_execute_realtime();	//	CNC
   83da8:	47a0      	blx	r4
					if(needtouch)
   83daa:	7833      	ldrb	r3, [r6, #0]
   83dac:	b113      	cbz	r3, 83db4 <main+0x3e4>
					{
						needtouch = false;
   83dae:	2300      	movs	r3, #0
   83db0:	7033      	strb	r3, [r6, #0]
						draw_pos();
   83db2:	47d0      	blx	sl
					}
					tft_draw_press_unpress();
   83db4:	4b22      	ldr	r3, [pc, #136]	; (83e40 <main+0x470>)
   83db6:	4798      	blx	r3
				if(Action1 == 4) break;
				beep(10);
				sprintf(buffer,"G1X0F%d",speed);
				protocol_execute_line(buffer);
				bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
				while(sys.state == STATE_CYCLE)
   83db8:	4b22      	ldr	r3, [pc, #136]	; (83e44 <main+0x474>)
   83dba:	785b      	ldrb	r3, [r3, #1]
   83dbc:	2b08      	cmp	r3, #8
   83dbe:	d0f3      	beq.n	83da8 <main+0x3d8>
						draw_pos();
					}
					tft_draw_press_unpress();
					i++;
				}
				if(Action1 == 4) break;
   83dc0:	4b21      	ldr	r3, [pc, #132]	; (83e48 <main+0x478>)
   83dc2:	681b      	ldr	r3, [r3, #0]
   83dc4:	2b04      	cmp	r3, #4
   83dc6:	d003      	beq.n	83dd0 <main+0x400>
				beep(10);
   83dc8:	200a      	movs	r0, #10
   83dca:	4b20      	ldr	r3, [pc, #128]	; (83e4c <main+0x47c>)
   83dcc:	4798      	blx	r3
			}
   83dce:	e75e      	b.n	83c8e <main+0x2be>
		}
		if(Action1 == 4)
   83dd0:	4b1d      	ldr	r3, [pc, #116]	; (83e48 <main+0x478>)
   83dd2:	681b      	ldr	r3, [r3, #0]
   83dd4:	2b04      	cmp	r3, #4
   83dd6:	d109      	bne.n	83dec <main+0x41c>
		{
			Action1 = 0;
   83dd8:	2200      	movs	r2, #0
   83dda:	4b1b      	ldr	r3, [pc, #108]	; (83e48 <main+0x478>)
   83ddc:	601a      	str	r2, [r3, #0]
			speed = tft_GetInt("speed",speed,0,100000);
   83dde:	481c      	ldr	r0, [pc, #112]	; (83e50 <main+0x480>)
   83de0:	9904      	ldr	r1, [sp, #16]
   83de2:	4b1c      	ldr	r3, [pc, #112]	; (83e54 <main+0x484>)
   83de4:	4e1c      	ldr	r6, [pc, #112]	; (83e58 <main+0x488>)
   83de6:	47b0      	blx	r6
   83de8:	9004      	str	r0, [sp, #16]
			goto znovu;
   83dea:	e657      	b.n	83a9c <main+0xcc>
		}
		if(Action1 == 5)
   83dec:	4b16      	ldr	r3, [pc, #88]	; (83e48 <main+0x478>)
   83dee:	681b      	ldr	r3, [r3, #0]
   83df0:	2b05      	cmp	r3, #5
   83df2:	d10a      	bne.n	83e0a <main+0x43a>
		{
			Action1 = 0;
   83df4:	2200      	movs	r2, #0
   83df6:	4b14      	ldr	r3, [pc, #80]	; (83e48 <main+0x478>)
   83df8:	601a      	str	r2, [r3, #0]
			x = tft_GetInt("X",x,0,10000);
   83dfa:	4818      	ldr	r0, [pc, #96]	; (83e5c <main+0x48c>)
   83dfc:	4659      	mov	r1, fp
   83dfe:	f242 7310 	movw	r3, #10000	; 0x2710
   83e02:	4f15      	ldr	r7, [pc, #84]	; (83e58 <main+0x488>)
   83e04:	47b8      	blx	r7
   83e06:	4683      	mov	fp, r0
			goto znovu;
   83e08:	e648      	b.n	83a9c <main+0xcc>
		}
		if(Action1 == 6)
   83e0a:	4b0f      	ldr	r3, [pc, #60]	; (83e48 <main+0x478>)
   83e0c:	681b      	ldr	r3, [r3, #0]
   83e0e:	2b06      	cmp	r3, #6
   83e10:	d10a      	bne.n	83e28 <main+0x458>
		{
			Action1 = 0;
   83e12:	2200      	movs	r2, #0
   83e14:	4b0c      	ldr	r3, [pc, #48]	; (83e48 <main+0x478>)
   83e16:	601a      	str	r2, [r3, #0]
			accel = tft_GetInt("accel",accel,0,10000);
   83e18:	4811      	ldr	r0, [pc, #68]	; (83e60 <main+0x490>)
   83e1a:	9905      	ldr	r1, [sp, #20]
   83e1c:	f242 7310 	movw	r3, #10000	; 0x2710
   83e20:	4f0d      	ldr	r7, [pc, #52]	; (83e58 <main+0x488>)
   83e22:	47b8      	blx	r7
   83e24:	9005      	str	r0, [sp, #20]
			goto znovu;
   83e26:	e639      	b.n	83a9c <main+0xcc>
		}
		if(Action1 == 7)
   83e28:	4b07      	ldr	r3, [pc, #28]	; (83e48 <main+0x478>)
   83e2a:	681b      	ldr	r3, [r3, #0]
   83e2c:	2b07      	cmp	r3, #7
   83e2e:	f47f aeda 	bne.w	83be6 <main+0x216>
		{
			Action1 = 0;
   83e32:	2200      	movs	r2, #0
   83e34:	4b04      	ldr	r3, [pc, #16]	; (83e48 <main+0x478>)
   83e36:	601a      	str	r2, [r3, #0]
			select_file("");
   83e38:	480a      	ldr	r0, [pc, #40]	; (83e64 <main+0x494>)
   83e3a:	4b0b      	ldr	r3, [pc, #44]	; (83e68 <main+0x498>)
   83e3c:	4798      	blx	r3
			goto znovu;
   83e3e:	e62d      	b.n	83a9c <main+0xcc>
   83e40:	00086eb5 	.word	0x00086eb5
   83e44:	20001484 	.word	0x20001484
   83e48:	200014fc 	.word	0x200014fc
   83e4c:	00086c79 	.word	0x00086c79
   83e50:	0009149c 	.word	0x0009149c
   83e54:	000186a0 	.word	0x000186a0
   83e58:	00086f69 	.word	0x00086f69
   83e5c:	000922d8 	.word	0x000922d8
   83e60:	000914b4 	.word	0x000914b4
   83e64:	00091d60 	.word	0x00091d60
   83e68:	0008990d 	.word	0x0008990d

00083e6c <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
   83e6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   83e70:	4607      	mov	r7, r0
   83e72:	4689      	mov	r9, r1
   83e74:	4690      	mov	r8, r2
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
   83e76:	4b0f      	ldr	r3, [pc, #60]	; (83eb4 <mc_line+0x48>)
   83e78:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   83e7c:	f013 0f20 	tst.w	r3, #32
   83e80:	d001      	beq.n	83e86 <mc_line+0x1a>
   83e82:	4b0d      	ldr	r3, [pc, #52]	; (83eb8 <mc_line+0x4c>)
   83e84:	4798      	blx	r3
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
   83e86:	4b0d      	ldr	r3, [pc, #52]	; (83ebc <mc_line+0x50>)
   83e88:	785b      	ldrb	r3, [r3, #1]
   83e8a:	2b02      	cmp	r3, #2
   83e8c:	d00f      	beq.n	83eae <mc_line+0x42>
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
   83e8e:	4d0c      	ldr	r5, [pc, #48]	; (83ec0 <mc_line+0x54>)
    if (sys.abort) { return; } // Bail, if system abort.
   83e90:	4c0a      	ldr	r4, [pc, #40]	; (83ebc <mc_line+0x50>)
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
   83e92:	4e0c      	ldr	r6, [pc, #48]	; (83ec4 <mc_line+0x58>)
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
   83e94:	47a8      	blx	r5
    if (sys.abort) { return; } // Bail, if system abort.
   83e96:	7823      	ldrb	r3, [r4, #0]
   83e98:	b94b      	cbnz	r3, 83eae <mc_line+0x42>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
   83e9a:	47b0      	blx	r6
   83e9c:	b110      	cbz	r0, 83ea4 <mc_line+0x38>
   83e9e:	4b0a      	ldr	r3, [pc, #40]	; (83ec8 <mc_line+0x5c>)
   83ea0:	4798      	blx	r3
    else { break; }
  } while (1);
   83ea2:	e7f7      	b.n	83e94 <mc_line+0x28>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
   83ea4:	4638      	mov	r0, r7
   83ea6:	4649      	mov	r1, r9
   83ea8:	4642      	mov	r2, r8
   83eaa:	4b08      	ldr	r3, [pc, #32]	; (83ecc <mc_line+0x60>)
   83eac:	4798      	blx	r3
   83eae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   83eb2:	bf00      	nop
   83eb4:	20001510 	.word	0x20001510
   83eb8:	000839cd 	.word	0x000839cd
   83ebc:	20001484 	.word	0x20001484
   83ec0:	00085011 	.word	0x00085011
   83ec4:	000848f1 	.word	0x000848f1
   83ec8:	00085359 	.word	0x00085359
   83ecc:	00084909 	.word	0x00084909

00083ed0 <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
   83ed0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83ed4:	b093      	sub	sp, #76	; 0x4c
   83ed6:	9005      	str	r0, [sp, #20]
   83ed8:	9111      	str	r1, [sp, #68]	; 0x44
   83eda:	4616      	mov	r6, r2
   83edc:	4699      	mov	r9, r3
   83ede:	f89d 4074 	ldrb.w	r4, [sp, #116]	; 0x74
   83ee2:	9406      	str	r4, [sp, #24]
   83ee4:	f89d 7078 	ldrb.w	r7, [sp, #120]	; 0x78
   83ee8:	f89d 407c 	ldrb.w	r4, [sp, #124]	; 0x7c
   83eec:	f89d 5080 	ldrb.w	r5, [sp, #128]	; 0x80
   83ef0:	950c      	str	r5, [sp, #48]	; 0x30
  float center_axis0 = position[axis_0] + offset[axis_0];
   83ef2:	00bb      	lsls	r3, r7, #2
   83ef4:	4602      	mov	r2, r0
   83ef6:	4418      	add	r0, r3
   83ef8:	9009      	str	r0, [sp, #36]	; 0x24
   83efa:	18f0      	adds	r0, r6, r3
   83efc:	900e      	str	r0, [sp, #56]	; 0x38
   83efe:	f856 8027 	ldr.w	r8, [r6, r7, lsl #2]
   83f02:	4d97      	ldr	r5, [pc, #604]	; (84160 <mc_arc+0x290>)
   83f04:	4640      	mov	r0, r8
   83f06:	f852 1027 	ldr.w	r1, [r2, r7, lsl #2]
   83f0a:	47a8      	blx	r5
   83f0c:	9007      	str	r0, [sp, #28]
  float center_axis1 = position[axis_1] + offset[axis_1];
   83f0e:	00a3      	lsls	r3, r4, #2
   83f10:	9905      	ldr	r1, [sp, #20]
   83f12:	eb01 0b03 	add.w	fp, r1, r3
   83f16:	18f2      	adds	r2, r6, r3
   83f18:	920f      	str	r2, [sp, #60]	; 0x3c
   83f1a:	f856 a024 	ldr.w	sl, [r6, r4, lsl #2]
   83f1e:	4650      	mov	r0, sl
   83f20:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
   83f24:	47a8      	blx	r5
   83f26:	9008      	str	r0, [sp, #32]
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
   83f28:	f108 4200 	add.w	r2, r8, #2147483648	; 0x80000000
   83f2c:	9200      	str	r2, [sp, #0]
  float r_axis1 = -offset[axis_1];
   83f2e:	f10a 4a00 	add.w	sl, sl, #2147483648	; 0x80000000
  float rt_axis0 = target[axis_0] - center_axis0;
   83f32:	4e8c      	ldr	r6, [pc, #560]	; (84164 <mc_arc+0x294>)
   83f34:	9b11      	ldr	r3, [sp, #68]	; 0x44
   83f36:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   83f3a:	9907      	ldr	r1, [sp, #28]
   83f3c:	47b0      	blx	r6
   83f3e:	4680      	mov	r8, r0
  float rt_axis1 = target[axis_1] - center_axis1;
   83f40:	9b11      	ldr	r3, [sp, #68]	; 0x44
   83f42:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   83f46:	9908      	ldr	r1, [sp, #32]
   83f48:	47b0      	blx	r6
   83f4a:	4607      	mov	r7, r0
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
   83f4c:	4c86      	ldr	r4, [pc, #536]	; (84168 <mc_arc+0x298>)
   83f4e:	9800      	ldr	r0, [sp, #0]
   83f50:	4639      	mov	r1, r7
   83f52:	47a0      	blx	r4
   83f54:	9002      	str	r0, [sp, #8]
   83f56:	4650      	mov	r0, sl
   83f58:	4641      	mov	r1, r8
   83f5a:	47a0      	blx	r4
   83f5c:	4601      	mov	r1, r0
   83f5e:	9802      	ldr	r0, [sp, #8]
   83f60:	47b0      	blx	r6
   83f62:	4e82      	ldr	r6, [pc, #520]	; (8416c <mc_arc+0x29c>)
   83f64:	47b0      	blx	r6
   83f66:	e9cd 0102 	strd	r0, r1, [sp, #8]
   83f6a:	9800      	ldr	r0, [sp, #0]
   83f6c:	4641      	mov	r1, r8
   83f6e:	47a0      	blx	r4
   83f70:	4680      	mov	r8, r0
   83f72:	4650      	mov	r0, sl
   83f74:	4639      	mov	r1, r7
   83f76:	47a0      	blx	r4
   83f78:	4601      	mov	r1, r0
   83f7a:	4640      	mov	r0, r8
   83f7c:	47a8      	blx	r5
   83f7e:	47b0      	blx	r6
   83f80:	4602      	mov	r2, r0
   83f82:	460b      	mov	r3, r1
   83f84:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   83f88:	4c79      	ldr	r4, [pc, #484]	; (84170 <mc_arc+0x2a0>)
   83f8a:	47a0      	blx	r4
   83f8c:	4b79      	ldr	r3, [pc, #484]	; (84174 <mc_arc+0x2a4>)
   83f8e:	4798      	blx	r3
   83f90:	9002      	str	r0, [sp, #8]
  if (is_clockwise_arc) { // Correct atan2 output per direction
   83f92:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
   83f96:	b19b      	cbz	r3, 83fc0 <mc_arc+0xf0>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
   83f98:	47b0      	blx	r6
   83f9a:	4604      	mov	r4, r0
   83f9c:	460d      	mov	r5, r1
   83f9e:	a368      	add	r3, pc, #416	; (adr r3, 84140 <mc_arc+0x270>)
   83fa0:	e9d3 2300 	ldrd	r2, r3, [r3]
   83fa4:	4e74      	ldr	r6, [pc, #464]	; (84178 <mc_arc+0x2a8>)
   83fa6:	47b0      	blx	r6
   83fa8:	b1f8      	cbz	r0, 83fea <mc_arc+0x11a>
   83faa:	4620      	mov	r0, r4
   83fac:	4629      	mov	r1, r5
   83fae:	a366      	add	r3, pc, #408	; (adr r3, 84148 <mc_arc+0x278>)
   83fb0:	e9d3 2300 	ldrd	r2, r3, [r3]
   83fb4:	4c71      	ldr	r4, [pc, #452]	; (8417c <mc_arc+0x2ac>)
   83fb6:	47a0      	blx	r4
   83fb8:	4b6e      	ldr	r3, [pc, #440]	; (84174 <mc_arc+0x2a4>)
   83fba:	4798      	blx	r3
   83fbc:	9002      	str	r0, [sp, #8]
   83fbe:	e014      	b.n	83fea <mc_arc+0x11a>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
   83fc0:	9802      	ldr	r0, [sp, #8]
   83fc2:	4b6a      	ldr	r3, [pc, #424]	; (8416c <mc_arc+0x29c>)
   83fc4:	4798      	blx	r3
   83fc6:	4604      	mov	r4, r0
   83fc8:	460d      	mov	r5, r1
   83fca:	a361      	add	r3, pc, #388	; (adr r3, 84150 <mc_arc+0x280>)
   83fcc:	e9d3 2300 	ldrd	r2, r3, [r3]
   83fd0:	4e6b      	ldr	r6, [pc, #428]	; (84180 <mc_arc+0x2b0>)
   83fd2:	47b0      	blx	r6
   83fd4:	b148      	cbz	r0, 83fea <mc_arc+0x11a>
   83fd6:	4620      	mov	r0, r4
   83fd8:	4629      	mov	r1, r5
   83fda:	a35b      	add	r3, pc, #364	; (adr r3, 84148 <mc_arc+0x278>)
   83fdc:	e9d3 2300 	ldrd	r2, r3, [r3]
   83fe0:	4c68      	ldr	r4, [pc, #416]	; (84184 <mc_arc+0x2b4>)
   83fe2:	47a0      	blx	r4
   83fe4:	4b63      	ldr	r3, [pc, #396]	; (84174 <mc_arc+0x2a4>)
   83fe6:	4798      	blx	r3
   83fe8:	9002      	str	r0, [sp, #8]
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
   83fea:	4b67      	ldr	r3, [pc, #412]	; (84188 <mc_arc+0x2b8>)
   83fec:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   83fee:	f8df 8170 	ldr.w	r8, [pc, #368]	; 84160 <mc_arc+0x290>
   83ff2:	4648      	mov	r0, r9
   83ff4:	4649      	mov	r1, r9
   83ff6:	47c0      	blx	r8
   83ff8:	900a      	str	r0, [sp, #40]	; 0x28
   83ffa:	4f5a      	ldr	r7, [pc, #360]	; (84164 <mc_arc+0x294>)
   83ffc:	4d5a      	ldr	r5, [pc, #360]	; (84168 <mc_arc+0x298>)
   83ffe:	4e5b      	ldr	r6, [pc, #364]	; (8416c <mc_arc+0x29c>)
   84000:	980a      	ldr	r0, [sp, #40]	; 0x28
   84002:	4621      	mov	r1, r4
   84004:	47b8      	blx	r7
   84006:	4601      	mov	r1, r0
   84008:	4620      	mov	r0, r4
   8400a:	47a8      	blx	r5
   8400c:	47b0      	blx	r6
   8400e:	4b5f      	ldr	r3, [pc, #380]	; (8418c <mc_arc+0x2bc>)
   84010:	4798      	blx	r3
   84012:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
   84016:	9802      	ldr	r0, [sp, #8]
   84018:	47b0      	blx	r6
   8401a:	4f5d      	ldr	r7, [pc, #372]	; (84190 <mc_arc+0x2c0>)
   8401c:	2200      	movs	r2, #0
   8401e:	4b5d      	ldr	r3, [pc, #372]	; (84194 <mc_arc+0x2c4>)
   84020:	47b8      	blx	r7
   84022:	4604      	mov	r4, r0
   84024:	460d      	mov	r5, r1
   84026:	4648      	mov	r0, r9
   84028:	47b0      	blx	r6
   8402a:	4602      	mov	r2, r0
   8402c:	460b      	mov	r3, r1
   8402e:	4620      	mov	r0, r4
   84030:	4629      	mov	r1, r5
   84032:	47b8      	blx	r7
   84034:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   84038:	4619      	mov	r1, r3
   8403a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   8403e:	4c56      	ldr	r4, [pc, #344]	; (84198 <mc_arc+0x2c8>)
   84040:	47a0      	blx	r4
   84042:	4b56      	ldr	r3, [pc, #344]	; (8419c <mc_arc+0x2cc>)
   84044:	4798      	blx	r3
   84046:	4b56      	ldr	r3, [pc, #344]	; (841a0 <mc_arc+0x2d0>)
   84048:	4798      	blx	r3
   8404a:	fa1f f980 	uxth.w	r9, r0
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
   8404e:	f1b9 0f00 	cmp.w	r9, #0
   84052:	f000 80ff 	beq.w	84254 <mc_arc+0x384>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
   84056:	9b06      	ldr	r3, [sp, #24]
   84058:	b13b      	cbz	r3, 8406a <mc_arc+0x19a>
   8405a:	4648      	mov	r0, r9
   8405c:	4b51      	ldr	r3, [pc, #324]	; (841a4 <mc_arc+0x2d4>)
   8405e:	4798      	blx	r3
   84060:	4601      	mov	r1, r0
   84062:	981c      	ldr	r0, [sp, #112]	; 0x70
   84064:	4b40      	ldr	r3, [pc, #256]	; (84168 <mc_arc+0x298>)
   84066:	4798      	blx	r3
   84068:	901c      	str	r0, [sp, #112]	; 0x70
   
    float theta_per_segment = angular_travel/segments;
   8406a:	4648      	mov	r0, r9
   8406c:	4b4d      	ldr	r3, [pc, #308]	; (841a4 <mc_arc+0x2d4>)
   8406e:	4798      	blx	r3
   84070:	4606      	mov	r6, r0
   84072:	4c4d      	ldr	r4, [pc, #308]	; (841a8 <mc_arc+0x2d8>)
   84074:	9802      	ldr	r0, [sp, #8]
   84076:	4631      	mov	r1, r6
   84078:	47a0      	blx	r4
   8407a:	4607      	mov	r7, r0
   8407c:	9010      	str	r0, [sp, #64]	; 0x40
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
   8407e:	9905      	ldr	r1, [sp, #20]
   84080:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   84082:	eb01 0882 	add.w	r8, r1, r2, lsl #2
   84086:	4d37      	ldr	r5, [pc, #220]	; (84164 <mc_arc+0x294>)
   84088:	9b11      	ldr	r3, [sp, #68]	; 0x44
   8408a:	4618      	mov	r0, r3
   8408c:	4613      	mov	r3, r2
   8408e:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
   84092:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
   84096:	47a8      	blx	r5
   84098:	4631      	mov	r1, r6
   8409a:	47a0      	blx	r4
   8409c:	900a      	str	r0, [sp, #40]	; 0x28
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
   8409e:	4c32      	ldr	r4, [pc, #200]	; (84168 <mc_arc+0x298>)
   840a0:	4638      	mov	r0, r7
   840a2:	463e      	mov	r6, r7
   840a4:	4639      	mov	r1, r7
   840a6:	47a0      	blx	r4
   840a8:	4601      	mov	r1, r0
   840aa:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
   840ae:	47a8      	blx	r5
   840b0:	4605      	mov	r5, r0
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
   840b2:	4f2e      	ldr	r7, [pc, #184]	; (8416c <mc_arc+0x29c>)
   840b4:	4630      	mov	r0, r6
   840b6:	47b8      	blx	r7
   840b8:	4e35      	ldr	r6, [pc, #212]	; (84190 <mc_arc+0x2c0>)
   840ba:	a327      	add	r3, pc, #156	; (adr r3, 84158 <mc_arc+0x288>)
   840bc:	e9d3 2300 	ldrd	r2, r3, [r3]
   840c0:	47b0      	blx	r6
   840c2:	e9cd 0102 	strd	r0, r1, [sp, #8]
   840c6:	4628      	mov	r0, r5
   840c8:	47b8      	blx	r7
   840ca:	2200      	movs	r2, #0
   840cc:	4b37      	ldr	r3, [pc, #220]	; (841ac <mc_arc+0x2dc>)
   840ce:	4f2d      	ldr	r7, [pc, #180]	; (84184 <mc_arc+0x2b4>)
   840d0:	47b8      	blx	r7
   840d2:	4602      	mov	r2, r0
   840d4:	460b      	mov	r3, r1
   840d6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   840da:	47b0      	blx	r6
   840dc:	4b25      	ldr	r3, [pc, #148]	; (84174 <mc_arc+0x2a4>)
   840de:	4798      	blx	r3
   840e0:	900c      	str	r0, [sp, #48]	; 0x30
    cos_T *= 0.5;
   840e2:	4628      	mov	r0, r5
   840e4:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   840e8:	47a0      	blx	r4
   840ea:	900d      	str	r0, [sp, #52]	; 0x34
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
   840ec:	f1b9 0f01 	cmp.w	r9, #1
   840f0:	f240 80b0 	bls.w	84254 <mc_arc+0x384>
   840f4:	2501      	movs	r5, #1
   840f6:	2600      	movs	r6, #0
        r_axis1 = r_axisi;
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
   840f8:	465f      	mov	r7, fp
   840fa:	46cb      	mov	fp, r9
   840fc:	46b1      	mov	r9, r6
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
   840fe:	f1b9 0f0b 	cmp.w	r9, #11
   84102:	d855      	bhi.n	841b0 <mc_arc+0x2e0>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
   84104:	4650      	mov	r0, sl
   84106:	990d      	ldr	r1, [sp, #52]	; 0x34
   84108:	47a0      	blx	r4
   8410a:	4606      	mov	r6, r0
   8410c:	9800      	ldr	r0, [sp, #0]
   8410e:	990c      	ldr	r1, [sp, #48]	; 0x30
   84110:	47a0      	blx	r4
   84112:	4631      	mov	r1, r6
   84114:	4b12      	ldr	r3, [pc, #72]	; (84160 <mc_arc+0x290>)
   84116:	4798      	blx	r3
   84118:	4606      	mov	r6, r0
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
   8411a:	9800      	ldr	r0, [sp, #0]
   8411c:	990d      	ldr	r1, [sp, #52]	; 0x34
   8411e:	47a0      	blx	r4
   84120:	9000      	str	r0, [sp, #0]
   84122:	4650      	mov	r0, sl
   84124:	990c      	ldr	r1, [sp, #48]	; 0x30
   84126:	47a0      	blx	r4
   84128:	4601      	mov	r1, r0
   8412a:	9800      	ldr	r0, [sp, #0]
   8412c:	4b0d      	ldr	r3, [pc, #52]	; (84164 <mc_arc+0x294>)
   8412e:	4798      	blx	r3
   84130:	9000      	str	r0, [sp, #0]
        r_axis1 = r_axisi;
        count++;
   84132:	f109 0901 	add.w	r9, r9, #1
   84136:	fa5f f989 	uxtb.w	r9, r9
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
   8413a:	46b2      	mov	sl, r6
   8413c:	e06d      	b.n	8421a <mc_arc+0x34a>
   8413e:	bf00      	nop
   84140:	a0b5ed8d 	.word	0xa0b5ed8d
   84144:	bea0c6f7 	.word	0xbea0c6f7
   84148:	54442d18 	.word	0x54442d18
   8414c:	401921fb 	.word	0x401921fb
   84150:	a0b5ed8d 	.word	0xa0b5ed8d
   84154:	3ea0c6f7 	.word	0x3ea0c6f7
   84158:	5c7dda4b 	.word	0x5c7dda4b
   8415c:	3fc55555 	.word	0x3fc55555
   84160:	0008c525 	.word	0x0008c525
   84164:	0008c521 	.word	0x0008c521
   84168:	0008c735 	.word	0x0008c735
   8416c:	0008be0d 	.word	0x0008be0d
   84170:	0008a2d9 	.word	0x0008a2d9
   84174:	0008c479 	.word	0x0008c479
   84178:	0008c3c1 	.word	0x0008c3c1
   8417c:	0008bb4d 	.word	0x0008bb4d
   84180:	0008c3ad 	.word	0x0008c3ad
   84184:	0008bb51 	.word	0x0008bb51
   84188:	20001510 	.word	0x20001510
   8418c:	0008a2dd 	.word	0x0008a2dd
   84190:	0008beb5 	.word	0x0008beb5
   84194:	3fe00000 	.word	0x3fe00000
   84198:	0008c109 	.word	0x0008c109
   8419c:	00089f89 	.word	0x00089f89
   841a0:	0008c439 	.word	0x0008c439
   841a4:	0008c68d 	.word	0x0008c68d
   841a8:	0008c89d 	.word	0x0008c89d
   841ac:	40100000 	.word	0x40100000
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
   841b0:	4628      	mov	r0, r5
   841b2:	4b2c      	ldr	r3, [pc, #176]	; (84264 <mc_arc+0x394>)
   841b4:	4798      	blx	r3
   841b6:	9910      	ldr	r1, [sp, #64]	; 0x40
   841b8:	47a0      	blx	r4
   841ba:	4b2b      	ldr	r3, [pc, #172]	; (84268 <mc_arc+0x398>)
   841bc:	4798      	blx	r3
   841be:	e9cd 0100 	strd	r0, r1, [sp]
   841c2:	4b2a      	ldr	r3, [pc, #168]	; (8426c <mc_arc+0x39c>)
   841c4:	4798      	blx	r3
   841c6:	4e2a      	ldr	r6, [pc, #168]	; (84270 <mc_arc+0x3a0>)
   841c8:	47b0      	blx	r6
   841ca:	4681      	mov	r9, r0
        sin_Ti = sin(i*theta_per_segment);
   841cc:	e9dd 0100 	ldrd	r0, r1, [sp]
   841d0:	4b28      	ldr	r3, [pc, #160]	; (84274 <mc_arc+0x3a4>)
   841d2:	4798      	blx	r3
   841d4:	47b0      	blx	r6
   841d6:	9002      	str	r0, [sp, #8]
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
   841d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   841da:	681e      	ldr	r6, [r3, #0]
   841dc:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   841e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   841e2:	f8d3 a000 	ldr.w	sl, [r3]
   841e6:	4630      	mov	r0, r6
   841e8:	4649      	mov	r1, r9
   841ea:	47a0      	blx	r4
   841ec:	9000      	str	r0, [sp, #0]
   841ee:	4650      	mov	r0, sl
   841f0:	9902      	ldr	r1, [sp, #8]
   841f2:	47a0      	blx	r4
   841f4:	4601      	mov	r1, r0
   841f6:	9800      	ldr	r0, [sp, #0]
   841f8:	4b1f      	ldr	r3, [pc, #124]	; (84278 <mc_arc+0x3a8>)
   841fa:	4798      	blx	r3
   841fc:	9000      	str	r0, [sp, #0]
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
   841fe:	9802      	ldr	r0, [sp, #8]
   84200:	4631      	mov	r1, r6
   84202:	47a0      	blx	r4
   84204:	4606      	mov	r6, r0
   84206:	4648      	mov	r0, r9
   84208:	4651      	mov	r1, sl
   8420a:	47a0      	blx	r4
   8420c:	4601      	mov	r1, r0
   8420e:	4630      	mov	r0, r6
   84210:	4b1a      	ldr	r3, [pc, #104]	; (8427c <mc_arc+0x3ac>)
   84212:	4798      	blx	r3
   84214:	4682      	mov	sl, r0
        count = 0;
   84216:	f04f 0900 	mov.w	r9, #0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
   8421a:	4e17      	ldr	r6, [pc, #92]	; (84278 <mc_arc+0x3a8>)
   8421c:	9807      	ldr	r0, [sp, #28]
   8421e:	9900      	ldr	r1, [sp, #0]
   84220:	47b0      	blx	r6
   84222:	9b09      	ldr	r3, [sp, #36]	; 0x24
   84224:	6018      	str	r0, [r3, #0]
      position[axis_1] = center_axis1 + r_axis1;
   84226:	9808      	ldr	r0, [sp, #32]
   84228:	4651      	mov	r1, sl
   8422a:	47b0      	blx	r6
   8422c:	6038      	str	r0, [r7, #0]
      position[axis_linear] += linear_per_segment;
   8422e:	f8d8 0000 	ldr.w	r0, [r8]
   84232:	990a      	ldr	r1, [sp, #40]	; 0x28
   84234:	47b0      	blx	r6
   84236:	f8c8 0000 	str.w	r0, [r8]
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
   8423a:	9805      	ldr	r0, [sp, #20]
   8423c:	991c      	ldr	r1, [sp, #112]	; 0x70
   8423e:	9a06      	ldr	r2, [sp, #24]
   84240:	4b0f      	ldr	r3, [pc, #60]	; (84280 <mc_arc+0x3b0>)
   84242:	4798      	blx	r3
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
   84244:	4b0f      	ldr	r3, [pc, #60]	; (84284 <mc_arc+0x3b4>)
   84246:	781b      	ldrb	r3, [r3, #0]
   84248:	b94b      	cbnz	r3, 8425e <mc_arc+0x38e>
   8424a:	3501      	adds	r5, #1
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
   8424c:	b2ab      	uxth	r3, r5
   8424e:	455b      	cmp	r3, fp
   84250:	f4ff af55 	bcc.w	840fe <mc_arc+0x22e>
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
   84254:	9811      	ldr	r0, [sp, #68]	; 0x44
   84256:	991c      	ldr	r1, [sp, #112]	; 0x70
   84258:	9a06      	ldr	r2, [sp, #24]
   8425a:	4b09      	ldr	r3, [pc, #36]	; (84280 <mc_arc+0x3b0>)
   8425c:	4798      	blx	r3
  #endif
}
   8425e:	b013      	add	sp, #76	; 0x4c
   84260:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84264:	0008c68d 	.word	0x0008c68d
   84268:	0008be0d 	.word	0x0008be0d
   8426c:	00089ef9 	.word	0x00089ef9
   84270:	0008c479 	.word	0x0008c479
   84274:	0008a1d1 	.word	0x0008a1d1
   84278:	0008c525 	.word	0x0008c525
   8427c:	0008c521 	.word	0x0008c521
   84280:	00083e6d 	.word	0x00083e6d
   84284:	20001484 	.word	0x20001484

00084288 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
   if (sys.state == STATE_CHECK_MODE) { return; }
   84288:	4b1a      	ldr	r3, [pc, #104]	; (842f4 <mc_dwell+0x6c>)
   8428a:	785b      	ldrb	r3, [r3, #1]
   8428c:	2b02      	cmp	r3, #2
   8428e:	d030      	beq.n	842f2 <mc_dwell+0x6a>
}


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
   84290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   84294:	4680      	mov	r8, r0
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   84296:	4d18      	ldr	r5, [pc, #96]	; (842f8 <mc_dwell+0x70>)
   84298:	4918      	ldr	r1, [pc, #96]	; (842fc <mc_dwell+0x74>)
   8429a:	47a8      	blx	r5
   8429c:	4f18      	ldr	r7, [pc, #96]	; (84300 <mc_dwell+0x78>)
   8429e:	47b8      	blx	r7
   842a0:	4e18      	ldr	r6, [pc, #96]	; (84304 <mc_dwell+0x7c>)
   842a2:	47b0      	blx	r6
   842a4:	4b18      	ldr	r3, [pc, #96]	; (84308 <mc_dwell+0x80>)
   842a6:	4798      	blx	r3
   842a8:	b284      	uxth	r4, r0
   protocol_buffer_synchronize();
   842aa:	4b18      	ldr	r3, [pc, #96]	; (8430c <mc_dwell+0x84>)
   842ac:	4798      	blx	r3
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   842ae:	4640      	mov	r0, r8
   842b0:	4917      	ldr	r1, [pc, #92]	; (84310 <mc_dwell+0x88>)
   842b2:	47a8      	blx	r5
   842b4:	4605      	mov	r5, r0
   842b6:	2032      	movs	r0, #50	; 0x32
   842b8:	fb00 f004 	mul.w	r0, r0, r4
   842bc:	4b15      	ldr	r3, [pc, #84]	; (84314 <mc_dwell+0x8c>)
   842be:	4798      	blx	r3
   842c0:	4601      	mov	r1, r0
   842c2:	4628      	mov	r0, r5
   842c4:	4b14      	ldr	r3, [pc, #80]	; (84318 <mc_dwell+0x90>)
   842c6:	4798      	blx	r3
   842c8:	47b8      	blx	r7
   842ca:	47b0      	blx	r6
   842cc:	4b13      	ldr	r3, [pc, #76]	; (8431c <mc_dwell+0x94>)
   842ce:	4798      	blx	r3
   842d0:	4b13      	ldr	r3, [pc, #76]	; (84320 <mc_dwell+0x98>)
   842d2:	4798      	blx	r3
   while (i-- > 0) {
   842d4:	b15c      	cbz	r4, 842ee <mc_dwell+0x66>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
   842d6:	4e13      	ldr	r6, [pc, #76]	; (84324 <mc_dwell+0x9c>)
     if (sys.abort) { return; }
   842d8:	4d06      	ldr	r5, [pc, #24]	; (842f4 <mc_dwell+0x6c>)
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   842da:	4f13      	ldr	r7, [pc, #76]	; (84328 <mc_dwell+0xa0>)
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
   842dc:	47b0      	blx	r6
     if (sys.abort) { return; }
   842de:	782b      	ldrb	r3, [r5, #0]
   842e0:	b92b      	cbnz	r3, 842ee <mc_dwell+0x66>
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   842e2:	2032      	movs	r0, #50	; 0x32
   842e4:	47b8      	blx	r7
   842e6:	3c01      	subs	r4, #1
   842e8:	b2a4      	uxth	r4, r4
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
   842ea:	2c00      	cmp	r4, #0
   842ec:	d1f6      	bne.n	842dc <mc_dwell+0x54>
   842ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   842f2:	4770      	bx	lr
   842f4:	20001484 	.word	0x20001484
   842f8:	0008c735 	.word	0x0008c735
   842fc:	41a00000 	.word	0x41a00000
   84300:	0008be0d 	.word	0x0008be0d
   84304:	00089f89 	.word	0x00089f89
   84308:	0008c439 	.word	0x0008c439
   8430c:	00085369 	.word	0x00085369
   84310:	447a0000 	.word	0x447a0000
   84314:	0008c68d 	.word	0x0008c68d
   84318:	0008c521 	.word	0x0008c521
   8431c:	0008c3e9 	.word	0x0008c3e9
   84320:	00089689 	.word	0x00089689
   84324:	00085011 	.word	0x00085011
   84328:	000896a5 	.word	0x000896a5

0008432c <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle()
{
   8432c:	b510      	push	{r4, lr}
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
   8432e:	4b08      	ldr	r3, [pc, #32]	; (84350 <mc_homing_cycle+0x24>)
   84330:	4798      	blx	r3
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
   84332:	2004      	movs	r0, #4
   84334:	4c07      	ldr	r4, [pc, #28]	; (84354 <mc_homing_cycle+0x28>)
   84336:	47a0      	blx	r4
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
   84338:	2003      	movs	r0, #3
   8433a:	47a0      	blx	r4
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
   8433c:	4b06      	ldr	r3, [pc, #24]	; (84358 <mc_homing_cycle+0x2c>)
   8433e:	4798      	blx	r3
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
   84340:	4b06      	ldr	r3, [pc, #24]	; (8435c <mc_homing_cycle+0x30>)
   84342:	781b      	ldrb	r3, [r3, #0]
   84344:	b91b      	cbnz	r3, 8434e <mc_homing_cycle+0x22>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
   84346:	4b06      	ldr	r3, [pc, #24]	; (84360 <mc_homing_cycle+0x34>)
   84348:	4798      	blx	r3

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
   8434a:	4b06      	ldr	r3, [pc, #24]	; (84364 <mc_homing_cycle+0x38>)
   8434c:	4798      	blx	r3
   8434e:	bd10      	pop	{r4, pc}
   84350:	0008374d 	.word	0x0008374d
   84354:	00083755 	.word	0x00083755
   84358:	00085011 	.word	0x00085011
   8435c:	20001484 	.word	0x20001484
   84360:	00082515 	.word	0x00082515
   84364:	00083749 	.word	0x00083749

00084368 <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
   84368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
   8436a:	4c31      	ldr	r4, [pc, #196]	; (84430 <mc_probe_cycle+0xc8>)
   8436c:	7864      	ldrb	r4, [r4, #1]
   8436e:	2c02      	cmp	r4, #2
   84370:	d05d      	beq.n	8442e <mc_probe_cycle+0xc6>
   84372:	461c      	mov	r4, r3
   84374:	4615      	mov	r5, r2
   84376:	460f      	mov	r7, r1
   84378:	4606      	mov	r6, r0

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
   8437a:	4b2e      	ldr	r3, [pc, #184]	; (84434 <mc_probe_cycle+0xcc>)
   8437c:	4798      	blx	r3

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
   8437e:	2200      	movs	r2, #0
   84380:	4b2b      	ldr	r3, [pc, #172]	; (84430 <mc_probe_cycle+0xc8>)
   84382:	771a      	strb	r2, [r3, #28]
  probe_configure_invert_mask(is_probe_away);
   84384:	4620      	mov	r0, r4
   84386:	4b2c      	ldr	r3, [pc, #176]	; (84438 <mc_probe_cycle+0xd0>)
   84388:	4798      	blx	r3
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
   8438a:	4b2c      	ldr	r3, [pc, #176]	; (8443c <mc_probe_cycle+0xd4>)
   8438c:	4798      	blx	r3
   8438e:	b130      	cbz	r0, 8439e <mc_probe_cycle+0x36>
    bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
   84390:	4a2b      	ldr	r2, [pc, #172]	; (84440 <mc_probe_cycle+0xd8>)
   84392:	7813      	ldrb	r3, [r2, #0]
   84394:	f043 0310 	orr.w	r3, r3, #16
   84398:	7013      	strb	r3, [r2, #0]
    protocol_execute_realtime();
   8439a:	4b2a      	ldr	r3, [pc, #168]	; (84444 <mc_probe_cycle+0xdc>)
   8439c:	4798      	blx	r3
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
   8439e:	4b24      	ldr	r3, [pc, #144]	; (84430 <mc_probe_cycle+0xc8>)
   843a0:	781b      	ldrb	r3, [r3, #0]
   843a2:	2b00      	cmp	r3, #0
   843a4:	d143      	bne.n	8442e <mc_probe_cycle+0xc6>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
   843a6:	4630      	mov	r0, r6
   843a8:	4639      	mov	r1, r7
   843aa:	462a      	mov	r2, r5
   843ac:	4b26      	ldr	r3, [pc, #152]	; (84448 <mc_probe_cycle+0xe0>)
   843ae:	4798      	blx	r3
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
   843b0:	2201      	movs	r2, #1
   843b2:	4b26      	ldr	r3, [pc, #152]	; (8444c <mc_probe_cycle+0xe4>)
   843b4:	701a      	strb	r2, [r3, #0]

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
   843b6:	4a26      	ldr	r2, [pc, #152]	; (84450 <mc_probe_cycle+0xe8>)
   843b8:	7813      	ldrb	r3, [r2, #0]
   843ba:	f043 0302 	orr.w	r3, r3, #2
   843be:	7013      	strb	r3, [r2, #0]
  do {
    protocol_execute_realtime(); 
   843c0:	4d20      	ldr	r5, [pc, #128]	; (84444 <mc_probe_cycle+0xdc>)
    if (sys.abort) { return; } // Check for system abort
   843c2:	4c1b      	ldr	r4, [pc, #108]	; (84430 <mc_probe_cycle+0xc8>)
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
   843c4:	47a8      	blx	r5
    if (sys.abort) { return; } // Check for system abort
   843c6:	7823      	ldrb	r3, [r4, #0]
   843c8:	2b00      	cmp	r3, #0
   843ca:	d130      	bne.n	8442e <mc_probe_cycle+0xc6>
  } while (sys.state != STATE_IDLE);
   843cc:	7863      	ldrb	r3, [r4, #1]
   843ce:	2b00      	cmp	r3, #0
   843d0:	d1f8      	bne.n	843c4 <mc_probe_cycle+0x5c>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
   843d2:	4b1e      	ldr	r3, [pc, #120]	; (8444c <mc_probe_cycle+0xe4>)
   843d4:	781b      	ldrb	r3, [r3, #0]
   843d6:	b2db      	uxtb	r3, r3
   843d8:	2b01      	cmp	r3, #1
   843da:	d111      	bne.n	84400 <mc_probe_cycle+0x98>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
   843dc:	f89d 3018 	ldrb.w	r3, [sp, #24]
   843e0:	b143      	cbz	r3, 843f4 <mc_probe_cycle+0x8c>
   843e2:	4b13      	ldr	r3, [pc, #76]	; (84430 <mc_probe_cycle+0xc8>)
   843e4:	f103 0410 	add.w	r4, r3, #16
   843e8:	3304      	adds	r3, #4
   843ea:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   843ee:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   843f2:	e008      	b.n	84406 <mc_probe_cycle+0x9e>
    else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
   843f4:	4a12      	ldr	r2, [pc, #72]	; (84440 <mc_probe_cycle+0xd8>)
   843f6:	7813      	ldrb	r3, [r2, #0]
   843f8:	f043 0310 	orr.w	r3, r3, #16
   843fc:	7013      	strb	r3, [r2, #0]
   843fe:	e002      	b.n	84406 <mc_probe_cycle+0x9e>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
   84400:	2201      	movs	r2, #1
   84402:	4b0b      	ldr	r3, [pc, #44]	; (84430 <mc_probe_cycle+0xc8>)
   84404:	771a      	strb	r2, [r3, #28]
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
   84406:	2200      	movs	r2, #0
   84408:	4b10      	ldr	r3, [pc, #64]	; (8444c <mc_probe_cycle+0xe4>)
   8440a:	701a      	strb	r2, [r3, #0]
  protocol_execute_realtime();   // Check and execute run-time commands
   8440c:	4b0d      	ldr	r3, [pc, #52]	; (84444 <mc_probe_cycle+0xdc>)
   8440e:	4798      	blx	r3
  if (sys.abort) { return; } // Check for system abort
   84410:	4b07      	ldr	r3, [pc, #28]	; (84430 <mc_probe_cycle+0xc8>)
   84412:	781b      	ldrb	r3, [r3, #0]
   84414:	b95b      	cbnz	r3, 8442e <mc_probe_cycle+0xc6>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
   84416:	4b0f      	ldr	r3, [pc, #60]	; (84454 <mc_probe_cycle+0xec>)
   84418:	4798      	blx	r3
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
   8441a:	4b0f      	ldr	r3, [pc, #60]	; (84458 <mc_probe_cycle+0xf0>)
   8441c:	4798      	blx	r3
  plan_sync_position(); // Sync planner position to current machine position.
   8441e:	4b0f      	ldr	r3, [pc, #60]	; (8445c <mc_probe_cycle+0xf4>)
   84420:	4798      	blx	r3

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
   84422:	4630      	mov	r0, r6
   84424:	490e      	ldr	r1, [pc, #56]	; (84460 <mc_probe_cycle+0xf8>)
   84426:	4b0f      	ldr	r3, [pc, #60]	; (84464 <mc_probe_cycle+0xfc>)
   84428:	4798      	blx	r3

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
   8442a:	4b0f      	ldr	r3, [pc, #60]	; (84468 <mc_probe_cycle+0x100>)
   8442c:	4798      	blx	r3
   8442e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   84430:	20001484 	.word	0x20001484
   84434:	00085369 	.word	0x00085369
   84438:	00084f85 	.word	0x00084f85
   8443c:	00084fb1 	.word	0x00084fb1
   84440:	200011b6 	.word	0x200011b6
   84444:	00085011 	.word	0x00085011
   84448:	00083e6d 	.word	0x00083e6d
   8444c:	200011b5 	.word	0x200011b5
   84450:	200011b4 	.word	0x200011b4
   84454:	00088879 	.word	0x00088879
   84458:	00084821 	.word	0x00084821
   8445c:	00084cbd 	.word	0x00084cbd
   84460:	20001488 	.word	0x20001488
   84464:	00089649 	.word	0x00089649
   84468:	00087899 	.word	0x00087899

0008446c <mc_reset>:
// active processes in the system. This also checks if a system reset is issued while Grbl
// is in a motion state. If so, kills the steppers and sets the system alarm to flag position
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
   8446c:	b508      	push	{r3, lr}
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
   8446e:	4b11      	ldr	r3, [pc, #68]	; (844b4 <mc_reset+0x48>)
   84470:	781b      	ldrb	r3, [r3, #0]
   84472:	f013 0f10 	tst.w	r3, #16
   84476:	d11c      	bne.n	844b2 <mc_reset+0x46>
    bit_true_atomic(sys_rt_exec_state, EXEC_RESET);
   84478:	4a0e      	ldr	r2, [pc, #56]	; (844b4 <mc_reset+0x48>)
   8447a:	7813      	ldrb	r3, [r2, #0]
   8447c:	f043 0310 	orr.w	r3, r3, #16
   84480:	7013      	strb	r3, [r2, #0]

    // Kill spindle and coolant.   
    spindle_stop();
   84482:	4b0d      	ldr	r3, [pc, #52]	; (844b8 <mc_reset+0x4c>)
   84484:	4798      	blx	r3
    coolant_stop();
   84486:	4b0d      	ldr	r3, [pc, #52]	; (844bc <mc_reset+0x50>)
   84488:	4798      	blx	r3

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
   8448a:	4b0d      	ldr	r3, [pc, #52]	; (844c0 <mc_reset+0x54>)
   8448c:	785b      	ldrb	r3, [r3, #1]
   8448e:	f013 0f0c 	tst.w	r3, #12
   84492:	d103      	bne.n	8449c <mc_reset+0x30>
   84494:	4a0a      	ldr	r2, [pc, #40]	; (844c0 <mc_reset+0x54>)
   84496:	7892      	ldrb	r2, [r2, #2]
   84498:	2a01      	cmp	r2, #1
   8449a:	d10a      	bne.n	844b2 <mc_reset+0x46>
      if (sys.state == STATE_HOMING) { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_HOMING_FAIL); }
   8449c:	2b04      	cmp	r3, #4
   8449e:	4a09      	ldr	r2, [pc, #36]	; (844c4 <mc_reset+0x58>)
   844a0:	7813      	ldrb	r3, [r2, #0]
   844a2:	bf0c      	ite	eq
   844a4:	f043 0320 	orreq.w	r3, r3, #32
      else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE); }
   844a8:	f043 0308 	orrne.w	r3, r3, #8
   844ac:	7013      	strb	r3, [r2, #0]
      st_go_idle(); // Force kill steppers. Position has likely been lost.
   844ae:	4b06      	ldr	r3, [pc, #24]	; (844c8 <mc_reset+0x5c>)
   844b0:	4798      	blx	r3
   844b2:	bd08      	pop	{r3, pc}
   844b4:	200011b4 	.word	0x200011b4
   844b8:	0008836d 	.word	0x0008836d
   844bc:	00080151 	.word	0x00080151
   844c0:	20001484 	.word	0x20001484
   844c4:	200011b6 	.word	0x200011b6
   844c8:	0008855d 	.word	0x0008855d
   844cc:	00000000 	.word	0x00000000

000844d0 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized. 
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)                  
{
   844d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   844d4:	b083      	sub	sp, #12
  char *ptr = line + *char_counter;
   844d6:	780b      	ldrb	r3, [r1, #0]
   844d8:	18c4      	adds	r4, r0, r3
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
   844da:	5cc3      	ldrb	r3, [r0, r3]
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
   844dc:	2b2d      	cmp	r3, #45	; 0x2d
   844de:	d104      	bne.n	844ea <read_float+0x1a>
    isnegative = true;
    c = *ptr++;
   844e0:	1ca5      	adds	r5, r4, #2
   844e2:	7863      	ldrb	r3, [r4, #1]
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
   844e4:	f04f 0b01 	mov.w	fp, #1
   844e8:	e006      	b.n	844f8 <read_float+0x28>
    c = *ptr++;
  } else if (c == '+') {
   844ea:	2b2b      	cmp	r3, #43	; 0x2b
{
  char *ptr = line + *char_counter;
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
   844ec:	bf12      	itee	ne
   844ee:	1c65      	addne	r5, r4, #1
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
    c = *ptr++;
  } else if (c == '+') {
    c = *ptr++;
   844f0:	1ca5      	addeq	r5, r4, #2
   844f2:	7863      	ldrbeq	r3, [r4, #1]
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
   844f4:	f04f 0b00 	mov.w	fp, #0
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
   844f8:	2700      	movs	r7, #0
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
   844fa:	463e      	mov	r6, r7
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
   844fc:	463c      	mov	r4, r7
  } else if (c == '+') {
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
   844fe:	46be      	mov	lr, r7
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
      isdecimal = true;
   84500:	f04f 0c01 	mov.w	ip, #1
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
  while(1) {
    c -= '0';
   84504:	3b30      	subs	r3, #48	; 0x30
   84506:	b2db      	uxtb	r3, r3
    if (c <= 9) {
   84508:	2b09      	cmp	r3, #9
   8450a:	d80f      	bhi.n	8452c <read_float+0x5c>
      ndigit++;
   8450c:	3601      	adds	r6, #1
   8450e:	b2f6      	uxtb	r6, r6
      if (ndigit <= MAX_INT_DIGITS) {
   84510:	2e08      	cmp	r6, #8
   84512:	d807      	bhi.n	84524 <read_float+0x54>
        if (isdecimal) { exp--; }
   84514:	b10f      	cbz	r7, 8451a <read_float+0x4a>
   84516:	3c01      	subs	r4, #1
   84518:	b2e4      	uxtb	r4, r4
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
   8451a:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
   8451e:	eb03 0e4e 	add.w	lr, r3, lr, lsl #1
   84522:	e007      	b.n	84534 <read_float+0x64>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
   84524:	b937      	cbnz	r7, 84534 <read_float+0x64>
   84526:	3401      	adds	r4, #1
   84528:	b2e4      	uxtb	r4, r4
   8452a:	e003      	b.n	84534 <read_float+0x64>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
   8452c:	2bfe      	cmp	r3, #254	; 0xfe
   8452e:	d104      	bne.n	8453a <read_float+0x6a>
   84530:	b92f      	cbnz	r7, 8453e <read_float+0x6e>
      isdecimal = true;
   84532:	4667      	mov	r7, ip
    } else {
      break;
    }
    c = *ptr++;
   84534:	f815 3b01 	ldrb.w	r3, [r5], #1
  }
   84538:	e7e4      	b.n	84504 <read_float+0x34>
   8453a:	4627      	mov	r7, r4
   8453c:	e000      	b.n	84540 <read_float+0x70>
   8453e:	4627      	mov	r7, r4
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
   84540:	2e00      	cmp	r6, #0
   84542:	d050      	beq.n	845e6 <read_float+0x116>
   84544:	4692      	mov	sl, r2
   84546:	9101      	str	r1, [sp, #4]
   84548:	9000      	str	r0, [sp, #0]
  
  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
   8454a:	4670      	mov	r0, lr
   8454c:	4b2c      	ldr	r3, [pc, #176]	; (84600 <read_float+0x130>)
   8454e:	4798      	blx	r3
   84550:	4606      	mov	r6, r0
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
   84552:	2100      	movs	r1, #0
   84554:	4b2b      	ldr	r3, [pc, #172]	; (84604 <read_float+0x134>)
   84556:	4798      	blx	r3
   84558:	2800      	cmp	r0, #0
   8455a:	d133      	bne.n	845c4 <read_float+0xf4>
    while (exp <= -2) {
   8455c:	b27f      	sxtb	r7, r7
   8455e:	f1b7 3fff 	cmp.w	r7, #4294967295
   84562:	da12      	bge.n	8458a <read_float+0xba>
      fval *= 0.01; 
   84564:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8460c <read_float+0x13c>
   84568:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 84610 <read_float+0x140>
   8456c:	4f26      	ldr	r7, [pc, #152]	; (84608 <read_float+0x138>)
   8456e:	4630      	mov	r0, r6
   84570:	47c8      	blx	r9
   84572:	a31f      	add	r3, pc, #124	; (adr r3, 845f0 <read_float+0x120>)
   84574:	e9d3 2300 	ldrd	r2, r3, [r3]
   84578:	47c0      	blx	r8
   8457a:	47b8      	blx	r7
   8457c:	3402      	adds	r4, #2
   8457e:	b2e4      	uxtb	r4, r4
  fval = (float)intval;
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
   84580:	b263      	sxtb	r3, r4
   84582:	f1b3 3fff 	cmp.w	r3, #4294967295
   84586:	dbf3      	blt.n	84570 <read_float+0xa0>
   84588:	4606      	mov	r6, r0
      fval *= 0.01; 
      exp += 2;
    }
    if (exp < 0) { 
   8458a:	f014 0f80 	tst.w	r4, #128	; 0x80
   8458e:	d00b      	beq.n	845a8 <read_float+0xd8>
      fval *= 0.1; 
   84590:	4630      	mov	r0, r6
   84592:	4b1e      	ldr	r3, [pc, #120]	; (8460c <read_float+0x13c>)
   84594:	4798      	blx	r3
   84596:	a318      	add	r3, pc, #96	; (adr r3, 845f8 <read_float+0x128>)
   84598:	e9d3 2300 	ldrd	r2, r3, [r3]
   8459c:	4c1c      	ldr	r4, [pc, #112]	; (84610 <read_float+0x140>)
   8459e:	47a0      	blx	r4
   845a0:	4b19      	ldr	r3, [pc, #100]	; (84608 <read_float+0x138>)
   845a2:	4798      	blx	r3
   845a4:	4606      	mov	r6, r0
   845a6:	e00d      	b.n	845c4 <read_float+0xf4>
    } else if (exp > 0) {
   845a8:	b263      	sxtb	r3, r4
   845aa:	2b00      	cmp	r3, #0
   845ac:	dd0a      	ble.n	845c4 <read_float+0xf4>
      do {
        fval *= 10.0;
   845ae:	4f19      	ldr	r7, [pc, #100]	; (84614 <read_float+0x144>)
   845b0:	f8df 8064 	ldr.w	r8, [pc, #100]	; 84618 <read_float+0x148>
   845b4:	4630      	mov	r0, r6
   845b6:	4641      	mov	r1, r8
   845b8:	47b8      	blx	r7
   845ba:	1e63      	subs	r3, r4, #1
      } while (--exp > 0);
   845bc:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   845c0:	d1f9      	bne.n	845b6 <read_float+0xe6>
   845c2:	4606      	mov	r6, r0
    } 
  }

  // Assign floating point value with correct sign.    
  if (isnegative) {
   845c4:	f1bb 0f00 	cmp.w	fp, #0
   845c8:	d004      	beq.n	845d4 <read_float+0x104>
    *float_ptr = -fval;
   845ca:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   845ce:	f8ca 6000 	str.w	r6, [sl]
   845d2:	e001      	b.n	845d8 <read_float+0x108>
  } else {
    *float_ptr = fval;
   845d4:	f8ca 6000 	str.w	r6, [sl]
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
   845d8:	9b00      	ldr	r3, [sp, #0]
   845da:	1aed      	subs	r5, r5, r3
   845dc:	3d01      	subs	r5, #1
   845de:	9b01      	ldr	r3, [sp, #4]
   845e0:	701d      	strb	r5, [r3, #0]
  
  return(true);
   845e2:	2001      	movs	r0, #1
   845e4:	e000      	b.n	845e8 <read_float+0x118>
    }
    c = *ptr++;
  }
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
   845e6:	2000      	movs	r0, #0
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
  
  return(true);
}
   845e8:	b003      	add	sp, #12
   845ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   845ee:	bf00      	nop
   845f0:	47ae147b 	.word	0x47ae147b
   845f4:	3f847ae1 	.word	0x3f847ae1
   845f8:	9999999a 	.word	0x9999999a
   845fc:	3fb99999 	.word	0x3fb99999
   84600:	0008c685 	.word	0x0008c685
   84604:	0008ca5d 	.word	0x0008ca5d
   84608:	0008c479 	.word	0x0008c479
   8460c:	0008be0d 	.word	0x0008be0d
   84610:	0008beb5 	.word	0x0008beb5
   84614:	0008c735 	.word	0x0008c735
   84618:	41200000 	.word	0x41200000

0008461c <hypot_f>:
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
   8461c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   84620:	4606      	mov	r6, r0
   84622:	4688      	mov	r8, r1
   84624:	4c09      	ldr	r4, [pc, #36]	; (8464c <hypot_f+0x30>)
   84626:	4d0a      	ldr	r5, [pc, #40]	; (84650 <hypot_f+0x34>)
   84628:	4f0a      	ldr	r7, [pc, #40]	; (84654 <hypot_f+0x38>)
   8462a:	4630      	mov	r0, r6
   8462c:	4631      	mov	r1, r6
   8462e:	47a0      	blx	r4
   84630:	4606      	mov	r6, r0
   84632:	4640      	mov	r0, r8
   84634:	4641      	mov	r1, r8
   84636:	47a0      	blx	r4
   84638:	4601      	mov	r1, r0
   8463a:	4630      	mov	r0, r6
   8463c:	47a8      	blx	r5
   8463e:	47b8      	blx	r7
   84640:	4b05      	ldr	r3, [pc, #20]	; (84658 <hypot_f+0x3c>)
   84642:	4798      	blx	r3
   84644:	4b05      	ldr	r3, [pc, #20]	; (8465c <hypot_f+0x40>)
   84646:	4798      	blx	r3
   84648:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8464c:	0008c735 	.word	0x0008c735
   84650:	0008c525 	.word	0x0008c525
   84654:	0008be0d 	.word	0x0008be0d
   84658:	0008a2dd 	.word	0x0008a2dd
   8465c:	0008c479 	.word	0x0008c479

00084660 <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate() 
{   
   84660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   84664:	b085      	sub	sp, #20
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
   84666:	4b66      	ldr	r3, [pc, #408]	; (84800 <planner_recalculate+0x1a0>)
   84668:	781c      	ldrb	r4, [r3, #0]


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
   8466a:	2c00      	cmp	r4, #0
   8466c:	bf08      	it	eq
   8466e:	2412      	moveq	r4, #18
  block_index--;
   84670:	3c01      	subs	r4, #1
   84672:	b2e4      	uxtb	r4, r4
{   
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
        
  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
   84674:	785e      	ldrb	r6, [r3, #1]
   84676:	42a6      	cmp	r6, r4
   84678:	f000 80bf 	beq.w	847fa <planner_recalculate+0x19a>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
   8467c:	4627      	mov	r7, r4

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
   8467e:	232c      	movs	r3, #44	; 0x2c
   84680:	4d5f      	ldr	r5, [pc, #380]	; (84800 <planner_recalculate+0x1a0>)
   84682:	fb03 5504 	mla	r5, r3, r4, r5
   84686:	f8d5 801c 	ldr.w	r8, [r5, #28]
   8468a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   8468c:	4601      	mov	r1, r0
   8468e:	4b5d      	ldr	r3, [pc, #372]	; (84804 <planner_recalculate+0x1a4>)
   84690:	4798      	blx	r3
   84692:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   84694:	4b5c      	ldr	r3, [pc, #368]	; (84808 <planner_recalculate+0x1a8>)
   84696:	4798      	blx	r3
   84698:	4605      	mov	r5, r0
   8469a:	4640      	mov	r0, r8
   8469c:	4629      	mov	r1, r5
   8469e:	4b5b      	ldr	r3, [pc, #364]	; (8480c <planner_recalculate+0x1ac>)
   846a0:	4798      	blx	r3
   846a2:	b900      	cbnz	r0, 846a6 <planner_recalculate+0x46>
   846a4:	46a8      	mov	r8, r5
   846a6:	232c      	movs	r3, #44	; 0x2c
   846a8:	4a55      	ldr	r2, [pc, #340]	; (84800 <planner_recalculate+0x1a0>)
   846aa:	fb03 2307 	mla	r3, r3, r7, r2
   846ae:	f8c3 8018 	str.w	r8, [r3, #24]


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
   846b2:	2c00      	cmp	r4, #0
   846b4:	bf08      	it	eq
   846b6:	2412      	moveq	r4, #18
  block_index--;
   846b8:	3c01      	subs	r4, #1
   846ba:	b2e4      	uxtb	r4, r4

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
   846bc:	42a6      	cmp	r6, r4
   846be:	d008      	beq.n	846d2 <planner_recalculate+0x72>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
   846c0:	222c      	movs	r2, #44	; 0x2c
   846c2:	4b53      	ldr	r3, [pc, #332]	; (84810 <planner_recalculate+0x1b0>)
   846c4:	fb02 3307 	mla	r3, r2, r7, r3
   846c8:	9301      	str	r3, [sp, #4]
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
   846ca:	4e4d      	ldr	r6, [pc, #308]	; (84800 <planner_recalculate+0x1a0>)
      next = current;
      current = &block_buffer[block_index];
   846cc:	f106 0b04 	add.w	fp, r6, #4
   846d0:	e043      	b.n	8475a <planner_recalculate+0xfa>
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
   846d2:	4b4b      	ldr	r3, [pc, #300]	; (84800 <planner_recalculate+0x1a0>)
   846d4:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
   846d8:	42b3      	cmp	r3, r6
   846da:	d141      	bne.n	84760 <planner_recalculate+0x100>
   846dc:	4b4d      	ldr	r3, [pc, #308]	; (84814 <planner_recalculate+0x1b4>)
   846de:	4798      	blx	r3
   846e0:	e03e      	b.n	84760 <planner_recalculate+0x100>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
   846e2:	4627      	mov	r7, r4
   846e4:	252c      	movs	r5, #44	; 0x2c
   846e6:	fb05 b504 	mla	r5, r5, r4, fp


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
   846ea:	2c00      	cmp	r4, #0
   846ec:	bf08      	it	eq
   846ee:	2412      	moveq	r4, #18
  block_index--;
   846f0:	3c01      	subs	r4, #1
   846f2:	b2e4      	uxtb	r4, r4
      next = current;
      current = &block_buffer[block_index];
      block_index = plan_prev_block_index(block_index);

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); } 
   846f4:	f896 331c 	ldrb.w	r3, [r6, #796]	; 0x31c
   846f8:	42a3      	cmp	r3, r4
   846fa:	d101      	bne.n	84700 <planner_recalculate+0xa0>
   846fc:	4b45      	ldr	r3, [pc, #276]	; (84814 <planner_recalculate+0x1b4>)
   846fe:	4798      	blx	r3

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
   84700:	232c      	movs	r3, #44	; 0x2c
   84702:	fb03 6307 	mla	r3, r3, r7, r6
   84706:	f8d3 801c 	ldr.w	r8, [r3, #28]
   8470a:	6998      	ldr	r0, [r3, #24]
   8470c:	4641      	mov	r1, r8
   8470e:	4b42      	ldr	r3, [pc, #264]	; (84818 <planner_recalculate+0x1b8>)
   84710:	4798      	blx	r3
   84712:	bb08      	cbnz	r0, 84758 <planner_recalculate+0xf8>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
   84714:	f04f 092c 	mov.w	r9, #44	; 0x2c
   84718:	fb09 6907 	mla	r9, r9, r7, r6
   8471c:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 84804 <planner_recalculate+0x1a4>
   84720:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
   84724:	4601      	mov	r1, r0
   84726:	47d0      	blx	sl
   84728:	f8d9 102c 	ldr.w	r1, [r9, #44]	; 0x2c
   8472c:	4b36      	ldr	r3, [pc, #216]	; (84808 <planner_recalculate+0x1a8>)
   8472e:	4798      	blx	r3
   84730:	9b01      	ldr	r3, [sp, #4]
   84732:	6959      	ldr	r1, [r3, #20]
   84734:	47d0      	blx	sl
   84736:	4681      	mov	r9, r0
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
   84738:	4640      	mov	r0, r8
   8473a:	4649      	mov	r1, r9
   8473c:	4b37      	ldr	r3, [pc, #220]	; (8481c <planner_recalculate+0x1bc>)
   8473e:	4798      	blx	r3
   84740:	b128      	cbz	r0, 8474e <planner_recalculate+0xee>
          current->entry_speed_sqr = entry_speed_sqr;
   84742:	232c      	movs	r3, #44	; 0x2c
   84744:	fb03 6707 	mla	r7, r3, r7, r6
   84748:	f8c7 9018 	str.w	r9, [r7, #24]
   8474c:	e004      	b.n	84758 <planner_recalculate+0xf8>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
   8474e:	232c      	movs	r3, #44	; 0x2c
   84750:	fb03 6707 	mla	r7, r3, r7, r6
   84754:	f8c7 8018 	str.w	r8, [r7, #24]


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
   84758:	9501      	str	r5, [sp, #4]
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
   8475a:	7873      	ldrb	r3, [r6, #1]
   8475c:	42a3      	cmp	r3, r4
   8475e:	d1c0      	bne.n	846e2 <planner_recalculate+0x82>
    }
  }    

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
   84760:	4e27      	ldr	r6, [pc, #156]	; (84800 <planner_recalculate+0x1a0>)
   84762:	7877      	ldrb	r7, [r6, #1]
   84764:	3604      	adds	r6, #4
   84766:	232c      	movs	r3, #44	; 0x2c
   84768:	fb03 6607 	mla	r6, r3, r7, r6


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
   8476c:	1c7c      	adds	r4, r7, #1
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
   8476e:	f004 04ff 	and.w	r4, r4, #255	; 0xff
   84772:	2c12      	cmp	r4, #18
   84774:	bf08      	it	eq
   84776:	2400      	moveq	r4, #0

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
   84778:	4b21      	ldr	r3, [pc, #132]	; (84800 <planner_recalculate+0x1a0>)
   8477a:	f893 8000 	ldrb.w	r8, [r3]
    current = next;
    next = &block_buffer[block_index];
   8477e:	469a      	mov	sl, r3
   84780:	3304      	adds	r3, #4
   84782:	9303      	str	r3, [sp, #12]
   84784:	f04f 0b2c 	mov.w	fp, #44	; 0x2c
   84788:	e033      	b.n	847f2 <planner_recalculate+0x192>
   8478a:	4625      	mov	r5, r4
   8478c:	fb0b f304 	mul.w	r3, fp, r4
   84790:	9a03      	ldr	r2, [sp, #12]
   84792:	441a      	add	r2, r3
   84794:	9201      	str	r2, [sp, #4]
    
    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
   84796:	f8d6 9014 	ldr.w	r9, [r6, #20]
   8479a:	4453      	add	r3, sl
   8479c:	699b      	ldr	r3, [r3, #24]
   8479e:	9302      	str	r3, [sp, #8]
   847a0:	4648      	mov	r0, r9
   847a2:	4619      	mov	r1, r3
   847a4:	4b19      	ldr	r3, [pc, #100]	; (8480c <planner_recalculate+0x1ac>)
   847a6:	4798      	blx	r3
   847a8:	b1a0      	cbz	r0, 847d4 <planner_recalculate+0x174>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
   847aa:	6a70      	ldr	r0, [r6, #36]	; 0x24
   847ac:	4601      	mov	r1, r0
   847ae:	4b15      	ldr	r3, [pc, #84]	; (84804 <planner_recalculate+0x1a4>)
   847b0:	4798      	blx	r3
   847b2:	6ab1      	ldr	r1, [r6, #40]	; 0x28
   847b4:	4b14      	ldr	r3, [pc, #80]	; (84808 <planner_recalculate+0x1a8>)
   847b6:	4798      	blx	r3
   847b8:	4601      	mov	r1, r0
   847ba:	4648      	mov	r0, r9
   847bc:	4b11      	ldr	r3, [pc, #68]	; (84804 <planner_recalculate+0x1a4>)
   847be:	4798      	blx	r3
   847c0:	4606      	mov	r6, r0
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
   847c2:	9802      	ldr	r0, [sp, #8]
   847c4:	4631      	mov	r1, r6
   847c6:	4b15      	ldr	r3, [pc, #84]	; (8481c <planner_recalculate+0x1bc>)
   847c8:	4798      	blx	r3
   847ca:	b118      	cbz	r0, 847d4 <planner_recalculate+0x174>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
   847cc:	fb0b a304 	mla	r3, fp, r4, sl
   847d0:	619e      	str	r6, [r3, #24]
        block_buffer_planned = block_index; // Set optimal plan pointer.
   847d2:	4627      	mov	r7, r4
    
    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
   847d4:	fb0b a505 	mla	r5, fp, r5, sl
   847d8:	69a8      	ldr	r0, [r5, #24]
   847da:	69e9      	ldr	r1, [r5, #28]
   847dc:	4b0e      	ldr	r3, [pc, #56]	; (84818 <planner_recalculate+0x1b8>)
   847de:	4798      	blx	r3
   847e0:	2800      	cmp	r0, #0
   847e2:	bf18      	it	ne
   847e4:	4627      	movne	r7, r4


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
   847e6:	3401      	adds	r4, #1
   847e8:	b2e4      	uxtb	r4, r4
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
   847ea:	2c12      	cmp	r4, #18
   847ec:	bf08      	it	eq
   847ee:	2400      	moveq	r4, #0
   847f0:	9e01      	ldr	r6, [sp, #4]

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
   847f2:	4544      	cmp	r4, r8
   847f4:	d1c9      	bne.n	8478a <planner_recalculate+0x12a>
   847f6:	4b02      	ldr	r3, [pc, #8]	; (84800 <planner_recalculate+0x1a0>)
   847f8:	705f      	strb	r7, [r3, #1]
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  } 
}
   847fa:	b005      	add	sp, #20
   847fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84800:	20000c0c 	.word	0x20000c0c
   84804:	0008c525 	.word	0x0008c525
   84808:	0008c735 	.word	0x0008c735
   8480c:	0008ca71 	.word	0x0008ca71
   84810:	20000c10 	.word	0x20000c10
   84814:	000889ed 	.word	0x000889ed
   84818:	0008ca5d 	.word	0x0008ca5d
   8481c:	0008caad 	.word	0x0008caad

00084820 <plan_reset>:


void plan_reset() 
{
  memset(&pl, 0, sizeof(pl)); // Clear planner struct
   84820:	4b0b      	ldr	r3, [pc, #44]	; (84850 <plan_reset+0x30>)
   84822:	2200      	movs	r2, #0
   84824:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
   84828:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
   8482c:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
   84830:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
   84834:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
   84838:	f8c3 2334 	str.w	r2, [r3, #820]	; 0x334
   8483c:	f8c3 2338 	str.w	r2, [r3, #824]	; 0x338
  block_buffer_tail = 0;
   84840:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c
  block_buffer_head = 0; // Empty = tail
   84844:	701a      	strb	r2, [r3, #0]
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
   84846:	2101      	movs	r1, #1
   84848:	f883 133c 	strb.w	r1, [r3, #828]	; 0x33c
  block_buffer_planned = 0; // = block_buffer_tail;
   8484c:	705a      	strb	r2, [r3, #1]
   8484e:	4770      	bx	lr
   84850:	20000c0c 	.word	0x20000c0c

00084854 <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
   84854:	4b0a      	ldr	r3, [pc, #40]	; (84880 <plan_discard_current_block+0x2c>)
   84856:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
   8485a:	781b      	ldrb	r3, [r3, #0]
   8485c:	4293      	cmp	r3, r2
   8485e:	d00e      	beq.n	8487e <plan_discard_current_block+0x2a>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
   84860:	1c53      	adds	r3, r2, #1
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
   84862:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   84866:	2b12      	cmp	r3, #18
   84868:	bf08      	it	eq
   8486a:	2300      	moveq	r3, #0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
   8486c:	4904      	ldr	r1, [pc, #16]	; (84880 <plan_discard_current_block+0x2c>)
   8486e:	7849      	ldrb	r1, [r1, #1]
   84870:	4291      	cmp	r1, r2
   84872:	bf04      	itt	eq
   84874:	4a02      	ldreq	r2, [pc, #8]	; (84880 <plan_discard_current_block+0x2c>)
   84876:	7053      	strbeq	r3, [r2, #1]
    block_buffer_tail = block_index;
   84878:	4a01      	ldr	r2, [pc, #4]	; (84880 <plan_discard_current_block+0x2c>)
   8487a:	f882 331c 	strb.w	r3, [r2, #796]	; 0x31c
   8487e:	4770      	bx	lr
   84880:	20000c0c 	.word	0x20000c0c

00084884 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
   84884:	4a05      	ldr	r2, [pc, #20]	; (8489c <plan_get_current_block+0x18>)
   84886:	f892 331c 	ldrb.w	r3, [r2, #796]	; 0x31c
   8488a:	7812      	ldrb	r2, [r2, #0]
   8488c:	429a      	cmp	r2, r3
  return(&block_buffer[block_buffer_tail]);
   8488e:	bf1d      	ittte	ne
   84890:	202c      	movne	r0, #44	; 0x2c
   84892:	4a03      	ldrne	r2, [pc, #12]	; (848a0 <plan_get_current_block+0x1c>)
   84894:	fb00 2003 	mlane	r0, r0, r3, r2
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
   84898:	2000      	moveq	r0, #0
  return(&block_buffer[block_buffer_tail]);
}
   8489a:	4770      	bx	lr
   8489c:	20000c0c 	.word	0x20000c0c
   848a0:	20000c10 	.word	0x20000c10

000848a4 <plan_get_exec_block_exit_speed>:


float plan_get_exec_block_exit_speed()
{
   848a4:	b538      	push	{r3, r4, r5, lr}
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
   848a6:	4b0e      	ldr	r3, [pc, #56]	; (848e0 <plan_get_exec_block_exit_speed+0x3c>)


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
   848a8:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
   848ac:	3301      	adds	r3, #1
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
   848ae:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   848b2:	2b12      	cmp	r3, #18
   848b4:	bf08      	it	eq
   848b6:	2300      	moveq	r3, #0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
   848b8:	4a09      	ldr	r2, [pc, #36]	; (848e0 <plan_get_exec_block_exit_speed+0x3c>)
   848ba:	7812      	ldrb	r2, [r2, #0]
   848bc:	429a      	cmp	r2, r3
   848be:	d00d      	beq.n	848dc <plan_get_exec_block_exit_speed+0x38>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
   848c0:	242c      	movs	r4, #44	; 0x2c
   848c2:	4a07      	ldr	r2, [pc, #28]	; (848e0 <plan_get_exec_block_exit_speed+0x3c>)
   848c4:	fb04 2303 	mla	r3, r4, r3, r2
   848c8:	f103 0414 	add.w	r4, r3, #20
   848cc:	4d05      	ldr	r5, [pc, #20]	; (848e4 <plan_get_exec_block_exit_speed+0x40>)
   848ce:	6860      	ldr	r0, [r4, #4]
   848d0:	47a8      	blx	r5
   848d2:	4b05      	ldr	r3, [pc, #20]	; (848e8 <plan_get_exec_block_exit_speed+0x44>)
   848d4:	4798      	blx	r3
   848d6:	4b05      	ldr	r3, [pc, #20]	; (848ec <plan_get_exec_block_exit_speed+0x48>)
   848d8:	4798      	blx	r3
   848da:	bd38      	pop	{r3, r4, r5, pc}


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
   848dc:	2000      	movs	r0, #0
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
   848de:	bd38      	pop	{r3, r4, r5, pc}
   848e0:	20000c0c 	.word	0x20000c0c
   848e4:	0008be0d 	.word	0x0008be0d
   848e8:	0008a2dd 	.word	0x0008a2dd
   848ec:	0008c479 	.word	0x0008c479

000848f0 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
  if (block_buffer_tail == next_buffer_head) { return(true); }
   848f0:	4b04      	ldr	r3, [pc, #16]	; (84904 <plan_check_full_buffer+0x14>)
   848f2:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
   848f6:	f893 333c 	ldrb.w	r3, [r3, #828]	; 0x33c
  return(false);
}
   848fa:	4298      	cmp	r0, r3
   848fc:	bf14      	ite	ne
   848fe:	2000      	movne	r0, #0
   84900:	2001      	moveq	r0, #1
   84902:	4770      	bx	lr
   84904:	20000c0c 	.word	0x20000c0c

00084908 <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
   84908:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8490c:	b08d      	sub	sp, #52	; 0x34
   8490e:	9100      	str	r1, [sp, #0]
   84910:	9202      	str	r2, [sp, #8]
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
   84912:	4b7d      	ldr	r3, [pc, #500]	; (84b08 <plan_buffer_line+0x200>)
   84914:	f893 b000 	ldrb.w	fp, [r3]
  block->step_event_count = 0;
   84918:	262c      	movs	r6, #44	; 0x2c
   8491a:	fb06 f60b 	mul.w	r6, r6, fp
   8491e:	199a      	adds	r2, r3, r6
   84920:	2400      	movs	r4, #0
   84922:	6154      	str	r4, [r2, #20]
  block->millimeters = 0;
   84924:	2100      	movs	r1, #0
   84926:	62d1      	str	r1, [r2, #44]	; 0x2c
  block->direction_bits = 0;
   84928:	7114      	strb	r4, [r2, #4]
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
   8492a:	4978      	ldr	r1, [pc, #480]	; (84b0c <plan_buffer_line+0x204>)
   8492c:	6291      	str	r1, [r2, #40]	; 0x28
   8492e:	f1a0 0a04 	sub.w	sl, r0, #4
   84932:	3304      	adds	r3, #4
   84934:	441e      	add	r6, r3
        delta_mm = ((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]))/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
   84936:	f8df 9218 	ldr.w	r9, [pc, #536]	; 84b50 <plan_buffer_line+0x248>
   8493a:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 84b34 <plan_buffer_line+0x22c>
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
   8493e:	4615      	mov	r5, r2
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
   84940:	f8cd b004 	str.w	fp, [sp, #4]
   84944:	fa5f fb84 	uxtb.w	fp, r4
        delta_mm = ((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]))/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
   84948:	f85a 0f04 	ldr.w	r0, [sl, #4]!
   8494c:	f859 1024 	ldr.w	r1, [r9, r4, lsl #2]
   84950:	47c0      	blx	r8
   84952:	4b6f      	ldr	r3, [pc, #444]	; (84b10 <plan_buffer_line+0x208>)
   84954:	4798      	blx	r3
   84956:	4b6f      	ldr	r3, [pc, #444]	; (84b14 <plan_buffer_line+0x20c>)
   84958:	4798      	blx	r3
   8495a:	ab09      	add	r3, sp, #36	; 0x24
   8495c:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
   84960:	4b69      	ldr	r3, [pc, #420]	; (84b08 <plan_buffer_line+0x200>)
   84962:	f503 7348 	add.w	r3, r3, #800	; 0x320
   84966:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   8496a:	1ac0      	subs	r0, r0, r3
   8496c:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
   84970:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
   84974:	f846 2f04 	str.w	r2, [r6, #4]!
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
   84978:	696b      	ldr	r3, [r5, #20]
   8497a:	4293      	cmp	r3, r2
   8497c:	bf38      	it	cc
   8497e:	4613      	movcc	r3, r2
   84980:	616b      	str	r3, [r5, #20]
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
   84982:	4b65      	ldr	r3, [pc, #404]	; (84b18 <plan_buffer_line+0x210>)
   84984:	4798      	blx	r3
   84986:	f859 1024 	ldr.w	r1, [r9, r4, lsl #2]
   8498a:	4b64      	ldr	r3, [pc, #400]	; (84b1c <plan_buffer_line+0x214>)
   8498c:	4798      	blx	r3
   8498e:	4607      	mov	r7, r0
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
   84990:	ab06      	add	r3, sp, #24
   84992:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
   84996:	2100      	movs	r1, #0
   84998:	4b61      	ldr	r3, [pc, #388]	; (84b20 <plan_buffer_line+0x218>)
   8499a:	4798      	blx	r3
   8499c:	b128      	cbz	r0, 849aa <plan_buffer_line+0xa2>
   8499e:	4658      	mov	r0, fp
   849a0:	4b60      	ldr	r3, [pc, #384]	; (84b24 <plan_buffer_line+0x21c>)
   849a2:	4798      	blx	r3
   849a4:	792b      	ldrb	r3, [r5, #4]
   849a6:	4318      	orrs	r0, r3
   849a8:	7128      	strb	r0, [r5, #4]
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
   849aa:	4638      	mov	r0, r7
   849ac:	4639      	mov	r1, r7
   849ae:	47c0      	blx	r8
   849b0:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   849b2:	4b5d      	ldr	r3, [pc, #372]	; (84b28 <plan_buffer_line+0x220>)
   849b4:	4798      	blx	r3
   849b6:	62e8      	str	r0, [r5, #44]	; 0x2c
   849b8:	3401      	adds	r4, #1
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
   849ba:	2c03      	cmp	r4, #3
   849bc:	d1c2      	bne.n	84944 <plan_buffer_line+0x3c>
   849be:	f8dd b004 	ldr.w	fp, [sp, #4]
   849c2:	4607      	mov	r7, r0
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
   849c4:	4c52      	ldr	r4, [pc, #328]	; (84b10 <plan_buffer_line+0x208>)
   849c6:	4638      	mov	r0, r7
   849c8:	47a0      	blx	r4
   849ca:	4b58      	ldr	r3, [pc, #352]	; (84b2c <plan_buffer_line+0x224>)
   849cc:	4798      	blx	r3
   849ce:	4b58      	ldr	r3, [pc, #352]	; (84b30 <plan_buffer_line+0x228>)
   849d0:	4798      	blx	r3
   849d2:	4604      	mov	r4, r0
   849d4:	232c      	movs	r3, #44	; 0x2c
   849d6:	4a4c      	ldr	r2, [pc, #304]	; (84b08 <plan_buffer_line+0x200>)
   849d8:	fb03 230b 	mla	r3, r3, fp, r2
   849dc:	62d8      	str	r0, [r3, #44]	; 0x2c
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
   849de:	695b      	ldr	r3, [r3, #20]
   849e0:	2b00      	cmp	r3, #0
   849e2:	f000 8142 	beq.w	84c6a <plan_buffer_line+0x362>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
   849e6:	9800      	ldr	r0, [sp, #0]
   849e8:	2100      	movs	r1, #0
   849ea:	4b4d      	ldr	r3, [pc, #308]	; (84b20 <plan_buffer_line+0x218>)
   849ec:	4798      	blx	r3
   849ee:	b980      	cbnz	r0, 84a12 <plan_buffer_line+0x10a>
  else if (invert_feed_rate) { feed_rate *= block->millimeters; }
   849f0:	9b02      	ldr	r3, [sp, #8]
   849f2:	b123      	cbz	r3, 849fe <plan_buffer_line+0xf6>
   849f4:	9800      	ldr	r0, [sp, #0]
   849f6:	4621      	mov	r1, r4
   849f8:	4b4e      	ldr	r3, [pc, #312]	; (84b34 <plan_buffer_line+0x22c>)
   849fa:	4798      	blx	r3
   849fc:	9000      	str	r0, [sp, #0]
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
   849fe:	9800      	ldr	r0, [sp, #0]
   84a00:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
   84a04:	4b46      	ldr	r3, [pc, #280]	; (84b20 <plan_buffer_line+0x218>)
   84a06:	4798      	blx	r3
   84a08:	b128      	cbz	r0, 84a16 <plan_buffer_line+0x10e>
   84a0a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   84a0e:	9300      	str	r3, [sp, #0]
   84a10:	e001      	b.n	84a16 <plan_buffer_line+0x10e>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
   84a12:	4b3e      	ldr	r3, [pc, #248]	; (84b0c <plan_buffer_line+0x204>)
   84a14:	9300      	str	r3, [sp, #0]
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
   84a16:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   84a1a:	4621      	mov	r1, r4
   84a1c:	4b3f      	ldr	r3, [pc, #252]	; (84b1c <plan_buffer_line+0x214>)
   84a1e:	4798      	blx	r3
   84a20:	9004      	str	r0, [sp, #16]
   84a22:	ac06      	add	r4, sp, #24
   84a24:	4e44      	ldr	r6, [pc, #272]	; (84b38 <plan_buffer_line+0x230>)
   84a26:	4d45      	ldr	r5, [pc, #276]	; (84b3c <plan_buffer_line+0x234>)
   84a28:	f10d 0824 	add.w	r8, sp, #36	; 0x24
  float junction_cos_theta = 0;
   84a2c:	2300      	movs	r3, #0
   84a2e:	9301      	str	r3, [sp, #4]
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
   84a30:	f8df 9100 	ldr.w	r9, [pc, #256]	; 84b34 <plan_buffer_line+0x22c>
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
   84a34:	222c      	movs	r2, #44	; 0x2c
   84a36:	f5a6 734b 	sub.w	r3, r6, #812	; 0x32c
   84a3a:	fb02 3a0b 	mla	sl, r2, fp, r3
   84a3e:	f8cd b014 	str.w	fp, [sp, #20]
   84a42:	46d3      	mov	fp, sl
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
   84a44:	f854 7b04 	ldr.w	r7, [r4], #4
   84a48:	4638      	mov	r0, r7
   84a4a:	2100      	movs	r1, #0
   84a4c:	4b3c      	ldr	r3, [pc, #240]	; (84b40 <plan_buffer_line+0x238>)
   84a4e:	4798      	blx	r3
   84a50:	2800      	cmp	r0, #0
   84a52:	d12f      	bne.n	84ab4 <plan_buffer_line+0x1ac>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
   84a54:	9804      	ldr	r0, [sp, #16]
   84a56:	4639      	mov	r1, r7
   84a58:	47c8      	blx	r9
   84a5a:	4603      	mov	r3, r0
   84a5c:	9002      	str	r0, [sp, #8]
   84a5e:	f844 0c04 	str.w	r0, [r4, #-4]
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
   84a62:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   84a66:	4619      	mov	r1, r3
   84a68:	4b2c      	ldr	r3, [pc, #176]	; (84b1c <plan_buffer_line+0x214>)
   84a6a:	4798      	blx	r3
   84a6c:	f020 4a00 	bic.w	sl, r0, #2147483648	; 0x80000000
   84a70:	9503      	str	r5, [sp, #12]

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
   84a72:	4650      	mov	r0, sl
   84a74:	f855 1c0c 	ldr.w	r1, [r5, #-12]
   84a78:	47c8      	blx	r9
   84a7a:	4607      	mov	r7, r0
   84a7c:	9900      	ldr	r1, [sp, #0]
   84a7e:	4b31      	ldr	r3, [pc, #196]	; (84b44 <plan_buffer_line+0x23c>)
   84a80:	4798      	blx	r3
   84a82:	b900      	cbnz	r0, 84a86 <plan_buffer_line+0x17e>
   84a84:	9700      	str	r7, [sp, #0]
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
   84a86:	f8db 7028 	ldr.w	r7, [fp, #40]	; 0x28
   84a8a:	4650      	mov	r0, sl
   84a8c:	9b03      	ldr	r3, [sp, #12]
   84a8e:	6819      	ldr	r1, [r3, #0]
   84a90:	47c8      	blx	r9
   84a92:	4682      	mov	sl, r0
   84a94:	4638      	mov	r0, r7
   84a96:	4651      	mov	r1, sl
   84a98:	4b21      	ldr	r3, [pc, #132]	; (84b20 <plan_buffer_line+0x218>)
   84a9a:	4798      	blx	r3
   84a9c:	b900      	cbnz	r0, 84aa0 <plan_buffer_line+0x198>
   84a9e:	4657      	mov	r7, sl
   84aa0:	f8cb 7028 	str.w	r7, [fp, #40]	; 0x28

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
   84aa4:	9802      	ldr	r0, [sp, #8]
   84aa6:	6831      	ldr	r1, [r6, #0]
   84aa8:	47c8      	blx	r9
   84aaa:	4601      	mov	r1, r0
   84aac:	9801      	ldr	r0, [sp, #4]
   84aae:	4b26      	ldr	r3, [pc, #152]	; (84b48 <plan_buffer_line+0x240>)
   84ab0:	4798      	blx	r3
   84ab2:	9001      	str	r0, [sp, #4]
   84ab4:	3604      	adds	r6, #4
   84ab6:	3504      	adds	r5, #4
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
   84ab8:	4544      	cmp	r4, r8
   84aba:	d1c3      	bne.n	84a44 <plan_buffer_line+0x13c>
   84abc:	f8dd b014 	ldr.w	fp, [sp, #20]
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
   84ac0:	4b11      	ldr	r3, [pc, #68]	; (84b08 <plan_buffer_line+0x200>)
   84ac2:	781a      	ldrb	r2, [r3, #0]
   84ac4:	f893 331c 	ldrb.w	r3, [r3, #796]	; 0x31c
   84ac8:	429a      	cmp	r2, r3
   84aca:	d107      	bne.n	84adc <plan_buffer_line+0x1d4>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
   84acc:	232c      	movs	r3, #44	; 0x2c
   84ace:	4a0e      	ldr	r2, [pc, #56]	; (84b08 <plan_buffer_line+0x200>)
   84ad0:	fb03 230b 	mla	r3, r3, fp, r2
   84ad4:	2200      	movs	r2, #0
   84ad6:	619a      	str	r2, [r3, #24]
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
   84ad8:	621a      	str	r2, [r3, #32]
   84ada:	e085      	b.n	84be8 <plan_buffer_line+0x2e0>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999) {
   84adc:	9801      	ldr	r0, [sp, #4]
   84ade:	4b0c      	ldr	r3, [pc, #48]	; (84b10 <plan_buffer_line+0x208>)
   84ae0:	4798      	blx	r3
   84ae2:	4604      	mov	r4, r0
   84ae4:	460d      	mov	r5, r1
   84ae6:	a306      	add	r3, pc, #24	; (adr r3, 84b00 <plan_buffer_line+0x1f8>)
   84ae8:	e9d3 2300 	ldrd	r2, r3, [r3]
   84aec:	4e17      	ldr	r6, [pc, #92]	; (84b4c <plan_buffer_line+0x244>)
   84aee:	47b0      	blx	r6
   84af0:	b380      	cbz	r0, 84b54 <plan_buffer_line+0x24c>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
   84af2:	232c      	movs	r3, #44	; 0x2c
   84af4:	4a04      	ldr	r2, [pc, #16]	; (84b08 <plan_buffer_line+0x200>)
   84af6:	fb03 230b 	mla	r3, r3, fp, r2
   84afa:	2200      	movs	r2, #0
   84afc:	621a      	str	r2, [r3, #32]
   84afe:	e073      	b.n	84be8 <plan_buffer_line+0x2e0>
   84b00:	e7210be9 	.word	0xe7210be9
   84b04:	3feffffd 	.word	0x3feffffd
   84b08:	20000c0c 	.word	0x20000c0c
   84b0c:	7e967699 	.word	0x7e967699
   84b10:	0008be0d 	.word	0x0008be0d
   84b14:	0008a0a1 	.word	0x0008a0a1
   84b18:	0008c68d 	.word	0x0008c68d
   84b1c:	0008c89d 	.word	0x0008c89d
   84b20:	0008ca71 	.word	0x0008ca71
   84b24:	0008835d 	.word	0x0008835d
   84b28:	0008c525 	.word	0x0008c525
   84b2c:	0008a2dd 	.word	0x0008a2dd
   84b30:	0008c479 	.word	0x0008c479
   84b34:	0008c735 	.word	0x0008c735
   84b38:	20000f38 	.word	0x20000f38
   84b3c:	20001528 	.word	0x20001528
   84b40:	0008ca5d 	.word	0x0008ca5d
   84b44:	0008caad 	.word	0x0008caad
   84b48:	0008c521 	.word	0x0008c521
   84b4c:	0008c3d5 	.word	0x0008c3d5
   84b50:	20001510 	.word	0x20001510
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.999999); // Check for numerical round-off to avoid divide by zero.
   84b54:	4620      	mov	r0, r4
   84b56:	4629      	mov	r1, r5
   84b58:	a345      	add	r3, pc, #276	; (adr r3, 84c70 <plan_buffer_line+0x368>)
   84b5a:	e9d3 2300 	ldrd	r2, r3, [r3]
   84b5e:	4c46      	ldr	r4, [pc, #280]	; (84c78 <plan_buffer_line+0x370>)
   84b60:	47a0      	blx	r4
   84b62:	b908      	cbnz	r0, 84b68 <plan_buffer_line+0x260>
   84b64:	4b45      	ldr	r3, [pc, #276]	; (84c7c <plan_buffer_line+0x374>)
   84b66:	9301      	str	r3, [sp, #4]
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
   84b68:	4e45      	ldr	r6, [pc, #276]	; (84c80 <plan_buffer_line+0x378>)
   84b6a:	9d01      	ldr	r5, [sp, #4]
   84b6c:	4f45      	ldr	r7, [pc, #276]	; (84c84 <plan_buffer_line+0x37c>)
   84b6e:	4c46      	ldr	r4, [pc, #280]	; (84c88 <plan_buffer_line+0x380>)
   84b70:	4628      	mov	r0, r5
   84b72:	47b0      	blx	r6
   84b74:	4602      	mov	r2, r0
   84b76:	460b      	mov	r3, r1
   84b78:	2000      	movs	r0, #0
   84b7a:	4944      	ldr	r1, [pc, #272]	; (84c8c <plan_buffer_line+0x384>)
   84b7c:	47b8      	blx	r7
   84b7e:	2200      	movs	r2, #0
   84b80:	4b43      	ldr	r3, [pc, #268]	; (84c90 <plan_buffer_line+0x388>)
   84b82:	47a0      	blx	r4
   84b84:	4b43      	ldr	r3, [pc, #268]	; (84c94 <plan_buffer_line+0x38c>)
   84b86:	4798      	blx	r3
   84b88:	4b43      	ldr	r3, [pc, #268]	; (84c98 <plan_buffer_line+0x390>)
   84b8a:	4798      	blx	r3
   84b8c:	4680      	mov	r8, r0

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
   84b8e:	232c      	movs	r3, #44	; 0x2c
   84b90:	4a42      	ldr	r2, [pc, #264]	; (84c9c <plan_buffer_line+0x394>)
   84b92:	fb03 230b 	mla	r3, r3, fp, r2
   84b96:	4c42      	ldr	r4, [pc, #264]	; (84ca0 <plan_buffer_line+0x398>)
   84b98:	6a98      	ldr	r0, [r3, #40]	; 0x28
   84b9a:	4b42      	ldr	r3, [pc, #264]	; (84ca4 <plan_buffer_line+0x39c>)
   84b9c:	6b99      	ldr	r1, [r3, #56]	; 0x38
   84b9e:	47a0      	blx	r4
   84ba0:	4641      	mov	r1, r8
   84ba2:	47a0      	blx	r4
   84ba4:	47b0      	blx	r6
   84ba6:	4604      	mov	r4, r0
   84ba8:	460d      	mov	r5, r1
   84baa:	4640      	mov	r0, r8
   84bac:	47b0      	blx	r6
   84bae:	4602      	mov	r2, r0
   84bb0:	460b      	mov	r3, r1
   84bb2:	2000      	movs	r0, #0
   84bb4:	4935      	ldr	r1, [pc, #212]	; (84c8c <plan_buffer_line+0x384>)
   84bb6:	47b8      	blx	r7
   84bb8:	4602      	mov	r2, r0
   84bba:	460b      	mov	r3, r1
   84bbc:	4620      	mov	r0, r4
   84bbe:	4629      	mov	r1, r5
   84bc0:	4c39      	ldr	r4, [pc, #228]	; (84ca8 <plan_buffer_line+0x3a0>)
   84bc2:	47a0      	blx	r4
   84bc4:	4604      	mov	r4, r0
   84bc6:	460d      	mov	r5, r1
   84bc8:	2200      	movs	r2, #0
   84bca:	2300      	movs	r3, #0
   84bcc:	4e37      	ldr	r6, [pc, #220]	; (84cac <plan_buffer_line+0x3a4>)
   84bce:	47b0      	blx	r6
   84bd0:	b920      	cbnz	r0, 84bdc <plan_buffer_line+0x2d4>
   84bd2:	4620      	mov	r0, r4
   84bd4:	4629      	mov	r1, r5
   84bd6:	4b30      	ldr	r3, [pc, #192]	; (84c98 <plan_buffer_line+0x390>)
   84bd8:	4798      	blx	r3
   84bda:	e000      	b.n	84bde <plan_buffer_line+0x2d6>
   84bdc:	2000      	movs	r0, #0
   84bde:	232c      	movs	r3, #44	; 0x2c
   84be0:	4a2e      	ldr	r2, [pc, #184]	; (84c9c <plan_buffer_line+0x394>)
   84be2:	fb03 230b 	mla	r3, r3, fp, r2
   84be6:	6218      	str	r0, [r3, #32]

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
   84be8:	9900      	ldr	r1, [sp, #0]
   84bea:	4608      	mov	r0, r1
   84bec:	4b2c      	ldr	r3, [pc, #176]	; (84ca0 <plan_buffer_line+0x398>)
   84bee:	4798      	blx	r3
   84bf0:	4605      	mov	r5, r0
   84bf2:	4a2a      	ldr	r2, [pc, #168]	; (84c9c <plan_buffer_line+0x394>)
   84bf4:	232c      	movs	r3, #44	; 0x2c
   84bf6:	fb03 230b 	mla	r3, r3, fp, r2
   84bfa:	6258      	str	r0, [r3, #36]	; 0x24
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
   84bfc:	6a1e      	ldr	r6, [r3, #32]
   84bfe:	f8d2 4338 	ldr.w	r4, [r2, #824]	; 0x338
   84c02:	4621      	mov	r1, r4
   84c04:	4b2a      	ldr	r3, [pc, #168]	; (84cb0 <plan_buffer_line+0x3a8>)
   84c06:	4798      	blx	r3
   84c08:	b908      	cbnz	r0, 84c0e <plan_buffer_line+0x306>
   84c0a:	4620      	mov	r0, r4
   84c0c:	e000      	b.n	84c10 <plan_buffer_line+0x308>
   84c0e:	4628      	mov	r0, r5
   84c10:	4631      	mov	r1, r6
   84c12:	4b28      	ldr	r3, [pc, #160]	; (84cb4 <plan_buffer_line+0x3ac>)
   84c14:	4798      	blx	r3
   84c16:	b938      	cbnz	r0, 84c28 <plan_buffer_line+0x320>
   84c18:	4628      	mov	r0, r5
   84c1a:	4621      	mov	r1, r4
   84c1c:	4b24      	ldr	r3, [pc, #144]	; (84cb0 <plan_buffer_line+0x3a8>)
   84c1e:	4798      	blx	r3
   84c20:	b908      	cbnz	r0, 84c26 <plan_buffer_line+0x31e>
   84c22:	4626      	mov	r6, r4
   84c24:	e000      	b.n	84c28 <plan_buffer_line+0x320>
   84c26:	462e      	mov	r6, r5
   84c28:	4c1c      	ldr	r4, [pc, #112]	; (84c9c <plan_buffer_line+0x394>)
   84c2a:	232c      	movs	r3, #44	; 0x2c
   84c2c:	fb03 430b 	mla	r3, r3, fp, r4
   84c30:	61de      	str	r6, [r3, #28]
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
   84c32:	f504 734b 	add.w	r3, r4, #812	; 0x32c
   84c36:	aa06      	add	r2, sp, #24
   84c38:	ca07      	ldmia	r2, {r0, r1, r2}
   84c3a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
   84c3e:	f8c4 5338 	str.w	r5, [r4, #824]	; 0x338
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
   84c42:	f504 7348 	add.w	r3, r4, #800	; 0x320
   84c46:	aa0c      	add	r2, sp, #48	; 0x30
   84c48:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   84c4c:	e883 0007 	stmia.w	r3, {r0, r1, r2}

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
   84c50:	f894 333c 	ldrb.w	r3, [r4, #828]	; 0x33c
   84c54:	7023      	strb	r3, [r4, #0]


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
   84c56:	3301      	adds	r3, #1
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
   84c58:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   84c5c:	2b12      	cmp	r3, #18
   84c5e:	bf08      	it	eq
   84c60:	2300      	moveq	r3, #0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
   84c62:	f884 333c 	strb.w	r3, [r4, #828]	; 0x33c
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
   84c66:	4b14      	ldr	r3, [pc, #80]	; (84cb8 <plan_buffer_line+0x3b0>)
   84c68:	4798      	blx	r3
}
   84c6a:	b00d      	add	sp, #52	; 0x34
   84c6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84c70:	e7210be9 	.word	0xe7210be9
   84c74:	bfeffffd 	.word	0xbfeffffd
   84c78:	0008c3d5 	.word	0x0008c3d5
   84c7c:	bf7fffef 	.word	0xbf7fffef
   84c80:	0008be0d 	.word	0x0008be0d
   84c84:	0008bb4d 	.word	0x0008bb4d
   84c88:	0008beb5 	.word	0x0008beb5
   84c8c:	3ff00000 	.word	0x3ff00000
   84c90:	3fe00000 	.word	0x3fe00000
   84c94:	0008a2dd 	.word	0x0008a2dd
   84c98:	0008c479 	.word	0x0008c479
   84c9c:	20000c0c 	.word	0x20000c0c
   84ca0:	0008c735 	.word	0x0008c735
   84ca4:	20001510 	.word	0x20001510
   84ca8:	0008c109 	.word	0x0008c109
   84cac:	0008c399 	.word	0x0008c399
   84cb0:	0008ca71 	.word	0x0008ca71
   84cb4:	0008caad 	.word	0x0008caad
   84cb8:	00084661 	.word	0x00084661

00084cbc <plan_sync_position>:
        pl.position[idx] = (sys.position[A_MOTOR] - sys.position[B_MOTOR])/2;
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
   84cbc:	4b05      	ldr	r3, [pc, #20]	; (84cd4 <plan_sync_position+0x18>)
   84cbe:	4a06      	ldr	r2, [pc, #24]	; (84cd8 <plan_sync_position+0x1c>)
   84cc0:	6851      	ldr	r1, [r2, #4]
   84cc2:	f8c3 1320 	str.w	r1, [r3, #800]	; 0x320
   84cc6:	6891      	ldr	r1, [r2, #8]
   84cc8:	f8c3 1324 	str.w	r1, [r3, #804]	; 0x324
   84ccc:	68d2      	ldr	r2, [r2, #12]
   84cce:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
   84cd2:	4770      	bx	lr
   84cd4:	20000c0c 	.word	0x20000c0c
   84cd8:	20001484 	.word	0x20001484

00084cdc <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
   84cdc:	4a04      	ldr	r2, [pc, #16]	; (84cf0 <plan_get_block_buffer_count+0x14>)
   84cde:	7813      	ldrb	r3, [r2, #0]
   84ce0:	f892 031c 	ldrb.w	r0, [r2, #796]	; 0x31c
   84ce4:	4283      	cmp	r3, r0
   84ce6:	bf38      	it	cc
   84ce8:	3312      	addcc	r3, #18
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
   84cea:	1a18      	subs	r0, r3, r0
   84cec:	b2c0      	uxtb	r0, r0
}
   84cee:	4770      	bx	lr
   84cf0:	20000c0c 	.word	0x20000c0c

00084cf4 <plan_cycle_reinitialize>:


// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
   84cf4:	b508      	push	{r3, lr}
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
   84cf6:	4b04      	ldr	r3, [pc, #16]	; (84d08 <plan_cycle_reinitialize+0x14>)
   84cf8:	4798      	blx	r3
  block_buffer_planned = block_buffer_tail;
   84cfa:	4b04      	ldr	r3, [pc, #16]	; (84d0c <plan_cycle_reinitialize+0x18>)
   84cfc:	f893 231c 	ldrb.w	r2, [r3, #796]	; 0x31c
   84d00:	705a      	strb	r2, [r3, #1]
  planner_recalculate();  
   84d02:	4b03      	ldr	r3, [pc, #12]	; (84d10 <plan_cycle_reinitialize+0x1c>)
   84d04:	4798      	blx	r3
   84d06:	bd08      	pop	{r3, pc}
   84d08:	000889ed 	.word	0x000889ed
   84d0c:	20000c0c 	.word	0x20000c0c
   84d10:	00084661 	.word	0x00084661

00084d14 <printString>:

#include "grbl.h"
#include "ra8875.h"

void printString(char *s)
{
   84d14:	b538      	push	{r3, r4, r5, lr}
   84d16:	4604      	mov	r4, r0
//	tft_textWrite(1,1,700,0,s,ALINE_LEFT);
	  while (*s)
   84d18:	7800      	ldrb	r0, [r0, #0]
   84d1a:	b128      	cbz	r0, 84d28 <printString+0x14>
		serial_write(*s++);
   84d1c:	4d03      	ldr	r5, [pc, #12]	; (84d2c <printString+0x18>)
   84d1e:	47a8      	blx	r5
#include "ra8875.h"

void printString(char *s)
{
//	tft_textWrite(1,1,700,0,s,ALINE_LEFT);
	  while (*s)
   84d20:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   84d24:	2800      	cmp	r0, #0
   84d26:	d1fa      	bne.n	84d1e <printString+0xa>
   84d28:	bd38      	pop	{r3, r4, r5, pc}
   84d2a:	bf00      	nop
   84d2c:	00087e41 	.word	0x00087e41

00084d30 <print_unsigned_int8>:
// }


// Prints an uint8 variable with base and number of desired digits.
void print_unsigned_int8(uint8_t n, uint8_t base, uint8_t digits)
{ 
   84d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   84d32:	af00      	add	r7, sp, #0
   84d34:	4614      	mov	r4, r2
  unsigned char buf[digits];
   84d36:	1dd3      	adds	r3, r2, #7
   84d38:	f023 0307 	bic.w	r3, r3, #7
   84d3c:	ebad 0d03 	sub.w	sp, sp, r3
  uint8_t i = 0;

  for (; i < digits; i++) {
   84d40:	b1ca      	cbz	r2, 84d76 <print_unsigned_int8+0x46>
   84d42:	466d      	mov	r5, sp
   84d44:	f10d 33ff 	add.w	r3, sp, #4294967295
   84d48:	1e56      	subs	r6, r2, #1
   84d4a:	b2f6      	uxtb	r6, r6
   84d4c:	446e      	add	r6, sp
      buf[i] = n % base ;
   84d4e:	fbb0 f2f1 	udiv	r2, r0, r1
   84d52:	fb01 0012 	mls	r0, r1, r2, r0
   84d56:	f803 0f01 	strb.w	r0, [r3, #1]!
      n /= base;
   84d5a:	b2d0      	uxtb	r0, r2
void print_unsigned_int8(uint8_t n, uint8_t base, uint8_t digits)
{ 
  unsigned char buf[digits];
  uint8_t i = 0;

  for (; i < digits; i++) {
   84d5c:	42b3      	cmp	r3, r6
   84d5e:	d1f6      	bne.n	84d4e <print_unsigned_int8+0x1e>
      buf[i] = n % base ;
      n /= base;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
   84d60:	4e06      	ldr	r6, [pc, #24]	; (84d7c <print_unsigned_int8+0x4c>)
   84d62:	192b      	adds	r3, r5, r4
   84d64:	f813 0c01 	ldrb.w	r0, [r3, #-1]
   84d68:	3030      	adds	r0, #48	; 0x30
   84d6a:	b2c0      	uxtb	r0, r0
   84d6c:	47b0      	blx	r6
  for (; i < digits; i++) {
      buf[i] = n % base ;
      n /= base;
  }

  for (; i > 0; i--)
   84d6e:	3c01      	subs	r4, #1
   84d70:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   84d74:	d1f5      	bne.n	84d62 <print_unsigned_int8+0x32>
      serial_write('0' + buf[i - 1]);
}
   84d76:	46bd      	mov	sp, r7
   84d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   84d7a:	bf00      	nop
   84d7c:	00087e41 	.word	0x00087e41

00084d80 <print_uint8_base2>:


// Prints an uint8 variable in base 2.
void print_uint8_base2(uint8_t n) {
   84d80:	b508      	push	{r3, lr}
  print_unsigned_int8(n,2,8);
   84d82:	2102      	movs	r1, #2
   84d84:	2208      	movs	r2, #8
   84d86:	4b01      	ldr	r3, [pc, #4]	; (84d8c <print_uint8_base2+0xc>)
   84d88:	4798      	blx	r3
   84d8a:	bd08      	pop	{r3, pc}
   84d8c:	00084d31 	.word	0x00084d31

00084d90 <print_uint8_base10>:
}


// Prints an uint8 variable in base 10.
void print_uint8_base10(uint8_t n)
{   
   84d90:	b508      	push	{r3, lr}
  uint8_t digits;
  if (n < 10) { digits = 1; } 
   84d92:	2809      	cmp	r0, #9
   84d94:	d904      	bls.n	84da0 <print_uint8_base10+0x10>
  else if (n < 100) { digits = 2; }
  else { digits = 3; }
   84d96:	2864      	cmp	r0, #100	; 0x64
   84d98:	bf34      	ite	cc
   84d9a:	2202      	movcc	r2, #2
   84d9c:	2203      	movcs	r2, #3
   84d9e:	e000      	b.n	84da2 <print_uint8_base10+0x12>

// Prints an uint8 variable in base 10.
void print_uint8_base10(uint8_t n)
{   
  uint8_t digits;
  if (n < 10) { digits = 1; } 
   84da0:	2201      	movs	r2, #1
  else if (n < 100) { digits = 2; }
  else { digits = 3; }
  print_unsigned_int8(n,10,digits);
   84da2:	210a      	movs	r1, #10
   84da4:	4b01      	ldr	r3, [pc, #4]	; (84dac <print_uint8_base10+0x1c>)
   84da6:	4798      	blx	r3
   84da8:	bd08      	pop	{r3, pc}
   84daa:	bf00      	nop
   84dac:	00084d31 	.word	0x00084d31

00084db0 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
   84db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   84db4:	b084      	sub	sp, #16
   84db6:	4606      	mov	r6, r0
   84db8:	460d      	mov	r5, r1
  if (n < 0) {
   84dba:	2100      	movs	r1, #0
   84dbc:	4b37      	ldr	r3, [pc, #220]	; (84e9c <printFloat+0xec>)
   84dbe:	4798      	blx	r3
   84dc0:	b120      	cbz	r0, 84dcc <printFloat+0x1c>
    serial_write('-');
   84dc2:	202d      	movs	r0, #45	; 0x2d
   84dc4:	4b36      	ldr	r3, [pc, #216]	; (84ea0 <printFloat+0xf0>)
   84dc6:	4798      	blx	r3
    n = -n;
   84dc8:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
   84dcc:	2d01      	cmp	r5, #1
   84dce:	d90e      	bls.n	84dee <printFloat+0x3e>
   84dd0:	462c      	mov	r4, r5
    n *= 100;
   84dd2:	4f34      	ldr	r7, [pc, #208]	; (84ea4 <printFloat+0xf4>)
   84dd4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 84eb8 <printFloat+0x108>
   84dd8:	4630      	mov	r0, r6
   84dda:	4641      	mov	r1, r8
   84ddc:	47b8      	blx	r7
   84dde:	4606      	mov	r6, r0
    decimals -= 2;
   84de0:	3c02      	subs	r4, #2
   84de2:	b2e4      	uxtb	r4, r4
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
   84de4:	2c01      	cmp	r4, #1
   84de6:	d8f7      	bhi.n	84dd8 <printFloat+0x28>
   84de8:	f005 0301 	and.w	r3, r5, #1
   84dec:	e000      	b.n	84df0 <printFloat+0x40>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
   84dee:	462b      	mov	r3, r5
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
   84df0:	b123      	cbz	r3, 84dfc <printFloat+0x4c>
   84df2:	4630      	mov	r0, r6
   84df4:	492c      	ldr	r1, [pc, #176]	; (84ea8 <printFloat+0xf8>)
   84df6:	4b2b      	ldr	r3, [pc, #172]	; (84ea4 <printFloat+0xf4>)
   84df8:	4798      	blx	r3
   84dfa:	4606      	mov	r6, r0
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
   84dfc:	4630      	mov	r0, r6
   84dfe:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   84e02:	4b2a      	ldr	r3, [pc, #168]	; (84eac <printFloat+0xfc>)
   84e04:	4798      	blx	r3
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
   84e06:	4b2a      	ldr	r3, [pc, #168]	; (84eb0 <printFloat+0x100>)
   84e08:	4798      	blx	r3
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
   84e0a:	222e      	movs	r2, #46	; 0x2e
   84e0c:	ab04      	add	r3, sp, #16
   84e0e:	442b      	add	r3, r5
   84e10:	f803 2c0c 	strb.w	r2, [r3, #-12]
  while(a > 0) {
   84e14:	4603      	mov	r3, r0
   84e16:	b1c8      	cbz	r0, 84e4c <printFloat+0x9c>
   84e18:	2400      	movs	r4, #0
    if (i == decimal_places) { i++; } // Skip decimal point location
   84e1a:	1c6e      	adds	r6, r5, #1
   84e1c:	b2f6      	uxtb	r6, r6
    buf[i++] = (a % 10) + '0'; // Get digit
   84e1e:	4f25      	ldr	r7, [pc, #148]	; (84eb4 <printFloat+0x104>)
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
   84e20:	42ac      	cmp	r4, r5
   84e22:	bf14      	ite	ne
   84e24:	4622      	movne	r2, r4
   84e26:	4632      	moveq	r2, r6
    buf[i++] = (a % 10) + '0'; // Get digit
   84e28:	1c54      	adds	r4, r2, #1
   84e2a:	b2e4      	uxtb	r4, r4
   84e2c:	a904      	add	r1, sp, #16
   84e2e:	4411      	add	r1, r2
   84e30:	fba7 0203 	umull	r0, r2, r7, r3
   84e34:	08d2      	lsrs	r2, r2, #3
   84e36:	eb02 0082 	add.w	r0, r2, r2, lsl #2
   84e3a:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
   84e3e:	3330      	adds	r3, #48	; 0x30
   84e40:	f801 3c0c 	strb.w	r3, [r1, #-12]
    a /= 10;
   84e44:	4613      	mov	r3, r2
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
   84e46:	2a00      	cmp	r2, #0
   84e48:	d1ea      	bne.n	84e20 <printFloat+0x70>
   84e4a:	e000      	b.n	84e4e <printFloat+0x9e>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
   84e4c:	2400      	movs	r4, #0
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
   84e4e:	42a5      	cmp	r5, r4
   84e50:	d90a      	bls.n	84e68 <printFloat+0xb8>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
   84e52:	2230      	movs	r2, #48	; 0x30
   84e54:	1c63      	adds	r3, r4, #1
   84e56:	b2db      	uxtb	r3, r3
   84e58:	a904      	add	r1, sp, #16
   84e5a:	440c      	add	r4, r1
   84e5c:	f804 2c0c 	strb.w	r2, [r4, #-12]
   84e60:	461c      	mov	r4, r3
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
   84e62:	42ab      	cmp	r3, r5
   84e64:	d1f6      	bne.n	84e54 <printFloat+0xa4>
   84e66:	e002      	b.n	84e6e <printFloat+0xbe>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
   84e68:	42a5      	cmp	r5, r4
   84e6a:	d109      	bne.n	84e80 <printFloat+0xd0>
   84e6c:	4625      	mov	r5, r4
    i++;
    buf[i++] = '0'; 
   84e6e:	1cac      	adds	r4, r5, #2
   84e70:	b2e4      	uxtb	r4, r4
  }
  while (i < decimal_places) { 
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    i++;
   84e72:	1c6b      	adds	r3, r5, #1
    buf[i++] = '0'; 
   84e74:	b2db      	uxtb	r3, r3
   84e76:	aa04      	add	r2, sp, #16
   84e78:	4413      	add	r3, r2
   84e7a:	2230      	movs	r2, #48	; 0x30
   84e7c:	f803 2c0c 	strb.w	r2, [r3, #-12]
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
   84e80:	b14c      	cbz	r4, 84e96 <printFloat+0xe6>
    serial_write(buf[i-1]);
   84e82:	4d07      	ldr	r5, [pc, #28]	; (84ea0 <printFloat+0xf0>)
   84e84:	ab04      	add	r3, sp, #16
   84e86:	4423      	add	r3, r4
   84e88:	f813 0c0d 	ldrb.w	r0, [r3, #-13]
   84e8c:	47a8      	blx	r5
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
   84e8e:	3c01      	subs	r4, #1
   84e90:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   84e94:	d1f6      	bne.n	84e84 <printFloat+0xd4>
    serial_write(buf[i-1]);
}
   84e96:	b004      	add	sp, #16
   84e98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   84e9c:	0008ca71 	.word	0x0008ca71
   84ea0:	00087e41 	.word	0x00087e41
   84ea4:	0008c735 	.word	0x0008c735
   84ea8:	41200000 	.word	0x41200000
   84eac:	0008c525 	.word	0x0008c525
   84eb0:	0008cac1 	.word	0x0008cac1
   84eb4:	cccccccd 	.word	0xcccccccd
   84eb8:	42c80000 	.word	0x42c80000
   84ebc:	00000000 	.word	0x00000000

00084ec0 <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
   84ec0:	b510      	push	{r4, lr}
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
   84ec2:	4b0d      	ldr	r3, [pc, #52]	; (84ef8 <printFloat_CoordValue+0x38>)
   84ec4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   84ec8:	f013 0f01 	tst.w	r3, #1
   84ecc:	d00c      	beq.n	84ee8 <printFloat_CoordValue+0x28>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
   84ece:	4b0b      	ldr	r3, [pc, #44]	; (84efc <printFloat_CoordValue+0x3c>)
   84ed0:	4798      	blx	r3
   84ed2:	a307      	add	r3, pc, #28	; (adr r3, 84ef0 <printFloat_CoordValue+0x30>)
   84ed4:	e9d3 2300 	ldrd	r2, r3, [r3]
   84ed8:	4c09      	ldr	r4, [pc, #36]	; (84f00 <printFloat_CoordValue+0x40>)
   84eda:	47a0      	blx	r4
   84edc:	4b09      	ldr	r3, [pc, #36]	; (84f04 <printFloat_CoordValue+0x44>)
   84ede:	4798      	blx	r3
   84ee0:	2104      	movs	r1, #4
   84ee2:	4b09      	ldr	r3, [pc, #36]	; (84f08 <printFloat_CoordValue+0x48>)
   84ee4:	4798      	blx	r3
   84ee6:	bd10      	pop	{r4, pc}
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
   84ee8:	2103      	movs	r1, #3
   84eea:	4b07      	ldr	r3, [pc, #28]	; (84f08 <printFloat_CoordValue+0x48>)
   84eec:	4798      	blx	r3
   84eee:	bd10      	pop	{r4, pc}
   84ef0:	57e16865 	.word	0x57e16865
   84ef4:	3fa42851 	.word	0x3fa42851
   84ef8:	20001510 	.word	0x20001510
   84efc:	0008be0d 	.word	0x0008be0d
   84f00:	0008beb5 	.word	0x0008beb5
   84f04:	0008c479 	.word	0x0008c479
   84f08:	00084db1 	.word	0x00084db1
   84f0c:	00000000 	.word	0x00000000

00084f10 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
   84f10:	b510      	push	{r4, lr}
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
   84f12:	4b0d      	ldr	r3, [pc, #52]	; (84f48 <printFloat_RateValue+0x38>)
   84f14:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   84f18:	f013 0f01 	tst.w	r3, #1
   84f1c:	d00c      	beq.n	84f38 <printFloat_RateValue+0x28>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
   84f1e:	4b0b      	ldr	r3, [pc, #44]	; (84f4c <printFloat_RateValue+0x3c>)
   84f20:	4798      	blx	r3
   84f22:	a307      	add	r3, pc, #28	; (adr r3, 84f40 <printFloat_RateValue+0x30>)
   84f24:	e9d3 2300 	ldrd	r2, r3, [r3]
   84f28:	4c09      	ldr	r4, [pc, #36]	; (84f50 <printFloat_RateValue+0x40>)
   84f2a:	47a0      	blx	r4
   84f2c:	4b09      	ldr	r3, [pc, #36]	; (84f54 <printFloat_RateValue+0x44>)
   84f2e:	4798      	blx	r3
   84f30:	2101      	movs	r1, #1
   84f32:	4b09      	ldr	r3, [pc, #36]	; (84f58 <printFloat_RateValue+0x48>)
   84f34:	4798      	blx	r3
   84f36:	bd10      	pop	{r4, pc}
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
   84f38:	2100      	movs	r1, #0
   84f3a:	4b07      	ldr	r3, [pc, #28]	; (84f58 <printFloat_RateValue+0x48>)
   84f3c:	4798      	blx	r3
   84f3e:	bd10      	pop	{r4, pc}
   84f40:	57e16865 	.word	0x57e16865
   84f44:	3fa42851 	.word	0x3fa42851
   84f48:	20001510 	.word	0x20001510
   84f4c:	0008be0d 	.word	0x0008be0d
   84f50:	0008beb5 	.word	0x0008beb5
   84f54:	0008c479 	.word	0x0008c479
   84f58:	00084db1 	.word	0x00084db1

00084f5c <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
   84f5c:	b508      	push	{r3, lr}
   84f5e:	2103      	movs	r1, #3
   84f60:	4b01      	ldr	r3, [pc, #4]	; (84f68 <printFloat_SettingValue+0xc>)
   84f62:	4798      	blx	r3
   84f64:	bd08      	pop	{r3, pc}
   84f66:	bf00      	nop
   84f68:	00084db1 	.word	0x00084db1

00084f6c <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
   84f6c:	4b04      	ldr	r3, [pc, #16]	; (84f80 <probe_init+0x14>)
   84f6e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   84f70:	f022 0220 	bic.w	r2, r2, #32
   84f74:	639a      	str	r2, [r3, #56]	; 0x38
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
   84f76:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   84f78:	f042 0220 	orr.w	r2, r2, #32
   84f7c:	639a      	str	r2, [r3, #56]	; 0x38
   84f7e:	4770      	bx	lr
   84f80:	400e0e00 	.word	0x400e0e00

00084f84 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
   84f84:	2200      	movs	r2, #0
   84f86:	4b08      	ldr	r3, [pc, #32]	; (84fa8 <probe_configure_invert_mask+0x24>)
   84f88:	701a      	strb	r2, [r3, #0]
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
   84f8a:	4b08      	ldr	r3, [pc, #32]	; (84fac <probe_configure_invert_mask+0x28>)
   84f8c:	f993 3040 	ldrsb.w	r3, [r3, #64]	; 0x40
   84f90:	4293      	cmp	r3, r2
   84f92:	db02      	blt.n	84f9a <probe_configure_invert_mask+0x16>
   84f94:	2220      	movs	r2, #32
   84f96:	4b04      	ldr	r3, [pc, #16]	; (84fa8 <probe_configure_invert_mask+0x24>)
   84f98:	701a      	strb	r2, [r3, #0]
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
   84f9a:	b120      	cbz	r0, 84fa6 <probe_configure_invert_mask+0x22>
   84f9c:	4a02      	ldr	r2, [pc, #8]	; (84fa8 <probe_configure_invert_mask+0x24>)
   84f9e:	7813      	ldrb	r3, [r2, #0]
   84fa0:	f083 0320 	eor.w	r3, r3, #32
   84fa4:	7013      	strb	r3, [r2, #0]
   84fa6:	4770      	bx	lr
   84fa8:	200014cd 	.word	0x200014cd
   84fac:	20001510 	.word	0x20001510

00084fb0 <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
   84fb0:	4b03      	ldr	r3, [pc, #12]	; (84fc0 <probe_get_state+0x10>)
   84fb2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   84fb4:	f003 0320 	and.w	r3, r3, #32
   84fb8:	4a02      	ldr	r2, [pc, #8]	; (84fc4 <probe_get_state+0x14>)
   84fba:	7810      	ldrb	r0, [r2, #0]
   84fbc:	4058      	eors	r0, r3
   84fbe:	4770      	bx	lr
   84fc0:	400e0e00 	.word	0x400e0e00
   84fc4:	200014cd 	.word	0x200014cd

00084fc8 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys_probe_state == PROBE_ACTIVE) {
   84fc8:	4b0d      	ldr	r3, [pc, #52]	; (85000 <probe_state_monitor+0x38>)
   84fca:	781b      	ldrb	r3, [r3, #0]
   84fcc:	b2db      	uxtb	r3, r3
   84fce:	2b01      	cmp	r3, #1
   84fd0:	d114      	bne.n	84ffc <probe_state_monitor+0x34>

// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
   84fd2:	b510      	push	{r4, lr}
  if (sys_probe_state == PROBE_ACTIVE) {
    if (probe_get_state()) {
   84fd4:	4b0b      	ldr	r3, [pc, #44]	; (85004 <probe_state_monitor+0x3c>)
   84fd6:	4798      	blx	r3
   84fd8:	b178      	cbz	r0, 84ffa <probe_state_monitor+0x32>
      sys_probe_state = PROBE_OFF;
   84fda:	2200      	movs	r2, #0
   84fdc:	4b08      	ldr	r3, [pc, #32]	; (85000 <probe_state_monitor+0x38>)
   84fde:	701a      	strb	r2, [r3, #0]
      memcpy(sys.probe_position, sys.position, sizeof(sys.position));
   84fe0:	4b09      	ldr	r3, [pc, #36]	; (85008 <probe_state_monitor+0x40>)
   84fe2:	f103 0410 	add.w	r4, r3, #16
   84fe6:	3304      	adds	r3, #4
   84fe8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   84fec:	e884 0007 	stmia.w	r4, {r0, r1, r2}
      bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
   84ff0:	4a06      	ldr	r2, [pc, #24]	; (8500c <probe_state_monitor+0x44>)
   84ff2:	7813      	ldrb	r3, [r2, #0]
   84ff4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   84ff8:	7013      	strb	r3, [r2, #0]
   84ffa:	bd10      	pop	{r4, pc}
   84ffc:	4770      	bx	lr
   84ffe:	bf00      	nop
   85000:	200011b5 	.word	0x200011b5
   85004:	00084fb1 	.word	0x00084fb1
   85008:	20001484 	.word	0x20001484
   8500c:	200011b4 	.word	0x200011b4

00085010 <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
   85010:	b530      	push	{r4, r5, lr}
   85012:	b083      	sub	sp, #12
  volatile uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
   85014:	4da8      	ldr	r5, [pc, #672]	; (852b8 <protocol_execute_realtime+0x2a8>)
      report_alarm_message(ALARM_HOMING_FAIL);
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
      bit_false_atomic(sys_rt_exec_state,EXEC_RESET); // Disable any existing reset
   85016:	4ca9      	ldr	r4, [pc, #676]	; (852bc <protocol_execute_realtime+0x2ac>)
  volatile uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
   85018:	782b      	ldrb	r3, [r5, #0]
   8501a:	b2db      	uxtb	r3, r3
   8501c:	f88d 3007 	strb.w	r3, [sp, #7]
  if (rt_exec) { // Enter only if any bit flag is true
   85020:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85024:	f013 0fff 	tst.w	r3, #255	; 0xff
   85028:	d041      	beq.n	850ae <protocol_execute_realtime+0x9e>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
   8502a:	2201      	movs	r2, #1
   8502c:	4ba4      	ldr	r3, [pc, #656]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8502e:	705a      	strb	r2, [r3, #1]
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
   85030:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85034:	f013 0f02 	tst.w	r3, #2
   85038:	d003      	beq.n	85042 <protocol_execute_realtime+0x32>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
   8503a:	4610      	mov	r0, r2
   8503c:	4ba1      	ldr	r3, [pc, #644]	; (852c4 <protocol_execute_realtime+0x2b4>)
   8503e:	4798      	blx	r3
   85040:	e022      	b.n	85088 <protocol_execute_realtime+0x78>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
   85042:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85046:	f013 0f04 	tst.w	r3, #4
   8504a:	d003      	beq.n	85054 <protocol_execute_realtime+0x44>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
   8504c:	2002      	movs	r0, #2
   8504e:	4b9d      	ldr	r3, [pc, #628]	; (852c4 <protocol_execute_realtime+0x2b4>)
   85050:	4798      	blx	r3
   85052:	e019      	b.n	85088 <protocol_execute_realtime+0x78>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
   85054:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85058:	f013 0f08 	tst.w	r3, #8
   8505c:	d003      	beq.n	85066 <protocol_execute_realtime+0x56>
      report_alarm_message(ALARM_ABORT_CYCLE);
   8505e:	2003      	movs	r0, #3
   85060:	4b98      	ldr	r3, [pc, #608]	; (852c4 <protocol_execute_realtime+0x2b4>)
   85062:	4798      	blx	r3
   85064:	e010      	b.n	85088 <protocol_execute_realtime+0x78>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
   85066:	f89d 3007 	ldrb.w	r3, [sp, #7]
   8506a:	f013 0f10 	tst.w	r3, #16
   8506e:	d003      	beq.n	85078 <protocol_execute_realtime+0x68>
      report_alarm_message(ALARM_PROBE_FAIL);
   85070:	2004      	movs	r0, #4
   85072:	4b94      	ldr	r3, [pc, #592]	; (852c4 <protocol_execute_realtime+0x2b4>)
   85074:	4798      	blx	r3
   85076:	e007      	b.n	85088 <protocol_execute_realtime+0x78>
    } else if (rt_exec & EXEC_ALARM_HOMING_FAIL) {
   85078:	f89d 3007 	ldrb.w	r3, [sp, #7]
   8507c:	f013 0f20 	tst.w	r3, #32
   85080:	d002      	beq.n	85088 <protocol_execute_realtime+0x78>
      report_alarm_message(ALARM_HOMING_FAIL);
   85082:	2005      	movs	r0, #5
   85084:	4b8f      	ldr	r3, [pc, #572]	; (852c4 <protocol_execute_realtime+0x2b4>)
   85086:	4798      	blx	r3
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
   85088:	f89d 3007 	ldrb.w	r3, [sp, #7]
   8508c:	f013 0f01 	tst.w	r3, #1
   85090:	d00a      	beq.n	850a8 <protocol_execute_realtime+0x98>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
   85092:	2001      	movs	r0, #1
   85094:	4b8c      	ldr	r3, [pc, #560]	; (852c8 <protocol_execute_realtime+0x2b8>)
   85096:	4798      	blx	r3
      bit_false_atomic(sys_rt_exec_state,EXEC_RESET); // Disable any existing reset
   85098:	7823      	ldrb	r3, [r4, #0]
   8509a:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   8509e:	7023      	strb	r3, [r4, #0]
        // TODO: Allow status reports during a critical alarm. Still need to think about implications of this.
//         if (sys_rt_exec_state & EXEC_STATUS_REPORT) { 
//           report_realtime_status();
//           bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT); 
//         }
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
   850a0:	7823      	ldrb	r3, [r4, #0]
   850a2:	f013 0f10 	tst.w	r3, #16
   850a6:	d0fb      	beq.n	850a0 <protocol_execute_realtime+0x90>
    }
    bit_false_atomic(sys_rt_exec_alarm,0xFF); // Clear all alarm flags
   850a8:	782b      	ldrb	r3, [r5, #0]
   850aa:	2300      	movs	r3, #0
   850ac:	702b      	strb	r3, [r5, #0]
  }
  
  // Check amd execute realtime commands
  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
   850ae:	7823      	ldrb	r3, [r4, #0]
   850b0:	b2db      	uxtb	r3, r3
   850b2:	f88d 3007 	strb.w	r3, [sp, #7]
  if (rt_exec) { // Enter only if any bit flag is true
   850b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   850ba:	f013 0fff 	tst.w	r3, #255	; 0xff
   850be:	f000 80d2 	beq.w	85266 <protocol_execute_realtime+0x256>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
   850c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   850c6:	f013 0f10 	tst.w	r3, #16
   850ca:	d003      	beq.n	850d4 <protocol_execute_realtime+0xc4>
      sys.abort = true;  // Only place this is set true.
   850cc:	2201      	movs	r2, #1
   850ce:	4b7c      	ldr	r3, [pc, #496]	; (852c0 <protocol_execute_realtime+0x2b0>)
   850d0:	701a      	strb	r2, [r3, #0]
      return; // Nothing else to do but exit.
   850d2:	e0ee      	b.n	852b2 <protocol_execute_realtime+0x2a2>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
   850d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   850d8:	f013 0f01 	tst.w	r3, #1
   850dc:	d005      	beq.n	850ea <protocol_execute_realtime+0xda>
      report_realtime_status();
   850de:	4b7b      	ldr	r3, [pc, #492]	; (852cc <protocol_execute_realtime+0x2bc>)
   850e0:	4798      	blx	r3
      bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT);
   850e2:	7823      	ldrb	r3, [r4, #0]
   850e4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   850e8:	7023      	strb	r3, [r4, #0]
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
   850ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
   850ee:	f013 0f68 	tst.w	r3, #104	; 0x68
   850f2:	d050      	beq.n	85196 <protocol_execute_realtime+0x186>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
   850f4:	4b72      	ldr	r3, [pc, #456]	; (852c0 <protocol_execute_realtime+0x2b0>)
   850f6:	785b      	ldrb	r3, [r3, #1]
   850f8:	b15b      	cbz	r3, 85112 <protocol_execute_realtime+0x102>
   850fa:	f013 0f7c 	tst.w	r3, #124	; 0x7c
   850fe:	f040 80d5 	bne.w	852ac <protocol_execute_realtime+0x29c>
   85102:	e044      	b.n	8518e <protocol_execute_realtime+0x17e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
   85104:	4b72      	ldr	r3, [pc, #456]	; (852d0 <protocol_execute_realtime+0x2c0>)
   85106:	4798      	blx	r3
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
   85108:	4b6d      	ldr	r3, [pc, #436]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8510a:	2201      	movs	r2, #1
   8510c:	709a      	strb	r2, [r3, #2]
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
   8510e:	785a      	ldrb	r2, [r3, #1]
   85110:	b942      	cbnz	r2, 85124 <protocol_execute_realtime+0x114>
   85112:	2202      	movs	r2, #2
   85114:	4b6a      	ldr	r3, [pc, #424]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85116:	709a      	strb	r2, [r3, #2]
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
   85118:	f89d 3007 	ldrb.w	r3, [sp, #7]
   8511c:	f013 0f40 	tst.w	r3, #64	; 0x40
   85120:	d10a      	bne.n	85138 <protocol_execute_realtime+0x128>
   85122:	e00e      	b.n	85142 <protocol_execute_realtime+0x132>
   85124:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85128:	f013 0f40 	tst.w	r3, #64	; 0x40
   8512c:	d009      	beq.n	85142 <protocol_execute_realtime+0x132>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
   8512e:	2a08      	cmp	r2, #8
   85130:	d102      	bne.n	85138 <protocol_execute_realtime+0x128>
   85132:	2240      	movs	r2, #64	; 0x40
   85134:	4b62      	ldr	r3, [pc, #392]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85136:	705a      	strb	r2, [r3, #1]
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
   85138:	4a61      	ldr	r2, [pc, #388]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8513a:	7893      	ldrb	r3, [r2, #2]
   8513c:	f043 0308 	orr.w	r3, r3, #8
   85140:	7093      	strb	r3, [r2, #2]
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
   85142:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85146:	f013 0f08 	tst.w	r3, #8
   8514a:	d007      	beq.n	8515c <protocol_execute_realtime+0x14c>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
   8514c:	4b5c      	ldr	r3, [pc, #368]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8514e:	785b      	ldrb	r3, [r3, #1]
   85150:	f013 0f20 	tst.w	r3, #32
   85154:	d102      	bne.n	8515c <protocol_execute_realtime+0x14c>
   85156:	2210      	movs	r2, #16
   85158:	4b59      	ldr	r3, [pc, #356]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8515a:	705a      	strb	r2, [r3, #1]
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
   8515c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85160:	f013 0f20 	tst.w	r3, #32
   85164:	d013      	beq.n	8518e <protocol_execute_realtime+0x17e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
   85166:	2006      	movs	r0, #6
   85168:	4b57      	ldr	r3, [pc, #348]	; (852c8 <protocol_execute_realtime+0x2b8>)
   8516a:	4798      	blx	r3
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
   8516c:	4b54      	ldr	r3, [pc, #336]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8516e:	789b      	ldrb	r3, [r3, #2]
   85170:	f013 0f02 	tst.w	r3, #2
   85174:	d005      	beq.n	85182 <protocol_execute_realtime+0x172>
   85176:	f89d 2007 	ldrb.w	r2, [sp, #7]
   8517a:	f042 0204 	orr.w	r2, r2, #4
   8517e:	f88d 2007 	strb.w	r2, [sp, #7]
          sys.suspend |= SUSPEND_ENERGIZE;
   85182:	4a4f      	ldr	r2, [pc, #316]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85184:	f043 0304 	orr.w	r3, r3, #4
   85188:	7093      	strb	r3, [r2, #2]
          sys.state = STATE_SAFETY_DOOR;
   8518a:	2320      	movs	r3, #32
   8518c:	7053      	strb	r3, [r2, #1]
        }
         
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
   8518e:	7823      	ldrb	r3, [r4, #0]
   85190:	f003 0397 	and.w	r3, r3, #151	; 0x97
   85194:	7023      	strb	r3, [r4, #0]
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
   85196:	f89d 3007 	ldrb.w	r3, [sp, #7]
   8519a:	f013 0f02 	tst.w	r3, #2
   8519e:	d041      	beq.n	85224 <protocol_execute_realtime+0x214>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
   851a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   851a4:	f013 0f68 	tst.w	r3, #104	; 0x68
   851a8:	d138      	bne.n	8521c <protocol_execute_realtime+0x20c>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
   851aa:	4b45      	ldr	r3, [pc, #276]	; (852c0 <protocol_execute_realtime+0x2b0>)
   851ac:	785b      	ldrb	r3, [r3, #1]
   851ae:	b13b      	cbz	r3, 851c0 <protocol_execute_realtime+0x1b0>
   851b0:	f013 0f50 	tst.w	r3, #80	; 0x50
   851b4:	d032      	beq.n	8521c <protocol_execute_realtime+0x20c>
   851b6:	4b42      	ldr	r3, [pc, #264]	; (852c0 <protocol_execute_realtime+0x2b0>)
   851b8:	789b      	ldrb	r3, [r3, #2]
   851ba:	f013 0f02 	tst.w	r3, #2
   851be:	d02d      	beq.n	8521c <protocol_execute_realtime+0x20c>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
   851c0:	4b3f      	ldr	r3, [pc, #252]	; (852c0 <protocol_execute_realtime+0x2b0>)
   851c2:	789b      	ldrb	r3, [r3, #2]
   851c4:	f013 0f04 	tst.w	r3, #4
   851c8:	d012      	beq.n	851f0 <protocol_execute_realtime+0x1e0>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
   851ca:	4b42      	ldr	r3, [pc, #264]	; (852d4 <protocol_execute_realtime+0x2c4>)
   851cc:	7a58      	ldrb	r0, [r3, #9]
   851ce:	b130      	cbz	r0, 851de <protocol_execute_realtime+0x1ce>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
   851d0:	68d9      	ldr	r1, [r3, #12]
   851d2:	4b41      	ldr	r3, [pc, #260]	; (852d8 <protocol_execute_realtime+0x2c8>)
   851d4:	4798      	blx	r3
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
   851d6:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
   851da:	4b40      	ldr	r3, [pc, #256]	; (852dc <protocol_execute_realtime+0x2cc>)
   851dc:	4798      	blx	r3
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
   851de:	4b3d      	ldr	r3, [pc, #244]	; (852d4 <protocol_execute_realtime+0x2c4>)
   851e0:	7a18      	ldrb	r0, [r3, #8]
   851e2:	b128      	cbz	r0, 851f0 <protocol_execute_realtime+0x1e0>
              coolant_set_state(gc_state.modal.coolant); 
   851e4:	4b3e      	ldr	r3, [pc, #248]	; (852e0 <protocol_execute_realtime+0x2d0>)
   851e6:	4798      	blx	r3
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
   851e8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   851ec:	4b3b      	ldr	r3, [pc, #236]	; (852dc <protocol_execute_realtime+0x2cc>)
   851ee:	4798      	blx	r3
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
   851f0:	4b3c      	ldr	r3, [pc, #240]	; (852e4 <protocol_execute_realtime+0x2d4>)
   851f2:	4798      	blx	r3
   851f4:	b160      	cbz	r0, 85210 <protocol_execute_realtime+0x200>
   851f6:	4b32      	ldr	r3, [pc, #200]	; (852c0 <protocol_execute_realtime+0x2b0>)
   851f8:	789b      	ldrb	r3, [r3, #2]
   851fa:	f013 0f08 	tst.w	r3, #8
   851fe:	d107      	bne.n	85210 <protocol_execute_realtime+0x200>
            sys.state = STATE_CYCLE;
   85200:	2208      	movs	r2, #8
   85202:	4b2f      	ldr	r3, [pc, #188]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85204:	705a      	strb	r2, [r3, #1]
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
   85206:	4b38      	ldr	r3, [pc, #224]	; (852e8 <protocol_execute_realtime+0x2d8>)
   85208:	4798      	blx	r3
            st_wake_up();
   8520a:	4b38      	ldr	r3, [pc, #224]	; (852ec <protocol_execute_realtime+0x2dc>)
   8520c:	4798      	blx	r3
   8520e:	e002      	b.n	85216 <protocol_execute_realtime+0x206>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
   85210:	2200      	movs	r2, #0
   85212:	4b2b      	ldr	r3, [pc, #172]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85214:	705a      	strb	r2, [r3, #1]
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
   85216:	2200      	movs	r2, #0
   85218:	4b29      	ldr	r3, [pc, #164]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8521a:	709a      	strb	r2, [r3, #2]
        }
      }    
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_START);
   8521c:	7823      	ldrb	r3, [r4, #0]
   8521e:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
   85222:	7023      	strb	r3, [r4, #0]
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
   85224:	f89d 3007 	ldrb.w	r3, [sp, #7]
   85228:	f013 0f04 	tst.w	r3, #4
   8522c:	d01b      	beq.n	85266 <protocol_execute_realtime+0x256>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR)) {
   8522e:	4b24      	ldr	r3, [pc, #144]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85230:	785b      	ldrb	r3, [r3, #1]
   85232:	f013 0f30 	tst.w	r3, #48	; 0x30
   85236:	d00e      	beq.n	85256 <protocol_execute_realtime+0x246>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
   85238:	4b21      	ldr	r3, [pc, #132]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8523a:	789b      	ldrb	r3, [r3, #2]
   8523c:	f013 0f04 	tst.w	r3, #4
   85240:	d003      	beq.n	8524a <protocol_execute_realtime+0x23a>
          spindle_stop();
   85242:	4b2b      	ldr	r3, [pc, #172]	; (852f0 <protocol_execute_realtime+0x2e0>)
   85244:	4798      	blx	r3
          coolant_stop();
   85246:	4b2b      	ldr	r3, [pc, #172]	; (852f4 <protocol_execute_realtime+0x2e4>)
   85248:	4798      	blx	r3
          // TODO: Install parking motion here.
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY);
   8524a:	4a1d      	ldr	r2, [pc, #116]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8524c:	7893      	ldrb	r3, [r2, #2]
   8524e:	f043 0302 	orr.w	r3, r3, #2
   85252:	7093      	strb	r3, [r2, #2]
   85254:	e003      	b.n	8525e <protocol_execute_realtime+0x24e>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
   85256:	4b1a      	ldr	r3, [pc, #104]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85258:	2200      	movs	r2, #0
   8525a:	709a      	strb	r2, [r3, #2]
        sys.state = STATE_IDLE;
   8525c:	705a      	strb	r2, [r3, #1]
      }
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
   8525e:	7823      	ldrb	r3, [r4, #0]
   85260:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   85264:	7023      	strb	r3, [r4, #0]

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
   85266:	4b16      	ldr	r3, [pc, #88]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85268:	785b      	ldrb	r3, [r3, #1]
   8526a:	f013 0f7c 	tst.w	r3, #124	; 0x7c
   8526e:	d001      	beq.n	85274 <protocol_execute_realtime+0x264>
   85270:	4b1d      	ldr	r3, [pc, #116]	; (852e8 <protocol_execute_realtime+0x2d8>)
   85272:	4798      	blx	r3
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
   85274:	4b12      	ldr	r3, [pc, #72]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85276:	785b      	ldrb	r3, [r3, #1]
   85278:	2b20      	cmp	r3, #32
   8527a:	d10a      	bne.n	85292 <protocol_execute_realtime+0x282>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
   8527c:	4b10      	ldr	r3, [pc, #64]	; (852c0 <protocol_execute_realtime+0x2b0>)
   8527e:	789b      	ldrb	r3, [r3, #2]
   85280:	f013 0f02 	tst.w	r3, #2
   85284:	d005      	beq.n	85292 <protocol_execute_realtime+0x282>
      if (!(system_check_safety_door_ajar())) {
   85286:	4b1c      	ldr	r3, [pc, #112]	; (852f8 <protocol_execute_realtime+0x2e8>)
   85288:	4798      	blx	r3
   8528a:	b910      	cbnz	r0, 85292 <protocol_execute_realtime+0x282>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
   8528c:	2210      	movs	r2, #16
   8528e:	4b0c      	ldr	r3, [pc, #48]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85290:	705a      	strb	r2, [r3, #1]
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
   85292:	4b0b      	ldr	r3, [pc, #44]	; (852c0 <protocol_execute_realtime+0x2b0>)
   85294:	789b      	ldrb	r3, [r3, #2]
   85296:	2b00      	cmp	r3, #0
   85298:	f47f aebe 	bne.w	85018 <protocol_execute_realtime+0x8>
   8529c:	e009      	b.n	852b2 <protocol_execute_realtime+0x2a2>
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
   8529e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   852a2:	f013 0f40 	tst.w	r3, #64	; 0x40
   852a6:	f47f af47 	bne.w	85138 <protocol_execute_realtime+0x128>
   852aa:	e74a      	b.n	85142 <protocol_execute_realtime+0x132>
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
   852ac:	2b08      	cmp	r3, #8
   852ae:	d1f6      	bne.n	8529e <protocol_execute_realtime+0x28e>
   852b0:	e728      	b.n	85104 <protocol_execute_realtime+0xf4>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
   852b2:	b003      	add	sp, #12
   852b4:	bd30      	pop	{r4, r5, pc}
   852b6:	bf00      	nop
   852b8:	200011b6 	.word	0x200011b6
   852bc:	200011b4 	.word	0x200011b4
   852c0:	20001484 	.word	0x20001484
   852c4:	000873f9 	.word	0x000873f9
   852c8:	0008746d 	.word	0x0008746d
   852cc:	00087c29 	.word	0x00087c29
   852d0:	000889ed 	.word	0x000889ed
   852d4:	200011c8 	.word	0x200011c8
   852d8:	000883a1 	.word	0x000883a1
   852dc:	00089689 	.word	0x00089689
   852e0:	0008017d 	.word	0x0008017d
   852e4:	00084885 	.word	0x00084885
   852e8:	00088a21 	.word	0x00088a21
   852ec:	000884dd 	.word	0x000884dd
   852f0:	0008836d 	.word	0x0008836d
   852f4:	00080151 	.word	0x00080151
   852f8:	0008922d 	.word	0x0008922d

000852fc <protocol_execute_line>:

// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
void protocol_execute_line(char *line) 
{      
   852fc:	b510      	push	{r4, lr}
   852fe:	4604      	mov	r4, r0
  protocol_execute_realtime(); // Runtime command check point.
   85300:	4b10      	ldr	r3, [pc, #64]	; (85344 <protocol_execute_line+0x48>)
   85302:	4798      	blx	r3
  if (sys.abort) { return; } // Bail to calling function upon system abort  
   85304:	4b10      	ldr	r3, [pc, #64]	; (85348 <protocol_execute_line+0x4c>)
   85306:	781b      	ldrb	r3, [r3, #0]
   85308:	b9d3      	cbnz	r3, 85340 <protocol_execute_line+0x44>

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
   8530a:	7823      	ldrb	r3, [r4, #0]
   8530c:	b91b      	cbnz	r3, 85316 <protocol_execute_line+0x1a>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
   8530e:	2000      	movs	r0, #0
   85310:	4b0e      	ldr	r3, [pc, #56]	; (8534c <protocol_execute_line+0x50>)
   85312:	4798      	blx	r3
   85314:	bd10      	pop	{r4, pc}

  } else if (line[0] == '$') {
   85316:	2b24      	cmp	r3, #36	; 0x24
   85318:	d105      	bne.n	85326 <protocol_execute_line+0x2a>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
   8531a:	4620      	mov	r0, r4
   8531c:	4b0c      	ldr	r3, [pc, #48]	; (85350 <protocol_execute_line+0x54>)
   8531e:	4798      	blx	r3
   85320:	4b0a      	ldr	r3, [pc, #40]	; (8534c <protocol_execute_line+0x50>)
   85322:	4798      	blx	r3
   85324:	bd10      	pop	{r4, pc}
    
  } else if (sys.state == STATE_ALARM) {
   85326:	4b08      	ldr	r3, [pc, #32]	; (85348 <protocol_execute_line+0x4c>)
   85328:	785b      	ldrb	r3, [r3, #1]
   8532a:	2b01      	cmp	r3, #1
   8532c:	d103      	bne.n	85336 <protocol_execute_line+0x3a>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
   8532e:	2009      	movs	r0, #9
   85330:	4b06      	ldr	r3, [pc, #24]	; (8534c <protocol_execute_line+0x50>)
   85332:	4798      	blx	r3
   85334:	bd10      	pop	{r4, pc}

  } else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
   85336:	4620      	mov	r0, r4
   85338:	4b06      	ldr	r3, [pc, #24]	; (85354 <protocol_execute_line+0x58>)
   8533a:	4798      	blx	r3
   8533c:	4b03      	ldr	r3, [pc, #12]	; (8534c <protocol_execute_line+0x50>)
   8533e:	4798      	blx	r3
   85340:	bd10      	pop	{r4, pc}
   85342:	bf00      	nop
   85344:	00085011 	.word	0x00085011
   85348:	20001484 	.word	0x20001484
   8534c:	000872f1 	.word	0x000872f1
   85350:	0008927d 	.word	0x0008927d
   85354:	00082531 	.word	0x00082531

00085358 <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); } 
   85358:	4a02      	ldr	r2, [pc, #8]	; (85364 <protocol_auto_cycle_start+0xc>)
   8535a:	7813      	ldrb	r3, [r2, #0]
   8535c:	f043 0302 	orr.w	r3, r3, #2
   85360:	7013      	strb	r3, [r2, #0]
   85362:	4770      	bx	lr
   85364:	200011b4 	.word	0x200011b4

00085368 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
   85368:	b570      	push	{r4, r5, r6, lr}
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
   8536a:	4b07      	ldr	r3, [pc, #28]	; (85388 <protocol_buffer_synchronize+0x20>)
   8536c:	4798      	blx	r3
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
   8536e:	4d07      	ldr	r5, [pc, #28]	; (8538c <protocol_buffer_synchronize+0x24>)
    if (sys.abort) { return; } // Check for system abort
   85370:	4c07      	ldr	r4, [pc, #28]	; (85390 <protocol_buffer_synchronize+0x28>)
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
   85372:	4e08      	ldr	r6, [pc, #32]	; (85394 <protocol_buffer_synchronize+0x2c>)
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
   85374:	47a8      	blx	r5
    if (sys.abort) { return; } // Check for system abort
   85376:	7823      	ldrb	r3, [r4, #0]
   85378:	b92b      	cbnz	r3, 85386 <protocol_buffer_synchronize+0x1e>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
   8537a:	47b0      	blx	r6
   8537c:	2800      	cmp	r0, #0
   8537e:	d1f9      	bne.n	85374 <protocol_buffer_synchronize+0xc>
   85380:	7863      	ldrb	r3, [r4, #1]
   85382:	2b08      	cmp	r3, #8
   85384:	d0f6      	beq.n	85374 <protocol_buffer_synchronize+0xc>
   85386:	bd70      	pop	{r4, r5, r6, pc}
   85388:	00085359 	.word	0x00085359
   8538c:	00085011 	.word	0x00085011
   85390:	20001484 	.word	0x20001484
   85394:	00084885 	.word	0x00084885

00085398 <SlovakTo852>:


unsigned char Slovak[36]= {'','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','',''};
unsigned char CP852[36]=  {225,228,232,239,233,237,229,181,242,243,244,224,182,185,187,250,253,190,193,196,200,207,201,205,197,165,210,211,212,192,166,169,171,218,221,174};
void SlovakTo852(char *text)
{
   85398:	b4f0      	push	{r4, r5, r6, r7}
	int i;
	while (*text != 0)
   8539a:	7804      	ldrb	r4, [r0, #0]
   8539c:	b984      	cbnz	r4, 853c0 <SlovakTo852+0x28>
   8539e:	e01a      	b.n	853d6 <SlovakTo852+0x3e>
	{
		for(i = 0; i< 36;i++)
		if(*text == Slovak[i])
   853a0:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   853a4:	42a1      	cmp	r1, r4
   853a6:	d104      	bne.n	853b2 <SlovakTo852+0x1a>
   853a8:	e000      	b.n	853ac <SlovakTo852+0x14>
   853aa:	463b      	mov	r3, r7
		{
			*text = CP852[i];
   853ac:	5ceb      	ldrb	r3, [r5, r3]
   853ae:	7003      	strb	r3, [r0, #0]
			break;
   853b0:	e002      	b.n	853b8 <SlovakTo852+0x20>
void SlovakTo852(char *text)
{
	int i;
	while (*text != 0)
	{
		for(i = 0; i< 36;i++)
   853b2:	3301      	adds	r3, #1
   853b4:	2b24      	cmp	r3, #36	; 0x24
   853b6:	d1f3      	bne.n	853a0 <SlovakTo852+0x8>
unsigned char Slovak[36]= {'','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','',''};
unsigned char CP852[36]=  {225,228,232,239,233,237,229,181,242,243,244,224,182,185,187,250,253,190,193,196,200,207,201,205,197,165,210,211,212,192,166,169,171,218,221,174};
void SlovakTo852(char *text)
{
	int i;
	while (*text != 0)
   853b8:	f810 4f01 	ldrb.w	r4, [r0, #1]!
   853bc:	b91c      	cbnz	r4, 853c6 <SlovakTo852+0x2e>
   853be:	e00a      	b.n	853d6 <SlovakTo852+0x3e>
	{
		for(i = 0; i< 36;i++)
		if(*text == Slovak[i])
   853c0:	4d06      	ldr	r5, [pc, #24]	; (853dc <SlovakTo852+0x44>)
   853c2:	2700      	movs	r7, #0
void SlovakTo852(char *text)
{
	int i;
	while (*text != 0)
	{
		for(i = 0; i< 36;i++)
   853c4:	2601      	movs	r6, #1
		if(*text == Slovak[i])
   853c6:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   853ca:	42a3      	cmp	r3, r4
   853cc:	d0ed      	beq.n	853aa <SlovakTo852+0x12>
   853ce:	f105 0224 	add.w	r2, r5, #36	; 0x24
void SlovakTo852(char *text)
{
	int i;
	while (*text != 0)
	{
		for(i = 0; i< 36;i++)
   853d2:	4633      	mov	r3, r6
   853d4:	e7e4      	b.n	853a0 <SlovakTo852+0x8>
			*text = CP852[i];
			break;
		}
		text++ ;
	}
}
   853d6:	bcf0      	pop	{r4, r5, r6, r7}
   853d8:	4770      	bx	lr
   853da:	bf00      	nop
   853dc:	20000004 	.word	0x20000004

000853e0 <PosR>:
unsigned int PosR(char znak,char *text)	//	Najde poslednu poziciu znaku v texte
{
	char lp=0;
	int c=0;
	while(text[c])
   853e0:	780b      	ldrb	r3, [r1, #0]
   853e2:	b163      	cbz	r3, 853fe <PosR+0x1e>
		}
		text++ ;
	}
}
unsigned int PosR(char znak,char *text)	//	Najde poslednu poziciu znaku v texte
{
   853e4:	b410      	push	{r4}
   853e6:	4602      	mov	r2, r0
   853e8:	460c      	mov	r4, r1
	char lp=0;
	int c=0;
	while(text[c])
   853ea:	2000      	movs	r0, #0
	{
		if(text[c] == znak)
   853ec:	4293      	cmp	r3, r2
   853ee:	bf04      	itt	eq
   853f0:	1b08      	subeq	r0, r1, r4
   853f2:	b2c0      	uxtbeq	r0, r0
}
unsigned int PosR(char znak,char *text)	//	Najde poslednu poziciu znaku v texte
{
	char lp=0;
	int c=0;
	while(text[c])
   853f4:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   853f8:	2b00      	cmp	r3, #0
   853fa:	d1f7      	bne.n	853ec <PosR+0xc>
   853fc:	e001      	b.n	85402 <PosR+0x22>
		text++ ;
	}
}
unsigned int PosR(char znak,char *text)	//	Najde poslednu poziciu znaku v texte
{
	char lp=0;
   853fe:	2000      	movs	r0, #0
   85400:	4770      	bx	lr
		if(text[c] == znak)
		lp = c;
		c++;
	}
	return lp;
}
   85402:	f85d 4b04 	ldr.w	r4, [sp], #4
   85406:	4770      	bx	lr

00085408 <LCD_SPIWrite>:

unsigned char LCD_SPIWrite(uint8_t val)
{
	//Wait for previous transfer to complete
	while ((SPI0->SPI_SR & SPI_SR_TXEMPTY) == 0);
   85408:	4a0a      	ldr	r2, [pc, #40]	; (85434 <LCD_SPIWrite+0x2c>)
   8540a:	6913      	ldr	r3, [r2, #16]
   8540c:	f413 7f00 	tst.w	r3, #512	; 0x200
   85410:	d0fb      	beq.n	8540a <LCD_SPIWrite+0x2>
	
	//load the Transmit Data Register with the value to transmit
	SPI0->SPI_TDR = val;
   85412:	4b08      	ldr	r3, [pc, #32]	; (85434 <LCD_SPIWrite+0x2c>)
   85414:	60d8      	str	r0, [r3, #12]
	
	//Wait for data to be transferred to serializer
	while ((SPI0->SPI_SR & SPI_SR_TDRE) == 0);
   85416:	461a      	mov	r2, r3
   85418:	6913      	ldr	r3, [r2, #16]
   8541a:	f013 0f02 	tst.w	r3, #2
   8541e:	d0fb      	beq.n	85418 <LCD_SPIWrite+0x10>
	
	while ( (SPI0->SPI_SR & SPI_SR_RDRF) == 0 ) ;
   85420:	4a04      	ldr	r2, [pc, #16]	; (85434 <LCD_SPIWrite+0x2c>)
   85422:	6913      	ldr	r3, [r2, #16]
   85424:	f013 0f01 	tst.w	r3, #1
   85428:	d0fb      	beq.n	85422 <LCD_SPIWrite+0x1a>

	return SPI0->SPI_RDR & 0x00FF ;
   8542a:	4b02      	ldr	r3, [pc, #8]	; (85434 <LCD_SPIWrite+0x2c>)
   8542c:	6898      	ldr	r0, [r3, #8]
}
   8542e:	b2c0      	uxtb	r0, r0
   85430:	4770      	bx	lr
   85432:	bf00      	nop
   85434:	40008000 	.word	0x40008000

00085438 <tft_writeData>:
/*!

*/
/**************************************************************************/
void  tft_writeData(uint8_t d) 
{
   85438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8543a:	4607      	mov	r7, r0
 	while(!(PIOD->PIO_PDSR & (PIO_PD8)));	//	touch screen moze nacitavat
   8543c:	4a0a      	ldr	r2, [pc, #40]	; (85468 <tft_writeData+0x30>)
   8543e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   85440:	f413 7f80 	tst.w	r3, #256	; 0x100
   85444:	d0fb      	beq.n	8543e <tft_writeData+0x6>
	lcd_spi_cs_low();
   85446:	4a08      	ldr	r2, [pc, #32]	; (85468 <tft_writeData+0x30>)
   85448:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8544a:	f413 7f80 	tst.w	r3, #256	; 0x100
   8544e:	d0fb      	beq.n	85448 <tft_writeData+0x10>
   85450:	4c05      	ldr	r4, [pc, #20]	; (85468 <tft_writeData+0x30>)
   85452:	f44f 7580 	mov.w	r5, #256	; 0x100
   85456:	6365      	str	r5, [r4, #52]	; 0x34
	LCD_SPIWrite(RA8875_DATAWRITE);
   85458:	2000      	movs	r0, #0
   8545a:	4e04      	ldr	r6, [pc, #16]	; (8546c <tft_writeData+0x34>)
   8545c:	47b0      	blx	r6
	LCD_SPIWrite(d);
   8545e:	4638      	mov	r0, r7
   85460:	47b0      	blx	r6
	lcd_spi_cs_high();
   85462:	6325      	str	r5, [r4, #48]	; 0x30
   85464:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   85466:	bf00      	nop
   85468:	400e1400 	.word	0x400e1400
   8546c:	00085409 	.word	0x00085409

00085470 <tft_readData>:

*/
/**************************************************************************/
uint8_t  tft_readData(void) 
{
 	while(!(PIOD->PIO_PDSR & (PIO_PD8)));	//	touch screen moze nacitavat
   85470:	4a0a      	ldr	r2, [pc, #40]	; (8549c <tft_readData+0x2c>)
   85472:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   85474:	f413 7f80 	tst.w	r3, #256	; 0x100
   85478:	d0fb      	beq.n	85472 <tft_readData+0x2>
	lcd_spi_cs_low();
   8547a:	4a08      	ldr	r2, [pc, #32]	; (8549c <tft_readData+0x2c>)
   8547c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   8547e:	f413 7f80 	tst.w	r3, #256	; 0x100
   85482:	d0fb      	beq.n	8547c <tft_readData+0xc>
/*!

*/
/**************************************************************************/
uint8_t  tft_readData(void) 
{
   85484:	b570      	push	{r4, r5, r6, lr}
 	while(!(PIOD->PIO_PDSR & (PIO_PD8)));	//	touch screen moze nacitavat
	lcd_spi_cs_low();
   85486:	4c05      	ldr	r4, [pc, #20]	; (8549c <tft_readData+0x2c>)
   85488:	f44f 7580 	mov.w	r5, #256	; 0x100
   8548c:	6365      	str	r5, [r4, #52]	; 0x34
	LCD_SPIWrite(RA8875_DATAREAD);
   8548e:	2040      	movs	r0, #64	; 0x40
   85490:	4e03      	ldr	r6, [pc, #12]	; (854a0 <tft_readData+0x30>)
   85492:	47b0      	blx	r6
	uint8_t x = LCD_SPIWrite(0x0);
   85494:	2000      	movs	r0, #0
   85496:	47b0      	blx	r6
	lcd_spi_cs_high();
   85498:	6325      	str	r5, [r4, #48]	; 0x30
	return x;
}
   8549a:	bd70      	pop	{r4, r5, r6, pc}
   8549c:	400e1400 	.word	0x400e1400
   854a0:	00085409 	.word	0x00085409

000854a4 <tft_writeCommand>:
/*!

*/
/**************************************************************************/
void  tft_writeCommand(uint8_t d) 
{
   854a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   854a6:	4607      	mov	r7, r0
 	while(!(PIOD->PIO_PDSR & (PIO_PD8)));	//	touch screen moze nacitavat
   854a8:	4a0a      	ldr	r2, [pc, #40]	; (854d4 <tft_writeCommand+0x30>)
   854aa:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   854ac:	f413 7f80 	tst.w	r3, #256	; 0x100
   854b0:	d0fb      	beq.n	854aa <tft_writeCommand+0x6>
	lcd_spi_cs_low();
   854b2:	4a08      	ldr	r2, [pc, #32]	; (854d4 <tft_writeCommand+0x30>)
   854b4:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   854b6:	f413 7f80 	tst.w	r3, #256	; 0x100
   854ba:	d0fb      	beq.n	854b4 <tft_writeCommand+0x10>
   854bc:	4c05      	ldr	r4, [pc, #20]	; (854d4 <tft_writeCommand+0x30>)
   854be:	f44f 7580 	mov.w	r5, #256	; 0x100
   854c2:	6365      	str	r5, [r4, #52]	; 0x34
	LCD_SPIWrite(RA8875_CMDWRITE);
   854c4:	2080      	movs	r0, #128	; 0x80
   854c6:	4e04      	ldr	r6, [pc, #16]	; (854d8 <tft_writeCommand+0x34>)
   854c8:	47b0      	blx	r6
	LCD_SPIWrite(d);
   854ca:	4638      	mov	r0, r7
   854cc:	47b0      	blx	r6
	lcd_spi_cs_high();
   854ce:	6325      	str	r5, [r4, #48]	; 0x30
   854d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   854d2:	bf00      	nop
   854d4:	400e1400 	.word	0x400e1400
   854d8:	00085409 	.word	0x00085409

000854dc <tft_textMode>:
/*!
      Sets the display in text mode (as opposed to graphics mode)
*/
/**************************************************************************/
void tft_textMode(void) 
{
   854dc:	b570      	push	{r4, r5, r6, lr}
  /* Set text mode */
  tft_writeCommand(RA8875_MWCR0);
   854de:	2040      	movs	r0, #64	; 0x40
   854e0:	4e0a      	ldr	r6, [pc, #40]	; (8550c <tft_textMode+0x30>)
   854e2:	47b0      	blx	r6
  uint8_t temp = tft_readData();
   854e4:	4d0a      	ldr	r5, [pc, #40]	; (85510 <tft_textMode+0x34>)
   854e6:	47a8      	blx	r5
  temp |= RA8875_MWCR0_TXTMODE; // Set bit 7
   854e8:	f060 007f 	orn	r0, r0, #127	; 0x7f
  tft_writeData(temp);
   854ec:	b2c0      	uxtb	r0, r0
   854ee:	4c09      	ldr	r4, [pc, #36]	; (85514 <tft_textMode+0x38>)
   854f0:	47a0      	blx	r4
  
  /* Select the internal (ROM) font */
  tft_writeCommand(0x21);
   854f2:	2021      	movs	r0, #33	; 0x21
   854f4:	47b0      	blx	r6
  temp = tft_readData();
   854f6:	47a8      	blx	r5
  temp &= ~((1<<7) | (1<<5)) | (1<<1); // Clear bits 7 and 5 and 1
   854f8:	f000 005f 	and.w	r0, r0, #95	; 0x5f
  temp |= (1 << 0);	// ISO/IEC 8859-2
  tft_writeData(temp);
   854fc:	f040 0001 	orr.w	r0, r0, #1
   85500:	47a0      	blx	r4
  tft_is_text_mode = true;
   85502:	2201      	movs	r2, #1
   85504:	4b04      	ldr	r3, [pc, #16]	; (85518 <tft_textMode+0x3c>)
   85506:	701a      	strb	r2, [r3, #0]
   85508:	bd70      	pop	{r4, r5, r6, pc}
   8550a:	bf00      	nop
   8550c:	000854a5 	.word	0x000854a5
   85510:	00085471 	.word	0x00085471
   85514:	00085439 	.word	0x00085439
   85518:	2000124c 	.word	0x2000124c

0008551c <tft_textSetCursor>:
      @args x[in] The x position of the cursor (in pixels, 0..1023)
      @args y[in] The y position of the cursor (in pixels, 0..511)
*/
/**************************************************************************/
void tft_textSetCursor(uint16_t x, uint16_t y) 
{
   8551c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8551e:	4607      	mov	r7, r0
   85520:	460e      	mov	r6, r1
  /* Set cursor location */
  tft_writeCommand(0x2A);
   85522:	202a      	movs	r0, #42	; 0x2a
   85524:	4d08      	ldr	r5, [pc, #32]	; (85548 <tft_textSetCursor+0x2c>)
   85526:	47a8      	blx	r5
  tft_writeData(x & 0xFF);
   85528:	b2f8      	uxtb	r0, r7
   8552a:	4c08      	ldr	r4, [pc, #32]	; (8554c <tft_textSetCursor+0x30>)
   8552c:	47a0      	blx	r4
  tft_writeCommand(0x2B);
   8552e:	202b      	movs	r0, #43	; 0x2b
   85530:	47a8      	blx	r5
  tft_writeData(x >> 8);
   85532:	0a38      	lsrs	r0, r7, #8
   85534:	47a0      	blx	r4
  tft_writeCommand(0x2C);
   85536:	202c      	movs	r0, #44	; 0x2c
   85538:	47a8      	blx	r5
  tft_writeData(y & 0xFF);
   8553a:	b2f0      	uxtb	r0, r6
   8553c:	47a0      	blx	r4
  tft_writeCommand(0x2D);
   8553e:	202d      	movs	r0, #45	; 0x2d
   85540:	47a8      	blx	r5
  tft_writeData(y >> 8);
   85542:	0a30      	lsrs	r0, r6, #8
   85544:	47a0      	blx	r4
   85546:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   85548:	000854a5 	.word	0x000854a5
   8554c:	00085439 	.word	0x00085439

00085550 <tft_textColor>:
      @args foreColor[in] The RGB565 color to use when rendering the text
      @args bgColor[in]   The RGB565 colot to use for the background
*/
/**************************************************************************/
void tft_textColor(uint16_t foreColor, uint16_t bgColor)
{
   85550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   85552:	4607      	mov	r7, r0
   85554:	460e      	mov	r6, r1
  /* Set Fore Color */
  tft_writeCommand(0x63);
   85556:	2063      	movs	r0, #99	; 0x63
   85558:	4d12      	ldr	r5, [pc, #72]	; (855a4 <tft_textColor+0x54>)
   8555a:	47a8      	blx	r5
  tft_writeData((foreColor & 0xf800) >> 11);
   8555c:	0af8      	lsrs	r0, r7, #11
   8555e:	4c12      	ldr	r4, [pc, #72]	; (855a8 <tft_textColor+0x58>)
   85560:	47a0      	blx	r4
  tft_writeCommand(0x64);
   85562:	2064      	movs	r0, #100	; 0x64
   85564:	47a8      	blx	r5
  tft_writeData((foreColor & 0x07e0) >> 5);
   85566:	f3c7 1045 	ubfx	r0, r7, #5, #6
   8556a:	47a0      	blx	r4
  tft_writeCommand(0x65);
   8556c:	2065      	movs	r0, #101	; 0x65
   8556e:	47a8      	blx	r5
  tft_writeData((foreColor & 0x001f));
   85570:	f007 001f 	and.w	r0, r7, #31
   85574:	47a0      	blx	r4
  
  /* Set Background Color */
  tft_writeCommand(0x60);
   85576:	2060      	movs	r0, #96	; 0x60
   85578:	47a8      	blx	r5
  tft_writeData((bgColor & 0xf800) >> 11);
   8557a:	0af0      	lsrs	r0, r6, #11
   8557c:	47a0      	blx	r4
  tft_writeCommand(0x61);
   8557e:	2061      	movs	r0, #97	; 0x61
   85580:	47a8      	blx	r5
  tft_writeData((bgColor & 0x07e0) >> 5);
   85582:	f3c6 1045 	ubfx	r0, r6, #5, #6
   85586:	47a0      	blx	r4
  tft_writeCommand(0x62);
   85588:	2062      	movs	r0, #98	; 0x62
   8558a:	47a8      	blx	r5
  tft_writeData((bgColor & 0x001f));
   8558c:	f006 001f 	and.w	r0, r6, #31
   85590:	47a0      	blx	r4
  
  /* Clear transparency flag */
  tft_writeCommand(0x22);
   85592:	2022      	movs	r0, #34	; 0x22
   85594:	47a8      	blx	r5
  uint8_t temp = tft_readData();
   85596:	4b05      	ldr	r3, [pc, #20]	; (855ac <tft_textColor+0x5c>)
   85598:	4798      	blx	r3
  temp &= ~(1<<6); // Clear bit 6
  tft_writeData(temp);
   8559a:	f000 00bf 	and.w	r0, r0, #191	; 0xbf
   8559e:	47a0      	blx	r4
   855a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   855a2:	bf00      	nop
   855a4:	000854a5 	.word	0x000854a5
   855a8:	00085439 	.word	0x00085439
   855ac:	00085471 	.word	0x00085471

000855b0 <tft_textEnlarge>:
      
      @args scale[in]   The zoom factor (0..3 for 1-4x zoom)
*/
/**************************************************************************/
void tft_textEnlarge(uint8_t scale)
{
   855b0:	b510      	push	{r4, lr}
   855b2:	2803      	cmp	r0, #3
   855b4:	bf28      	it	cs
   855b6:	2003      	movcs	r0, #3
   855b8:	4604      	mov	r4, r0
  if (scale > 3) scale = 3;

  /* Set font size flags */
  tft_writeCommand(0x22);
   855ba:	2022      	movs	r0, #34	; 0x22
   855bc:	4b07      	ldr	r3, [pc, #28]	; (855dc <tft_textEnlarge+0x2c>)
   855be:	4798      	blx	r3
  uint8_t temp = tft_readData();
   855c0:	4b07      	ldr	r3, [pc, #28]	; (855e0 <tft_textEnlarge+0x30>)
   855c2:	4798      	blx	r3
  temp &= ~(0xF); // Clears bits 0..3
   855c4:	f020 000f 	bic.w	r0, r0, #15
  temp |= scale << 2;
   855c8:	ea40 0084 	orr.w	r0, r0, r4, lsl #2
   855cc:	f000 00fc 	and.w	r0, r0, #252	; 0xfc
  temp |= scale;
  tft_writeData(temp);  
   855d0:	4320      	orrs	r0, r4
   855d2:	4b04      	ldr	r3, [pc, #16]	; (855e4 <tft_textEnlarge+0x34>)
   855d4:	4798      	blx	r3

  tft_textScale = scale;
   855d6:	4b04      	ldr	r3, [pc, #16]	; (855e8 <tft_textEnlarge+0x38>)
   855d8:	701c      	strb	r4, [r3, #0]
   855da:	bd10      	pop	{r4, pc}
   855dc:	000854a5 	.word	0x000854a5
   855e0:	00085471 	.word	0x00085471
   855e4:	00085439 	.word	0x00085439
   855e8:	200014a4 	.word	0x200014a4

000855ec <tft_textWriteRaw>:
      @args buffer[in]    The buffer containing the characters to render
      @args len[in]       The size of the buffer in bytes
*/
/**************************************************************************/
void tft_textWriteRaw(const char* buffer, uint16_t len) 
{
   855ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   855ee:	b0c1      	sub	sp, #260	; 0x104
   855f0:	4604      	mov	r4, r0
  if (len == 0) len = strlen(buffer);
   855f2:	bb11      	cbnz	r1, 8563a <tft_textWriteRaw+0x4e>
   855f4:	4b19      	ldr	r3, [pc, #100]	; (8565c <tft_textWriteRaw+0x70>)
   855f6:	4798      	blx	r3
   855f8:	b285      	uxth	r5, r0
//  char *char852 = (char*)malloc(len+1);
  char char852[256];
  memcpy(char852,buffer,len+1);
   855fa:	4668      	mov	r0, sp
   855fc:	4621      	mov	r1, r4
   855fe:	1c6a      	adds	r2, r5, #1
   85600:	4b17      	ldr	r3, [pc, #92]	; (85660 <tft_textWriteRaw+0x74>)
   85602:	4798      	blx	r3
  SlovakTo852(char852);
   85604:	4668      	mov	r0, sp
   85606:	4b17      	ldr	r3, [pc, #92]	; (85664 <tft_textWriteRaw+0x78>)
   85608:	4798      	blx	r3
  if(!tft_is_text_mode)
   8560a:	4b17      	ldr	r3, [pc, #92]	; (85668 <tft_textWriteRaw+0x7c>)
   8560c:	781b      	ldrb	r3, [r3, #0]
   8560e:	b90b      	cbnz	r3, 85614 <tft_textWriteRaw+0x28>
	tft_textMode();
   85610:	4b16      	ldr	r3, [pc, #88]	; (8566c <tft_textWriteRaw+0x80>)
   85612:	4798      	blx	r3
  tft_writeCommand(RA8875_MRWC);
   85614:	2002      	movs	r0, #2
   85616:	4b16      	ldr	r3, [pc, #88]	; (85670 <tft_textWriteRaw+0x84>)
   85618:	4798      	blx	r3
  for (uint16_t i=0;i<len;i++)
   8561a:	b1e5      	cbz	r5, 85656 <tft_textWriteRaw+0x6a>
   8561c:	466e      	mov	r6, sp
      @args buffer[in]    The buffer containing the characters to render
      @args len[in]       The size of the buffer in bytes
*/
/**************************************************************************/
void tft_textWriteRaw(const char* buffer, uint16_t len) 
{
   8561e:	466c      	mov	r4, sp
  if(!tft_is_text_mode)
	tft_textMode();
  tft_writeCommand(RA8875_MRWC);
  for (uint16_t i=0;i<len;i++)
  {
    tft_writeData(char852[i]);
   85620:	4f14      	ldr	r7, [pc, #80]	; (85674 <tft_textWriteRaw+0x88>)
   85622:	f814 0b01 	ldrb.w	r0, [r4], #1
   85626:	47b8      	blx	r7
   85628:	1ba3      	subs	r3, r4, r6
  memcpy(char852,buffer,len+1);
  SlovakTo852(char852);
  if(!tft_is_text_mode)
	tft_textMode();
  tft_writeCommand(RA8875_MRWC);
  for (uint16_t i=0;i<len;i++)
   8562a:	b29b      	uxth	r3, r3
   8562c:	429d      	cmp	r5, r3
   8562e:	d8f8      	bhi.n	85622 <tft_textWriteRaw+0x36>
   85630:	e011      	b.n	85656 <tft_textWriteRaw+0x6a>
  char char852[256];
  memcpy(char852,buffer,len+1);
  SlovakTo852(char852);
  if(!tft_is_text_mode)
	tft_textMode();
  tft_writeCommand(RA8875_MRWC);
   85632:	2002      	movs	r0, #2
   85634:	4b0e      	ldr	r3, [pc, #56]	; (85670 <tft_textWriteRaw+0x84>)
   85636:	4798      	blx	r3
   85638:	e7f0      	b.n	8561c <tft_textWriteRaw+0x30>
   8563a:	460d      	mov	r5, r1
void tft_textWriteRaw(const char* buffer, uint16_t len) 
{
  if (len == 0) len = strlen(buffer);
//  char *char852 = (char*)malloc(len+1);
  char char852[256];
  memcpy(char852,buffer,len+1);
   8563c:	4668      	mov	r0, sp
   8563e:	4621      	mov	r1, r4
   85640:	1c6a      	adds	r2, r5, #1
   85642:	4b07      	ldr	r3, [pc, #28]	; (85660 <tft_textWriteRaw+0x74>)
   85644:	4798      	blx	r3
  SlovakTo852(char852);
   85646:	4668      	mov	r0, sp
   85648:	4b06      	ldr	r3, [pc, #24]	; (85664 <tft_textWriteRaw+0x78>)
   8564a:	4798      	blx	r3
  if(!tft_is_text_mode)
   8564c:	4b06      	ldr	r3, [pc, #24]	; (85668 <tft_textWriteRaw+0x7c>)
   8564e:	781b      	ldrb	r3, [r3, #0]
   85650:	2b00      	cmp	r3, #0
   85652:	d1ee      	bne.n	85632 <tft_textWriteRaw+0x46>
   85654:	e7dc      	b.n	85610 <tft_textWriteRaw+0x24>
    // This delay_ms is needed with textEnlarge(1) because
    // Teensy 3.X is much faster than Arduino Uno
//    if (tft_textScale > 0) delay_ms(1);
  }
//  free(char852);
}
   85656:	b041      	add	sp, #260	; 0x104
   85658:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8565a:	bf00      	nop
   8565c:	0008d399 	.word	0x0008d399
   85660:	0008d0dd 	.word	0x0008d0dd
   85664:	00085399 	.word	0x00085399
   85668:	2000124c 	.word	0x2000124c
   8566c:	000854dd 	.word	0x000854dd
   85670:	000854a5 	.word	0x000854a5
   85674:	00085439 	.word	0x00085439

00085678 <tft_textWrite>:
void tft_textWrite(uint16_t left,uint16_t top,uint16_t right, uint16_t bottom, char* buffer, uint8_t align)
{
   85678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8567c:	b0b7      	sub	sp, #220	; 0xdc
   8567e:	4604      	mov	r4, r0
   85680:	460e      	mov	r6, r1
   85682:	4690      	mov	r8, r2
   85684:	461f      	mov	r7, r3
   85686:	f89d b104 	ldrb.w	fp, [sp, #260]	; 0x104
	#define charwidth 8
	#define charheight 16
	int len,text_width;
	char buff[105];
	len = strlen(buffer);
   8568a:	9840      	ldr	r0, [sp, #256]	; 0x100
   8568c:	4b70      	ldr	r3, [pc, #448]	; (85850 <tft_textWrite+0x1d8>)
   8568e:	4798      	blx	r3
   85690:	4605      	mov	r5, r0
	memcpy(buff,buffer,len+1);
   85692:	a81b      	add	r0, sp, #108	; 0x6c
   85694:	9940      	ldr	r1, [sp, #256]	; 0x100
   85696:	1c6a      	adds	r2, r5, #1
   85698:	4b6e      	ldr	r3, [pc, #440]	; (85854 <tft_textWrite+0x1dc>)
   8569a:	4798      	blx	r3
	if(right)
   8569c:	f1b8 0f00 	cmp.w	r8, #0
   856a0:	d035      	beq.n	8570e <tft_textWrite+0x96>
	{
		if(right < left)	//	Predpokladam ze je to sirka
   856a2:	45a0      	cmp	r8, r4
   856a4:	f080 80c4 	bcs.w	85830 <tft_textWrite+0x1b8>
			right+= left;
   856a8:	44a0      	add	r8, r4
   856aa:	fa1f f888 	uxth.w	r8, r8
		if(len > (((right - left)* charwidth * (tft_textScale + 1)-3)))	//	Ak je text dlhsi ako sa zmesti do daneho priestoru
   856ae:	ebc4 0908 	rsb	r9, r4, r8
   856b2:	ea4f 03c9 	mov.w	r3, r9, lsl #3
   856b6:	4a68      	ldr	r2, [pc, #416]	; (85858 <tft_textWrite+0x1e0>)
   856b8:	7812      	ldrb	r2, [r2, #0]
   856ba:	fb02 3303 	mla	r3, r2, r3, r3
   856be:	3b03      	subs	r3, #3
   856c0:	429d      	cmp	r5, r3
   856c2:	dd04      	ble.n	856ce <tft_textWrite+0x56>
			buff[(right - left)* charwidth * (tft_textScale + 1)-3] = 0;
   856c4:	aa36      	add	r2, sp, #216	; 0xd8
   856c6:	4413      	add	r3, r2
   856c8:	2200      	movs	r2, #0
   856ca:	f803 2c6c 	strb.w	r2, [r3, #-108]
	}
	len = strlen(buff);
   856ce:	a81b      	add	r0, sp, #108	; 0x6c
   856d0:	4b5f      	ldr	r3, [pc, #380]	; (85850 <tft_textWrite+0x1d8>)
   856d2:	4798      	blx	r3
	if(right && ((align & 0x03) == ALINE_RIGHT))	//	Je zadany pravy okraj a chcem to zarovnat napravo
   856d4:	f1b8 0f00 	cmp.w	r8, #0
   856d8:	d019      	beq.n	8570e <tft_textWrite+0x96>
   856da:	f00b 0303 	and.w	r3, fp, #3
   856de:	2b02      	cmp	r3, #2
   856e0:	d115      	bne.n	8570e <tft_textWrite+0x96>
	{
		text_width = len * charwidth * (tft_textScale + 1);
   856e2:	4b5d      	ldr	r3, [pc, #372]	; (85858 <tft_textWrite+0x1e0>)
   856e4:	781b      	ldrb	r3, [r3, #0]
   856e6:	3301      	adds	r3, #1
   856e8:	00c0      	lsls	r0, r0, #3
   856ea:	fb03 f000 	mul.w	r0, r3, r0
		if(text_width < (right - left))
   856ee:	4581      	cmp	r9, r0
   856f0:	dd0d      	ble.n	8570e <tft_textWrite+0x96>
		{
			char chyba_medzier = ((right - left) - text_width) / (charwidth * (tft_textScale + 1)) + 3;	//	Zistim pocet medzier ktore doplnim na koniec
   856f2:	ebc0 0009 	rsb	r0, r0, r9
   856f6:	00db      	lsls	r3, r3, #3
   856f8:	fb90 f3f3 	sdiv	r3, r0, r3
   856fc:	3303      	adds	r3, #3
			sprintf(buff,"%s%*s",buffer,chyba_medzier,"");
   856fe:	4a57      	ldr	r2, [pc, #348]	; (8585c <tft_textWrite+0x1e4>)
   85700:	9200      	str	r2, [sp, #0]
   85702:	a81b      	add	r0, sp, #108	; 0x6c
   85704:	4956      	ldr	r1, [pc, #344]	; (85860 <tft_textWrite+0x1e8>)
   85706:	9a40      	ldr	r2, [sp, #256]	; 0x100
   85708:	b2db      	uxtb	r3, r3
   8570a:	4d56      	ldr	r5, [pc, #344]	; (85864 <tft_textWrite+0x1ec>)
   8570c:	47a8      	blx	r5
		}
	}
	len = strlen(buff);
   8570e:	a81b      	add	r0, sp, #108	; 0x6c
   85710:	4b4f      	ldr	r3, [pc, #316]	; (85850 <tft_textWrite+0x1d8>)
   85712:	4798      	blx	r3
	text_width = len * charwidth * (tft_textScale + 1);	
   85714:	4b50      	ldr	r3, [pc, #320]	; (85858 <tft_textWrite+0x1e0>)
   85716:	781b      	ldrb	r3, [r3, #0]
   85718:	f103 0901 	add.w	r9, r3, #1
   8571c:	00c0      	lsls	r0, r0, #3
   8571e:	fb09 fa00 	mul.w	sl, r9, r0
	if(bottom != 0)
   85722:	b14f      	cbz	r7, 85738 <tft_textWrite+0xc0>
		top = top + ((bottom-top - (16 * (tft_textScale + 1))) / 2);
   85724:	1bbf      	subs	r7, r7, r6
   85726:	43db      	mvns	r3, r3
   85728:	eb07 1703 	add.w	r7, r7, r3, lsl #4
   8572c:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
   85730:	f3c7 074f 	ubfx	r7, r7, #1, #16
   85734:	443e      	add	r6, r7
   85736:	b2b6      	uxth	r6, r6
	switch (align & 0x03)
   85738:	f00b 0b03 	and.w	fp, fp, #3
   8573c:	f1bb 0f01 	cmp.w	fp, #1
   85740:	d00a      	beq.n	85758 <tft_textWrite+0xe0>
   85742:	f1bb 0f02 	cmp.w	fp, #2
   85746:	d166      	bne.n	85816 <tft_textWrite+0x19e>
	{
		case ALINE_LEFT:	break;
		case ALINE_RIGHT:	if ((right - left) > text_width)	//	Je dost miesta, tak zarovnam vpravo
   85748:	ebc4 0308 	rsb	r3, r4, r8
   8574c:	459a      	cmp	sl, r3
   8574e:	da62      	bge.n	85816 <tft_textWrite+0x19e>
								left = right - text_width;
   85750:	ebca 0408 	rsb	r4, sl, r8
   85754:	b2a4      	uxth	r4, r4
   85756:	e05e      	b.n	85816 <tft_textWrite+0x19e>
							break;
		case ALINE_CENTER:	if(text_width > (right - left))	//	Sirka textu je vacsia ako sirka vybraneho okna
   85758:	4645      	mov	r5, r8
   8575a:	ebc4 0808 	rsb	r8, r4, r8
   8575e:	45c2      	cmp	sl, r8
   85760:	dd50      	ble.n	85804 <tft_textWrite+0x18c>
							{	//	text rozdelim na dva riadky
								left = left + (right - left - text_width) / 2;
   85762:	ebca 0808 	rsb	r8, sl, r8
   85766:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
   8576a:	eb04 0468 	add.w	r4, r4, r8, asr #1
   8576e:	b2a4      	uxth	r4, r4
								unsigned char a;
								char buffer1[100];
								a = PosR(32,buff);
   85770:	2020      	movs	r0, #32
   85772:	a91b      	add	r1, sp, #108	; 0x6c
   85774:	4b3c      	ldr	r3, [pc, #240]	; (85868 <tft_textWrite+0x1f0>)
   85776:	4798      	blx	r3
								if(a > 0)	//	Text obsahuje medzeru tak ho rozdelim na dva riadky
   85778:	f010 0fff 	tst.w	r0, #255	; 0xff
   8577c:	d042      	beq.n	85804 <tft_textWrite+0x18c>
								{
									unsigned int left1,maxsize;
									memcpy(buffer1,buff,a);
   8577e:	b2c7      	uxtb	r7, r0
   85780:	a802      	add	r0, sp, #8
   85782:	a91b      	add	r1, sp, #108	; 0x6c
   85784:	463a      	mov	r2, r7
   85786:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 85854 <tft_textWrite+0x1dc>
   8578a:	47d8      	blx	fp
									buffer1[a] = 0;
   8578c:	ab36      	add	r3, sp, #216	; 0xd8
   8578e:	443b      	add	r3, r7
   85790:	f04f 0200 	mov.w	r2, #0
   85794:	f803 2cd0 	strb.w	r2, [r3, #-208]
									maxsize =  strlen(buffer1) * charwidth * (tft_textScale + 1);
   85798:	a802      	add	r0, sp, #8
   8579a:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 85850 <tft_textWrite+0x1d8>
   8579e:	47c0      	blx	r8
									left1 = left + (right - left - maxsize) / 2;
   857a0:	1b2d      	subs	r5, r5, r4
   857a2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
   857a6:	fb00 5019 	mls	r0, r0, r9, r5
   857aa:	eb04 0050 	add.w	r0, r4, r0, lsr #1
									tft_textSetCursor(left1 + ((tft_textScale + 1) * charwidth) / 2,top - charheight);
   857ae:	eb00 0069 	add.w	r0, r0, r9, asr #1
   857b2:	f1a6 0110 	sub.w	r1, r6, #16
   857b6:	b280      	uxth	r0, r0
   857b8:	b289      	uxth	r1, r1
   857ba:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 8586c <tft_textWrite+0x1f4>
   857be:	47d0      	blx	sl
									tft_textWriteRaw(buffer1,0);
   857c0:	a802      	add	r0, sp, #8
   857c2:	2100      	movs	r1, #0
   857c4:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 85870 <tft_textWrite+0x1f8>
   857c8:	47c8      	blx	r9
									memcpy(buffer1,buff + a + 1,strlen(buff)-a);
   857ca:	a81b      	add	r0, sp, #108	; 0x6c
   857cc:	47c0      	blx	r8
   857ce:	1bc2      	subs	r2, r0, r7
   857d0:	1c79      	adds	r1, r7, #1
   857d2:	a802      	add	r0, sp, #8
   857d4:	ab1b      	add	r3, sp, #108	; 0x6c
   857d6:	4419      	add	r1, r3
   857d8:	47d8      	blx	fp
									left1 = left + (right - left - strlen(buffer1) * charwidth * (tft_textScale + 1)) / 2;
   857da:	a802      	add	r0, sp, #8
   857dc:	47c0      	blx	r8
   857de:	4b1e      	ldr	r3, [pc, #120]	; (85858 <tft_textWrite+0x1e0>)
   857e0:	781b      	ldrb	r3, [r3, #0]
   857e2:	3301      	adds	r3, #1
   857e4:	00db      	lsls	r3, r3, #3
   857e6:	fb00 5013 	mls	r0, r0, r3, r5
   857ea:	eb04 0050 	add.w	r0, r4, r0, lsr #1
									tft_textSetCursor(left1 + ((tft_textScale + 1) * charwidth) / 2,top + charheight);
   857ee:	eb00 0063 	add.w	r0, r0, r3, asr #1
   857f2:	f106 0110 	add.w	r1, r6, #16
   857f6:	b280      	uxth	r0, r0
   857f8:	b289      	uxth	r1, r1
   857fa:	47d0      	blx	sl
									tft_textWriteRaw(buffer1,0);
   857fc:	a802      	add	r0, sp, #8
   857fe:	2100      	movs	r1, #0
   85800:	47c8      	blx	r9
   85802:	e022      	b.n	8584a <tft_textWrite+0x1d2>
									return ;
								}
							}
							left = left + (right - left - text_width) / 2;
   85804:	1b2d      	subs	r5, r5, r4
   85806:	ebca 0a05 	rsb	sl, sl, r5
   8580a:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
   8580e:	f3ca 0a4f 	ubfx	sl, sl, #1, #16
   85812:	4454      	add	r4, sl
   85814:	b2a4      	uxth	r4, r4
							break;

	}
	tft_textSetCursor(left,top);
   85816:	4620      	mov	r0, r4
   85818:	4631      	mov	r1, r6
   8581a:	4b14      	ldr	r3, [pc, #80]	; (8586c <tft_textWrite+0x1f4>)
   8581c:	4798      	blx	r3
	tft_textWriteRaw(buff,0);
   8581e:	a81b      	add	r0, sp, #108	; 0x6c
   85820:	2100      	movs	r1, #0
   85822:	4b13      	ldr	r3, [pc, #76]	; (85870 <tft_textWrite+0x1f8>)
   85824:	4798      	blx	r3
   85826:	e010      	b.n	8584a <tft_textWrite+0x1d2>
		if(right < left)	//	Predpokladam ze je to sirka
			right+= left;
		if(len > (((right - left)* charwidth * (tft_textScale + 1)-3)))	//	Ak je text dlhsi ako sa zmesti do daneho priestoru
			buff[(right - left)* charwidth * (tft_textScale + 1)-3] = 0;
	}
	len = strlen(buff);
   85828:	a81b      	add	r0, sp, #108	; 0x6c
   8582a:	4b09      	ldr	r3, [pc, #36]	; (85850 <tft_textWrite+0x1d8>)
   8582c:	4798      	blx	r3
   8582e:	e754      	b.n	856da <tft_textWrite+0x62>
	memcpy(buff,buffer,len+1);
	if(right)
	{
		if(right < left)	//	Predpokladam ze je to sirka
			right+= left;
		if(len > (((right - left)* charwidth * (tft_textScale + 1)-3)))	//	Ak je text dlhsi ako sa zmesti do daneho priestoru
   85830:	ebc4 0908 	rsb	r9, r4, r8
   85834:	ea4f 03c9 	mov.w	r3, r9, lsl #3
   85838:	4a07      	ldr	r2, [pc, #28]	; (85858 <tft_textWrite+0x1e0>)
   8583a:	7812      	ldrb	r2, [r2, #0]
   8583c:	fb02 3303 	mla	r3, r2, r3, r3
   85840:	3b03      	subs	r3, #3
   85842:	429d      	cmp	r5, r3
   85844:	f73f af3e 	bgt.w	856c4 <tft_textWrite+0x4c>
   85848:	e7ee      	b.n	85828 <tft_textWrite+0x1b0>
							break;

	}
	tft_textSetCursor(left,top);
	tft_textWriteRaw(buff,0);
}
   8584a:	b037      	add	sp, #220	; 0xdc
   8584c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   85850:	0008d399 	.word	0x0008d399
   85854:	0008d0dd 	.word	0x0008d0dd
   85858:	200014a4 	.word	0x200014a4
   8585c:	00091d60 	.word	0x00091d60
   85860:	00091710 	.word	0x00091710
   85864:	0008d291 	.word	0x0008d291
   85868:	000853e1 	.word	0x000853e1
   8586c:	0008551d 	.word	0x0008551d
   85870:	000855ed 	.word	0x000855ed

00085874 <tft_graphicsMode>:
/**************************************************************************/
/*!
      Sets the display in graphics mode (as opposed to text mode)
*/
/**************************************************************************/
void tft_graphicsMode(void) {
   85874:	b508      	push	{r3, lr}
  tft_writeCommand(RA8875_MWCR0);
   85876:	2040      	movs	r0, #64	; 0x40
   85878:	4b05      	ldr	r3, [pc, #20]	; (85890 <tft_graphicsMode+0x1c>)
   8587a:	4798      	blx	r3
  uint8_t temp = tft_readData();
   8587c:	4b05      	ldr	r3, [pc, #20]	; (85894 <tft_graphicsMode+0x20>)
   8587e:	4798      	blx	r3
  temp &= ~RA8875_MWCR0_TXTMODE; // bit #7
  tft_writeData(temp);
   85880:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   85884:	4b04      	ldr	r3, [pc, #16]	; (85898 <tft_graphicsMode+0x24>)
   85886:	4798      	blx	r3
  tft_is_text_mode = false;
   85888:	2200      	movs	r2, #0
   8588a:	4b04      	ldr	r3, [pc, #16]	; (8589c <tft_graphicsMode+0x28>)
   8588c:	701a      	strb	r2, [r3, #0]
   8588e:	bd08      	pop	{r3, pc}
   85890:	000854a5 	.word	0x000854a5
   85894:	00085471 	.word	0x00085471
   85898:	00085439 	.word	0x00085439
   8589c:	2000124c 	.word	0x2000124c

000858a0 <tft_graphicCursorEnable>:
	tft_writeCommand(0x41);
	tft_writeData(0x00);	//	Adresa je LAYER
	tft_graphicCursorEnable();
}
void tft_graphicCursorEnable(void)
{
   858a0:	b508      	push	{r3, lr}
	tft_writeCommand(0x41);
   858a2:	2041      	movs	r0, #65	; 0x41
   858a4:	4b02      	ldr	r3, [pc, #8]	; (858b0 <tft_graphicCursorEnable+0x10>)
   858a6:	4798      	blx	r3
	tft_writeData(1 << 7);	//	Povolim kurzor
   858a8:	2080      	movs	r0, #128	; 0x80
   858aa:	4b02      	ldr	r3, [pc, #8]	; (858b4 <tft_graphicCursorEnable+0x14>)
   858ac:	4798      	blx	r3
   858ae:	bd08      	pop	{r3, pc}
   858b0:	000854a5 	.word	0x000854a5
   858b4:	00085439 	.word	0x00085439

000858b8 <tft_graphicCursorType>:
	/* Wait for the command to finish */
	  /* Wait for the command to finish */
}

void tft_graphicCursorType(uint8_t typ)
{
   858b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   858ba:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
   858be:	4607      	mov	r7, r0
	int i;	
	if(tft_cursor_type == typ) return;
   858c0:	4b20      	ldr	r3, [pc, #128]	; (85944 <tft_graphicCursorType+0x8c>)
   858c2:	781b      	ldrb	r3, [r3, #0]
   858c4:	4283      	cmp	r3, r0
   858c6:	d039      	beq.n	8593c <tft_graphicCursorType+0x84>
	uint8_t const target[256]  ={0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBF,0xFA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xEB,0xAF,0xAA,0xAA,0xAA,0xAA,0xAA,0xBE,0xAB,0xAA,0xFA,0xAA,0xAA,0xAA,0xAA,0xEA,0xAB,0xAA,0xAE,0xAA,0xAA,0xAA,0xAB,0xAA,0xAB,0xAA,0xAB,0xAA,0xAA,0xAA,0xAB,0xAA,0xAB,0xAA,0xAB,0xAA,0xAA,0xAA,0xAE,0xAA,0xAB,0xAA,0xAA,0xEA,0xAA,0xAA,0xAE,0xAA,0xAB,0xAA,0xAA,0xEA,0xAA,0xAA,0xBA,0xAA,0xAB,0xAA,0xAA,0xBA,0xAA,0xAA,0xBA,0xAA,0xAB,0xAA,0xAA,0xBA,0xAA,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0xBA,0xAA,0xAB,0xAA,0xAA,0xBA,0xAA,0xAA,0xBA,0xAA,0xAB,0xAA,0xAA,0xBA,0xAA,0xAA,0xBA,0xAA,0xAB,0xAA,0xAA,0xBA,0xAA,0xAA,0xAE,0xAA,0xAB,0xAA,0xAA,0xEA,0xAA,0xAA,0xAE,0xAA,0xAB,0xAA,0xAA,0xEA,0xAA,0xAA,0xAB,0xAA,0xAB,0xAA,0xAB,0xAA,0xAA,0xAA,0xAB,0xAA,0xAB,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xEA,0xAB,0xAA,0xAE,0xAA,0xAA,0xAA,0xAA,0xBE,0xAB,0xAA,0xFA,0xAA,0xAA,0xAA,0xAA,0xAB,0xEB,0xAF,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBF,0xFA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
   858c8:	4e1f      	ldr	r6, [pc, #124]	; (85948 <tft_graphicCursorType+0x90>)
   858ca:	f44f 7580 	mov.w	r5, #256	; 0x100
   858ce:	eb0d 0005 	add.w	r0, sp, r5
   858d2:	4631      	mov	r1, r6
   858d4:	462a      	mov	r2, r5
   858d6:	4c1d      	ldr	r4, [pc, #116]	; (8594c <tft_graphicCursorType+0x94>)
   858d8:	47a0      	blx	r4
	uint8_t const arrow[256]   ={0xEA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xFA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCE,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC3,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0xEA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x3A,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x0E,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x03,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0xEA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0x3A,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0x0E,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0x03,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0x00,0xEA,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0x00,0x3A,0xAA,0xAA,0xAA,0xAA,0xC0,0x00,0xFF,0xFE,0xAA,0xAA,0xAA,0xAA,0xC0,0x30,0xEA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC0,0xF0,0x3A,0xAA,0xAA,0xAA,0xAA,0xAA,0xC3,0xAC,0x3A,0xAA,0xAA,0xAA,0xAA,0xAA,0xCE,0xAC,0x0E,0xAA,0xAA,0xAA,0xAA,0xAA,0xFA,0xAB,0x0E,0xAA,0xAA,0xAA,0xAA,0xAA,0xEA,0xAB,0x03,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC3,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xC3,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBF,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
   858da:	4668      	mov	r0, sp
   858dc:	1971      	adds	r1, r6, r5
   858de:	462a      	mov	r2, r5
   858e0:	47a0      	blx	r4
//	graphicCursorDisable();
	tft_writeCommand(0x41);
   858e2:	2041      	movs	r0, #65	; 0x41
   858e4:	4c1a      	ldr	r4, [pc, #104]	; (85950 <tft_graphicCursorType+0x98>)
   858e6:	47a0      	blx	r4
	tft_writeData(0x08);	//	Adresa je kurzor
   858e8:	2008      	movs	r0, #8
   858ea:	4b1a      	ldr	r3, [pc, #104]	; (85954 <tft_graphicCursorType+0x9c>)
   858ec:	4798      	blx	r3
	tft_writeCommand(0x02);	//	Memory write
   858ee:	2002      	movs	r0, #2
   858f0:	47a0      	blx	r4
	if(typ == 1)
   858f2:	2f01      	cmp	r7, #1
   858f4:	d11a      	bne.n	8592c <tft_graphicCursorType+0x74>
   858f6:	f10d 34ff 	add.w	r4, sp, #4294967295
   858fa:	f10d 06ff 	add.w	r6, sp, #255	; 0xff
		for(i = 0; i < 256; i++)
		tft_writeData(arrow[i]);
   858fe:	4d15      	ldr	r5, [pc, #84]	; (85954 <tft_graphicCursorType+0x9c>)
   85900:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   85904:	47a8      	blx	r5
//	graphicCursorDisable();
	tft_writeCommand(0x41);
	tft_writeData(0x08);	//	Adresa je kurzor
	tft_writeCommand(0x02);	//	Memory write
	if(typ == 1)
		for(i = 0; i < 256; i++)
   85906:	42b4      	cmp	r4, r6
   85908:	d1fa      	bne.n	85900 <tft_graphicCursorType+0x48>
   8590a:	e004      	b.n	85916 <tft_graphicCursorType+0x5e>
		tft_writeData(arrow[i]);
	if(typ == 2)
		for(i = 0; i < 256; i++)
			tft_writeData(target[i]);
   8590c:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   85910:	47a8      	blx	r5
	tft_writeCommand(0x02);	//	Memory write
	if(typ == 1)
		for(i = 0; i < 256; i++)
		tft_writeData(arrow[i]);
	if(typ == 2)
		for(i = 0; i < 256; i++)
   85912:	42b4      	cmp	r4, r6
   85914:	d1fa      	bne.n	8590c <tft_graphicCursorType+0x54>
			tft_writeData(target[i]);
	tft_cursor_type = typ;
   85916:	4b0b      	ldr	r3, [pc, #44]	; (85944 <tft_graphicCursorType+0x8c>)
   85918:	701f      	strb	r7, [r3, #0]
	tft_writeCommand(0x41);
   8591a:	2041      	movs	r0, #65	; 0x41
   8591c:	4b0c      	ldr	r3, [pc, #48]	; (85950 <tft_graphicCursorType+0x98>)
   8591e:	4798      	blx	r3
	tft_writeData(0x00);	//	Adresa je LAYER
   85920:	2000      	movs	r0, #0
   85922:	4b0c      	ldr	r3, [pc, #48]	; (85954 <tft_graphicCursorType+0x9c>)
   85924:	4798      	blx	r3
	tft_graphicCursorEnable();
   85926:	4b0c      	ldr	r3, [pc, #48]	; (85958 <tft_graphicCursorType+0xa0>)
   85928:	4798      	blx	r3
   8592a:	e007      	b.n	8593c <tft_graphicCursorType+0x84>
	tft_writeData(0x08);	//	Adresa je kurzor
	tft_writeCommand(0x02);	//	Memory write
	if(typ == 1)
		for(i = 0; i < 256; i++)
		tft_writeData(arrow[i]);
	if(typ == 2)
   8592c:	2f02      	cmp	r7, #2
   8592e:	d1f2      	bne.n	85916 <tft_graphicCursorType+0x5e>
   85930:	f10d 04ff 	add.w	r4, sp, #255	; 0xff
   85934:	f20d 16ff 	addw	r6, sp, #511	; 0x1ff
		for(i = 0; i < 256; i++)
			tft_writeData(target[i]);
   85938:	4d06      	ldr	r5, [pc, #24]	; (85954 <tft_graphicCursorType+0x9c>)
   8593a:	e7e7      	b.n	8590c <tft_graphicCursorType+0x54>
	tft_cursor_type = typ;
	tft_writeCommand(0x41);
	tft_writeData(0x00);	//	Adresa je LAYER
	tft_graphicCursorEnable();
}
   8593c:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
   85940:	bdf0      	pop	{r4, r5, r6, r7, pc}
   85942:	bf00      	nop
   85944:	20001482 	.word	0x20001482
   85948:	000914f8 	.word	0x000914f8
   8594c:	0008d0dd 	.word	0x0008d0dd
   85950:	000854a5 	.word	0x000854a5
   85954:	00085439 	.word	0x00085439
   85958:	000858a1 	.word	0x000858a1

0008595c <tft_graphicCursorDisable>:
{
	tft_writeCommand(0x41);
	tft_writeData(1 << 7);	//	Povolim kurzor
}
void tft_graphicCursorDisable(void)
{
   8595c:	b508      	push	{r3, lr}
	tft_writeCommand(0x41);
   8595e:	2041      	movs	r0, #65	; 0x41
   85960:	4b02      	ldr	r3, [pc, #8]	; (8596c <tft_graphicCursorDisable+0x10>)
   85962:	4798      	blx	r3
	tft_writeData(0x00);	//	Zakazem kurzor
   85964:	2000      	movs	r0, #0
   85966:	4b02      	ldr	r3, [pc, #8]	; (85970 <tft_graphicCursorDisable+0x14>)
   85968:	4798      	blx	r3
   8596a:	bd08      	pop	{r3, pc}
   8596c:	000854a5 	.word	0x000854a5
   85970:	00085439 	.word	0x00085439

00085974 <tft_graphicCursor>:
}

void tft_graphicCursor(uint16_t x, uint16_t y)
{
   85974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   85976:	4607      	mov	r7, r0
   85978:	460e      	mov	r6, r1
	if(tft_cursor_type == 2)
   8597a:	4b16      	ldr	r3, [pc, #88]	; (859d4 <tft_graphicCursor+0x60>)
   8597c:	781b      	ldrb	r3, [r3, #0]
   8597e:	2b02      	cmp	r3, #2
   85980:	d10d      	bne.n	8599e <tft_graphicCursor+0x2a>
	{
		x -= 15;
   85982:	f1a0 070f 	sub.w	r7, r0, #15
   85986:	b2bf      	uxth	r7, r7
		if(x > 20000)	//	overflow
			x = 0;
   85988:	f644 6320 	movw	r3, #20000	; 0x4e20
   8598c:	429f      	cmp	r7, r3
   8598e:	bf88      	it	hi
   85990:	2700      	movhi	r7, #0
		y -= 15;
   85992:	f1a1 060f 	sub.w	r6, r1, #15
   85996:	b2b6      	uxth	r6, r6
		if(y > 20000)	//	overflow
			y = 0;
   85998:	429e      	cmp	r6, r3
   8599a:	bf88      	it	hi
   8599c:	2600      	movhi	r6, #0
	}
	/* Set cursor location */
	tft_writeCommand(0x80);	//	X low
   8599e:	2080      	movs	r0, #128	; 0x80
   859a0:	4d0d      	ldr	r5, [pc, #52]	; (859d8 <tft_graphicCursor+0x64>)
   859a2:	47a8      	blx	r5
	tft_writeData(x & 0xFF);
   859a4:	b2f8      	uxtb	r0, r7
   859a6:	4c0d      	ldr	r4, [pc, #52]	; (859dc <tft_graphicCursor+0x68>)
   859a8:	47a0      	blx	r4
	tft_writeCommand(0x81);	//	X high
   859aa:	2081      	movs	r0, #129	; 0x81
   859ac:	47a8      	blx	r5
	tft_writeData(x >> 8);
   859ae:	0a38      	lsrs	r0, r7, #8
   859b0:	47a0      	blx	r4
	tft_writeCommand(0x82);	//	Y low
   859b2:	2082      	movs	r0, #130	; 0x82
   859b4:	47a8      	blx	r5
	tft_writeData(y & 0xFF);
   859b6:	b2f0      	uxtb	r0, r6
   859b8:	47a0      	blx	r4
	tft_writeCommand(0x83);	//	Y high
   859ba:	2083      	movs	r0, #131	; 0x83
   859bc:	47a8      	blx	r5
	tft_writeData(y >> 8);
   859be:	0a30      	lsrs	r0, r6, #8
   859c0:	47a0      	blx	r4
	tft_writeCommand(0x84);	//	farba  0 kurzoru RRRGGGBB
   859c2:	2084      	movs	r0, #132	; 0x84
   859c4:	47a8      	blx	r5
	tft_writeData(0xE0);	//	RED
   859c6:	20e0      	movs	r0, #224	; 0xe0
   859c8:	47a0      	blx	r4
	tft_writeCommand(0x85);	//	farba  1 kurzoru RRRGGGBB
   859ca:	2085      	movs	r0, #133	; 0x85
   859cc:	47a8      	blx	r5
	tft_writeData(0x07 << 2); // GREEN
   859ce:	201c      	movs	r0, #28
   859d0:	47a0      	blx	r4
   859d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   859d4:	20001482 	.word	0x20001482
   859d8:	000854a5 	.word	0x000854a5
   859dc:	00085439 	.word	0x00085439

000859e0 <tft_writeReg>:
/*!

*/
/**************************************************************************/
void  tft_writeReg(uint8_t reg, uint8_t val) 
{
   859e0:	b510      	push	{r4, lr}
   859e2:	460c      	mov	r4, r1
  tft_writeCommand(reg);
   859e4:	4b02      	ldr	r3, [pc, #8]	; (859f0 <tft_writeReg+0x10>)
   859e6:	4798      	blx	r3
  tft_writeData(val);
   859e8:	4620      	mov	r0, r4
   859ea:	4b02      	ldr	r3, [pc, #8]	; (859f4 <tft_writeReg+0x14>)
   859ec:	4798      	blx	r3
   859ee:	bd10      	pop	{r4, pc}
   859f0:	000854a5 	.word	0x000854a5
   859f4:	00085439 	.word	0x00085439

000859f8 <tft_PLLinit>:
/**************************************************************************/
/*!
      Initialise the PLL
*/
/**************************************************************************/
void tft_PLLinit(void) {
   859f8:	b538      	push	{r3, r4, r5, lr}
    tft_writeReg(RA8875_PLLC1, RA8875_PLLC1_PLLDIV1 + 10);
   859fa:	2088      	movs	r0, #136	; 0x88
   859fc:	210a      	movs	r1, #10
   859fe:	4d05      	ldr	r5, [pc, #20]	; (85a14 <tft_PLLinit+0x1c>)
   85a00:	47a8      	blx	r5
    delay_ms(1);
   85a02:	2001      	movs	r0, #1
   85a04:	4c04      	ldr	r4, [pc, #16]	; (85a18 <tft_PLLinit+0x20>)
   85a06:	47a0      	blx	r4
    tft_writeReg(RA8875_PLLC2, RA8875_PLLC2_DIV4);
   85a08:	2089      	movs	r0, #137	; 0x89
   85a0a:	2102      	movs	r1, #2
   85a0c:	47a8      	blx	r5
    delay_ms(1);
   85a0e:	2001      	movs	r0, #1
   85a10:	47a0      	blx	r4
   85a12:	bd38      	pop	{r3, r4, r5, pc}
   85a14:	000859e1 	.word	0x000859e1
   85a18:	00089689 	.word	0x00089689

00085a1c <tft_initialize>:
/**************************************************************************/
/*!
      Initialises the driver IC (clock setup, etc.)
*/
/**************************************************************************/
void tft_initialize(void) {
   85a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  tft_PLLinit();
   85a1e:	4b32      	ldr	r3, [pc, #200]	; (85ae8 <tft_initialize+0xcc>)
   85a20:	4798      	blx	r3
  tft_writeReg(RA8875_SYSR, RA8875_SYSR_16BPP | RA8875_SYSR_MCU8);
   85a22:	2010      	movs	r0, #16
   85a24:	210c      	movs	r1, #12
   85a26:	4c31      	ldr	r4, [pc, #196]	; (85aec <tft_initialize+0xd0>)
   85a28:	47a0      	blx	r4
    hsync_finetune  = 0;
    vsync_nondisp   = 32;
    vsync_start     = 23;
    vsync_pw        = 2;

  tft_writeReg(RA8875_PCSR, pixclk);
   85a2a:	2004      	movs	r0, #4
   85a2c:	2181      	movs	r1, #129	; 0x81
   85a2e:	47a0      	blx	r4
  delay_ms(1);
   85a30:	2001      	movs	r0, #1
   85a32:	4e2f      	ldr	r6, [pc, #188]	; (85af0 <tft_initialize+0xd4>)
   85a34:	47b0      	blx	r6
  
  /* Horizontal settings registers */
  tft_writeReg(RA8875_HDWR, (tft_width / 8) - 1);                          // H width: (HDWR + 1) * 8 = 480
   85a36:	4f2f      	ldr	r7, [pc, #188]	; (85af4 <tft_initialize+0xd8>)
   85a38:	8839      	ldrh	r1, [r7, #0]
   85a3a:	08c9      	lsrs	r1, r1, #3
   85a3c:	3901      	subs	r1, #1
   85a3e:	2014      	movs	r0, #20
   85a40:	b2c9      	uxtb	r1, r1
   85a42:	47a0      	blx	r4
  tft_writeReg(RA8875_HNDFTR, RA8875_HNDFTR_DE_HIGH + hsync_finetune);
   85a44:	2015      	movs	r0, #21
   85a46:	2100      	movs	r1, #0
   85a48:	47a0      	blx	r4
  tft_writeReg(RA8875_HNDR, (hsync_nondisp - hsync_finetune - 2)/8);    // H non-display: HNDR * 8 + HNDFTR + 2 = 10
   85a4a:	2016      	movs	r0, #22
   85a4c:	2103      	movs	r1, #3
   85a4e:	47a0      	blx	r4
  tft_writeReg(RA8875_HSTR, hsync_start/8 - 1);                         // Hsync start: (HSTR + 1)*8 
   85a50:	2017      	movs	r0, #23
   85a52:	2103      	movs	r1, #3
   85a54:	47a0      	blx	r4
  tft_writeReg(RA8875_HPWR, RA8875_HPWR_LOW + (hsync_pw/8 - 1));        // HSync pulse width = (HPWR+1) * 8
   85a56:	2018      	movs	r0, #24
   85a58:	210b      	movs	r1, #11
   85a5a:	47a0      	blx	r4
  
  /* Vertical settings registers */
  tft_writeReg(RA8875_VDHR0, (uint16_t)(tft_height - 1) & 0xFF);
   85a5c:	4d26      	ldr	r5, [pc, #152]	; (85af8 <tft_initialize+0xdc>)
   85a5e:	7829      	ldrb	r1, [r5, #0]
   85a60:	3901      	subs	r1, #1
   85a62:	2019      	movs	r0, #25
   85a64:	b2c9      	uxtb	r1, r1
   85a66:	47a0      	blx	r4
  tft_writeReg(RA8875_VDHR1, (uint16_t)(tft_height - 1) >> 8);
   85a68:	8829      	ldrh	r1, [r5, #0]
   85a6a:	3901      	subs	r1, #1
   85a6c:	201a      	movs	r0, #26
   85a6e:	f3c1 2107 	ubfx	r1, r1, #8, #8
   85a72:	47a0      	blx	r4
  tft_writeReg(RA8875_VNDR0, vsync_nondisp-1);                          // V non-display period = VNDR + 1
   85a74:	201b      	movs	r0, #27
   85a76:	211f      	movs	r1, #31
   85a78:	47a0      	blx	r4
  tft_writeReg(RA8875_VNDR1, vsync_nondisp >> 8);
   85a7a:	201c      	movs	r0, #28
   85a7c:	2100      	movs	r1, #0
   85a7e:	47a0      	blx	r4
  tft_writeReg(RA8875_VSTR0, vsync_start-1);                            // Vsync start position = VSTR + 1
   85a80:	201d      	movs	r0, #29
   85a82:	2116      	movs	r1, #22
   85a84:	47a0      	blx	r4
  tft_writeReg(RA8875_VSTR1, vsync_start >> 8);
   85a86:	201e      	movs	r0, #30
   85a88:	2100      	movs	r1, #0
   85a8a:	47a0      	blx	r4
  tft_writeReg(RA8875_VPWR, RA8875_VPWR_LOW + vsync_pw - 1);            // Vsync pulse width = VPWR + 1
   85a8c:	201f      	movs	r0, #31
   85a8e:	2101      	movs	r1, #1
   85a90:	47a0      	blx	r4
  
  /* Set active window X */
  tft_writeReg(RA8875_HSAW0, 0);                                        // horizontal start point
   85a92:	2030      	movs	r0, #48	; 0x30
   85a94:	2100      	movs	r1, #0
   85a96:	47a0      	blx	r4
  tft_writeReg(RA8875_HSAW1, 0);
   85a98:	2031      	movs	r0, #49	; 0x31
   85a9a:	2100      	movs	r1, #0
   85a9c:	47a0      	blx	r4
  tft_writeReg(RA8875_HEAW0, (uint16_t)(tft_width - 1) & 0xFF);            // horizontal end point
   85a9e:	7839      	ldrb	r1, [r7, #0]
   85aa0:	3901      	subs	r1, #1
   85aa2:	2034      	movs	r0, #52	; 0x34
   85aa4:	b2c9      	uxtb	r1, r1
   85aa6:	47a0      	blx	r4
  tft_writeReg(RA8875_HEAW1, (uint16_t)(tft_width - 1) >> 8);
   85aa8:	8839      	ldrh	r1, [r7, #0]
   85aaa:	3901      	subs	r1, #1
   85aac:	2035      	movs	r0, #53	; 0x35
   85aae:	f3c1 2107 	ubfx	r1, r1, #8, #8
   85ab2:	47a0      	blx	r4
  
  /* Set active window Y */
  tft_writeReg(RA8875_VSAW0, 0);                                        // vertical start point
   85ab4:	2032      	movs	r0, #50	; 0x32
   85ab6:	2100      	movs	r1, #0
   85ab8:	47a0      	blx	r4
  tft_writeReg(RA8875_VSAW1, 0);  
   85aba:	2033      	movs	r0, #51	; 0x33
   85abc:	2100      	movs	r1, #0
   85abe:	47a0      	blx	r4
  tft_writeReg(RA8875_VEAW0, (uint16_t)(tft_height - 1) & 0xFF);           // horizontal end point
   85ac0:	7829      	ldrb	r1, [r5, #0]
   85ac2:	3901      	subs	r1, #1
   85ac4:	2036      	movs	r0, #54	; 0x36
   85ac6:	b2c9      	uxtb	r1, r1
   85ac8:	47a0      	blx	r4
  tft_writeReg(RA8875_VEAW1, (uint16_t)(tft_height - 1) >> 8);
   85aca:	8829      	ldrh	r1, [r5, #0]
   85acc:	3901      	subs	r1, #1
   85ace:	2037      	movs	r0, #55	; 0x37
   85ad0:	f3c1 2107 	ubfx	r1, r1, #8, #8
   85ad4:	47a0      	blx	r4
  

  /* ToDo: Setup touch panel? */
  
  /* Clear the entire window */
  tft_writeReg(RA8875_MCLR, RA8875_MCLR_START | RA8875_MCLR_FULL);
   85ad6:	208e      	movs	r0, #142	; 0x8e
   85ad8:	2180      	movs	r1, #128	; 0x80
   85ada:	47a0      	blx	r4
  delay_ms(10); 
   85adc:	200a      	movs	r0, #10
   85ade:	47b0      	blx	r6
  tft_textEnlarge(0);
   85ae0:	2000      	movs	r0, #0
   85ae2:	4b06      	ldr	r3, [pc, #24]	; (85afc <tft_initialize+0xe0>)
   85ae4:	4798      	blx	r3
   85ae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   85ae8:	000859f9 	.word	0x000859f9
   85aec:	000859e1 	.word	0x000859e1
   85af0:	00089689 	.word	0x00089689
   85af4:	2000124e 	.word	0x2000124e
   85af8:	20001480 	.word	0x20001480
   85afc:	000855b1 	.word	0x000855b1

00085b00 <tft_GPIOX>:
/**************************************************************************/
/*!

*/
/**************************************************************************/
void tft_GPIOX(bool on) {
   85b00:	b508      	push	{r3, lr}
  if (on)
   85b02:	b120      	cbz	r0, 85b0e <tft_GPIOX+0xe>
    tft_writeReg(RA8875_GPIOX, 1);
   85b04:	20c7      	movs	r0, #199	; 0xc7
   85b06:	2101      	movs	r1, #1
   85b08:	4b03      	ldr	r3, [pc, #12]	; (85b18 <tft_GPIOX+0x18>)
   85b0a:	4798      	blx	r3
   85b0c:	bd08      	pop	{r3, pc}
  else 
    tft_writeReg(RA8875_GPIOX, 0);
   85b0e:	20c7      	movs	r0, #199	; 0xc7
   85b10:	2100      	movs	r1, #0
   85b12:	4b01      	ldr	r3, [pc, #4]	; (85b18 <tft_GPIOX+0x18>)
   85b14:	4798      	blx	r3
   85b16:	bd08      	pop	{r3, pc}
   85b18:	000859e1 	.word	0x000859e1

00085b1c <tft_PWM1out>:
/**************************************************************************/
/*!

*/
/**************************************************************************/
void tft_PWM1out(uint8_t p) {
   85b1c:	b508      	push	{r3, lr}
   85b1e:	4601      	mov	r1, r0
  tft_writeReg(RA8875_P1DCR, p);
   85b20:	208b      	movs	r0, #139	; 0x8b
   85b22:	4b01      	ldr	r3, [pc, #4]	; (85b28 <tft_PWM1out+0xc>)
   85b24:	4798      	blx	r3
   85b26:	bd08      	pop	{r3, pc}
   85b28:	000859e1 	.word	0x000859e1

00085b2c <tft_displayOn>:
/*!
      Turns the display on or off
*/
/**************************************************************************/
void tft_displayOn(bool on) 
{
   85b2c:	b508      	push	{r3, lr}
 if (on) 
   85b2e:	b120      	cbz	r0, 85b3a <tft_displayOn+0xe>
   tft_writeReg(RA8875_PWRR, RA8875_PWRR_NORMAL | RA8875_PWRR_DISPON);
   85b30:	2001      	movs	r0, #1
   85b32:	2180      	movs	r1, #128	; 0x80
   85b34:	4b03      	ldr	r3, [pc, #12]	; (85b44 <tft_displayOn+0x18>)
   85b36:	4798      	blx	r3
   85b38:	bd08      	pop	{r3, pc}
 else
   tft_writeReg(RA8875_PWRR, RA8875_PWRR_NORMAL | RA8875_PWRR_DISPOFF);
   85b3a:	2001      	movs	r0, #1
   85b3c:	2100      	movs	r1, #0
   85b3e:	4b01      	ldr	r3, [pc, #4]	; (85b44 <tft_displayOn+0x18>)
   85b40:	4798      	blx	r3
   85b42:	bd08      	pop	{r3, pc}
   85b44:	000859e1 	.word	0x000859e1

00085b48 <tft_readReg>:
/*!

*/
/**************************************************************************/
uint8_t  tft_readReg(uint8_t reg) 
{
   85b48:	b508      	push	{r3, lr}
  tft_writeCommand(reg);
   85b4a:	4b02      	ldr	r3, [pc, #8]	; (85b54 <tft_readReg+0xc>)
   85b4c:	4798      	blx	r3
  return tft_readData();
   85b4e:	4b02      	ldr	r3, [pc, #8]	; (85b58 <tft_readReg+0x10>)
   85b50:	4798      	blx	r3
}
   85b52:	bd08      	pop	{r3, pc}
   85b54:	000854a5 	.word	0x000854a5
   85b58:	00085471 	.word	0x00085471

00085b5c <tft_waitPoll>:
/**************************************************************************/
/*!
      Waits for screen to finish by polling the status!
*/
/**************************************************************************/
bool tft_waitPoll(uint8_t regname, uint8_t waitflag) {
   85b5c:	b570      	push	{r4, r5, r6, lr}
   85b5e:	4606      	mov	r6, r0
   85b60:	460d      	mov	r5, r1
  /* Wait for the command to finish */
  while (1)
  {
    uint8_t temp = tft_readReg(regname);
   85b62:	4c03      	ldr	r4, [pc, #12]	; (85b70 <tft_waitPoll+0x14>)
   85b64:	4630      	mov	r0, r6
   85b66:	47a0      	blx	r4
    if (!(temp & waitflag))
   85b68:	4228      	tst	r0, r5
   85b6a:	d1fb      	bne.n	85b64 <tft_waitPoll+0x8>
      return true;
  }  
  return false; // MEMEFIX: yeah i know, unreached! - add timeout?
}
   85b6c:	2001      	movs	r0, #1
   85b6e:	bd70      	pop	{r4, r5, r6, pc}
   85b70:	00085b49 	.word	0x00085b49

00085b74 <tft_touchEnable>:
/*!
      Enables or disables the on-chip touch screen controller
*/
/**************************************************************************/
void tft_touchEnable(bool on) 
{
   85b74:	b510      	push	{r4, lr}
  if (on) 
   85b76:	b178      	cbz	r0, 85b98 <tft_touchEnable+0x24>
  {
    /* Enable Touch Panel (Reg 0x70) */
    tft_writeReg(RA8875_TPCR0, RA8875_TPCR0_ENABLE        | 
   85b78:	2070      	movs	r0, #112	; 0x70
   85b7a:	21b2      	movs	r1, #178	; 0xb2
   85b7c:	4c0c      	ldr	r4, [pc, #48]	; (85bb0 <tft_touchEnable+0x3c>)
   85b7e:	47a0      	blx	r4
                           RA8875_TPCR0_WAIT_4096CLK  |
                           RA8875_TPCR0_WAKEDISABLE   | 
                           RA8875_TPCR0_ADCCLK_DIV4); // 10mhz max!
    /* Set Auto Mode      (Reg 0x71) */
    tft_writeReg(RA8875_TPCR1, RA8875_TPCR1_AUTO    | 
   85b80:	2071      	movs	r0, #113	; 0x71
   85b82:	2104      	movs	r1, #4
   85b84:	47a0      	blx	r4
                           // RA8875_TPCR1_VREFEXT | 
                           RA8875_TPCR1_DEBOUNCE);
    /* Enable TP INT */
    tft_writeReg(RA8875_INTC1, tft_readReg(RA8875_INTC1) | RA8875_INTC1_TP);
   85b86:	20f0      	movs	r0, #240	; 0xf0
   85b88:	4b0a      	ldr	r3, [pc, #40]	; (85bb4 <tft_touchEnable+0x40>)
   85b8a:	4798      	blx	r3
   85b8c:	f040 0104 	orr.w	r1, r0, #4
   85b90:	20f0      	movs	r0, #240	; 0xf0
   85b92:	b2c9      	uxtb	r1, r1
   85b94:	47a0      	blx	r4
   85b96:	bd10      	pop	{r4, pc}
  } 
  else
  {
    /* Disable TP INT */
    tft_writeReg(RA8875_INTC1, tft_readReg(RA8875_INTC1) & ~RA8875_INTC1_TP);
   85b98:	20f0      	movs	r0, #240	; 0xf0
   85b9a:	4b06      	ldr	r3, [pc, #24]	; (85bb4 <tft_touchEnable+0x40>)
   85b9c:	4798      	blx	r3
   85b9e:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
   85ba2:	20f0      	movs	r0, #240	; 0xf0
   85ba4:	4c02      	ldr	r4, [pc, #8]	; (85bb0 <tft_touchEnable+0x3c>)
   85ba6:	47a0      	blx	r4
    /* Disable Touch Panel (Reg 0x70) */
    tft_writeReg(RA8875_TPCR0, RA8875_TPCR0_DISABLE);
   85ba8:	2070      	movs	r0, #112	; 0x70
   85baa:	2100      	movs	r1, #0
   85bac:	47a0      	blx	r4
   85bae:	bd10      	pop	{r4, pc}
   85bb0:	000859e1 	.word	0x000859e1
   85bb4:	00085b49 	.word	0x00085b49

00085bb8 <tft_istouched>:
      @returns  True is a touch event has occured (reading it via
                touchRead() will clear the interrupt in memory)
*/
/**************************************************************************/
bool tft_istouched(void) 
{
   85bb8:	b500      	push	{lr}
   85bba:	b083      	sub	sp, #12
	volatile int touch_status;
	touch_status = tft_readReg(RA8875_INTC2) & RA8875_INTC2_TP;
   85bbc:	20f1      	movs	r0, #241	; 0xf1
   85bbe:	4b07      	ldr	r3, [pc, #28]	; (85bdc <tft_istouched+0x24>)
   85bc0:	4798      	blx	r3
   85bc2:	f000 0004 	and.w	r0, r0, #4
   85bc6:	b2c0      	uxtb	r0, r0
   85bc8:	9001      	str	r0, [sp, #4]
	if (touch_status == RA8875_INTC2_TP) return true;
   85bca:	9801      	ldr	r0, [sp, #4]
	return false;
}
   85bcc:	2804      	cmp	r0, #4
   85bce:	bf14      	ite	ne
   85bd0:	2000      	movne	r0, #0
   85bd2:	2001      	moveq	r0, #1
   85bd4:	b003      	add	sp, #12
   85bd6:	f85d fb04 	ldr.w	pc, [sp], #4
   85bda:	bf00      	nop
   85bdc:	00085b49 	.word	0x00085b49

00085be0 <tft_touchRead>:
      @note Calling this function will clear the touch panel interrupt on
            the RA8875, resetting the flag used by the 'touched' function
*/
/**************************************************************************/
bool tft_touchRead(uint16_t *x, uint16_t *y) 
{
   85be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   85be4:	4606      	mov	r6, r0
   85be6:	460d      	mov	r5, r1
  uint16_t tx, ty;
  uint8_t temp;
  
  tx = tft_readReg(RA8875_TPXH);
   85be8:	2072      	movs	r0, #114	; 0x72
   85bea:	4c0d      	ldr	r4, [pc, #52]	; (85c20 <tft_touchRead+0x40>)
   85bec:	47a0      	blx	r4
   85bee:	fa1f f880 	uxth.w	r8, r0
  ty = tft_readReg(RA8875_TPYH);
   85bf2:	2073      	movs	r0, #115	; 0x73
   85bf4:	47a0      	blx	r4
   85bf6:	b287      	uxth	r7, r0
  temp = tft_readReg(RA8875_TPXYL);
   85bf8:	2074      	movs	r0, #116	; 0x74
   85bfa:	47a0      	blx	r4
  tx <<= 2;
  ty <<= 2;
  tx |= temp & 0x03;        // get the bottom x bits
   85bfc:	f000 0303 	and.w	r3, r0, #3
   85c00:	ea43 0388 	orr.w	r3, r3, r8, lsl #2
  ty |= (temp >> 2) & 0x03; // get the bottom y bits
   85c04:	f3c0 0081 	ubfx	r0, r0, #2, #2
   85c08:	ea40 0087 	orr.w	r0, r0, r7, lsl #2

  *x = tx;
   85c0c:	8033      	strh	r3, [r6, #0]
  *y = ty;
   85c0e:	8028      	strh	r0, [r5, #0]

  /* Clear TP INT Status */
  tft_writeReg(RA8875_INTC2, RA8875_INTC2_TP);
   85c10:	20f1      	movs	r0, #241	; 0xf1
   85c12:	2104      	movs	r1, #4
   85c14:	4b03      	ldr	r3, [pc, #12]	; (85c24 <tft_touchRead+0x44>)
   85c16:	4798      	blx	r3

  return true;
}
   85c18:	2001      	movs	r0, #1
   85c1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   85c1e:	bf00      	nop
   85c20:	00085b49 	.word	0x00085b49
   85c24:	000859e1 	.word	0x000859e1

00085c28 <tft_circleHelper>:
/*!
      Helper function for higher level circle drawing code
*/
/**************************************************************************/
void tft_circleHelper(int16_t x0, int16_t y0, int16_t r, uint16_t color, bool filled)
{
   85c28:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   85c2c:	4680      	mov	r8, r0
   85c2e:	460f      	mov	r7, r1
   85c30:	4691      	mov	r9, r2
   85c32:	461e      	mov	r6, r3
  /* Set X */
  tft_writeCommand(0x99);
   85c34:	2099      	movs	r0, #153	; 0x99
   85c36:	4c1c      	ldr	r4, [pc, #112]	; (85ca8 <tft_circleHelper+0x80>)
   85c38:	47a0      	blx	r4
  tft_writeData(x0);
   85c3a:	fa5f f088 	uxtb.w	r0, r8
   85c3e:	4d1b      	ldr	r5, [pc, #108]	; (85cac <tft_circleHelper+0x84>)
   85c40:	47a8      	blx	r5
  tft_writeCommand(0x9a);
   85c42:	209a      	movs	r0, #154	; 0x9a
   85c44:	47a0      	blx	r4
  tft_writeData(x0 >> 8);
   85c46:	f3c8 2007 	ubfx	r0, r8, #8, #8
   85c4a:	47a8      	blx	r5
  
  /* Set Y */
  tft_writeCommand(0x9b);
   85c4c:	209b      	movs	r0, #155	; 0x9b
   85c4e:	47a0      	blx	r4
  tft_writeData(y0); 
   85c50:	b2f8      	uxtb	r0, r7
   85c52:	47a8      	blx	r5
  tft_writeCommand(0x9c);	   
   85c54:	209c      	movs	r0, #156	; 0x9c
   85c56:	47a0      	blx	r4
  tft_writeData(y0 >> 8);
   85c58:	f3c7 2007 	ubfx	r0, r7, #8, #8
   85c5c:	47a8      	blx	r5
  
  /* Set Radius */
  tft_writeCommand(0x9d);
   85c5e:	209d      	movs	r0, #157	; 0x9d
   85c60:	47a0      	blx	r4
  tft_writeData(r);  
   85c62:	fa5f f089 	uxtb.w	r0, r9
   85c66:	47a8      	blx	r5
  
  /* Set Color */
  tft_writeCommand(0x63);
   85c68:	2063      	movs	r0, #99	; 0x63
   85c6a:	47a0      	blx	r4
  tft_writeData((color & 0xf800) >> 11);
   85c6c:	0af0      	lsrs	r0, r6, #11
   85c6e:	47a8      	blx	r5
  tft_writeCommand(0x64);
   85c70:	2064      	movs	r0, #100	; 0x64
   85c72:	47a0      	blx	r4
  tft_writeData((color & 0x07e0) >> 5);
   85c74:	f3c6 1045 	ubfx	r0, r6, #5, #6
   85c78:	47a8      	blx	r5
  tft_writeCommand(0x65);
   85c7a:	2065      	movs	r0, #101	; 0x65
   85c7c:	47a0      	blx	r4
  tft_writeData((color & 0x001f));
   85c7e:	f006 001f 	and.w	r0, r6, #31
   85c82:	47a8      	blx	r5
  
  /* Draw! */
  tft_writeCommand(RA8875_DCR);
   85c84:	2090      	movs	r0, #144	; 0x90
   85c86:	47a0      	blx	r4
  if (filled)
   85c88:	f89d 3020 	ldrb.w	r3, [sp, #32]
   85c8c:	b113      	cbz	r3, 85c94 <tft_circleHelper+0x6c>
  {
    tft_writeData(RA8875_DCR_CIRCLE_START | RA8875_DCR_FILL);
   85c8e:	2060      	movs	r0, #96	; 0x60
   85c90:	47a8      	blx	r5
   85c92:	e002      	b.n	85c9a <tft_circleHelper+0x72>
  }
  else
  {
    tft_writeData(RA8875_DCR_CIRCLE_START | RA8875_DCR_NOFILL);
   85c94:	2040      	movs	r0, #64	; 0x40
   85c96:	4b05      	ldr	r3, [pc, #20]	; (85cac <tft_circleHelper+0x84>)
   85c98:	4798      	blx	r3
  }
  
  /* Wait for the command to finish */
  tft_waitPoll(RA8875_DCR, RA8875_DCR_CIRCLE_STATUS);
   85c9a:	2090      	movs	r0, #144	; 0x90
   85c9c:	2140      	movs	r1, #64	; 0x40
   85c9e:	4b04      	ldr	r3, [pc, #16]	; (85cb0 <tft_circleHelper+0x88>)
   85ca0:	4798      	blx	r3
   85ca2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   85ca6:	bf00      	nop
   85ca8:	000854a5 	.word	0x000854a5
   85cac:	00085439 	.word	0x00085439
   85cb0:	00085b5d 	.word	0x00085b5d

00085cb4 <tft_drawCircle>:
      @args w[in]     The circle's radius
      @args color[in] The RGB565 color to use when drawing the pixel
*/
/**************************************************************************/
void tft_drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color)
{
   85cb4:	b510      	push	{r4, lr}
   85cb6:	b082      	sub	sp, #8
  tft_circleHelper(x0, y0, r, color, false);
   85cb8:	2400      	movs	r4, #0
   85cba:	9400      	str	r4, [sp, #0]
   85cbc:	4c01      	ldr	r4, [pc, #4]	; (85cc4 <tft_drawCircle+0x10>)
   85cbe:	47a0      	blx	r4
}
   85cc0:	b002      	add	sp, #8
   85cc2:	bd10      	pop	{r4, pc}
   85cc4:	00085c29 	.word	0x00085c29

00085cc8 <tft_rectHelperRound>:
{
	tft_rectHelper(x,y,w,h,color,filled,false);
}*/

void tft_rectHelperRound(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color, bool filled, uint8_t radius)
{
   85cc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   85ccc:	b083      	sub	sp, #12
   85cce:	4682      	mov	sl, r0
   85cd0:	4689      	mov	r9, r1
   85cd2:	4690      	mov	r8, r2
   85cd4:	9301      	str	r3, [sp, #4]
   85cd6:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
   85cda:	f89d b034 	ldrb.w	fp, [sp, #52]	; 0x34
   85cde:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	tft_graphicsMode();
   85ce2:	4b3a      	ldr	r3, [pc, #232]	; (85dcc <tft_rectHelperRound+0x104>)
   85ce4:	4798      	blx	r3
	/* Set X */
	tft_writeCommand(0x91);
   85ce6:	2091      	movs	r0, #145	; 0x91
   85ce8:	4d39      	ldr	r5, [pc, #228]	; (85dd0 <tft_rectHelperRound+0x108>)
   85cea:	47a8      	blx	r5
	tft_writeData(x);
   85cec:	fa5f f08a 	uxtb.w	r0, sl
   85cf0:	4c38      	ldr	r4, [pc, #224]	; (85dd4 <tft_rectHelperRound+0x10c>)
   85cf2:	47a0      	blx	r4
	tft_writeCommand(0x92);
   85cf4:	2092      	movs	r0, #146	; 0x92
   85cf6:	47a8      	blx	r5
	tft_writeData(x >> 8);
   85cf8:	f3ca 2007 	ubfx	r0, sl, #8, #8
   85cfc:	47a0      	blx	r4
	
	/* Set Y */
	tft_writeCommand(0x93);
   85cfe:	2093      	movs	r0, #147	; 0x93
   85d00:	47a8      	blx	r5
	tft_writeData(y);
   85d02:	fa5f f089 	uxtb.w	r0, r9
   85d06:	47a0      	blx	r4
	tft_writeCommand(0x94);
   85d08:	2094      	movs	r0, #148	; 0x94
   85d0a:	47a8      	blx	r5
	tft_writeData(y >> 8);
   85d0c:	f3c9 2007 	ubfx	r0, r9, #8, #8
   85d10:	47a0      	blx	r4
	
	/* Set X1 */
	tft_writeCommand(0x95);
   85d12:	2095      	movs	r0, #149	; 0x95
   85d14:	47a8      	blx	r5
	tft_writeData(w);
   85d16:	fa5f f088 	uxtb.w	r0, r8
   85d1a:	47a0      	blx	r4
	tft_writeCommand(0x96);
   85d1c:	2096      	movs	r0, #150	; 0x96
   85d1e:	47a8      	blx	r5
	tft_writeData((w) >> 8);
   85d20:	f3c8 2007 	ubfx	r0, r8, #8, #8
   85d24:	47a0      	blx	r4
	
	/* Set Y1 */
	tft_writeCommand(0x97);
   85d26:	2097      	movs	r0, #151	; 0x97
   85d28:	47a8      	blx	r5
	tft_writeData(h);
   85d2a:	f8dd 8004 	ldr.w	r8, [sp, #4]
   85d2e:	fa5f f088 	uxtb.w	r0, r8
   85d32:	47a0      	blx	r4
	tft_writeCommand(0x98);
   85d34:	2098      	movs	r0, #152	; 0x98
   85d36:	47a8      	blx	r5
	tft_writeData((h) >> 8);
   85d38:	f3c8 2007 	ubfx	r0, r8, #8, #8
   85d3c:	47a0      	blx	r4
	/* Set Color */
	tft_writeCommand(0x63);
   85d3e:	2063      	movs	r0, #99	; 0x63
   85d40:	47a8      	blx	r5
	tft_writeData((color & 0xf800) >> 11);
   85d42:	0af0      	lsrs	r0, r6, #11
   85d44:	47a0      	blx	r4
	tft_writeCommand(0x64);
   85d46:	2064      	movs	r0, #100	; 0x64
   85d48:	47a8      	blx	r5
	tft_writeData((color & 0x07e0) >> 5);
   85d4a:	f3c6 1045 	ubfx	r0, r6, #5, #6
   85d4e:	47a0      	blx	r4
	tft_writeCommand(0x65);
   85d50:	2065      	movs	r0, #101	; 0x65
   85d52:	47a8      	blx	r5
	tft_writeData((color & 0x001f));
   85d54:	f006 001f 	and.w	r0, r6, #31
   85d58:	47a0      	blx	r4

	/* Draw! */
	if(radius)
   85d5a:	b317      	cbz	r7, 85da2 <tft_rectHelperRound+0xda>
	{
		//	Set radius
		tft_writeCommand(0xA1);
   85d5c:	20a1      	movs	r0, #161	; 0xa1
   85d5e:	462c      	mov	r4, r5
   85d60:	47a8      	blx	r5
		tft_writeData(radius);
   85d62:	4638      	mov	r0, r7
   85d64:	4d1b      	ldr	r5, [pc, #108]	; (85dd4 <tft_rectHelperRound+0x10c>)
   85d66:	47a8      	blx	r5
		tft_writeCommand(0xA2);
   85d68:	20a2      	movs	r0, #162	; 0xa2
   85d6a:	47a0      	blx	r4
		tft_writeData(radius >> 8);
   85d6c:	2600      	movs	r6, #0
   85d6e:	4630      	mov	r0, r6
   85d70:	47a8      	blx	r5
		tft_writeCommand(0xA3);
   85d72:	20a3      	movs	r0, #163	; 0xa3
   85d74:	47a0      	blx	r4
		tft_writeData(radius);
   85d76:	4638      	mov	r0, r7
   85d78:	47a8      	blx	r5
		tft_writeCommand(0xA4);
   85d7a:	20a4      	movs	r0, #164	; 0xa4
   85d7c:	47a0      	blx	r4
		tft_writeData(radius >> 8);
   85d7e:	4630      	mov	r0, r6
   85d80:	47a8      	blx	r5
		tft_writeCommand(RA8875_ELLIPSE);
   85d82:	20a0      	movs	r0, #160	; 0xa0
   85d84:	47a0      	blx	r4
		if (filled)
   85d86:	f1bb 0f00 	cmp.w	fp, #0
   85d8a:	d002      	beq.n	85d92 <tft_rectHelperRound+0xca>
			tft_writeData(0xE0);
   85d8c:	20e0      	movs	r0, #224	; 0xe0
   85d8e:	47a8      	blx	r5
   85d90:	e002      	b.n	85d98 <tft_rectHelperRound+0xd0>
		else
			tft_writeData(0xA0);
   85d92:	20a0      	movs	r0, #160	; 0xa0
   85d94:	4b0f      	ldr	r3, [pc, #60]	; (85dd4 <tft_rectHelperRound+0x10c>)
   85d96:	4798      	blx	r3
		tft_waitPoll(RA8875_ELLIPSE, RA8875_ELLIPSE_STATUS);
   85d98:	20a0      	movs	r0, #160	; 0xa0
   85d9a:	2180      	movs	r1, #128	; 0x80
   85d9c:	4b0e      	ldr	r3, [pc, #56]	; (85dd8 <tft_rectHelperRound+0x110>)
   85d9e:	4798      	blx	r3
   85da0:	e010      	b.n	85dc4 <tft_rectHelperRound+0xfc>
	}else
	{
		tft_writeCommand(RA8875_DCR);
   85da2:	2090      	movs	r0, #144	; 0x90
   85da4:	4b0a      	ldr	r3, [pc, #40]	; (85dd0 <tft_rectHelperRound+0x108>)
   85da6:	4798      	blx	r3
		if (filled)
   85da8:	f1bb 0f00 	cmp.w	fp, #0
   85dac:	d003      	beq.n	85db6 <tft_rectHelperRound+0xee>
			tft_writeData(0xB0);
   85dae:	20b0      	movs	r0, #176	; 0xb0
   85db0:	4b08      	ldr	r3, [pc, #32]	; (85dd4 <tft_rectHelperRound+0x10c>)
   85db2:	4798      	blx	r3
   85db4:	e002      	b.n	85dbc <tft_rectHelperRound+0xf4>
		else
			tft_writeData(0x90);
   85db6:	2090      	movs	r0, #144	; 0x90
   85db8:	4b06      	ldr	r3, [pc, #24]	; (85dd4 <tft_rectHelperRound+0x10c>)
   85dba:	4798      	blx	r3
		tft_waitPoll(RA8875_DCR, RA8875_DCR_LINESQUTRI_STATUS);
   85dbc:	2090      	movs	r0, #144	; 0x90
   85dbe:	2180      	movs	r1, #128	; 0x80
   85dc0:	4b05      	ldr	r3, [pc, #20]	; (85dd8 <tft_rectHelperRound+0x110>)
   85dc2:	4798      	blx	r3
	}
	
	/* Wait for the command to finish */
	  /* Wait for the command to finish */
}
   85dc4:	b003      	add	sp, #12
   85dc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   85dca:	bf00      	nop
   85dcc:	00085875 	.word	0x00085875
   85dd0:	000854a5 	.word	0x000854a5
   85dd4:	00085439 	.word	0x00085439
   85dd8:	00085b5d 	.word	0x00085b5d

00085ddc <tft_fillRect>:
      @args h[in]     The rectangle height
      @args color[in] The RGB565 color to use when drawing the pixel
*/
/**************************************************************************/
void tft_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)
{
   85ddc:	b510      	push	{r4, lr}
   85dde:	b084      	sub	sp, #16
	tft_rectHelperRound(x, y, x+w, y+h, color, true,0);
   85de0:	4402      	add	r2, r0
   85de2:	440b      	add	r3, r1
   85de4:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   85de8:	9400      	str	r4, [sp, #0]
   85dea:	2401      	movs	r4, #1
   85dec:	9401      	str	r4, [sp, #4]
   85dee:	2400      	movs	r4, #0
   85df0:	9402      	str	r4, [sp, #8]
   85df2:	b212      	sxth	r2, r2
   85df4:	b21b      	sxth	r3, r3
   85df6:	4c02      	ldr	r4, [pc, #8]	; (85e00 <tft_fillRect+0x24>)
   85df8:	47a0      	blx	r4
}
   85dfa:	b004      	add	sp, #16
   85dfc:	bd10      	pop	{r4, pc}
   85dfe:	bf00      	nop
   85e00:	00085cc9 	.word	0x00085cc9

00085e04 <tft_fillRectRound>:
void tft_fillRectRound(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color,uint8_t radius)
{
   85e04:	b510      	push	{r4, lr}
   85e06:	b084      	sub	sp, #16
	tft_rectHelperRound(x, y, x+w, y+h, color, true,radius);
   85e08:	4402      	add	r2, r0
   85e0a:	440b      	add	r3, r1
   85e0c:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   85e10:	9400      	str	r4, [sp, #0]
   85e12:	2401      	movs	r4, #1
   85e14:	9401      	str	r4, [sp, #4]
   85e16:	f89d 401c 	ldrb.w	r4, [sp, #28]
   85e1a:	9402      	str	r4, [sp, #8]
   85e1c:	b212      	sxth	r2, r2
   85e1e:	b21b      	sxth	r3, r3
   85e20:	4c01      	ldr	r4, [pc, #4]	; (85e28 <tft_fillRectRound+0x24>)
   85e22:	47a0      	blx	r4
}
   85e24:	b004      	add	sp, #16
   85e26:	bd10      	pop	{r4, pc}
   85e28:	00085cc9 	.word	0x00085cc9

00085e2c <tft_fillScreen>:

      @args color[in] The RGB565 color to use when drawing the pixel
*/
/**************************************************************************/
void tft_fillScreen(uint16_t color)
{  
   85e2c:	b510      	push	{r4, lr}
   85e2e:	b084      	sub	sp, #16
  tft_rectHelperRound(0, 0, tft_width-1, tft_height-1, color, true,0);
   85e30:	4b0a      	ldr	r3, [pc, #40]	; (85e5c <tft_fillScreen+0x30>)
   85e32:	881a      	ldrh	r2, [r3, #0]
   85e34:	3a01      	subs	r2, #1
   85e36:	4b0a      	ldr	r3, [pc, #40]	; (85e60 <tft_fillScreen+0x34>)
   85e38:	881b      	ldrh	r3, [r3, #0]
   85e3a:	3b01      	subs	r3, #1
   85e3c:	9000      	str	r0, [sp, #0]
   85e3e:	2101      	movs	r1, #1
   85e40:	9101      	str	r1, [sp, #4]
   85e42:	2100      	movs	r1, #0
   85e44:	9102      	str	r1, [sp, #8]
   85e46:	4608      	mov	r0, r1
   85e48:	b212      	sxth	r2, r2
   85e4a:	b21b      	sxth	r3, r3
   85e4c:	4c05      	ldr	r4, [pc, #20]	; (85e64 <tft_fillScreen+0x38>)
   85e4e:	47a0      	blx	r4
  delay_ms(10);	//	Pockam kym prekresli celu obrazovku
   85e50:	200a      	movs	r0, #10
   85e52:	4b05      	ldr	r3, [pc, #20]	; (85e68 <tft_fillScreen+0x3c>)
   85e54:	4798      	blx	r3
}
   85e56:	b004      	add	sp, #16
   85e58:	bd10      	pop	{r4, pc}
   85e5a:	bf00      	nop
   85e5c:	2000124e 	.word	0x2000124e
   85e60:	20001480 	.word	0x20001480
   85e64:	00085cc9 	.word	0x00085cc9
   85e68:	00089689 	.word	0x00089689

00085e6c <tft_triangleHelper>:
/*!
      Helper function for higher level triangle drawing code
*/
/**************************************************************************/
void tft_triangleHelper(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color, bool filled)
{
   85e6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   85e70:	b083      	sub	sp, #12
   85e72:	4683      	mov	fp, r0
   85e74:	468a      	mov	sl, r1
   85e76:	4691      	mov	r9, r2
   85e78:	9301      	str	r3, [sp, #4]
   85e7a:	f9bd 8030 	ldrsh.w	r8, [sp, #48]	; 0x30
   85e7e:	f9bd 7034 	ldrsh.w	r7, [sp, #52]	; 0x34
   85e82:	f8bd 6038 	ldrh.w	r6, [sp, #56]	; 0x38
  /* Set Point 0 */
  tft_writeCommand(0x91);
   85e86:	2091      	movs	r0, #145	; 0x91
   85e88:	4c2e      	ldr	r4, [pc, #184]	; (85f44 <tft_triangleHelper+0xd8>)
   85e8a:	47a0      	blx	r4
  tft_writeData(x0);
   85e8c:	fa5f f08b 	uxtb.w	r0, fp
   85e90:	4d2d      	ldr	r5, [pc, #180]	; (85f48 <tft_triangleHelper+0xdc>)
   85e92:	47a8      	blx	r5
  tft_writeCommand(0x92);
   85e94:	2092      	movs	r0, #146	; 0x92
   85e96:	47a0      	blx	r4
  tft_writeData(x0 >> 8);
   85e98:	f3cb 2007 	ubfx	r0, fp, #8, #8
   85e9c:	47a8      	blx	r5
  tft_writeCommand(0x93);
   85e9e:	2093      	movs	r0, #147	; 0x93
   85ea0:	47a0      	blx	r4
  tft_writeData(y0); 
   85ea2:	fa5f f08a 	uxtb.w	r0, sl
   85ea6:	47a8      	blx	r5
  tft_writeCommand(0x94);
   85ea8:	2094      	movs	r0, #148	; 0x94
   85eaa:	47a0      	blx	r4
  tft_writeData(y0 >> 8);
   85eac:	f3ca 2007 	ubfx	r0, sl, #8, #8
   85eb0:	47a8      	blx	r5

  /* Set Point 1 */
  tft_writeCommand(0x95);
   85eb2:	2095      	movs	r0, #149	; 0x95
   85eb4:	47a0      	blx	r4
  tft_writeData(x1);
   85eb6:	fa5f f089 	uxtb.w	r0, r9
   85eba:	47a8      	blx	r5
  tft_writeCommand(0x96);
   85ebc:	2096      	movs	r0, #150	; 0x96
   85ebe:	47a0      	blx	r4
  tft_writeData(x1 >> 8);
   85ec0:	f3c9 2007 	ubfx	r0, r9, #8, #8
   85ec4:	47a8      	blx	r5
  tft_writeCommand(0x97);
   85ec6:	2097      	movs	r0, #151	; 0x97
   85ec8:	47a0      	blx	r4
  tft_writeData(y1); 
   85eca:	f8dd 9004 	ldr.w	r9, [sp, #4]
   85ece:	fa5f f089 	uxtb.w	r0, r9
   85ed2:	47a8      	blx	r5
  tft_writeCommand(0x98);
   85ed4:	2098      	movs	r0, #152	; 0x98
   85ed6:	47a0      	blx	r4
  tft_writeData(y1 >> 8);
   85ed8:	f3c9 2007 	ubfx	r0, r9, #8, #8
   85edc:	47a8      	blx	r5

  /* Set Point 2 */
  tft_writeCommand(0xA9);
   85ede:	20a9      	movs	r0, #169	; 0xa9
   85ee0:	47a0      	blx	r4
  tft_writeData(x2);
   85ee2:	fa5f f088 	uxtb.w	r0, r8
   85ee6:	47a8      	blx	r5
  tft_writeCommand(0xAA);
   85ee8:	20aa      	movs	r0, #170	; 0xaa
   85eea:	47a0      	blx	r4
  tft_writeData(x2 >> 8);
   85eec:	f3c8 2007 	ubfx	r0, r8, #8, #8
   85ef0:	47a8      	blx	r5
  tft_writeCommand(0xAB);
   85ef2:	20ab      	movs	r0, #171	; 0xab
   85ef4:	47a0      	blx	r4
  tft_writeData(y2); 
   85ef6:	b2f8      	uxtb	r0, r7
   85ef8:	47a8      	blx	r5
  tft_writeCommand(0xAC);
   85efa:	20ac      	movs	r0, #172	; 0xac
   85efc:	47a0      	blx	r4
  tft_writeData(y2 >> 8);
   85efe:	f3c7 2007 	ubfx	r0, r7, #8, #8
   85f02:	47a8      	blx	r5
  
  /* Set Color */
  tft_writeCommand(0x63);
   85f04:	2063      	movs	r0, #99	; 0x63
   85f06:	47a0      	blx	r4
  tft_writeData((color & 0xf800) >> 11);
   85f08:	0af0      	lsrs	r0, r6, #11
   85f0a:	47a8      	blx	r5
  tft_writeCommand(0x64);
   85f0c:	2064      	movs	r0, #100	; 0x64
   85f0e:	47a0      	blx	r4
  tft_writeData((color & 0x07e0) >> 5);
   85f10:	f3c6 1045 	ubfx	r0, r6, #5, #6
   85f14:	47a8      	blx	r5
  tft_writeCommand(0x65);
   85f16:	2065      	movs	r0, #101	; 0x65
   85f18:	47a0      	blx	r4
  tft_writeData((color & 0x001f));
   85f1a:	f006 001f 	and.w	r0, r6, #31
   85f1e:	47a8      	blx	r5
  
  /* Draw! */
  tft_writeCommand(RA8875_DCR);
   85f20:	2090      	movs	r0, #144	; 0x90
   85f22:	47a0      	blx	r4
  if (filled)
   85f24:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
   85f28:	b113      	cbz	r3, 85f30 <tft_triangleHelper+0xc4>
  {
    tft_writeData(0xA1);
   85f2a:	20a1      	movs	r0, #161	; 0xa1
   85f2c:	47a8      	blx	r5
   85f2e:	e002      	b.n	85f36 <tft_triangleHelper+0xca>
  }
  else
  {
    tft_writeData(0x81);
   85f30:	2081      	movs	r0, #129	; 0x81
   85f32:	4b05      	ldr	r3, [pc, #20]	; (85f48 <tft_triangleHelper+0xdc>)
   85f34:	4798      	blx	r3
  }
  
  /* Wait for the command to finish */
  tft_waitPoll(RA8875_DCR, RA8875_DCR_LINESQUTRI_STATUS);
   85f36:	2090      	movs	r0, #144	; 0x90
   85f38:	2180      	movs	r1, #128	; 0x80
   85f3a:	4b04      	ldr	r3, [pc, #16]	; (85f4c <tft_triangleHelper+0xe0>)
   85f3c:	4798      	blx	r3
}
   85f3e:	b003      	add	sp, #12
   85f40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   85f44:	000854a5 	.word	0x000854a5
   85f48:	00085439 	.word	0x00085439
   85f4c:	00085b5d 	.word	0x00085b5d

00085f50 <tft_fillTriangle>:
      @args y2[in]    The 0-based y location of point 2 on the triangle
      @args color[in] The RGB565 color to use when drawing the pixel
*/
/**************************************************************************/
void tft_fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color)
{
   85f50:	b510      	push	{r4, lr}
   85f52:	b084      	sub	sp, #16
  tft_triangleHelper(x0, y0, x1, y1, x2, y2, color, true);
   85f54:	f9bd 4018 	ldrsh.w	r4, [sp, #24]
   85f58:	9400      	str	r4, [sp, #0]
   85f5a:	f9bd 401c 	ldrsh.w	r4, [sp, #28]
   85f5e:	9401      	str	r4, [sp, #4]
   85f60:	f8bd 4020 	ldrh.w	r4, [sp, #32]
   85f64:	9402      	str	r4, [sp, #8]
   85f66:	2401      	movs	r4, #1
   85f68:	9403      	str	r4, [sp, #12]
   85f6a:	4c02      	ldr	r4, [pc, #8]	; (85f74 <tft_fillTriangle+0x24>)
   85f6c:	47a0      	blx	r4
}
   85f6e:	b004      	add	sp, #16
   85f70:	bd10      	pop	{r4, pc}
   85f72:	bf00      	nop
   85f74:	00085e6d 	.word	0x00085e6d

00085f78 <tft_caption_draw>:
	uint8_t x = LCD_SPIWrite(0x0);
	lcd_spi_cs_high();
	return x;
}
void tft_caption_draw(unsigned char handle)
{
   85f78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   85f7c:	b085      	sub	sp, #20
#define TRIANGLE_SIZE 15	
#define CIRCLE_SIZE 30
	TGraphics *p;
	p = Gall;
   85f7e:	4b8e      	ldr	r3, [pc, #568]	; (861b8 <tft_caption_draw+0x240>)
   85f80:	681c      	ldr	r4, [r3, #0]
	int center_x,center_y;
	do
	{
		if(p->handle == handle)
   85f82:	7c23      	ldrb	r3, [r4, #16]
   85f84:	4283      	cmp	r3, r0
   85f86:	f040 810f 	bne.w	861a8 <tft_caption_draw+0x230>
		{
//			SetColor(p->BackColor);
//			fillRect(p->Rect.x,p->Rect.y,p->Rect.width,p->Rect.height,p->BackColor);
			tft_textMode();
   85f8a:	4b8c      	ldr	r3, [pc, #560]	; (861bc <tft_caption_draw+0x244>)
   85f8c:	4798      	blx	r3
			tft_textEnlarge(1);
   85f8e:	2001      	movs	r0, #1
   85f90:	4b8b      	ldr	r3, [pc, #556]	; (861c0 <tft_caption_draw+0x248>)
   85f92:	4798      	blx	r3
//			textTransparent(p->BackColor);
			tft_textColor(p->Color,p->BackColor);
   85f94:	8b20      	ldrh	r0, [r4, #24]
   85f96:	8aa1      	ldrh	r1, [r4, #20]
   85f98:	4b8a      	ldr	r3, [pc, #552]	; (861c4 <tft_caption_draw+0x24c>)
   85f9a:	4798      	blx	r3
			if(p->type == 1)
   85f9c:	7c63      	ldrb	r3, [r4, #17]
   85f9e:	2b01      	cmp	r3, #1
   85fa0:	f040 80dc 	bne.w	8615c <tft_caption_draw+0x1e4>
			{
				center_x = p->Rect.x + p->Rect.width / 2;
   85fa4:	f8d4 b000 	ldr.w	fp, [r4]
   85fa8:	f8d4 8008 	ldr.w	r8, [r4, #8]
   85fac:	eb0b 0658 	add.w	r6, fp, r8, lsr #1
				center_y = p->Rect.y + p->Rect.height / 2;
   85fb0:	f8d4 a004 	ldr.w	sl, [r4, #4]
   85fb4:	f8d4 900c 	ldr.w	r9, [r4, #12]
   85fb8:	eb0a 0559 	add.w	r5, sl, r9, lsr #1
				if(!strncmp(p->text,"~DOWN",5))
   85fbc:	6a27      	ldr	r7, [r4, #32]
   85fbe:	4638      	mov	r0, r7
   85fc0:	4981      	ldr	r1, [pc, #516]	; (861c8 <tft_caption_draw+0x250>)
   85fc2:	2205      	movs	r2, #5
   85fc4:	4b81      	ldr	r3, [pc, #516]	; (861cc <tft_caption_draw+0x254>)
   85fc6:	4798      	blx	r3
   85fc8:	b9a0      	cbnz	r0, 85ff4 <tft_caption_draw+0x7c>
					tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x,center_y+TRIANGLE_SIZE,RA8875_BLACK);
   85fca:	b2b2      	uxth	r2, r6
   85fcc:	b2ad      	uxth	r5, r5
   85fce:	f1a5 030f 	sub.w	r3, r5, #15
   85fd2:	f1a2 000f 	sub.w	r0, r2, #15
   85fd6:	b21b      	sxth	r3, r3
   85fd8:	320f      	adds	r2, #15
   85fda:	b236      	sxth	r6, r6
   85fdc:	9600      	str	r6, [sp, #0]
   85fde:	350f      	adds	r5, #15
   85fe0:	b229      	sxth	r1, r5
   85fe2:	9101      	str	r1, [sp, #4]
   85fe4:	2100      	movs	r1, #0
   85fe6:	9102      	str	r1, [sp, #8]
   85fe8:	b200      	sxth	r0, r0
   85fea:	4619      	mov	r1, r3
   85fec:	b212      	sxth	r2, r2
   85fee:	4d78      	ldr	r5, [pc, #480]	; (861d0 <tft_caption_draw+0x258>)
   85ff0:	47a8      	blx	r5
   85ff2:	e0b3      	b.n	8615c <tft_caption_draw+0x1e4>
				else if(!strncmp(p->text,"~UP",3))
   85ff4:	4638      	mov	r0, r7
   85ff6:	4977      	ldr	r1, [pc, #476]	; (861d4 <tft_caption_draw+0x25c>)
   85ff8:	2203      	movs	r2, #3
   85ffa:	4b74      	ldr	r3, [pc, #464]	; (861cc <tft_caption_draw+0x254>)
   85ffc:	4798      	blx	r3
   85ffe:	b9a0      	cbnz	r0, 8602a <tft_caption_draw+0xb2>
					tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x,center_y-TRIANGLE_SIZE,RA8875_BLACK);
   86000:	b2b2      	uxth	r2, r6
   86002:	b2ad      	uxth	r5, r5
   86004:	f105 030f 	add.w	r3, r5, #15
   86008:	f1a2 000f 	sub.w	r0, r2, #15
   8600c:	b21b      	sxth	r3, r3
   8600e:	320f      	adds	r2, #15
   86010:	b236      	sxth	r6, r6
   86012:	9600      	str	r6, [sp, #0]
   86014:	3d0f      	subs	r5, #15
   86016:	b229      	sxth	r1, r5
   86018:	9101      	str	r1, [sp, #4]
   8601a:	2100      	movs	r1, #0
   8601c:	9102      	str	r1, [sp, #8]
   8601e:	b200      	sxth	r0, r0
   86020:	4619      	mov	r1, r3
   86022:	b212      	sxth	r2, r2
   86024:	4d6a      	ldr	r5, [pc, #424]	; (861d0 <tft_caption_draw+0x258>)
   86026:	47a8      	blx	r5
   86028:	e098      	b.n	8615c <tft_caption_draw+0x1e4>
				else if(!strncmp(p->text,"~RIGHT",6))
   8602a:	4638      	mov	r0, r7
   8602c:	496a      	ldr	r1, [pc, #424]	; (861d8 <tft_caption_draw+0x260>)
   8602e:	2206      	movs	r2, #6
   86030:	4b66      	ldr	r3, [pc, #408]	; (861cc <tft_caption_draw+0x254>)
   86032:	4798      	blx	r3
   86034:	b9a0      	cbnz	r0, 86060 <tft_caption_draw+0xe8>
					tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x-TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x + TRIANGLE_SIZE ,center_y,RA8875_BLACK);
   86036:	b2ab      	uxth	r3, r5
   86038:	b2b6      	uxth	r6, r6
   8603a:	f1a6 020f 	sub.w	r2, r6, #15
   8603e:	b212      	sxth	r2, r2
   86040:	f1a3 010f 	sub.w	r1, r3, #15
   86044:	330f      	adds	r3, #15
   86046:	360f      	adds	r6, #15
   86048:	b230      	sxth	r0, r6
   8604a:	9000      	str	r0, [sp, #0]
   8604c:	b22d      	sxth	r5, r5
   8604e:	9501      	str	r5, [sp, #4]
   86050:	2000      	movs	r0, #0
   86052:	9002      	str	r0, [sp, #8]
   86054:	4610      	mov	r0, r2
   86056:	b209      	sxth	r1, r1
   86058:	b21b      	sxth	r3, r3
   8605a:	4d5d      	ldr	r5, [pc, #372]	; (861d0 <tft_caption_draw+0x258>)
   8605c:	47a8      	blx	r5
   8605e:	e07d      	b.n	8615c <tft_caption_draw+0x1e4>
				else if(!strncmp(p->text,"~LEFT",6))
   86060:	4638      	mov	r0, r7
   86062:	495e      	ldr	r1, [pc, #376]	; (861dc <tft_caption_draw+0x264>)
   86064:	2206      	movs	r2, #6
   86066:	4b59      	ldr	r3, [pc, #356]	; (861cc <tft_caption_draw+0x254>)
   86068:	4798      	blx	r3
   8606a:	b9a0      	cbnz	r0, 86096 <tft_caption_draw+0x11e>
					tft_fillTriangle(center_x+TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x - TRIANGLE_SIZE ,center_y,RA8875_BLACK);
   8606c:	b2ab      	uxth	r3, r5
   8606e:	b2b6      	uxth	r6, r6
   86070:	f106 020f 	add.w	r2, r6, #15
   86074:	b212      	sxth	r2, r2
   86076:	f1a3 010f 	sub.w	r1, r3, #15
   8607a:	330f      	adds	r3, #15
   8607c:	3e0f      	subs	r6, #15
   8607e:	b230      	sxth	r0, r6
   86080:	9000      	str	r0, [sp, #0]
   86082:	b22d      	sxth	r5, r5
   86084:	9501      	str	r5, [sp, #4]
   86086:	2000      	movs	r0, #0
   86088:	9002      	str	r0, [sp, #8]
   8608a:	4610      	mov	r0, r2
   8608c:	b209      	sxth	r1, r1
   8608e:	b21b      	sxth	r3, r3
   86090:	4d4f      	ldr	r5, [pc, #316]	; (861d0 <tft_caption_draw+0x258>)
   86092:	47a8      	blx	r5
   86094:	e062      	b.n	8615c <tft_caption_draw+0x1e4>
				else if(!strncmp(p->text,"~CW",3))
   86096:	4638      	mov	r0, r7
   86098:	4951      	ldr	r1, [pc, #324]	; (861e0 <tft_caption_draw+0x268>)
   8609a:	2203      	movs	r2, #3
   8609c:	4b4b      	ldr	r3, [pc, #300]	; (861cc <tft_caption_draw+0x254>)
   8609e:	4798      	blx	r3
   860a0:	bb10      	cbnz	r0, 860e8 <tft_caption_draw+0x170>
				{
					tft_drawCircle(center_x,center_y,CIRCLE_SIZE,RA8875_BLACK);
   860a2:	b2ad      	uxth	r5, r5
   860a4:	fa0f f986 	sxth.w	r9, r6
   860a8:	fa0f f885 	sxth.w	r8, r5
   860ac:	4648      	mov	r0, r9
   860ae:	4641      	mov	r1, r8
   860b0:	221e      	movs	r2, #30
   860b2:	2300      	movs	r3, #0
   860b4:	4f4b      	ldr	r7, [pc, #300]	; (861e4 <tft_caption_draw+0x26c>)
   860b6:	47b8      	blx	r7
					tft_drawCircle(center_x,center_y,CIRCLE_SIZE + 1,RA8875_BLACK);
   860b8:	4648      	mov	r0, r9
   860ba:	4641      	mov	r1, r8
   860bc:	221f      	movs	r2, #31
   860be:	2300      	movs	r3, #0
   860c0:	47b8      	blx	r7
					center_x += CIRCLE_SIZE;
   860c2:	361e      	adds	r6, #30
					tft_fillTriangle(center_x-TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x+TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x,center_y+TRIANGLE_SIZE / 3,RA8875_BLACK);
   860c4:	b2b2      	uxth	r2, r6
   860c6:	1f6b      	subs	r3, r5, #5
   860c8:	1f50      	subs	r0, r2, #5
   860ca:	b21b      	sxth	r3, r3
   860cc:	3205      	adds	r2, #5
   860ce:	b236      	sxth	r6, r6
   860d0:	9600      	str	r6, [sp, #0]
   860d2:	3505      	adds	r5, #5
   860d4:	b229      	sxth	r1, r5
   860d6:	9101      	str	r1, [sp, #4]
   860d8:	2100      	movs	r1, #0
   860da:	9102      	str	r1, [sp, #8]
   860dc:	b200      	sxth	r0, r0
   860de:	4619      	mov	r1, r3
   860e0:	b212      	sxth	r2, r2
   860e2:	4d3b      	ldr	r5, [pc, #236]	; (861d0 <tft_caption_draw+0x258>)
   860e4:	47a8      	blx	r5
   860e6:	e039      	b.n	8615c <tft_caption_draw+0x1e4>
				}else if(!strncmp(p->text,"~CCW",4))
   860e8:	4638      	mov	r0, r7
   860ea:	493f      	ldr	r1, [pc, #252]	; (861e8 <tft_caption_draw+0x270>)
   860ec:	2204      	movs	r2, #4
   860ee:	4b37      	ldr	r3, [pc, #220]	; (861cc <tft_caption_draw+0x254>)
   860f0:	4798      	blx	r3
   860f2:	bb10      	cbnz	r0, 8613a <tft_caption_draw+0x1c2>
				{
					tft_drawCircle(center_x,center_y,CIRCLE_SIZE,RA8875_BLACK);
   860f4:	b2ad      	uxth	r5, r5
   860f6:	fa0f f986 	sxth.w	r9, r6
   860fa:	fa0f f885 	sxth.w	r8, r5
   860fe:	4648      	mov	r0, r9
   86100:	4641      	mov	r1, r8
   86102:	221e      	movs	r2, #30
   86104:	2300      	movs	r3, #0
   86106:	4f37      	ldr	r7, [pc, #220]	; (861e4 <tft_caption_draw+0x26c>)
   86108:	47b8      	blx	r7
					tft_drawCircle(center_x,center_y,CIRCLE_SIZE + 1,RA8875_BLACK);
   8610a:	4648      	mov	r0, r9
   8610c:	4641      	mov	r1, r8
   8610e:	221f      	movs	r2, #31
   86110:	2300      	movs	r3, #0
   86112:	47b8      	blx	r7
					center_x -= CIRCLE_SIZE;
   86114:	3e1e      	subs	r6, #30
					tft_fillTriangle(center_x-TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x+TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x,center_y+TRIANGLE_SIZE / 3,RA8875_BLACK);
   86116:	b2b2      	uxth	r2, r6
   86118:	1f6b      	subs	r3, r5, #5
   8611a:	1f50      	subs	r0, r2, #5
   8611c:	b21b      	sxth	r3, r3
   8611e:	3205      	adds	r2, #5
   86120:	b236      	sxth	r6, r6
   86122:	9600      	str	r6, [sp, #0]
   86124:	3505      	adds	r5, #5
   86126:	b229      	sxth	r1, r5
   86128:	9101      	str	r1, [sp, #4]
   8612a:	2100      	movs	r1, #0
   8612c:	9102      	str	r1, [sp, #8]
   8612e:	b200      	sxth	r0, r0
   86130:	4619      	mov	r1, r3
   86132:	b212      	sxth	r2, r2
   86134:	4d26      	ldr	r5, [pc, #152]	; (861d0 <tft_caption_draw+0x258>)
   86136:	47a8      	blx	r5
   86138:	e010      	b.n	8615c <tft_caption_draw+0x1e4>
				}

				else tft_textWrite(p->Rect.x+3,p->Rect.y,p->Rect.x + p->Rect.width-3,p->Rect.y + p->Rect.height,p->text,ALINE_CENTER);	// button
   8613a:	fa1f f28b 	uxth.w	r2, fp
   8613e:	fa1f f18a 	uxth.w	r1, sl
   86142:	1cd0      	adds	r0, r2, #3
   86144:	4442      	add	r2, r8
   86146:	3a03      	subs	r2, #3
   86148:	eb01 0309 	add.w	r3, r1, r9
   8614c:	9700      	str	r7, [sp, #0]
   8614e:	2501      	movs	r5, #1
   86150:	9501      	str	r5, [sp, #4]
   86152:	b280      	uxth	r0, r0
   86154:	b292      	uxth	r2, r2
   86156:	b29b      	uxth	r3, r3
   86158:	4d24      	ldr	r5, [pc, #144]	; (861ec <tft_caption_draw+0x274>)
   8615a:	47a8      	blx	r5
			}
			if(p->type == 4)
   8615c:	7c63      	ldrb	r3, [r4, #17]
   8615e:	2b04      	cmp	r3, #4
   86160:	d111      	bne.n	86186 <tft_caption_draw+0x20e>
				tft_textWrite(p->Rect.x+3,p->Rect.y,p->Rect.x + p->Rect.width-3,p->Rect.y + p->Rect.height,p->text,ALINE_CENTER);	// button 1
   86162:	8822      	ldrh	r2, [r4, #0]
   86164:	88a1      	ldrh	r1, [r4, #4]
   86166:	1cd0      	adds	r0, r2, #3
   86168:	68a3      	ldr	r3, [r4, #8]
   8616a:	4413      	add	r3, r2
   8616c:	1eda      	subs	r2, r3, #3
   8616e:	68e3      	ldr	r3, [r4, #12]
   86170:	440b      	add	r3, r1
   86172:	6a24      	ldr	r4, [r4, #32]
   86174:	9400      	str	r4, [sp, #0]
   86176:	2401      	movs	r4, #1
   86178:	9401      	str	r4, [sp, #4]
   8617a:	b280      	uxth	r0, r0
   8617c:	b292      	uxth	r2, r2
   8617e:	b29b      	uxth	r3, r3
   86180:	4c1a      	ldr	r4, [pc, #104]	; (861ec <tft_caption_draw+0x274>)
   86182:	47a0      	blx	r4
   86184:	e014      	b.n	861b0 <tft_caption_draw+0x238>
			else if(p->type == 2)
   86186:	2b02      	cmp	r3, #2
   86188:	d112      	bne.n	861b0 <tft_caption_draw+0x238>
				tft_textWrite(p->Rect.x,p->Rect.y,p->Rect.x + p->Rect.width,p->Rect.y + p->Rect.height,p->text,ALINE_RIGHT);	// check box
   8618a:	8820      	ldrh	r0, [r4, #0]
   8618c:	88a1      	ldrh	r1, [r4, #4]
   8618e:	68a3      	ldr	r3, [r4, #8]
   86190:	18c2      	adds	r2, r0, r3
   86192:	68e3      	ldr	r3, [r4, #12]
   86194:	440b      	add	r3, r1
   86196:	6a24      	ldr	r4, [r4, #32]
   86198:	9400      	str	r4, [sp, #0]
   8619a:	2402      	movs	r4, #2
   8619c:	9401      	str	r4, [sp, #4]
   8619e:	b292      	uxth	r2, r2
   861a0:	b29b      	uxth	r3, r3
   861a2:	4c12      	ldr	r4, [pc, #72]	; (861ec <tft_caption_draw+0x274>)
   861a4:	47a0      	blx	r4
   861a6:	e003      	b.n	861b0 <tft_caption_draw+0x238>
			break;
		}
		p = p->next;
   861a8:	69e4      	ldr	r4, [r4, #28]
	}while(p);
   861aa:	2c00      	cmp	r4, #0
   861ac:	f47f aee9 	bne.w	85f82 <tft_caption_draw+0xa>
}
   861b0:	b005      	add	sp, #20
   861b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   861b6:	bf00      	nop
   861b8:	200014f0 	.word	0x200014f0
   861bc:	000854dd 	.word	0x000854dd
   861c0:	000855b1 	.word	0x000855b1
   861c4:	00085551 	.word	0x00085551
   861c8:	00091718 	.word	0x00091718
   861cc:	0008d3f5 	.word	0x0008d3f5
   861d0:	00085f51 	.word	0x00085f51
   861d4:	00091720 	.word	0x00091720
   861d8:	00091724 	.word	0x00091724
   861dc:	0009172c 	.word	0x0009172c
   861e0:	00091734 	.word	0x00091734
   861e4:	00085cb5 	.word	0x00085cb5
   861e8:	00091738 	.word	0x00091738
   861ec:	00085679 	.word	0x00085679

000861f0 <tft_frame_draw>:
	}while(p);

}
#define ROUNDED_BUTTONS
void tft_frame_draw(unsigned char handle)
{
   861f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   861f4:	b085      	sub	sp, #20
	TGraphics *p;
	unsigned int x,width1;
	unsigned int y,height1;
	
	p = Gall;
   861f6:	4b5a      	ldr	r3, [pc, #360]	; (86360 <tft_frame_draw+0x170>)
   861f8:	681c      	ldr	r4, [r3, #0]
	do
	{
		if(p->handle == handle)
   861fa:	7c23      	ldrb	r3, [r4, #16]
   861fc:	4283      	cmp	r3, r0
   861fe:	f040 80a7 	bne.w	86350 <tft_frame_draw+0x160>
		{
			x = p->Rect.x;
   86202:	6827      	ldr	r7, [r4, #0]
			y = p->Rect.y;
   86204:	6866      	ldr	r6, [r4, #4]
			width1 = p->Rect.width;
   86206:	68a5      	ldr	r5, [r4, #8]
			height1 = p->Rect.height;
   86208:	f8d4 800c 	ldr.w	r8, [r4, #12]
			if(p->type == 2)	//	Checkbox
   8620c:	7c63      	ldrb	r3, [r4, #17]
   8620e:	2b02      	cmp	r3, #2
			{
				width1 = 15;
				height1 = 15;
   86210:	bf04      	itt	eq
   86212:	f04f 080f 	moveq.w	r8, #15
			y = p->Rect.y;
			width1 = p->Rect.width;
			height1 = p->Rect.height;
			if(p->type == 2)	//	Checkbox
			{
				width1 = 15;
   86216:	4645      	moveq	r5, r8
				height1 = 15;
			}
			if(p->value != 0)
   86218:	7ca3      	ldrb	r3, [r4, #18]
   8621a:	2b00      	cmp	r3, #0
   8621c:	d04b      	beq.n	862b6 <tft_frame_draw+0xc6>
			{
				if(p->radius)
   8621e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   86222:	b1eb      	cbz	r3, 86260 <tft_frame_draw+0x70>
				{
					tft_fillRectRound(x+1,y+1,width1+1,height1+1,RA885_LIGHTGRAY,p->radius);
   86224:	1c78      	adds	r0, r7, #1
   86226:	1c71      	adds	r1, r6, #1
   86228:	1c6a      	adds	r2, r5, #1
   8622a:	f108 0e01 	add.w	lr, r8, #1
   8622e:	f24d 6c9a 	movw	ip, #54938	; 0xd69a
   86232:	f8cd c000 	str.w	ip, [sp]
   86236:	9301      	str	r3, [sp, #4]
   86238:	b200      	sxth	r0, r0
   8623a:	b209      	sxth	r1, r1
   8623c:	b212      	sxth	r2, r2
   8623e:	fa0f f38e 	sxth.w	r3, lr
   86242:	f8df 9120 	ldr.w	r9, [pc, #288]	; 86364 <tft_frame_draw+0x174>
   86246:	47c8      	blx	r9
					tft_fillRectRound(x,y,width1,height1,p->BackColor,p->radius);
   86248:	8aa3      	ldrh	r3, [r4, #20]
   8624a:	9300      	str	r3, [sp, #0]
   8624c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   86250:	9301      	str	r3, [sp, #4]
   86252:	b238      	sxth	r0, r7
   86254:	b231      	sxth	r1, r6
   86256:	b22a      	sxth	r2, r5
   86258:	fa0f f388 	sxth.w	r3, r8
   8625c:	47c8      	blx	r9
   8625e:	e07b      	b.n	86358 <tft_frame_draw+0x168>
				} else
				{
					tft_fillRect(x,y + height1,width1,1,RA885_LIGHTGRAY);
   86260:	fa0f fa87 	sxth.w	sl, r7
   86264:	eb08 0106 	add.w	r1, r8, r6
   86268:	b22b      	sxth	r3, r5
   8626a:	f24d 6b9a 	movw	fp, #54938	; 0xd69a
   8626e:	f8cd b000 	str.w	fp, [sp]
   86272:	4650      	mov	r0, sl
   86274:	b209      	sxth	r1, r1
   86276:	9303      	str	r3, [sp, #12]
   86278:	461a      	mov	r2, r3
   8627a:	2301      	movs	r3, #1
   8627c:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 86368 <tft_frame_draw+0x178>
   86280:	47c8      	blx	r9
					tft_fillRect(x,y,1,height1,RA885_LIGHTGRAY);
   86282:	b236      	sxth	r6, r6
   86284:	fa0f f888 	sxth.w	r8, r8
   86288:	f8cd b000 	str.w	fp, [sp]
   8628c:	4650      	mov	r0, sl
   8628e:	4631      	mov	r1, r6
   86290:	2201      	movs	r2, #1
   86292:	4643      	mov	r3, r8
   86294:	47c8      	blx	r9
					tft_fillRect(x,y,width1,1,p->BackColor);
   86296:	8aa3      	ldrh	r3, [r4, #20]
   86298:	9300      	str	r3, [sp, #0]
   8629a:	4650      	mov	r0, sl
   8629c:	4631      	mov	r1, r6
   8629e:	9a03      	ldr	r2, [sp, #12]
   862a0:	2301      	movs	r3, #1
   862a2:	47c8      	blx	r9
					tft_fillRect(x+width1,y,1,height1,p->BackColor);
   862a4:	19e8      	adds	r0, r5, r7
   862a6:	8aa3      	ldrh	r3, [r4, #20]
   862a8:	9300      	str	r3, [sp, #0]
   862aa:	b200      	sxth	r0, r0
   862ac:	4631      	mov	r1, r6
   862ae:	2201      	movs	r2, #1
   862b0:	4643      	mov	r3, r8
   862b2:	47c8      	blx	r9
   862b4:	e050      	b.n	86358 <tft_frame_draw+0x168>
				}
			}else
			{
				if(p->radius)
   862b6:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   862ba:	b1db      	cbz	r3, 862f4 <tft_frame_draw+0x104>
				{
					tft_fillRectRound(x,y,width1,height1,RA885_LIGHTGRAY,p->radius);
   862bc:	f24d 629a 	movw	r2, #54938	; 0xd69a
   862c0:	9200      	str	r2, [sp, #0]
   862c2:	9301      	str	r3, [sp, #4]
   862c4:	b238      	sxth	r0, r7
   862c6:	b231      	sxth	r1, r6
   862c8:	b22a      	sxth	r2, r5
   862ca:	fa0f f388 	sxth.w	r3, r8
   862ce:	f8df 9094 	ldr.w	r9, [pc, #148]	; 86364 <tft_frame_draw+0x174>
   862d2:	47c8      	blx	r9
					tft_fillRectRound(x+1,y+1,width1+1,height1+1,p->BackColor,p->radius);
   862d4:	1c78      	adds	r0, r7, #1
   862d6:	1c71      	adds	r1, r6, #1
   862d8:	1c6a      	adds	r2, r5, #1
   862da:	f108 0301 	add.w	r3, r8, #1
   862de:	8aa5      	ldrh	r5, [r4, #20]
   862e0:	9500      	str	r5, [sp, #0]
   862e2:	f894 4024 	ldrb.w	r4, [r4, #36]	; 0x24
   862e6:	9401      	str	r4, [sp, #4]
   862e8:	b200      	sxth	r0, r0
   862ea:	b209      	sxth	r1, r1
   862ec:	b212      	sxth	r2, r2
   862ee:	b21b      	sxth	r3, r3
   862f0:	47c8      	blx	r9
   862f2:	e031      	b.n	86358 <tft_frame_draw+0x168>
				} else
				{
					tft_fillRect(x,y,width1,height1,p->BackColor);
   862f4:	b2bf      	uxth	r7, r7
   862f6:	fa0f fb87 	sxth.w	fp, r7
   862fa:	fa0f fa86 	sxth.w	sl, r6
   862fe:	fa0f f388 	sxth.w	r3, r8
   86302:	9303      	str	r3, [sp, #12]
   86304:	8aa3      	ldrh	r3, [r4, #20]
   86306:	9300      	str	r3, [sp, #0]
   86308:	4658      	mov	r0, fp
   8630a:	4651      	mov	r1, sl
   8630c:	b22a      	sxth	r2, r5
   8630e:	9b03      	ldr	r3, [sp, #12]
   86310:	f8df 9054 	ldr.w	r9, [pc, #84]	; 86368 <tft_frame_draw+0x178>
   86314:	47c8      	blx	r9
					tft_fillRect(x,y,1,height1,p->BackColor);
   86316:	8aa3      	ldrh	r3, [r4, #20]
   86318:	9300      	str	r3, [sp, #0]
   8631a:	4658      	mov	r0, fp
   8631c:	4651      	mov	r1, sl
   8631e:	2201      	movs	r2, #1
   86320:	9b03      	ldr	r3, [sp, #12]
   86322:	47c8      	blx	r9
					tft_fillRect(x+1,y,width1-2,1,RA885_LIGHTGRAY);
   86324:	b2ad      	uxth	r5, r5
   86326:	1c78      	adds	r0, r7, #1
   86328:	1eaa      	subs	r2, r5, #2
   8632a:	f24d 649a 	movw	r4, #54938	; 0xd69a
   8632e:	9400      	str	r4, [sp, #0]
   86330:	b200      	sxth	r0, r0
   86332:	4651      	mov	r1, sl
   86334:	b212      	sxth	r2, r2
   86336:	2301      	movs	r3, #1
   86338:	47c8      	blx	r9
					tft_fillRect(x+width1,y+1,1,height1-2,RA885_LIGHTGRAY);
   8633a:	19e8      	adds	r0, r5, r7
   8633c:	1c71      	adds	r1, r6, #1
   8633e:	f1a8 0302 	sub.w	r3, r8, #2
   86342:	9400      	str	r4, [sp, #0]
   86344:	b200      	sxth	r0, r0
   86346:	b209      	sxth	r1, r1
   86348:	2201      	movs	r2, #1
   8634a:	b21b      	sxth	r3, r3
   8634c:	47c8      	blx	r9
   8634e:	e003      	b.n	86358 <tft_frame_draw+0x168>
				}
			};
			break;
		}
		p = p->next;
   86350:	69e4      	ldr	r4, [r4, #28]
	}while(p);
   86352:	2c00      	cmp	r4, #0
   86354:	f47f af51 	bne.w	861fa <tft_frame_draw+0xa>
}
   86358:	b005      	add	sp, #20
   8635a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8635e:	bf00      	nop
   86360:	200014f0 	.word	0x200014f0
   86364:	00085e05 	.word	0x00085e05
   86368:	00085ddd 	.word	0x00085ddd

0008636c <tft_touched>:
	}while(p);
	return 0;
}

uint8_t tft_touched(unsigned int x, unsigned int y)
{
   8636c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   86370:	b08b      	sub	sp, #44	; 0x2c
   86372:	4605      	mov	r5, r0
	uint8_t result = 0;
	TGraphics *p;
	p = Gall;
   86374:	4b9b      	ldr	r3, [pc, #620]	; (865e4 <tft_touched+0x278>)
   86376:	681c      	ldr	r4, [r3, #0]
	return 0;
}

uint8_t tft_touched(unsigned int x, unsigned int y)
{
	uint8_t result = 0;
   86378:	2000      	movs	r0, #0
	p = Gall;
	do
	{
		if( (x >= p->Rect.x) && (y >= p->Rect.y) && (x <= (p->Rect.x + p->Rect.width)) && (y <= (p->Rect.y + p->Rect.height)))
		{
			IsTouched = 1;
   8637a:	f8df b2a4 	ldr.w	fp, [pc, #676]	; 86620 <tft_touched+0x2b4>
			result = 1;
			if(!realtime)
   8637e:	f8df 82a4 	ldr.w	r8, [pc, #676]	; 86624 <tft_touched+0x2b8>
//					save_colors();
//					trackbardraw(p->Rect.x,p->Rect.y,p->Rect.width,p->Rect.height,p->value,p->BackColor,p->Color);
//					restore_colors();
				}
			}
			dotyk = 1;
   86382:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 86628 <tft_touched+0x2bc>
   86386:	460f      	mov	r7, r1
	uint8_t result = 0;
	TGraphics *p;
	p = Gall;
	do
	{
		if( (x >= p->Rect.x) && (y >= p->Rect.y) && (x <= (p->Rect.x + p->Rect.width)) && (y <= (p->Rect.y + p->Rect.height)))
   86388:	6823      	ldr	r3, [r4, #0]
   8638a:	42ab      	cmp	r3, r5
   8638c:	f200 8190 	bhi.w	866b0 <tft_touched+0x344>
   86390:	6862      	ldr	r2, [r4, #4]
   86392:	42ba      	cmp	r2, r7
   86394:	f200 818c 	bhi.w	866b0 <tft_touched+0x344>
   86398:	68a1      	ldr	r1, [r4, #8]
   8639a:	440b      	add	r3, r1
   8639c:	429d      	cmp	r5, r3
   8639e:	f200 8187 	bhi.w	866b0 <tft_touched+0x344>
   863a2:	68e3      	ldr	r3, [r4, #12]
   863a4:	441a      	add	r2, r3
   863a6:	4297      	cmp	r7, r2
   863a8:	f200 8182 	bhi.w	866b0 <tft_touched+0x344>
		{
			IsTouched = 1;
   863ac:	2301      	movs	r3, #1
   863ae:	f88b 3000 	strb.w	r3, [fp]
			result = 1;
			if(!realtime)
   863b2:	f898 3000 	ldrb.w	r3, [r8]
   863b6:	f013 0fff 	tst.w	r3, #255	; 0xff
   863ba:	f040 816f 	bne.w	8669c <tft_touched+0x330>
			{
				if(p->type == 1)	//	tlacitko
   863be:	7c63      	ldrb	r3, [r4, #17]
   863c0:	2b01      	cmp	r3, #1
   863c2:	f040 8107 	bne.w	865d4 <tft_touched+0x268>
				{
					p->value = 1;
   863c6:	2601      	movs	r6, #1
   863c8:	74a6      	strb	r6, [r4, #18]
//					save_colors();
					tft_frame_draw(p->handle); 
   863ca:	7c20      	ldrb	r0, [r4, #16]
   863cc:	4b86      	ldr	r3, [pc, #536]	; (865e8 <tft_touched+0x27c>)
   863ce:	4798      	blx	r3
					tft_textMode();
   863d0:	4b86      	ldr	r3, [pc, #536]	; (865ec <tft_touched+0x280>)
   863d2:	4798      	blx	r3
					tft_textColor(p->Color,p->BackColor);
   863d4:	8b20      	ldrh	r0, [r4, #24]
   863d6:	8aa1      	ldrh	r1, [r4, #20]
   863d8:	4b85      	ldr	r3, [pc, #532]	; (865f0 <tft_touched+0x284>)
   863da:	4798      	blx	r3
					tft_textEnlarge(1);
   863dc:	4630      	mov	r0, r6
   863de:	4b85      	ldr	r3, [pc, #532]	; (865f4 <tft_touched+0x288>)
   863e0:	4798      	blx	r3
					int center_x = p->Rect.x + p->Rect.width / 2;
   863e2:	f8d4 9000 	ldr.w	r9, [r4]
   863e6:	68a3      	ldr	r3, [r4, #8]
   863e8:	9308      	str	r3, [sp, #32]
   863ea:	eb09 0353 	add.w	r3, r9, r3, lsr #1
   863ee:	9306      	str	r3, [sp, #24]
					int center_y = p->Rect.y + p->Rect.height / 2 + 2;
   863f0:	6863      	ldr	r3, [r4, #4]
   863f2:	9309      	str	r3, [sp, #36]	; 0x24
   863f4:	68e6      	ldr	r6, [r4, #12]
   863f6:	3302      	adds	r3, #2
   863f8:	eb03 0356 	add.w	r3, r3, r6, lsr #1
   863fc:	9307      	str	r3, [sp, #28]
					if(!strncmp(p->text,"~DOWN",5))
   863fe:	6a23      	ldr	r3, [r4, #32]
   86400:	9305      	str	r3, [sp, #20]
   86402:	4618      	mov	r0, r3
   86404:	497c      	ldr	r1, [pc, #496]	; (865f8 <tft_touched+0x28c>)
   86406:	2205      	movs	r2, #5
   86408:	4b7c      	ldr	r3, [pc, #496]	; (865fc <tft_touched+0x290>)
   8640a:	4798      	blx	r3
   8640c:	b9b0      	cbnz	r0, 8643c <tft_touched+0xd0>
						tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x,center_y+TRIANGLE_SIZE,RA8875_BLACK);
   8640e:	9e06      	ldr	r6, [sp, #24]
   86410:	b2b2      	uxth	r2, r6
   86412:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   86416:	f1a1 030f 	sub.w	r3, r1, #15
   8641a:	f1a2 000f 	sub.w	r0, r2, #15
   8641e:	b21b      	sxth	r3, r3
   86420:	320f      	adds	r2, #15
   86422:	b236      	sxth	r6, r6
   86424:	9600      	str	r6, [sp, #0]
   86426:	310f      	adds	r1, #15
   86428:	b209      	sxth	r1, r1
   8642a:	9101      	str	r1, [sp, #4]
   8642c:	2100      	movs	r1, #0
   8642e:	9102      	str	r1, [sp, #8]
   86430:	b200      	sxth	r0, r0
   86432:	4619      	mov	r1, r3
   86434:	b212      	sxth	r2, r2
   86436:	4e72      	ldr	r6, [pc, #456]	; (86600 <tft_touched+0x294>)
   86438:	47b0      	blx	r6
   8643a:	e0cb      	b.n	865d4 <tft_touched+0x268>
					else if(!strncmp(p->text,"~UP",3))
   8643c:	9805      	ldr	r0, [sp, #20]
   8643e:	4971      	ldr	r1, [pc, #452]	; (86604 <tft_touched+0x298>)
   86440:	2203      	movs	r2, #3
   86442:	4b6e      	ldr	r3, [pc, #440]	; (865fc <tft_touched+0x290>)
   86444:	4798      	blx	r3
   86446:	b9b0      	cbnz	r0, 86476 <tft_touched+0x10a>
						tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x,center_y-TRIANGLE_SIZE,RA8875_BLACK);
   86448:	9e06      	ldr	r6, [sp, #24]
   8644a:	b2b2      	uxth	r2, r6
   8644c:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   86450:	f101 030f 	add.w	r3, r1, #15
   86454:	f1a2 000f 	sub.w	r0, r2, #15
   86458:	b21b      	sxth	r3, r3
   8645a:	320f      	adds	r2, #15
   8645c:	b236      	sxth	r6, r6
   8645e:	9600      	str	r6, [sp, #0]
   86460:	390f      	subs	r1, #15
   86462:	b209      	sxth	r1, r1
   86464:	9101      	str	r1, [sp, #4]
   86466:	2100      	movs	r1, #0
   86468:	9102      	str	r1, [sp, #8]
   8646a:	b200      	sxth	r0, r0
   8646c:	4619      	mov	r1, r3
   8646e:	b212      	sxth	r2, r2
   86470:	4e63      	ldr	r6, [pc, #396]	; (86600 <tft_touched+0x294>)
   86472:	47b0      	blx	r6
   86474:	e0ae      	b.n	865d4 <tft_touched+0x268>
					else if(!strncmp(p->text,"~RIGHT",6))
   86476:	9805      	ldr	r0, [sp, #20]
   86478:	4963      	ldr	r1, [pc, #396]	; (86608 <tft_touched+0x29c>)
   8647a:	2206      	movs	r2, #6
   8647c:	4b5f      	ldr	r3, [pc, #380]	; (865fc <tft_touched+0x290>)
   8647e:	4798      	blx	r3
   86480:	b9b0      	cbnz	r0, 864b0 <tft_touched+0x144>
						tft_fillTriangle(center_x-TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x-TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x + TRIANGLE_SIZE ,center_y,RA8875_BLACK);
   86482:	9e07      	ldr	r6, [sp, #28]
   86484:	b2b3      	uxth	r3, r6
   86486:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   8648a:	f1a0 020f 	sub.w	r2, r0, #15
   8648e:	b212      	sxth	r2, r2
   86490:	f1a3 010f 	sub.w	r1, r3, #15
   86494:	330f      	adds	r3, #15
   86496:	300f      	adds	r0, #15
   86498:	b200      	sxth	r0, r0
   8649a:	9000      	str	r0, [sp, #0]
   8649c:	b230      	sxth	r0, r6
   8649e:	9001      	str	r0, [sp, #4]
   864a0:	2000      	movs	r0, #0
   864a2:	9002      	str	r0, [sp, #8]
   864a4:	4610      	mov	r0, r2
   864a6:	b209      	sxth	r1, r1
   864a8:	b21b      	sxth	r3, r3
   864aa:	4e55      	ldr	r6, [pc, #340]	; (86600 <tft_touched+0x294>)
   864ac:	47b0      	blx	r6
   864ae:	e091      	b.n	865d4 <tft_touched+0x268>
					else if(!strncmp(p->text,"~LEFT",6))
   864b0:	9805      	ldr	r0, [sp, #20]
   864b2:	4956      	ldr	r1, [pc, #344]	; (8660c <tft_touched+0x2a0>)
   864b4:	2206      	movs	r2, #6
   864b6:	4b51      	ldr	r3, [pc, #324]	; (865fc <tft_touched+0x290>)
   864b8:	4798      	blx	r3
   864ba:	b9b0      	cbnz	r0, 864ea <tft_touched+0x17e>
						tft_fillTriangle(center_x+TRIANGLE_SIZE,center_y-TRIANGLE_SIZE,center_x+TRIANGLE_SIZE,center_y+TRIANGLE_SIZE,center_x - TRIANGLE_SIZE ,center_y,RA8875_BLACK);
   864bc:	9e07      	ldr	r6, [sp, #28]
   864be:	b2b3      	uxth	r3, r6
   864c0:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   864c4:	f100 020f 	add.w	r2, r0, #15
   864c8:	b212      	sxth	r2, r2
   864ca:	f1a3 010f 	sub.w	r1, r3, #15
   864ce:	330f      	adds	r3, #15
   864d0:	380f      	subs	r0, #15
   864d2:	b200      	sxth	r0, r0
   864d4:	9000      	str	r0, [sp, #0]
   864d6:	b230      	sxth	r0, r6
   864d8:	9001      	str	r0, [sp, #4]
   864da:	2000      	movs	r0, #0
   864dc:	9002      	str	r0, [sp, #8]
   864de:	4610      	mov	r0, r2
   864e0:	b209      	sxth	r1, r1
   864e2:	b21b      	sxth	r3, r3
   864e4:	4e46      	ldr	r6, [pc, #280]	; (86600 <tft_touched+0x294>)
   864e6:	47b0      	blx	r6
   864e8:	e074      	b.n	865d4 <tft_touched+0x268>
					else if(!strncmp(p->text,"~CW",3))
   864ea:	9805      	ldr	r0, [sp, #20]
   864ec:	4948      	ldr	r1, [pc, #288]	; (86610 <tft_touched+0x2a4>)
   864ee:	2203      	movs	r2, #3
   864f0:	4b42      	ldr	r3, [pc, #264]	; (865fc <tft_touched+0x290>)
   864f2:	4798      	blx	r3
   864f4:	bb40      	cbnz	r0, 86548 <tft_touched+0x1dc>
					{
						tft_drawCircle(center_x,center_y,CIRCLE_SIZE,RA8875_BLACK);
   864f6:	f8bd 901c 	ldrh.w	r9, [sp, #28]
   864fa:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
   864fe:	fa0f f289 	sxth.w	r2, r9
   86502:	9305      	str	r3, [sp, #20]
   86504:	4618      	mov	r0, r3
   86506:	9207      	str	r2, [sp, #28]
   86508:	4611      	mov	r1, r2
   8650a:	221e      	movs	r2, #30
   8650c:	2300      	movs	r3, #0
   8650e:	4e41      	ldr	r6, [pc, #260]	; (86614 <tft_touched+0x2a8>)
   86510:	47b0      	blx	r6
						tft_drawCircle(center_x,center_y,CIRCLE_SIZE + 1,RA8875_BLACK);
   86512:	9805      	ldr	r0, [sp, #20]
   86514:	9907      	ldr	r1, [sp, #28]
   86516:	221f      	movs	r2, #31
   86518:	2300      	movs	r3, #0
   8651a:	47b0      	blx	r6
						center_x += CIRCLE_SIZE;
   8651c:	9906      	ldr	r1, [sp, #24]
   8651e:	311e      	adds	r1, #30
						tft_fillTriangle(center_x-TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x+TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x,center_y+TRIANGLE_SIZE / 3,RA8875_BLACK);
   86520:	b28a      	uxth	r2, r1
   86522:	f1a9 0305 	sub.w	r3, r9, #5
   86526:	1f50      	subs	r0, r2, #5
   86528:	b21b      	sxth	r3, r3
   8652a:	3205      	adds	r2, #5
   8652c:	b209      	sxth	r1, r1
   8652e:	9100      	str	r1, [sp, #0]
   86530:	f109 0105 	add.w	r1, r9, #5
   86534:	b209      	sxth	r1, r1
   86536:	9101      	str	r1, [sp, #4]
   86538:	2100      	movs	r1, #0
   8653a:	9102      	str	r1, [sp, #8]
   8653c:	b200      	sxth	r0, r0
   8653e:	4619      	mov	r1, r3
   86540:	b212      	sxth	r2, r2
   86542:	4e2f      	ldr	r6, [pc, #188]	; (86600 <tft_touched+0x294>)
   86544:	47b0      	blx	r6
   86546:	e045      	b.n	865d4 <tft_touched+0x268>
					}else if(!strncmp(p->text,"~CCW",4))
   86548:	9805      	ldr	r0, [sp, #20]
   8654a:	4933      	ldr	r1, [pc, #204]	; (86618 <tft_touched+0x2ac>)
   8654c:	2204      	movs	r2, #4
   8654e:	4b2b      	ldr	r3, [pc, #172]	; (865fc <tft_touched+0x290>)
   86550:	4798      	blx	r3
   86552:	bb40      	cbnz	r0, 865a6 <tft_touched+0x23a>
					{
						tft_drawCircle(center_x,center_y,CIRCLE_SIZE,RA8875_BLACK);
   86554:	f8bd 901c 	ldrh.w	r9, [sp, #28]
   86558:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
   8655c:	fa0f f289 	sxth.w	r2, r9
   86560:	9305      	str	r3, [sp, #20]
   86562:	4618      	mov	r0, r3
   86564:	9207      	str	r2, [sp, #28]
   86566:	4611      	mov	r1, r2
   86568:	221e      	movs	r2, #30
   8656a:	2300      	movs	r3, #0
   8656c:	4e29      	ldr	r6, [pc, #164]	; (86614 <tft_touched+0x2a8>)
   8656e:	47b0      	blx	r6
						tft_drawCircle(center_x,center_y,CIRCLE_SIZE + 1,RA8875_BLACK);
   86570:	9805      	ldr	r0, [sp, #20]
   86572:	9907      	ldr	r1, [sp, #28]
   86574:	221f      	movs	r2, #31
   86576:	2300      	movs	r3, #0
   86578:	47b0      	blx	r6
						center_x += CIRCLE_SIZE;
   8657a:	9906      	ldr	r1, [sp, #24]
   8657c:	311e      	adds	r1, #30
						tft_fillTriangle(center_x-TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x+TRIANGLE_SIZE / 3,center_y-TRIANGLE_SIZE / 3,center_x,center_y+TRIANGLE_SIZE / 3,RA8875_BLACK);
   8657e:	b28a      	uxth	r2, r1
   86580:	f1a9 0305 	sub.w	r3, r9, #5
   86584:	1f50      	subs	r0, r2, #5
   86586:	b21b      	sxth	r3, r3
   86588:	3205      	adds	r2, #5
   8658a:	b209      	sxth	r1, r1
   8658c:	9100      	str	r1, [sp, #0]
   8658e:	f109 0105 	add.w	r1, r9, #5
   86592:	b209      	sxth	r1, r1
   86594:	9101      	str	r1, [sp, #4]
   86596:	2100      	movs	r1, #0
   86598:	9102      	str	r1, [sp, #8]
   8659a:	b200      	sxth	r0, r0
   8659c:	4619      	mov	r1, r3
   8659e:	b212      	sxth	r2, r2
   865a0:	4e17      	ldr	r6, [pc, #92]	; (86600 <tft_touched+0x294>)
   865a2:	47b0      	blx	r6
   865a4:	e016      	b.n	865d4 <tft_touched+0x268>
					}
					else
						tft_textWrite(p->Rect.x+3,p->Rect.y+2,p->Rect.x + p->Rect.width-3,p->Rect.y + p->Rect.height+2,p->text,ALINE_CENTER);	// button
   865a6:	fa1f f989 	uxth.w	r9, r9
   865aa:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   865ae:	f109 0003 	add.w	r0, r9, #3
   865b2:	1c99      	adds	r1, r3, #2
   865b4:	9a08      	ldr	r2, [sp, #32]
   865b6:	4491      	add	r9, r2
   865b8:	f1a9 0203 	sub.w	r2, r9, #3
   865bc:	4433      	add	r3, r6
   865be:	3302      	adds	r3, #2
   865c0:	9e05      	ldr	r6, [sp, #20]
   865c2:	9600      	str	r6, [sp, #0]
   865c4:	2601      	movs	r6, #1
   865c6:	9601      	str	r6, [sp, #4]
   865c8:	b280      	uxth	r0, r0
   865ca:	b289      	uxth	r1, r1
   865cc:	b292      	uxth	r2, r2
   865ce:	b29b      	uxth	r3, r3
   865d0:	4e12      	ldr	r6, [pc, #72]	; (8661c <tft_touched+0x2b0>)
   865d2:	47b0      	blx	r6
//				restore_colors();
				}
				if(p->type == 4)	//	tlacitko1
   865d4:	7c63      	ldrb	r3, [r4, #17]
   865d6:	2b04      	cmp	r3, #4
   865d8:	d14a      	bne.n	86670 <tft_touched+0x304>
				{
					if(p->value)
   865da:	7ca3      	ldrb	r3, [r4, #18]
   865dc:	b333      	cbz	r3, 8662c <tft_touched+0x2c0>
						p->value = 0;
   865de:	2300      	movs	r3, #0
   865e0:	74a3      	strb	r3, [r4, #18]
   865e2:	e025      	b.n	86630 <tft_touched+0x2c4>
   865e4:	200014f0 	.word	0x200014f0
   865e8:	000861f1 	.word	0x000861f1
   865ec:	000854dd 	.word	0x000854dd
   865f0:	00085551 	.word	0x00085551
   865f4:	000855b1 	.word	0x000855b1
   865f8:	00091718 	.word	0x00091718
   865fc:	0008d3f5 	.word	0x0008d3f5
   86600:	00085f51 	.word	0x00085f51
   86604:	00091720 	.word	0x00091720
   86608:	00091724 	.word	0x00091724
   8660c:	0009172c 	.word	0x0009172c
   86610:	00091734 	.word	0x00091734
   86614:	00085cb5 	.word	0x00085cb5
   86618:	00091738 	.word	0x00091738
   8661c:	00085679 	.word	0x00085679
   86620:	20000f49 	.word	0x20000f49
   86624:	2000117c 	.word	0x2000117c
   86628:	200014ec 	.word	0x200014ec
					else
						p->value = 1;
   8662c:	2301      	movs	r3, #1
   8662e:	74a3      	strb	r3, [r4, #18]
//					save_colors();
					tft_frame_draw(p->handle);
   86630:	7c20      	ldrb	r0, [r4, #16]
   86632:	4b23      	ldr	r3, [pc, #140]	; (866c0 <tft_touched+0x354>)
   86634:	4798      	blx	r3
					tft_textMode();
   86636:	4b23      	ldr	r3, [pc, #140]	; (866c4 <tft_touched+0x358>)
   86638:	4798      	blx	r3
					tft_textColor(p->Color,p->BackColor);
   8663a:	8b20      	ldrh	r0, [r4, #24]
   8663c:	8aa1      	ldrh	r1, [r4, #20]
   8663e:	4b22      	ldr	r3, [pc, #136]	; (866c8 <tft_touched+0x35c>)
   86640:	4798      	blx	r3
					tft_textEnlarge(1);
   86642:	2001      	movs	r0, #1
   86644:	4b21      	ldr	r3, [pc, #132]	; (866cc <tft_touched+0x360>)
   86646:	4798      	blx	r3
					tft_textWrite(p->Rect.x+3,p->Rect.y+2,p->Rect.x + p->Rect.width-3,p->Rect.y + p->Rect.height+2,p->text,ALINE_CENTER);	// button
   86648:	8823      	ldrh	r3, [r4, #0]
   8664a:	88a6      	ldrh	r6, [r4, #4]
   8664c:	1cd8      	adds	r0, r3, #3
   8664e:	1cb1      	adds	r1, r6, #2
   86650:	68a2      	ldr	r2, [r4, #8]
   86652:	441a      	add	r2, r3
   86654:	3a03      	subs	r2, #3
   86656:	68e3      	ldr	r3, [r4, #12]
   86658:	4433      	add	r3, r6
   8665a:	3302      	adds	r3, #2
   8665c:	6a26      	ldr	r6, [r4, #32]
   8665e:	9600      	str	r6, [sp, #0]
   86660:	2601      	movs	r6, #1
   86662:	9601      	str	r6, [sp, #4]
   86664:	b280      	uxth	r0, r0
   86666:	b289      	uxth	r1, r1
   86668:	b292      	uxth	r2, r2
   8666a:	b29b      	uxth	r3, r3
   8666c:	4e18      	ldr	r6, [pc, #96]	; (866d0 <tft_touched+0x364>)
   8666e:	47b0      	blx	r6
//					restore_colors();
				}
				if(p->type == 2)	//	check box
   86670:	7c63      	ldrb	r3, [r4, #17]
   86672:	2b02      	cmp	r3, #2
   86674:	d107      	bne.n	86686 <tft_touched+0x31a>
				{
					if(p->value)
   86676:	7ca3      	ldrb	r3, [r4, #18]
   86678:	b113      	cbz	r3, 86680 <tft_touched+0x314>
					p->value = 0;
   8667a:	2300      	movs	r3, #0
   8667c:	74a3      	strb	r3, [r4, #18]
   8667e:	e00d      	b.n	8669c <tft_touched+0x330>
					else
					p->value = 1;
   86680:	2301      	movs	r3, #1
   86682:	74a3      	strb	r3, [r4, #18]
   86684:	e00a      	b.n	8669c <tft_touched+0x330>
//					save_colors();
//					chbvalue_draw(p->Rect.x,p->Rect.y,p->value);
//					restore_colors();
				}
				if(p->type == 3)	//	Trackbar
   86686:	2b03      	cmp	r3, #3
   86688:	d108      	bne.n	8669c <tft_touched+0x330>
				{
					p->value = (x - p->Rect.x) * 100 / p->Rect.width;
   8668a:	6823      	ldr	r3, [r4, #0]
   8668c:	1aea      	subs	r2, r5, r3
   8668e:	2364      	movs	r3, #100	; 0x64
   86690:	fb03 f302 	mul.w	r3, r3, r2
   86694:	68a2      	ldr	r2, [r4, #8]
   86696:	fbb3 f3f2 	udiv	r3, r3, r2
   8669a:	74a3      	strb	r3, [r4, #18]
//					save_colors();
//					trackbardraw(p->Rect.x,p->Rect.y,p->Rect.width,p->Rect.height,p->value,p->BackColor,p->Color);
//					restore_colors();
				}
			}
			dotyk = 1;
   8669c:	2001      	movs	r0, #1
   8669e:	f88a 0000 	strb.w	r0, [sl]
			LastTouchXPos = x;
   866a2:	4b0c      	ldr	r3, [pc, #48]	; (866d4 <tft_touched+0x368>)
   866a4:	601d      	str	r5, [r3, #0]
			LastTouchYPos = y;
   866a6:	4b0c      	ldr	r3, [pc, #48]	; (866d8 <tft_touched+0x36c>)
   866a8:	601f      	str	r7, [r3, #0]
			Action = p->handle;
   866aa:	7c22      	ldrb	r2, [r4, #16]
   866ac:	4b0b      	ldr	r3, [pc, #44]	; (866dc <tft_touched+0x370>)
   866ae:	601a      	str	r2, [r3, #0]
//			beep(10);
		}
		p = p->next;
   866b0:	69e4      	ldr	r4, [r4, #28]
	}while(p);
   866b2:	2c00      	cmp	r4, #0
   866b4:	f47f ae68 	bne.w	86388 <tft_touched+0x1c>
	return result;
}
   866b8:	b00b      	add	sp, #44	; 0x2c
   866ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   866be:	bf00      	nop
   866c0:	000861f1 	.word	0x000861f1
   866c4:	000854dd 	.word	0x000854dd
   866c8:	00085551 	.word	0x00085551
   866cc:	000855b1 	.word	0x000855b1
   866d0:	00085679 	.word	0x00085679
   866d4:	2000150c 	.word	0x2000150c
   866d8:	200014f4 	.word	0x200014f4
   866dc:	20001500 	.word	0x20001500

000866e0 <tft_untouched>:
void tft_untouched(unsigned int x, unsigned int y)
{
   866e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   866e4:	4605      	mov	r5, r0
   866e6:	460e      	mov	r6, r1
	TGraphics *p;
	p = Gall;
   866e8:	4b18      	ldr	r3, [pc, #96]	; (8674c <tft_untouched+0x6c>)
   866ea:	681c      	ldr	r4, [r3, #0]
	do
	{
		if( (x >= p->Rect.x) && (y >= p->Rect.y) && (x <= (p->Rect.x + p->Rect.width)) && (y <= (p->Rect.y + p->Rect.height)))
		{
			IsTouched = 0;
   866ec:	f8df 9070 	ldr.w	r9, [pc, #112]	; 86760 <tft_untouched+0x80>
			if(!realtime)
   866f0:	f8df 8070 	ldr.w	r8, [pc, #112]	; 86764 <tft_untouched+0x84>
					tft_frame_draw(p->handle);
					tft_caption_draw(p->handle);
//					restore_colors();
				}
			}
			dotyk = 0;
   866f4:	4f16      	ldr	r7, [pc, #88]	; (86750 <tft_untouched+0x70>)
{
	TGraphics *p;
	p = Gall;
	do
	{
		if( (x >= p->Rect.x) && (y >= p->Rect.y) && (x <= (p->Rect.x + p->Rect.width)) && (y <= (p->Rect.y + p->Rect.height)))
   866f6:	6823      	ldr	r3, [r4, #0]
   866f8:	42ab      	cmp	r3, r5
   866fa:	d822      	bhi.n	86742 <tft_untouched+0x62>
   866fc:	6862      	ldr	r2, [r4, #4]
   866fe:	42b2      	cmp	r2, r6
   86700:	d81f      	bhi.n	86742 <tft_untouched+0x62>
   86702:	68a1      	ldr	r1, [r4, #8]
   86704:	440b      	add	r3, r1
   86706:	429d      	cmp	r5, r3
   86708:	d81b      	bhi.n	86742 <tft_untouched+0x62>
   8670a:	68e3      	ldr	r3, [r4, #12]
   8670c:	441a      	add	r2, r3
   8670e:	4296      	cmp	r6, r2
   86710:	d817      	bhi.n	86742 <tft_untouched+0x62>
		{
			IsTouched = 0;
   86712:	2300      	movs	r3, #0
   86714:	f889 3000 	strb.w	r3, [r9]
			if(!realtime)
   86718:	f898 3000 	ldrb.w	r3, [r8]
   8671c:	f013 0fff 	tst.w	r3, #255	; 0xff
   86720:	d10a      	bne.n	86738 <tft_untouched+0x58>
			{
				if(p->type == 1)	//	tlacitko
   86722:	7c63      	ldrb	r3, [r4, #17]
   86724:	2b01      	cmp	r3, #1
   86726:	d107      	bne.n	86738 <tft_untouched+0x58>
				{
					p->value = 0;
   86728:	2300      	movs	r3, #0
   8672a:	74a3      	strb	r3, [r4, #18]
//					save_colors();
					tft_frame_draw(p->handle);
   8672c:	7c20      	ldrb	r0, [r4, #16]
   8672e:	4b09      	ldr	r3, [pc, #36]	; (86754 <tft_untouched+0x74>)
   86730:	4798      	blx	r3
					tft_caption_draw(p->handle);
   86732:	7c20      	ldrb	r0, [r4, #16]
   86734:	4b08      	ldr	r3, [pc, #32]	; (86758 <tft_untouched+0x78>)
   86736:	4798      	blx	r3
//					restore_colors();
				}
			}
			dotyk = 0;
   86738:	2300      	movs	r3, #0
   8673a:	703b      	strb	r3, [r7, #0]
			Action1 = p->handle;
   8673c:	7c22      	ldrb	r2, [r4, #16]
   8673e:	4b07      	ldr	r3, [pc, #28]	; (8675c <tft_untouched+0x7c>)
   86740:	601a      	str	r2, [r3, #0]
		}
		p = p->next;
   86742:	69e4      	ldr	r4, [r4, #28]
	}while(p);
   86744:	2c00      	cmp	r4, #0
   86746:	d1d6      	bne.n	866f6 <tft_untouched+0x16>
}
   86748:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8674c:	200014f0 	.word	0x200014f0
   86750:	200014ec 	.word	0x200014ec
   86754:	000861f1 	.word	0x000861f1
   86758:	00085f79 	.word	0x00085f79
   8675c:	200014fc 	.word	0x200014fc
   86760:	20000f49 	.word	0x20000f49
   86764:	2000117c 	.word	0x2000117c

00086768 <tft_delete_all_objects>:
		joystick_read(&x,&y);
	}*/
}

void tft_delete_all_objects(void)
{
   86768:	b570      	push	{r4, r5, r6, lr}
	TGraphics *temp;
	temp = Gall;	//	temp ukazuje na prvyv zozname=>posledne pridany objekt
   8676a:	4b0b      	ldr	r3, [pc, #44]	; (86798 <tft_delete_all_objects+0x30>)
   8676c:	681c      	ldr	r4, [r3, #0]
	Action1 = 0;
   8676e:	2300      	movs	r3, #0
   86770:	4a0a      	ldr	r2, [pc, #40]	; (8679c <tft_delete_all_objects+0x34>)
   86772:	6013      	str	r3, [r2, #0]
	Action = 0;
   86774:	4a0a      	ldr	r2, [pc, #40]	; (867a0 <tft_delete_all_objects+0x38>)
   86776:	6013      	str	r3, [r2, #0]
	while(temp)
   86778:	b154      	cbz	r4, 86790 <tft_delete_all_objects+0x28>
	{
		Gall=temp->next;
   8677a:	4e07      	ldr	r6, [pc, #28]	; (86798 <tft_delete_all_objects+0x30>)
		free(temp->text);
   8677c:	4d09      	ldr	r5, [pc, #36]	; (867a4 <tft_delete_all_objects+0x3c>)
	temp = Gall;	//	temp ukazuje na prvyv zozname=>posledne pridany objekt
	Action1 = 0;
	Action = 0;
	while(temp)
	{
		Gall=temp->next;
   8677e:	69e3      	ldr	r3, [r4, #28]
   86780:	6033      	str	r3, [r6, #0]
		free(temp->text);
   86782:	6a20      	ldr	r0, [r4, #32]
   86784:	47a8      	blx	r5
		free(temp);
   86786:	4620      	mov	r0, r4
   86788:	47a8      	blx	r5
		temp = Gall;
   8678a:	6834      	ldr	r4, [r6, #0]
{
	TGraphics *temp;
	temp = Gall;	//	temp ukazuje na prvyv zozname=>posledne pridany objekt
	Action1 = 0;
	Action = 0;
	while(temp)
   8678c:	2c00      	cmp	r4, #0
   8678e:	d1f6      	bne.n	8677e <tft_delete_all_objects+0x16>
		Gall=temp->next;
		free(temp->text);
		free(temp);
		temp = Gall;
	}
	tft_graphicCursorDisable();
   86790:	4b05      	ldr	r3, [pc, #20]	; (867a8 <tft_delete_all_objects+0x40>)
   86792:	4798      	blx	r3
   86794:	bd70      	pop	{r4, r5, r6, pc}
   86796:	bf00      	nop
   86798:	200014f0 	.word	0x200014f0
   8679c:	200014fc 	.word	0x200014fc
   867a0:	20001500 	.word	0x20001500
   867a4:	0008cbc1 	.word	0x0008cbc1
   867a8:	0008595d 	.word	0x0008595d

000867ac <tft_add_object>:
}
void tft_add_object(unsigned int x, unsigned int y, unsigned int width1, unsigned int height1, unsigned char handle, unsigned char type, unsigned char value,unsigned int BackColor,unsigned int Color, const char *text, char radius)
{
   867ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   867b0:	b083      	sub	sp, #12
   867b2:	4681      	mov	r9, r0
   867b4:	4688      	mov	r8, r1
   867b6:	4617      	mov	r7, r2
   867b8:	461e      	mov	r6, r3
	TGraphics *p;
//	p = new(TGraphics);

	p = (TGraphics*)malloc(sizeof(TGraphics));
   867ba:	2028      	movs	r0, #40	; 0x28
   867bc:	4b29      	ldr	r3, [pc, #164]	; (86864 <tft_add_object+0xb8>)
   867be:	4798      	blx	r3
	if((p ==NULL) || (((p->text =(char*)malloc(strlen(text)+1))==NULL)))
   867c0:	b148      	cbz	r0, 867d6 <tft_add_object+0x2a>
   867c2:	4604      	mov	r4, r0
   867c4:	980f      	ldr	r0, [sp, #60]	; 0x3c
   867c6:	4b28      	ldr	r3, [pc, #160]	; (86868 <tft_add_object+0xbc>)
   867c8:	4798      	blx	r3
   867ca:	3001      	adds	r0, #1
   867cc:	4b25      	ldr	r3, [pc, #148]	; (86864 <tft_add_object+0xb8>)
   867ce:	4798      	blx	r3
   867d0:	4605      	mov	r5, r0
   867d2:	6220      	str	r0, [r4, #32]
   867d4:	b9b8      	cbnz	r0, 86806 <tft_add_object+0x5a>
	{
		tft_fillScreen(RA8875_RED);
   867d6:	f44f 4078 	mov.w	r0, #63488	; 0xf800
   867da:	4b24      	ldr	r3, [pc, #144]	; (8686c <tft_add_object+0xc0>)
   867dc:	4798      	blx	r3
		tft_textColor(RA8875_BLACK,RA8875_RED);
   867de:	2000      	movs	r0, #0
   867e0:	f44f 4178 	mov.w	r1, #63488	; 0xf800
   867e4:	4b22      	ldr	r3, [pc, #136]	; (86870 <tft_add_object+0xc4>)
   867e6:	4798      	blx	r3
		tft_textEnlarge(2);
   867e8:	2002      	movs	r0, #2
   867ea:	4b22      	ldr	r3, [pc, #136]	; (86874 <tft_add_object+0xc8>)
   867ec:	4798      	blx	r3
		tft_textWrite(0,30, 800, 80, (char*)"malloc() error. No Space", ALINE_CENTER);
   867ee:	4b22      	ldr	r3, [pc, #136]	; (86878 <tft_add_object+0xcc>)
   867f0:	9300      	str	r3, [sp, #0]
   867f2:	2301      	movs	r3, #1
   867f4:	9301      	str	r3, [sp, #4]
   867f6:	2000      	movs	r0, #0
   867f8:	211e      	movs	r1, #30
   867fa:	f44f 7248 	mov.w	r2, #800	; 0x320
   867fe:	2350      	movs	r3, #80	; 0x50
   86800:	4c1e      	ldr	r4, [pc, #120]	; (8687c <tft_add_object+0xd0>)
   86802:	47a0      	blx	r4
		while(1);
   86804:	e7fe      	b.n	86804 <tft_add_object+0x58>
	}
	//	mem_use1 += sizeof(struct TGraphics) + strlen(text)+1;
	p->Rect.x = x;
   86806:	f8c4 9000 	str.w	r9, [r4]
	p->Rect.y = y;
   8680a:	f8c4 8004 	str.w	r8, [r4, #4]
	p->Rect.width = width1;
   8680e:	60a7      	str	r7, [r4, #8]
	p->Rect.height = height1;
   86810:	60e6      	str	r6, [r4, #12]
	p->next = NULL;
   86812:	2300      	movs	r3, #0
   86814:	61e3      	str	r3, [r4, #28]
	p->handle = handle;
   86816:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   8681a:	7423      	strb	r3, [r4, #16]
	p->type = type;
   8681c:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   86820:	7463      	strb	r3, [r4, #17]
	p->value = value;
   86822:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   86826:	74a3      	strb	r3, [r4, #18]
	p->BackColor = BackColor;
   86828:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8682a:	6163      	str	r3, [r4, #20]
	p->Color = Color;
   8682c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8682e:	61a3      	str	r3, [r4, #24]
	p->radius = radius;
   86830:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   86834:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	memcpy(p->text,text,strlen(text)+1);
   86838:	980f      	ldr	r0, [sp, #60]	; 0x3c
   8683a:	4b0b      	ldr	r3, [pc, #44]	; (86868 <tft_add_object+0xbc>)
   8683c:	4798      	blx	r3
   8683e:	1c42      	adds	r2, r0, #1
   86840:	4628      	mov	r0, r5
   86842:	990f      	ldr	r1, [sp, #60]	; 0x3c
   86844:	4b0e      	ldr	r3, [pc, #56]	; (86880 <tft_add_object+0xd4>)
   86846:	4798      	blx	r3
	//	p->text = text;
	if(Gall == NULL)
   86848:	4b0e      	ldr	r3, [pc, #56]	; (86884 <tft_add_object+0xd8>)
   8684a:	681b      	ldr	r3, [r3, #0]
   8684c:	b923      	cbnz	r3, 86858 <tft_add_object+0xac>
	{
		Gall = Gcurrent = p;
   8684e:	4b0e      	ldr	r3, [pc, #56]	; (86888 <tft_add_object+0xdc>)
   86850:	601c      	str	r4, [r3, #0]
   86852:	4b0c      	ldr	r3, [pc, #48]	; (86884 <tft_add_object+0xd8>)
   86854:	601c      	str	r4, [r3, #0]
   86856:	e002      	b.n	8685e <tft_add_object+0xb2>
	}else
	{
		p->next = Gall;
   86858:	61e3      	str	r3, [r4, #28]
		Gall = p;
   8685a:	4b0a      	ldr	r3, [pc, #40]	; (86884 <tft_add_object+0xd8>)
   8685c:	601c      	str	r4, [r3, #0]
	}
}
   8685e:	b003      	add	sp, #12
   86860:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   86864:	0008cbb1 	.word	0x0008cbb1
   86868:	0008d399 	.word	0x0008d399
   8686c:	00085e2d 	.word	0x00085e2d
   86870:	00085551 	.word	0x00085551
   86874:	000855b1 	.word	0x000855b1
   86878:	00091740 	.word	0x00091740
   8687c:	00085679 	.word	0x00085679
   86880:	0008d0dd 	.word	0x0008d0dd
   86884:	200014f0 	.word	0x200014f0
   86888:	20001508 	.word	0x20001508

0008688c <tft_button>:
		p = p->next;
	}while(p);
}

void tft_button(unsigned int x,unsigned int y,unsigned int width1,unsigned int height1,const char *text, unsigned char handle, uint16_t color,uint8_t radius)
{
   8688c:	b570      	push	{r4, r5, r6, lr}
   8688e:	b088      	sub	sp, #32
   86890:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
	//	save_colors();
	tft_add_object(x,y,width1,height1,handle,1,0,color,RA8875_BLACK,text,radius);
   86894:	9400      	str	r4, [sp, #0]
   86896:	2501      	movs	r5, #1
   86898:	9501      	str	r5, [sp, #4]
   8689a:	2500      	movs	r5, #0
   8689c:	9502      	str	r5, [sp, #8]
   8689e:	f8bd 6038 	ldrh.w	r6, [sp, #56]	; 0x38
   868a2:	9603      	str	r6, [sp, #12]
   868a4:	9504      	str	r5, [sp, #16]
   868a6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   868a8:	9505      	str	r5, [sp, #20]
   868aa:	f89d 503c 	ldrb.w	r5, [sp, #60]	; 0x3c
   868ae:	9506      	str	r5, [sp, #24]
   868b0:	4d04      	ldr	r5, [pc, #16]	; (868c4 <tft_button+0x38>)
   868b2:	47a8      	blx	r5
	tft_frame_draw(handle);
   868b4:	4620      	mov	r0, r4
   868b6:	4b04      	ldr	r3, [pc, #16]	; (868c8 <tft_button+0x3c>)
   868b8:	4798      	blx	r3
	tft_caption_draw(handle);
   868ba:	4620      	mov	r0, r4
   868bc:	4b03      	ldr	r3, [pc, #12]	; (868cc <tft_button+0x40>)
   868be:	4798      	blx	r3
	//	restore_colors();
}
   868c0:	b008      	add	sp, #32
   868c2:	bd70      	pop	{r4, r5, r6, pc}
   868c4:	000867ad 	.word	0x000867ad
   868c8:	000861f1 	.word	0x000861f1
   868cc:	00085f79 	.word	0x00085f79

000868d0 <tft_drawcalcbuttons>:
		p->next = Gall;
		Gall = p;
	}
}
void tft_drawcalcbuttons(void)
{	//	1 
   868d0:	b570      	push	{r4, r5, r6, lr}
   868d2:	b084      	sub	sp, #16
	tft_button(CalcX(10,4,1),CalcY(10,4,4),CalcHeight(10,4),CalcHeight(10,4),"0",10+0,RA8875_LIME,10);
   868d4:	4b55      	ldr	r3, [pc, #340]	; (86a2c <tft_drawcalcbuttons+0x15c>)
   868d6:	9300      	str	r3, [sp, #0]
   868d8:	240a      	movs	r4, #10
   868da:	9401      	str	r4, [sp, #4]
   868dc:	f64c 76e0 	movw	r6, #53216	; 0xcfe0
   868e0:	9602      	str	r6, [sp, #8]
   868e2:	9403      	str	r4, [sp, #12]
   868e4:	2005      	movs	r0, #5
   868e6:	f240 116d 	movw	r1, #365	; 0x16d
   868ea:	226e      	movs	r2, #110	; 0x6e
   868ec:	4613      	mov	r3, r2
   868ee:	4d50      	ldr	r5, [pc, #320]	; (86a30 <tft_drawcalcbuttons+0x160>)
   868f0:	47a8      	blx	r5
	tft_button(CalcX(10,4,3),CalcY(10,4,4),CalcHeight(10,4),CalcHeight(10,4),"<-",3  ,RA8875_LIME,10);
   868f2:	4b50      	ldr	r3, [pc, #320]	; (86a34 <tft_drawcalcbuttons+0x164>)
   868f4:	9300      	str	r3, [sp, #0]
   868f6:	2303      	movs	r3, #3
   868f8:	9301      	str	r3, [sp, #4]
   868fa:	9602      	str	r6, [sp, #8]
   868fc:	9403      	str	r4, [sp, #12]
   868fe:	20f5      	movs	r0, #245	; 0xf5
   86900:	f240 116d 	movw	r1, #365	; 0x16d
   86904:	226e      	movs	r2, #110	; 0x6e
   86906:	4613      	mov	r3, r2
   86908:	47a8      	blx	r5
	tft_button(CalcX(10,4,1),CalcY(10,4,3),CalcHeight(10,4),CalcHeight(10,4),"1",10+1,RA8875_LIME,10);
   8690a:	4b4b      	ldr	r3, [pc, #300]	; (86a38 <tft_drawcalcbuttons+0x168>)
   8690c:	9300      	str	r3, [sp, #0]
   8690e:	230b      	movs	r3, #11
   86910:	9301      	str	r3, [sp, #4]
   86912:	9602      	str	r6, [sp, #8]
   86914:	9403      	str	r4, [sp, #12]
   86916:	2005      	movs	r0, #5
   86918:	21f5      	movs	r1, #245	; 0xf5
   8691a:	226e      	movs	r2, #110	; 0x6e
   8691c:	4613      	mov	r3, r2
   8691e:	47a8      	blx	r5
	tft_button(CalcX(10,4,2),CalcY(10,4,3),CalcHeight(10,4),CalcHeight(10,4),"2",10+2,RA8875_LIME,10);
   86920:	4b46      	ldr	r3, [pc, #280]	; (86a3c <tft_drawcalcbuttons+0x16c>)
   86922:	9300      	str	r3, [sp, #0]
   86924:	230c      	movs	r3, #12
   86926:	9301      	str	r3, [sp, #4]
   86928:	9602      	str	r6, [sp, #8]
   8692a:	9403      	str	r4, [sp, #12]
   8692c:	207d      	movs	r0, #125	; 0x7d
   8692e:	21f5      	movs	r1, #245	; 0xf5
   86930:	226e      	movs	r2, #110	; 0x6e
   86932:	4613      	mov	r3, r2
   86934:	47a8      	blx	r5
	tft_button(CalcX(10,4,3),CalcY(10,4,3),CalcHeight(10,4),CalcHeight(10,4),"3",10+3,RA8875_LIME,10);
   86936:	4b42      	ldr	r3, [pc, #264]	; (86a40 <tft_drawcalcbuttons+0x170>)
   86938:	9300      	str	r3, [sp, #0]
   8693a:	230d      	movs	r3, #13
   8693c:	9301      	str	r3, [sp, #4]
   8693e:	9602      	str	r6, [sp, #8]
   86940:	9403      	str	r4, [sp, #12]
   86942:	20f5      	movs	r0, #245	; 0xf5
   86944:	4601      	mov	r1, r0
   86946:	226e      	movs	r2, #110	; 0x6e
   86948:	4613      	mov	r3, r2
   8694a:	47a8      	blx	r5
	tft_button(CalcX(10,4,1),CalcY(10,4,2),CalcHeight(10,4),CalcHeight(10,4),"4",10+4,RA8875_LIME,10);
   8694c:	4b3d      	ldr	r3, [pc, #244]	; (86a44 <tft_drawcalcbuttons+0x174>)
   8694e:	9300      	str	r3, [sp, #0]
   86950:	230e      	movs	r3, #14
   86952:	9301      	str	r3, [sp, #4]
   86954:	9602      	str	r6, [sp, #8]
   86956:	9403      	str	r4, [sp, #12]
   86958:	2005      	movs	r0, #5
   8695a:	217d      	movs	r1, #125	; 0x7d
   8695c:	226e      	movs	r2, #110	; 0x6e
   8695e:	4613      	mov	r3, r2
   86960:	47a8      	blx	r5
	tft_button(CalcX(10,4,2),CalcY(10,4,2),CalcHeight(10,4),CalcHeight(10,4),"5",10+5,RA8875_LIME,10);
   86962:	4b39      	ldr	r3, [pc, #228]	; (86a48 <tft_drawcalcbuttons+0x178>)
   86964:	9300      	str	r3, [sp, #0]
   86966:	230f      	movs	r3, #15
   86968:	9301      	str	r3, [sp, #4]
   8696a:	9602      	str	r6, [sp, #8]
   8696c:	9403      	str	r4, [sp, #12]
   8696e:	207d      	movs	r0, #125	; 0x7d
   86970:	4601      	mov	r1, r0
   86972:	226e      	movs	r2, #110	; 0x6e
   86974:	4613      	mov	r3, r2
   86976:	47a8      	blx	r5
	tft_button(CalcX(10,4,3),CalcY(10,4,2),CalcHeight(10,4),CalcHeight(10,4),"6",10+6,RA8875_LIME,10);
   86978:	4b34      	ldr	r3, [pc, #208]	; (86a4c <tft_drawcalcbuttons+0x17c>)
   8697a:	9300      	str	r3, [sp, #0]
   8697c:	2310      	movs	r3, #16
   8697e:	9301      	str	r3, [sp, #4]
   86980:	9602      	str	r6, [sp, #8]
   86982:	9403      	str	r4, [sp, #12]
   86984:	20f5      	movs	r0, #245	; 0xf5
   86986:	217d      	movs	r1, #125	; 0x7d
   86988:	226e      	movs	r2, #110	; 0x6e
   8698a:	4613      	mov	r3, r2
   8698c:	47a8      	blx	r5
	tft_button(CalcX(10,4,1),CalcY(10,4,1),CalcHeight(10,4),CalcHeight(10,4),"7",10+7,RA8875_LIME,10);
   8698e:	4b30      	ldr	r3, [pc, #192]	; (86a50 <tft_drawcalcbuttons+0x180>)
   86990:	9300      	str	r3, [sp, #0]
   86992:	2311      	movs	r3, #17
   86994:	9301      	str	r3, [sp, #4]
   86996:	9602      	str	r6, [sp, #8]
   86998:	9403      	str	r4, [sp, #12]
   8699a:	2005      	movs	r0, #5
   8699c:	4601      	mov	r1, r0
   8699e:	226e      	movs	r2, #110	; 0x6e
   869a0:	4613      	mov	r3, r2
   869a2:	47a8      	blx	r5
	tft_button(CalcX(10,4,2),CalcY(10,4,1),CalcHeight(10,4),CalcHeight(10,4),"8",10+8,RA8875_LIME,10);
   869a4:	4b2b      	ldr	r3, [pc, #172]	; (86a54 <tft_drawcalcbuttons+0x184>)
   869a6:	9300      	str	r3, [sp, #0]
   869a8:	2312      	movs	r3, #18
   869aa:	9301      	str	r3, [sp, #4]
   869ac:	9602      	str	r6, [sp, #8]
   869ae:	9403      	str	r4, [sp, #12]
   869b0:	207d      	movs	r0, #125	; 0x7d
   869b2:	2105      	movs	r1, #5
   869b4:	226e      	movs	r2, #110	; 0x6e
   869b6:	4613      	mov	r3, r2
   869b8:	47a8      	blx	r5
	tft_button(CalcX(10,4,3),CalcY(10,4,1),CalcHeight(10,4),CalcHeight(10,4),"9",10+9,RA8875_LIME,10);
   869ba:	4b27      	ldr	r3, [pc, #156]	; (86a58 <tft_drawcalcbuttons+0x188>)
   869bc:	9300      	str	r3, [sp, #0]
   869be:	2313      	movs	r3, #19
   869c0:	9301      	str	r3, [sp, #4]
   869c2:	9602      	str	r6, [sp, #8]
   869c4:	9403      	str	r4, [sp, #12]
   869c6:	20f5      	movs	r0, #245	; 0xf5
   869c8:	2105      	movs	r1, #5
   869ca:	226e      	movs	r2, #110	; 0x6e
   869cc:	4613      	mov	r3, r2
   869ce:	47a8      	blx	r5
	tft_button(400,CalcY(10,4,4),300,CalcHeight(10,4),"OK",1,RA8875_GREEN,10);
   869d0:	4b22      	ldr	r3, [pc, #136]	; (86a5c <tft_drawcalcbuttons+0x18c>)
   869d2:	9300      	str	r3, [sp, #0]
   869d4:	2301      	movs	r3, #1
   869d6:	9301      	str	r3, [sp, #4]
   869d8:	f44f 63fc 	mov.w	r3, #2016	; 0x7e0
   869dc:	9302      	str	r3, [sp, #8]
   869de:	9403      	str	r4, [sp, #12]
   869e0:	f44f 70c8 	mov.w	r0, #400	; 0x190
   869e4:	f240 116d 	movw	r1, #365	; 0x16d
   869e8:	f44f 7296 	mov.w	r2, #300	; 0x12c
   869ec:	236e      	movs	r3, #110	; 0x6e
   869ee:	47a8      	blx	r5
	tft_button(400,CalcY(10,4,3),300,CalcHeight(10,4),"Zrui",2,RA8875_RED,10);
   869f0:	4b1b      	ldr	r3, [pc, #108]	; (86a60 <tft_drawcalcbuttons+0x190>)
   869f2:	9300      	str	r3, [sp, #0]
   869f4:	2302      	movs	r3, #2
   869f6:	9301      	str	r3, [sp, #4]
   869f8:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   869fc:	9302      	str	r3, [sp, #8]
   869fe:	9403      	str	r4, [sp, #12]
   86a00:	f44f 70c8 	mov.w	r0, #400	; 0x190
   86a04:	21f5      	movs	r1, #245	; 0xf5
   86a06:	f44f 7296 	mov.w	r2, #300	; 0x12c
   86a0a:	236e      	movs	r3, #110	; 0x6e
   86a0c:	47a8      	blx	r5
	tft_button(CalcX(10,4,2),CalcY(10,4,4),CalcHeight(10,4),CalcHeight(10,4),",",4   ,RA8875_LIME,10);
   86a0e:	4b15      	ldr	r3, [pc, #84]	; (86a64 <tft_drawcalcbuttons+0x194>)
   86a10:	9300      	str	r3, [sp, #0]
   86a12:	2304      	movs	r3, #4
   86a14:	9301      	str	r3, [sp, #4]
   86a16:	9602      	str	r6, [sp, #8]
   86a18:	9403      	str	r4, [sp, #12]
   86a1a:	207d      	movs	r0, #125	; 0x7d
   86a1c:	f240 116d 	movw	r1, #365	; 0x16d
   86a20:	226e      	movs	r2, #110	; 0x6e
   86a22:	4613      	mov	r3, r2
   86a24:	47a8      	blx	r5
	
}
   86a26:	b004      	add	sp, #16
   86a28:	bd70      	pop	{r4, r5, r6, pc}
   86a2a:	bf00      	nop
   86a2c:	000917fc 	.word	0x000917fc
   86a30:	0008688d 	.word	0x0008688d
   86a34:	0009175c 	.word	0x0009175c
   86a38:	00091760 	.word	0x00091760
   86a3c:	00091764 	.word	0x00091764
   86a40:	00091768 	.word	0x00091768
   86a44:	0009176c 	.word	0x0009176c
   86a48:	00091770 	.word	0x00091770
   86a4c:	00091774 	.word	0x00091774
   86a50:	00091778 	.word	0x00091778
   86a54:	0009177c 	.word	0x0009177c
   86a58:	00091780 	.word	0x00091780
   86a5c:	00091784 	.word	0x00091784
   86a60:	00091788 	.word	0x00091788
   86a64:	00091790 	.word	0x00091790

00086a68 <TC0_Handler>:
	}
}


void TC0_Handler(void)
{
   86a68:	b082      	sub	sp, #8
	volatile uint32_t ul_status;
	ul_status = TC0->TC_CHANNEL->TC_SR;	//	vynulujem priznak prerusenie
   86a6a:	4b05      	ldr	r3, [pc, #20]	; (86a80 <TC0_Handler+0x18>)
   86a6c:	6a1b      	ldr	r3, [r3, #32]
   86a6e:	9301      	str	r3, [sp, #4]
	if(ul_status)
   86a70:	9b01      	ldr	r3, [sp, #4]
   86a72:	b113      	cbz	r3, 86a7a <TC0_Handler+0x12>
		needtouch = true;
   86a74:	2201      	movs	r2, #1
   86a76:	4b03      	ldr	r3, [pc, #12]	; (86a84 <TC0_Handler+0x1c>)
   86a78:	705a      	strb	r2, [r3, #1]
//	live_counter++;
//	tft_JoyPWMset();
//	need_joystick = true;
	
}
   86a7a:	b002      	add	sp, #8
   86a7c:	4770      	bx	lr
   86a7e:	bf00      	nop
   86a80:	40080000 	.word	0x40080000
   86a84:	20000f49 	.word	0x20000f49

00086a88 <tft_InitTimer>:
}


void tft_InitTimer()
{
	PMC->PMC_PCER0 |= 1 << ID_TC0;
   86a88:	4a0e      	ldr	r2, [pc, #56]	; (86ac4 <tft_InitTimer+0x3c>)
   86a8a:	6913      	ldr	r3, [r2, #16]
   86a8c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   86a90:	6113      	str	r3, [r2, #16]
	
	// Disable TC clock
	TC0->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKDIS;
   86a92:	4b0d      	ldr	r3, [pc, #52]	; (86ac8 <tft_InitTimer+0x40>)
   86a94:	2202      	movs	r2, #2
   86a96:	601a      	str	r2, [r3, #0]
	
	// Disable interrupts
	TC0->TC_CHANNEL[0].TC_IDR = 0xFFFFFFFF;
   86a98:	f04f 32ff 	mov.w	r2, #4294967295
   86a9c:	629a      	str	r2, [r3, #40]	; 0x28
	
	// Clear status register
	TC0->TC_CHANNEL[0].TC_SR;
   86a9e:	6a1a      	ldr	r2, [r3, #32]
	
	// Set Mode
	TC0->TC_CHANNEL[0].TC_CMR = TC_CMR_CPCTRG | TC_CMR_TCCLKS_TIMER_CLOCK5;
   86aa0:	f244 0204 	movw	r2, #16388	; 0x4004
   86aa4:	605a      	str	r2, [r3, #4]
	
	// Compare Value
	TC0->TC_CHANNEL[0].TC_RC = 1000; // 24 = 1 ms; 59 = 2 ms
   86aa6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   86aaa:	61da      	str	r2, [r3, #28]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   86aac:	4a07      	ldr	r2, [pc, #28]	; (86acc <tft_InitTimer+0x44>)
   86aae:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   86ab2:	6011      	str	r1, [r2, #0]
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   86ab4:	21b0      	movs	r1, #176	; 0xb0
   86ab6:	f882 131b 	strb.w	r1, [r2, #795]	; 0x31b
	
	// Configure and enable interrupt on RC compare
	NVIC_EnableIRQ(TC0_IRQn);
	NVIC_SetPriority(TC0_IRQn, 11);	//	Toto prerusenie musi mat nizsiu prioritu ako prerusenie pre casovanie motorov

	TC0->TC_CHANNEL[0].TC_IER = TC_IER_CPCS;
   86aba:	2210      	movs	r2, #16
   86abc:	625a      	str	r2, [r3, #36]	; 0x24
	
	// Reset counter (SWTRG) and enable counter clock (CLKEN)
	TC0->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
   86abe:	2205      	movs	r2, #5
   86ac0:	601a      	str	r2, [r3, #0]
   86ac2:	4770      	bx	lr
   86ac4:	400e0600 	.word	0x400e0600
   86ac8:	40080000 	.word	0x40080000
   86acc:	e000e100 	.word	0xe000e100

00086ad0 <tft_init>:

	return SPI0->SPI_RDR & 0x00FF ;
}

void tft_init()
{ 
   86ad0:	b510      	push	{r4, lr}
   86ad2:	b082      	sub	sp, #8
	  tft_width = 800;
   86ad4:	f44f 7248 	mov.w	r2, #800	; 0x320
   86ad8:	4b43      	ldr	r3, [pc, #268]	; (86be8 <tft_init+0x118>)
   86ada:	801a      	strh	r2, [r3, #0]
	  tft_height = 480;
   86adc:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   86ae0:	4b42      	ldr	r3, [pc, #264]	; (86bec <tft_init+0x11c>)
   86ae2:	801a      	strh	r2, [r3, #0]
	  tft_is_text_mode = false;
   86ae4:	2400      	movs	r4, #0
   86ae6:	4b42      	ldr	r3, [pc, #264]	; (86bf0 <tft_init+0x120>)
   86ae8:	701c      	strb	r4, [r3, #0]
	  PMC->PMC_PCER0 |= 1 << ID_PIOA;
   86aea:	4a42      	ldr	r2, [pc, #264]	; (86bf4 <tft_init+0x124>)
   86aec:	6913      	ldr	r3, [r2, #16]
   86aee:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   86af2:	6113      	str	r3, [r2, #16]
	  PMC->PMC_PCER0 |= 1 << ID_PIOB;
   86af4:	6913      	ldr	r3, [r2, #16]
   86af6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   86afa:	6113      	str	r3, [r2, #16]
	  PMC->PMC_PCER0 |= 1 << ID_PIOD;
   86afc:	6913      	ldr	r3, [r2, #16]
   86afe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   86b02:	6113      	str	r3, [r2, #16]
	  
	  PIOA->PIO_PDR |= PIO_PA25;		//MISO
   86b04:	4b3c      	ldr	r3, [pc, #240]	; (86bf8 <tft_init+0x128>)
   86b06:	6859      	ldr	r1, [r3, #4]
   86b08:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   86b0c:	6059      	str	r1, [r3, #4]
	  PIOA->PIO_ODR |= PIO_PA25;		//Input
   86b0e:	6959      	ldr	r1, [r3, #20]
   86b10:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   86b14:	6159      	str	r1, [r3, #20]
	  
	  PIOA->PIO_PDR |= PIO_PA26;		//MOSI
   86b16:	6859      	ldr	r1, [r3, #4]
   86b18:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
   86b1c:	6059      	str	r1, [r3, #4]
	  PIOA->PIO_OER |= PIO_PA26;		//MOSI	Output
   86b1e:	6919      	ldr	r1, [r3, #16]
   86b20:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
   86b24:	6119      	str	r1, [r3, #16]
	  PIOA->PIO_ABSR &= ~PIO_PA26;		//Peripheral A
   86b26:	6f19      	ldr	r1, [r3, #112]	; 0x70
   86b28:	f021 6180 	bic.w	r1, r1, #67108864	; 0x4000000
   86b2c:	6719      	str	r1, [r3, #112]	; 0x70
	  
	  PIOA->PIO_PDR |= PIO_PA27;		//SPCK
   86b2e:	6859      	ldr	r1, [r3, #4]
   86b30:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
   86b34:	6059      	str	r1, [r3, #4]
	  PIOA->PIO_OER |= PIO_PA27;		//SPCK	Output
   86b36:	6919      	ldr	r1, [r3, #16]
   86b38:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
   86b3c:	6119      	str	r1, [r3, #16]
	  PIOA->PIO_ABSR &= ~PIO_PA27;		//Peripheral A
   86b3e:	6f19      	ldr	r1, [r3, #112]	; 0x70
   86b40:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
   86b44:	6719      	str	r1, [r3, #112]	; 0x70
	  
	  PIOD->PIO_OER |= PIO_PD8;			//CS pre displej
   86b46:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
   86b4a:	6919      	ldr	r1, [r3, #16]
   86b4c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   86b50:	6119      	str	r1, [r3, #16]
	  //	PIOA->PIO_ABSR &= ~PIO_PA29;	//Peripheral B
	  PIOD->PIO_PUER |= PIO_PD8;		//pull-up
   86b52:	6e59      	ldr	r1, [r3, #100]	; 0x64
   86b54:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   86b58:	6659      	str	r1, [r3, #100]	; 0x64
	  lcd_spi_cs_high();				//
   86b5a:	f44f 7180 	mov.w	r1, #256	; 0x100
   86b5e:	6319      	str	r1, [r3, #48]	; 0x30


	  //Enable clock for the SPI0 peripheral
	  PMC->PMC_PCER0 |= 1 << ID_SPI0;
   86b60:	6913      	ldr	r3, [r2, #16]
   86b62:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   86b66:	6113      	str	r3, [r2, #16]
	  //Disable the SPI0 peripheral so we can configure it.
	  SPI0->SPI_CR = SPI_CR_SPIDIS;
   86b68:	4b24      	ldr	r3, [pc, #144]	; (86bfc <tft_init+0x12c>)
   86b6a:	2202      	movs	r2, #2
   86b6c:	601a      	str	r2, [r3, #0]
	  //Set as Master, Fixed Peripheral Select, Mode Fault Detection disabled and
	  //	Peripheral Chip Select is PCS = xxx0 NPCS[3:0] = 1110
	  SPI0->SPI_MR = SPI_MR_MSTR | SPI_MR_MODFDIS | 0x000e0000;
   86b6e:	4a24      	ldr	r2, [pc, #144]	; (86c00 <tft_init+0x130>)
   86b70:	605a      	str	r2, [r3, #4]
	  //SPCK baudrate = MCK / SCBR = 84MHz / 128 = 656250Hz
	  SPI0->SPI_CSR[0] |= 0x0000FF00  | 1 << 1;
   86b72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   86b74:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
   86b78:	f042 0202 	orr.w	r2, r2, #2
   86b7c:	631a      	str	r2, [r3, #48]	; 0x30
	  //Enable the SPI0 unit
	  SPI0->SPI_CR = SPI_CR_SPIEN;
   86b7e:	2201      	movs	r2, #1
   86b80:	601a      	str	r2, [r3, #0]
	  delay_ms(10);
   86b82:	200a      	movs	r0, #10
   86b84:	4b1f      	ldr	r3, [pc, #124]	; (86c04 <tft_init+0x134>)
   86b86:	4798      	blx	r3
	  volatile unsigned char x;
	  x = tft_readReg(0);
   86b88:	4620      	mov	r0, r4
   86b8a:	4b1f      	ldr	r3, [pc, #124]	; (86c08 <tft_init+0x138>)
   86b8c:	4798      	blx	r3
   86b8e:	f88d 0007 	strb.w	r0, [sp, #7]
	  if (x != 0x75) {
   86b92:	f89d 3007 	ldrb.w	r3, [sp, #7]
   86b96:	b2db      	uxtb	r3, r3
   86b98:	2b75      	cmp	r3, #117	; 0x75
   86b9a:	d123      	bne.n	86be4 <tft_init+0x114>
		  return ;
	  }
	tft_initialize();
   86b9c:	4b1b      	ldr	r3, [pc, #108]	; (86c0c <tft_init+0x13c>)
   86b9e:	4798      	blx	r3
  	tft_displayOn(true);
   86ba0:	2001      	movs	r0, #1
   86ba2:	4b1b      	ldr	r3, [pc, #108]	; (86c10 <tft_init+0x140>)
   86ba4:	4798      	blx	r3
	tft_GPIOX(true);      // Enable TFT - display enable tied to GPIOX
   86ba6:	2001      	movs	r0, #1
   86ba8:	4b1a      	ldr	r3, [pc, #104]	; (86c14 <tft_init+0x144>)
   86baa:	4798      	blx	r3

*/
/**************************************************************************/
void tft_PWM1config(bool on, uint8_t clock) {
  if (on) {
    tft_writeReg(RA8875_P1CR, RA8875_P1CR_ENABLE | (clock & 0xF));
   86bac:	208a      	movs	r0, #138	; 0x8a
   86bae:	4601      	mov	r1, r0
   86bb0:	4b19      	ldr	r3, [pc, #100]	; (86c18 <tft_init+0x148>)
   86bb2:	4798      	blx	r3
	  }
	tft_initialize();
  	tft_displayOn(true);
	tft_GPIOX(true);      // Enable TFT - display enable tied to GPIOX
	tft_PWM1config(true, RA8875_PWM_CLK_DIV1024); // PWM output for backlight
	tft_PWM1out(255);
   86bb4:	20ff      	movs	r0, #255	; 0xff
   86bb6:	4b19      	ldr	r3, [pc, #100]	; (86c1c <tft_init+0x14c>)
   86bb8:	4798      	blx	r3
	  	
	tft_graphicsMode();                 // go back to graphics mode
   86bba:	4b19      	ldr	r3, [pc, #100]	; (86c20 <tft_init+0x150>)
   86bbc:	4798      	blx	r3
	tft_fillScreen(RA8875_LIME);
   86bbe:	f64c 70e0 	movw	r0, #53216	; 0xcfe0
   86bc2:	4b18      	ldr	r3, [pc, #96]	; (86c24 <tft_init+0x154>)
   86bc4:	4798      	blx	r3
	tft_textMode();
   86bc6:	4b18      	ldr	r3, [pc, #96]	; (86c28 <tft_init+0x158>)
   86bc8:	4798      	blx	r3
	tft_textEnlarge(0);
   86bca:	4620      	mov	r0, r4
   86bcc:	4b17      	ldr	r3, [pc, #92]	; (86c2c <tft_init+0x15c>)
   86bce:	4798      	blx	r3
	tft_textColor(RA8875_WHITE,RA8875_BLACK);
   86bd0:	f64f 70ff 	movw	r0, #65535	; 0xffff
   86bd4:	4621      	mov	r1, r4
   86bd6:	4b16      	ldr	r3, [pc, #88]	; (86c30 <tft_init+0x160>)
   86bd8:	4798      	blx	r3
	tft_touchEnable(true);
   86bda:	2001      	movs	r0, #1
   86bdc:	4b15      	ldr	r3, [pc, #84]	; (86c34 <tft_init+0x164>)
   86bde:	4798      	blx	r3
	tft_InitTimer();
   86be0:	4b15      	ldr	r3, [pc, #84]	; (86c38 <tft_init+0x168>)
   86be2:	4798      	blx	r3
}
   86be4:	b002      	add	sp, #8
   86be6:	bd10      	pop	{r4, pc}
   86be8:	2000124e 	.word	0x2000124e
   86bec:	20001480 	.word	0x20001480
   86bf0:	2000124c 	.word	0x2000124c
   86bf4:	400e0600 	.word	0x400e0600
   86bf8:	400e0e00 	.word	0x400e0e00
   86bfc:	40008000 	.word	0x40008000
   86c00:	000e0011 	.word	0x000e0011
   86c04:	00089689 	.word	0x00089689
   86c08:	00085b49 	.word	0x00085b49
   86c0c:	00085a1d 	.word	0x00085a1d
   86c10:	00085b2d 	.word	0x00085b2d
   86c14:	00085b01 	.word	0x00085b01
   86c18:	000859e1 	.word	0x000859e1
   86c1c:	00085b1d 	.word	0x00085b1d
   86c20:	00085875 	.word	0x00085875
   86c24:	00085e2d 	.word	0x00085e2d
   86c28:	000854dd 	.word	0x000854dd
   86c2c:	000855b1 	.word	0x000855b1
   86c30:	00085551 	.word	0x00085551
   86c34:	00085b75 	.word	0x00085b75
   86c38:	00086a89 	.word	0x00086a89

00086c3c <tft_calibrate_load>:
	// Reset counter (SWTRG) and enable counter clock (CLKEN)
	TC0->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
}

void tft_calibrate_load(void)
{
   86c3c:	b5f0      	push	{r4, r5, r6, r7, lr}
   86c3e:	b089      	sub	sp, #36	; 0x24
   86c40:	f10d 0403 	add.w	r4, sp, #3
   86c44:	f10d 071f 	add.w	r7, sp, #31
   86c48:	ab08      	add	r3, sp, #32
   86c4a:	f1c3 0621 	rsb	r6, r3, #33	; 0x21
	uint8_t buffer[28];
	for(int i = 0; i< 28; i++)
		buffer[i] = flash_read_8(4 + i);
   86c4e:	4d08      	ldr	r5, [pc, #32]	; (86c70 <tft_calibrate_load+0x34>)
   86c50:	1930      	adds	r0, r6, r4
   86c52:	47a8      	blx	r5
   86c54:	f804 0f01 	strb.w	r0, [r4, #1]!
}

void tft_calibrate_load(void)
{
	uint8_t buffer[28];
	for(int i = 0; i< 28; i++)
   86c58:	42bc      	cmp	r4, r7
   86c5a:	d1f9      	bne.n	86c50 <tft_calibrate_load+0x14>
		buffer[i] = flash_read_8(4 + i);
	memcpy(&TouchCalibration,buffer,28);
   86c5c:	4c05      	ldr	r4, [pc, #20]	; (86c74 <tft_calibrate_load+0x38>)
   86c5e:	ad01      	add	r5, sp, #4
   86c60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   86c62:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   86c64:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   86c68:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
   86c6c:	b009      	add	sp, #36	; 0x24
   86c6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   86c70:	00082465 	.word	0x00082465
   86c74:	200014d0 	.word	0x200014d0

00086c78 <beep>:
	flash_write_buffer(4,buffer,28);
}


void beep(int ms)
{
   86c78:	b538      	push	{r3, r4, r5, lr}
	PMC->PMC_PCER0 |= 1 << ID_PIOA;	//	Beep existuje este ako samostatna procedura
   86c7a:	4a08      	ldr	r2, [pc, #32]	; (86c9c <beep+0x24>)
   86c7c:	6913      	ldr	r3, [r2, #16]
   86c7e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   86c82:	6113      	str	r3, [r2, #16]
	PIOA->PIO_OER |= PIO_PA16;
   86c84:	4c06      	ldr	r4, [pc, #24]	; (86ca0 <beep+0x28>)
   86c86:	6923      	ldr	r3, [r4, #16]
   86c88:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   86c8c:	6123      	str	r3, [r4, #16]
	PIOA->PIO_SODR = PIO_PA16;
   86c8e:	f44f 3580 	mov.w	r5, #65536	; 0x10000
   86c92:	6325      	str	r5, [r4, #48]	; 0x30
	delay_ms(ms);
   86c94:	4b03      	ldr	r3, [pc, #12]	; (86ca4 <beep+0x2c>)
   86c96:	4798      	blx	r3
	PIOA->PIO_CODR = PIO_PA16;
   86c98:	6365      	str	r5, [r4, #52]	; 0x34
   86c9a:	bd38      	pop	{r3, r4, r5, pc}
   86c9c:	400e0600 	.word	0x400e0600
   86ca0:	400e0e00 	.word	0x400e0e00
   86ca4:	00089689 	.word	0x00089689

00086ca8 <setCalibrationMatrix>:
}

int setCalibrationMatrix( POINT * displayPtr,POINT * screenPtr,TOUCH_MATRIX * matrixPtr)
{
   86ca8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int  retValue = 0 ;
	matrixPtr->Divider = ((screenPtr[0].x - screenPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) -	((screenPtr[1].x - screenPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;
   86cac:	690f      	ldr	r7, [r1, #16]
   86cae:	694d      	ldr	r5, [r1, #20]
   86cb0:	680b      	ldr	r3, [r1, #0]
   86cb2:	1bdc      	subs	r4, r3, r7
   86cb4:	68cb      	ldr	r3, [r1, #12]
   86cb6:	1b5b      	subs	r3, r3, r5
   86cb8:	688e      	ldr	r6, [r1, #8]
   86cba:	1bf6      	subs	r6, r6, r7
   86cbc:	684f      	ldr	r7, [r1, #4]
   86cbe:	1bed      	subs	r5, r5, r7
   86cc0:	fb05 f506 	mul.w	r5, r5, r6
   86cc4:	fb03 5304 	mla	r3, r3, r4, r5
   86cc8:	6193      	str	r3, [r2, #24]
	if ( matrixPtr->Divider == 0 )
   86cca:	2b00      	cmp	r3, #0
   86ccc:	d07b      	beq.n	86dc6 <setCalibrationMatrix+0x11e>
	{
		retValue = -1 ;
	}
	else
	{
		matrixPtr->An = ((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) -
   86cce:	6907      	ldr	r7, [r0, #16]
   86cd0:	694b      	ldr	r3, [r1, #20]
   86cd2:	6804      	ldr	r4, [r0, #0]
   86cd4:	1be4      	subs	r4, r4, r7
   86cd6:	68cd      	ldr	r5, [r1, #12]
   86cd8:	1aed      	subs	r5, r5, r3
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;
   86cda:	6886      	ldr	r6, [r0, #8]
   86cdc:	1bf6      	subs	r6, r6, r7
   86cde:	684f      	ldr	r7, [r1, #4]
   86ce0:	1bdb      	subs	r3, r3, r7
   86ce2:	fb03 f306 	mul.w	r3, r3, r6
	{
		retValue = -1 ;
	}
	else
	{
		matrixPtr->An = ((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) -
   86ce6:	fb05 3304 	mla	r3, r5, r4, r3
   86cea:	6013      	str	r3, [r2, #0]
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
   86cec:	690b      	ldr	r3, [r1, #16]
   86cee:	6907      	ldr	r7, [r0, #16]
   86cf0:	680c      	ldr	r4, [r1, #0]
   86cf2:	1ae4      	subs	r4, r4, r3
   86cf4:	6885      	ldr	r5, [r0, #8]
   86cf6:	1bed      	subs	r5, r5, r7
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;
   86cf8:	6806      	ldr	r6, [r0, #0]
   86cfa:	1bf6      	subs	r6, r6, r7
   86cfc:	688f      	ldr	r7, [r1, #8]
   86cfe:	1bdb      	subs	r3, r3, r7
   86d00:	fb03 f306 	mul.w	r3, r3, r6
	else
	{
		matrixPtr->An = ((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) -
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
   86d04:	fb05 3304 	mla	r3, r5, r4, r3
   86d08:	6053      	str	r3, [r2, #4]
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
   86d0a:	690d      	ldr	r5, [r1, #16]
   86d0c:	6883      	ldr	r3, [r0, #8]
   86d0e:	f8d1 c008 	ldr.w	ip, [r1, #8]
   86d12:	6906      	ldr	r6, [r0, #16]
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
   86d14:	f8d1 e000 	ldr.w	lr, [r1]
   86d18:	6804      	ldr	r4, [r0, #0]
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
   86d1a:	fb03 f705 	mul.w	r7, r3, r5
   86d1e:	fb06 781c 	mls	r8, r6, ip, r7
   86d22:	684f      	ldr	r7, [r1, #4]
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
   86d24:	fb0e f606 	mul.w	r6, lr, r6
   86d28:	fb04 6515 	mls	r5, r4, r5, r6
   86d2c:	68ce      	ldr	r6, [r1, #12]
   86d2e:	fb06 f505 	mul.w	r5, r6, r5
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
   86d32:	fb07 5708 	mla	r7, r7, r8, r5
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
		(screenPtr[1].x * displayPtr[0].x - screenPtr[0].x * displayPtr[1].x) * screenPtr[2].y ;
   86d36:	fb04 f40c 	mul.w	r4, r4, ip
   86d3a:	fb0e 4413 	mls	r4, lr, r3, r4
   86d3e:	694b      	ldr	r3, [r1, #20]

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
   86d40:	fb03 7304 	mla	r3, r3, r4, r7
		((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) -
		((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
   86d44:	6093      	str	r3, [r2, #8]
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
		(screenPtr[1].x * displayPtr[0].x - screenPtr[0].x * displayPtr[1].x) * screenPtr[2].y ;

		matrixPtr->Dn = ((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].y - screenPtr[2].y)) -
   86d46:	6947      	ldr	r7, [r0, #20]
   86d48:	694b      	ldr	r3, [r1, #20]
   86d4a:	6844      	ldr	r4, [r0, #4]
   86d4c:	1be4      	subs	r4, r4, r7
   86d4e:	68cd      	ldr	r5, [r1, #12]
   86d50:	1aed      	subs	r5, r5, r3
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;
   86d52:	68c6      	ldr	r6, [r0, #12]
   86d54:	1bf6      	subs	r6, r6, r7
   86d56:	684f      	ldr	r7, [r1, #4]
   86d58:	1bdb      	subs	r3, r3, r7
   86d5a:	fb03 f306 	mul.w	r3, r3, r6

		matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
		(screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
		(screenPtr[1].x * displayPtr[0].x - screenPtr[0].x * displayPtr[1].x) * screenPtr[2].y ;

		matrixPtr->Dn = ((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].y - screenPtr[2].y)) -
   86d5e:	fb05 3304 	mla	r3, r5, r4, r3
   86d62:	60d3      	str	r3, [r2, #12]
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
   86d64:	690b      	ldr	r3, [r1, #16]
   86d66:	6947      	ldr	r7, [r0, #20]
   86d68:	680c      	ldr	r4, [r1, #0]
   86d6a:	1ae4      	subs	r4, r4, r3
   86d6c:	68c5      	ldr	r5, [r0, #12]
   86d6e:	1bed      	subs	r5, r5, r7
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;
   86d70:	6846      	ldr	r6, [r0, #4]
   86d72:	1bf6      	subs	r6, r6, r7
   86d74:	688f      	ldr	r7, [r1, #8]
   86d76:	1bdb      	subs	r3, r3, r7
   86d78:	fb03 f306 	mul.w	r3, r3, r6
		(screenPtr[1].x * displayPtr[0].x - screenPtr[0].x * displayPtr[1].x) * screenPtr[2].y ;

		matrixPtr->Dn = ((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].y - screenPtr[2].y)) -
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
   86d7c:	fb05 3304 	mla	r3, r5, r4, r3
   86d80:	6113      	str	r3, [r2, #16]
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
   86d82:	690f      	ldr	r7, [r1, #16]
   86d84:	68c3      	ldr	r3, [r0, #12]
   86d86:	f8d1 c008 	ldr.w	ip, [r1, #8]
   86d8a:	f8d0 8014 	ldr.w	r8, [r0, #20]
		(screenPtr[0].x * displayPtr[2].y - screenPtr[2].x * displayPtr[0].y) * screenPtr[1].y +
   86d8e:	f8d1 e000 	ldr.w	lr, [r1]
   86d92:	6846      	ldr	r6, [r0, #4]
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
   86d94:	fb03 f407 	mul.w	r4, r3, r7
   86d98:	fb08 451c 	mls	r5, r8, ip, r4
		(screenPtr[0].x * displayPtr[2].y - screenPtr[2].x * displayPtr[0].y) * screenPtr[1].y +
   86d9c:	fb0e f808 	mul.w	r8, lr, r8
   86da0:	fb06 8717 	mls	r7, r6, r7, r8
   86da4:	68cc      	ldr	r4, [r1, #12]
   86da6:	fb04 f707 	mul.w	r7, r4, r7
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
   86daa:	6848      	ldr	r0, [r1, #4]
   86dac:	fb00 7405 	mla	r4, r0, r5, r7
		(screenPtr[0].x * displayPtr[2].y - screenPtr[2].x * displayPtr[0].y) * screenPtr[1].y +
		(screenPtr[1].x * displayPtr[0].y - screenPtr[0].x * displayPtr[1].y) * screenPtr[2].y ;
   86db0:	fb06 f60c 	mul.w	r6, r6, ip
   86db4:	fb0e 6013 	mls	r0, lr, r3, r6
   86db8:	694b      	ldr	r3, [r1, #20]

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
		(screenPtr[0].x * displayPtr[2].y - screenPtr[2].x * displayPtr[0].y) * screenPtr[1].y +
   86dba:	fb03 4300 	mla	r3, r3, r0, r4
		((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;

		matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) -
		((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;

		matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
   86dbe:	6153      	str	r3, [r2, #20]
	PIOA->PIO_CODR = PIO_PA16;
}

int setCalibrationMatrix( POINT * displayPtr,POINT * screenPtr,TOUCH_MATRIX * matrixPtr)
{
	int  retValue = 0 ;
   86dc0:	2000      	movs	r0, #0
   86dc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	matrixPtr->Divider = ((screenPtr[0].x - screenPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) -	((screenPtr[1].x - screenPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;
	if ( matrixPtr->Divider == 0 )
	{
		retValue = -1 ;
   86dc6:	f04f 30ff 	mov.w	r0, #4294967295
		(screenPtr[1].x * displayPtr[0].y - screenPtr[0].x * displayPtr[1].y) * screenPtr[2].y ;
	}

	return( retValue ) ;

} /* end of setCalibrationMatrix() */
   86dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   86dce:	bf00      	nop

00086dd0 <getDisplayPoint>:

int getDisplayPoint( POINT * displayPtr,POINT * screenPtr,TOUCH_MATRIX * matrixPtr )
{
   86dd0:	b4f0      	push	{r4, r5, r6, r7}
	int  retValue = 0 ;
	if ( matrixPtr->Divider != 0 )
   86dd2:	6996      	ldr	r6, [r2, #24]
   86dd4:	b1e6      	cbz	r6, 86e10 <getDisplayPoint+0x40>
	{
		/* Operation order is important since we are doing integer */
		/*  math. Make sure you add all terms together before      */
		/*  dividing, so that the remainder is not rounded off     */
		/*  prematurely.                                           */
		displayPtr->x = ( (matrixPtr->An * screenPtr->x) +
   86dd6:	6814      	ldr	r4, [r2, #0]
   86dd8:	680b      	ldr	r3, [r1, #0]
		(matrixPtr->Bn * screenPtr->y) +
   86dda:	6857      	ldr	r7, [r2, #4]
   86ddc:	684d      	ldr	r5, [r1, #4]
   86dde:	fb05 f507 	mul.w	r5, r5, r7
	{
		/* Operation order is important since we are doing integer */
		/*  math. Make sure you add all terms together before      */
		/*  dividing, so that the remainder is not rounded off     */
		/*  prematurely.                                           */
		displayPtr->x = ( (matrixPtr->An * screenPtr->x) +
   86de2:	fb03 5404 	mla	r4, r3, r4, r5
		(matrixPtr->Bn * screenPtr->y) +
   86de6:	6893      	ldr	r3, [r2, #8]
   86de8:	4423      	add	r3, r4
		matrixPtr->Cn
		) / matrixPtr->Divider ;
   86dea:	fb93 f3f6 	sdiv	r3, r3, r6
	{
		/* Operation order is important since we are doing integer */
		/*  math. Make sure you add all terms together before      */
		/*  dividing, so that the remainder is not rounded off     */
		/*  prematurely.                                           */
		displayPtr->x = ( (matrixPtr->An * screenPtr->x) +
   86dee:	6003      	str	r3, [r0, #0]
		(matrixPtr->Bn * screenPtr->y) +
		matrixPtr->Cn
		) / matrixPtr->Divider ;

		displayPtr->y = ( (matrixPtr->Dn * screenPtr->x) +
   86df0:	68d4      	ldr	r4, [r2, #12]
   86df2:	680d      	ldr	r5, [r1, #0]
		(matrixPtr->En * screenPtr->y) +
   86df4:	6913      	ldr	r3, [r2, #16]
   86df6:	6849      	ldr	r1, [r1, #4]
   86df8:	fb01 f303 	mul.w	r3, r1, r3
		displayPtr->x = ( (matrixPtr->An * screenPtr->x) +
		(matrixPtr->Bn * screenPtr->y) +
		matrixPtr->Cn
		) / matrixPtr->Divider ;

		displayPtr->y = ( (matrixPtr->Dn * screenPtr->x) +
   86dfc:	fb05 3404 	mla	r4, r5, r4, r3
		(matrixPtr->En * screenPtr->y) +
   86e00:	6953      	ldr	r3, [r2, #20]
   86e02:	4423      	add	r3, r4
		matrixPtr->Fn
		) / matrixPtr->Divider ;
   86e04:	6992      	ldr	r2, [r2, #24]
   86e06:	fb93 f3f2 	sdiv	r3, r3, r2
		displayPtr->x = ( (matrixPtr->An * screenPtr->x) +
		(matrixPtr->Bn * screenPtr->y) +
		matrixPtr->Cn
		) / matrixPtr->Divider ;

		displayPtr->y = ( (matrixPtr->Dn * screenPtr->x) +
   86e0a:	6043      	str	r3, [r0, #4]

} /* end of setCalibrationMatrix() */

int getDisplayPoint( POINT * displayPtr,POINT * screenPtr,TOUCH_MATRIX * matrixPtr )
{
	int  retValue = 0 ;
   86e0c:	2000      	movs	r0, #0
   86e0e:	e001      	b.n	86e14 <getDisplayPoint+0x44>
		matrixPtr->Fn
		) / matrixPtr->Divider ;
	}
	else
	{
		retValue = -1 ;
   86e10:	f04f 30ff 	mov.w	r0, #4294967295
	}
	return( retValue ) ;
} /* end of getDisplayPoint() */
   86e14:	bcf0      	pop	{r4, r5, r6, r7}
   86e16:	4770      	bx	lr

00086e18 <tft_GetTouch>:
//	need_joystick = true;
	
}
void tft_GetTouch()
{
	if(!needtouch) return;
   86e18:	4b1e      	ldr	r3, [pc, #120]	; (86e94 <tft_GetTouch+0x7c>)
   86e1a:	785b      	ldrb	r3, [r3, #1]
   86e1c:	2b00      	cmp	r3, #0
   86e1e:	d038      	beq.n	86e92 <tft_GetTouch+0x7a>
//	tft_JoyPWMset();
//	need_joystick = true;
	
}
void tft_GetTouch()
{
   86e20:	b500      	push	{lr}
   86e22:	b087      	sub	sp, #28
	if(!needtouch) return;
	uint16_t x,y;
	POINT lcd, touch;
	needtouch = false;
   86e24:	2200      	movs	r2, #0
   86e26:	4b1b      	ldr	r3, [pc, #108]	; (86e94 <tft_GetTouch+0x7c>)
   86e28:	705a      	strb	r2, [r3, #1]
	if(tft_istouched())
   86e2a:	4b1b      	ldr	r3, [pc, #108]	; (86e98 <tft_GetTouch+0x80>)
   86e2c:	4798      	blx	r3
   86e2e:	b310      	cbz	r0, 86e76 <tft_GetTouch+0x5e>
	{
		tft_touchRead(&x,&y);
   86e30:	f10d 0016 	add.w	r0, sp, #22
   86e34:	a905      	add	r1, sp, #20
   86e36:	4b19      	ldr	r3, [pc, #100]	; (86e9c <tft_GetTouch+0x84>)
   86e38:	4798      	blx	r3
		if (Calibrating) {
   86e3a:	4b16      	ldr	r3, [pc, #88]	; (86e94 <tft_GetTouch+0x7c>)
   86e3c:	789b      	ldrb	r3, [r3, #2]
   86e3e:	b143      	cbz	r3, 86e52 <tft_GetTouch+0x3a>
			TouchXPos = x;
   86e40:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   86e44:	4b16      	ldr	r3, [pc, #88]	; (86ea0 <tft_GetTouch+0x88>)
   86e46:	601a      	str	r2, [r3, #0]
			TouchYPos = y;
   86e48:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   86e4c:	4b15      	ldr	r3, [pc, #84]	; (86ea4 <tft_GetTouch+0x8c>)
   86e4e:	601a      	str	r2, [r3, #0]
   86e50:	e01c      	b.n	86e8c <tft_GetTouch+0x74>
		} else {
			touch.x = x;
   86e52:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   86e56:	9301      	str	r3, [sp, #4]
			touch.y = y;
   86e58:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   86e5c:	9302      	str	r3, [sp, #8]
			getDisplayPoint(&lcd, &touch, &TouchCalibration);
   86e5e:	a803      	add	r0, sp, #12
   86e60:	a901      	add	r1, sp, #4
   86e62:	4a11      	ldr	r2, [pc, #68]	; (86ea8 <tft_GetTouch+0x90>)
   86e64:	4b11      	ldr	r3, [pc, #68]	; (86eac <tft_GetTouch+0x94>)
   86e66:	4798      	blx	r3
			TouchXPos = lcd.x;
   86e68:	4b0d      	ldr	r3, [pc, #52]	; (86ea0 <tft_GetTouch+0x88>)
   86e6a:	9a03      	ldr	r2, [sp, #12]
   86e6c:	601a      	str	r2, [r3, #0]
			TouchYPos = lcd.y;
   86e6e:	4b0d      	ldr	r3, [pc, #52]	; (86ea4 <tft_GetTouch+0x8c>)
   86e70:	9a04      	ldr	r2, [sp, #16]
   86e72:	601a      	str	r2, [r3, #0]
   86e74:	e00a      	b.n	86e8c <tft_GetTouch+0x74>
		}
	}else if(dotyk)	//	Nie je stlacene, ale dotyk uz bol
   86e76:	4b0e      	ldr	r3, [pc, #56]	; (86eb0 <tft_GetTouch+0x98>)
   86e78:	781b      	ldrb	r3, [r3, #0]
   86e7a:	f013 0fff 	tst.w	r3, #255	; 0xff
   86e7e:	d005      	beq.n	86e8c <tft_GetTouch+0x74>
	{
		unpressed = 1;
   86e80:	2201      	movs	r2, #1
   86e82:	4b04      	ldr	r3, [pc, #16]	; (86e94 <tft_GetTouch+0x7c>)
   86e84:	70da      	strb	r2, [r3, #3]
		dotyk = 0;
   86e86:	2200      	movs	r2, #0
   86e88:	4b09      	ldr	r3, [pc, #36]	; (86eb0 <tft_GetTouch+0x98>)
   86e8a:	701a      	strb	r2, [r3, #0]
	}
}
   86e8c:	b007      	add	sp, #28
   86e8e:	f85d fb04 	ldr.w	pc, [sp], #4
   86e92:	4770      	bx	lr
   86e94:	20000f49 	.word	0x20000f49
   86e98:	00085bb9 	.word	0x00085bb9
   86e9c:	00085be1 	.word	0x00085be1
   86ea0:	20001504 	.word	0x20001504
   86ea4:	200014f8 	.word	0x200014f8
   86ea8:	200014d0 	.word	0x200014d0
   86eac:	00086dd1 	.word	0x00086dd1
   86eb0:	200014ec 	.word	0x200014ec

00086eb4 <tft_draw_press_unpress>:
		p = p->next;
	}while(p);
}

void tft_draw_press_unpress(void)
{
   86eb4:	b508      	push	{r3, lr}
	tft_GetTouch();
   86eb6:	4b1f      	ldr	r3, [pc, #124]	; (86f34 <tft_draw_press_unpress+0x80>)
   86eb8:	4798      	blx	r3
	if((TouchXPos != 0) && (TouchYPos != 0))
   86eba:	4b1f      	ldr	r3, [pc, #124]	; (86f38 <tft_draw_press_unpress+0x84>)
   86ebc:	681b      	ldr	r3, [r3, #0]
   86ebe:	2b00      	cmp	r3, #0
   86ec0:	d029      	beq.n	86f16 <tft_draw_press_unpress+0x62>
   86ec2:	4b1e      	ldr	r3, [pc, #120]	; (86f3c <tft_draw_press_unpress+0x88>)
   86ec4:	681b      	ldr	r3, [r3, #0]
   86ec6:	2b00      	cmp	r3, #0
   86ec8:	d025      	beq.n	86f16 <tft_draw_press_unpress+0x62>
	{
		if(!IsTouched)
   86eca:	4b1d      	ldr	r3, [pc, #116]	; (86f40 <tft_draw_press_unpress+0x8c>)
   86ecc:	781b      	ldrb	r3, [r3, #0]
   86ece:	f013 0fff 	tst.w	r3, #255	; 0xff
   86ed2:	d11b      	bne.n	86f0c <tft_draw_press_unpress+0x58>
		{
			if(tft_touched(TouchXPos,TouchYPos))	// ak som klikol niekde kde to zije
   86ed4:	4b18      	ldr	r3, [pc, #96]	; (86f38 <tft_draw_press_unpress+0x84>)
   86ed6:	6818      	ldr	r0, [r3, #0]
   86ed8:	4b18      	ldr	r3, [pc, #96]	; (86f3c <tft_draw_press_unpress+0x88>)
   86eda:	6819      	ldr	r1, [r3, #0]
   86edc:	4b19      	ldr	r3, [pc, #100]	; (86f44 <tft_draw_press_unpress+0x90>)
   86ede:	4798      	blx	r3
   86ee0:	b1a0      	cbz	r0, 86f0c <tft_draw_press_unpress+0x58>
			{
				if(!realtime)
   86ee2:	4b19      	ldr	r3, [pc, #100]	; (86f48 <tft_draw_press_unpress+0x94>)
   86ee4:	781b      	ldrb	r3, [r3, #0]
   86ee6:	f013 0fff 	tst.w	r3, #255	; 0xff
   86eea:	d102      	bne.n	86ef2 <tft_draw_press_unpress+0x3e>
					beep(10);
   86eec:	200a      	movs	r0, #10
   86eee:	4b17      	ldr	r3, [pc, #92]	; (86f4c <tft_draw_press_unpress+0x98>)
   86ef0:	4798      	blx	r3
				tft_graphicCursor(TouchXPos,TouchYPos);
   86ef2:	4b11      	ldr	r3, [pc, #68]	; (86f38 <tft_draw_press_unpress+0x84>)
   86ef4:	6818      	ldr	r0, [r3, #0]
   86ef6:	4b11      	ldr	r3, [pc, #68]	; (86f3c <tft_draw_press_unpress+0x88>)
   86ef8:	6819      	ldr	r1, [r3, #0]
   86efa:	b280      	uxth	r0, r0
   86efc:	b289      	uxth	r1, r1
   86efe:	4b14      	ldr	r3, [pc, #80]	; (86f50 <tft_draw_press_unpress+0x9c>)
   86f00:	4798      	blx	r3
				tft_graphicCursorType(1);
   86f02:	2001      	movs	r0, #1
   86f04:	4b13      	ldr	r3, [pc, #76]	; (86f54 <tft_draw_press_unpress+0xa0>)
   86f06:	4798      	blx	r3
				tft_graphicCursorEnable();
   86f08:	4b13      	ldr	r3, [pc, #76]	; (86f58 <tft_draw_press_unpress+0xa4>)
   86f0a:	4798      	blx	r3
			}
		}
		TouchXPos = 0;
   86f0c:	2300      	movs	r3, #0
   86f0e:	4a0a      	ldr	r2, [pc, #40]	; (86f38 <tft_draw_press_unpress+0x84>)
   86f10:	6013      	str	r3, [r2, #0]
		TouchYPos = 0;
   86f12:	4a0a      	ldr	r2, [pc, #40]	; (86f3c <tft_draw_press_unpress+0x88>)
   86f14:	6013      	str	r3, [r2, #0]
	}
	if(unpressed)
   86f16:	4b0a      	ldr	r3, [pc, #40]	; (86f40 <tft_draw_press_unpress+0x8c>)
   86f18:	78db      	ldrb	r3, [r3, #3]
   86f1a:	f013 0fff 	tst.w	r3, #255	; 0xff
   86f1e:	d008      	beq.n	86f32 <tft_draw_press_unpress+0x7e>
	{
		unpressed=false;
   86f20:	2200      	movs	r2, #0
   86f22:	4b07      	ldr	r3, [pc, #28]	; (86f40 <tft_draw_press_unpress+0x8c>)
   86f24:	70da      	strb	r2, [r3, #3]
		tft_untouched(LastTouchXPos,LastTouchYPos);
   86f26:	4b0d      	ldr	r3, [pc, #52]	; (86f5c <tft_draw_press_unpress+0xa8>)
   86f28:	6818      	ldr	r0, [r3, #0]
   86f2a:	4b0d      	ldr	r3, [pc, #52]	; (86f60 <tft_draw_press_unpress+0xac>)
   86f2c:	6819      	ldr	r1, [r3, #0]
   86f2e:	4b0d      	ldr	r3, [pc, #52]	; (86f64 <tft_draw_press_unpress+0xb0>)
   86f30:	4798      	blx	r3
   86f32:	bd08      	pop	{r3, pc}
   86f34:	00086e19 	.word	0x00086e19
   86f38:	20001504 	.word	0x20001504
   86f3c:	200014f8 	.word	0x200014f8
   86f40:	20000f49 	.word	0x20000f49
   86f44:	0008636d 	.word	0x0008636d
   86f48:	2000117c 	.word	0x2000117c
   86f4c:	00086c79 	.word	0x00086c79
   86f50:	00085975 	.word	0x00085975
   86f54:	000858b9 	.word	0x000858b9
   86f58:	000858a1 	.word	0x000858a1
   86f5c:	2000150c 	.word	0x2000150c
   86f60:	200014f4 	.word	0x200014f4
   86f64:	000866e1 	.word	0x000866e1

00086f68 <tft_GetInt>:
			}
		}
	}
}
int tft_GetInt(char *Text,int defval, int min, int max)
{
   86f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   86f6c:	b0a1      	sub	sp, #132	; 0x84
   86f6e:	4604      	mov	r4, r0
   86f70:	9105      	str	r1, [sp, #20]
   86f72:	4616      	mov	r6, r2
   86f74:	469b      	mov	fp, r3
	char buffer[100],first=1;
	int bufferpos;
	tft_delete_all_objects();
   86f76:	4b82      	ldr	r3, [pc, #520]	; (87180 <tft_GetInt+0x218>)
   86f78:	4798      	blx	r3
	tft_fillScreen(RA8875_BLACK);
   86f7a:	2000      	movs	r0, #0
   86f7c:	4b81      	ldr	r3, [pc, #516]	; (87184 <tft_GetInt+0x21c>)
   86f7e:	4798      	blx	r3
	tft_drawcalcbuttons();	//	Vykreslim klavesnicu 0-9,....
   86f80:	4b81      	ldr	r3, [pc, #516]	; (87188 <tft_GetInt+0x220>)
   86f82:	4798      	blx	r3
	if(min < 0)	//	Pouzitelne su aj zaporne cisla
   86f84:	2e00      	cmp	r6, #0
   86f86:	da0e      	bge.n	86fa6 <tft_GetInt+0x3e>
		tft_button(CalcX(10,4,4),CalcY(10,4,1),CalcHeight(10,4),CalcHeight(10,4),"-",5,RA8875_LIME,10);
   86f88:	4b80      	ldr	r3, [pc, #512]	; (8718c <tft_GetInt+0x224>)
   86f8a:	9300      	str	r3, [sp, #0]
   86f8c:	2105      	movs	r1, #5
   86f8e:	9101      	str	r1, [sp, #4]
   86f90:	f64c 73e0 	movw	r3, #53216	; 0xcfe0
   86f94:	9302      	str	r3, [sp, #8]
   86f96:	230a      	movs	r3, #10
   86f98:	9303      	str	r3, [sp, #12]
   86f9a:	f240 106d 	movw	r0, #365	; 0x16d
   86f9e:	226e      	movs	r2, #110	; 0x6e
   86fa0:	4613      	mov	r3, r2
   86fa2:	4d7b      	ldr	r5, [pc, #492]	; (87190 <tft_GetInt+0x228>)
   86fa4:	47a8      	blx	r5
	tft_textMode();
   86fa6:	f8df 9208 	ldr.w	r9, [pc, #520]	; 871b0 <tft_GetInt+0x248>
   86faa:	47c8      	blx	r9
	tft_textEnlarge(1);
   86fac:	2001      	movs	r0, #1
   86fae:	4b79      	ldr	r3, [pc, #484]	; (87194 <tft_GetInt+0x22c>)
   86fb0:	4798      	blx	r3
	tft_textColor(RA8875_YELLOW,RA8875_BLACK);
   86fb2:	f64f 70e0 	movw	r0, #65504	; 0xffe0
   86fb6:	2100      	movs	r1, #0
   86fb8:	f8df a1f8 	ldr.w	sl, [pc, #504]	; 871b4 <tft_GetInt+0x24c>
   86fbc:	47d0      	blx	sl
	tft_textWrite(500,10,0,0, (char*)Text, ALINE_LEFT);
   86fbe:	9400      	str	r4, [sp, #0]
   86fc0:	2500      	movs	r5, #0
   86fc2:	9501      	str	r5, [sp, #4]
   86fc4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   86fc8:	210a      	movs	r1, #10
   86fca:	462a      	mov	r2, r5
   86fcc:	462b      	mov	r3, r5
   86fce:	4f72      	ldr	r7, [pc, #456]	; (87198 <tft_GetInt+0x230>)
   86fd0:	47b8      	blx	r7
	tft_graphicsMode();
   86fd2:	4b72      	ldr	r3, [pc, #456]	; (8719c <tft_GetInt+0x234>)
   86fd4:	4798      	blx	r3
	tft_fillRect(500,100,150,50,RA8875_YELLOW);
   86fd6:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   86fda:	9300      	str	r3, [sp, #0]
   86fdc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   86fe0:	2164      	movs	r1, #100	; 0x64
   86fe2:	2296      	movs	r2, #150	; 0x96
   86fe4:	2332      	movs	r3, #50	; 0x32
   86fe6:	4c6e      	ldr	r4, [pc, #440]	; (871a0 <tft_GetInt+0x238>)
   86fe8:	47a0      	blx	r4
	bufferpos = sprintf(buffer,"%d",defval);
   86fea:	f10d 081c 	add.w	r8, sp, #28
   86fee:	4640      	mov	r0, r8
   86ff0:	496c      	ldr	r1, [pc, #432]	; (871a4 <tft_GetInt+0x23c>)
   86ff2:	9a05      	ldr	r2, [sp, #20]
   86ff4:	4b6c      	ldr	r3, [pc, #432]	; (871a8 <tft_GetInt+0x240>)
   86ff6:	4798      	blx	r3
   86ff8:	4604      	mov	r4, r0
	tft_textColor(RA8875_BLACK,RA8875_YELLOW);
   86ffa:	4628      	mov	r0, r5
   86ffc:	f64f 71e0 	movw	r1, #65504	; 0xffe0
   87000:	47d0      	blx	sl
	tft_textMode();
   87002:	47c8      	blx	r9
	tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
   87004:	f8cd 8000 	str.w	r8, [sp]
   87008:	9501      	str	r5, [sp, #4]
   8700a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   8700e:	2164      	movs	r1, #100	; 0x64
   87010:	228c      	movs	r2, #140	; 0x8c
   87012:	462b      	mov	r3, r5
   87014:	47b8      	blx	r7
	Action1 = 0;
   87016:	4b65      	ldr	r3, [pc, #404]	; (871ac <tft_GetInt+0x244>)
   87018:	601d      	str	r5, [r3, #0]
		}
	}
}
int tft_GetInt(char *Text,int defval, int min, int max)
{
	char buffer[100],first=1;
   8701a:	2701      	movs	r7, #1
	tft_textMode();
	tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
	Action1 = 0;
	while(1)
	{
		tft_draw_press_unpress();
   8701c:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 871c8 <tft_GetInt+0x260>
		//		FontNo=FONT_DIGI;
		if(Action1 == 3)	//	Pressed backspace
   87020:	461d      	mov	r5, r3
			if(bufferpos > 0)
			{
				bufferpos--;
				buffer[bufferpos] = 0;
			}
			tft_fillRect(500,100,150,50,RA8875_YELLOW);
   87022:	f8df 917c 	ldr.w	r9, [pc, #380]	; 871a0 <tft_GetInt+0x238>
	tft_textMode();
	tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
	Action1 = 0;
	while(1)
	{
		tft_draw_press_unpress();
   87026:	47d0      	blx	sl
		//		FontNo=FONT_DIGI;
		if(Action1 == 3)	//	Pressed backspace
   87028:	682b      	ldr	r3, [r5, #0]
   8702a:	2b03      	cmp	r3, #3
   8702c:	d127      	bne.n	8707e <tft_GetInt+0x116>
		{
			if(bufferpos > 0)
   8702e:	2c00      	cmp	r4, #0
   87030:	dd05      	ble.n	8703e <tft_GetInt+0xd6>
			{
				bufferpos--;
   87032:	3c01      	subs	r4, #1
				buffer[bufferpos] = 0;
   87034:	ab20      	add	r3, sp, #128	; 0x80
   87036:	4423      	add	r3, r4
   87038:	2200      	movs	r2, #0
   8703a:	f803 2c64 	strb.w	r2, [r3, #-100]
			}
			tft_fillRect(500,100,150,50,RA8875_YELLOW);
   8703e:	f64f 78e0 	movw	r8, #65504	; 0xffe0
   87042:	f8cd 8000 	str.w	r8, [sp]
   87046:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   8704a:	2164      	movs	r1, #100	; 0x64
   8704c:	2296      	movs	r2, #150	; 0x96
   8704e:	2332      	movs	r3, #50	; 0x32
   87050:	47c8      	blx	r9
			tft_textMode();
   87052:	4b57      	ldr	r3, [pc, #348]	; (871b0 <tft_GetInt+0x248>)
   87054:	4798      	blx	r3
			tft_textColor(RA8875_BLACK,RA8875_YELLOW);
   87056:	2000      	movs	r0, #0
   87058:	4641      	mov	r1, r8
   8705a:	4b56      	ldr	r3, [pc, #344]	; (871b4 <tft_GetInt+0x24c>)
   8705c:	4798      	blx	r3
			tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
   8705e:	ab07      	add	r3, sp, #28
   87060:	9300      	str	r3, [sp, #0]
   87062:	f04f 0800 	mov.w	r8, #0
   87066:	f8cd 8004 	str.w	r8, [sp, #4]
   8706a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   8706e:	2164      	movs	r1, #100	; 0x64
   87070:	228c      	movs	r2, #140	; 0x8c
   87072:	4643      	mov	r3, r8
   87074:	f8df c120 	ldr.w	ip, [pc, #288]	; 87198 <tft_GetInt+0x230>
   87078:	47e0      	blx	ip
			Action1 = 0;
   8707a:	f8c5 8000 	str.w	r8, [r5]
		}
		if(Action1 >= 10)	//	Pressed number 0-9
   8707e:	682b      	ldr	r3, [r5, #0]
   87080:	2b09      	cmp	r3, #9
   87082:	dd2d      	ble.n	870e0 <tft_GetInt+0x178>
		{
			if(first)
   87084:	b137      	cbz	r7, 87094 <tft_GetInt+0x12c>
			{
				first = 0;
				bufferpos = 0;
				memset(buffer,0,sizeof(buffer));
   87086:	a807      	add	r0, sp, #28
   87088:	2100      	movs	r1, #0
   8708a:	2264      	movs	r2, #100	; 0x64
   8708c:	4b4a      	ldr	r3, [pc, #296]	; (871b8 <tft_GetInt+0x250>)
   8708e:	4798      	blx	r3
		if(Action1 >= 10)	//	Pressed number 0-9
		{
			if(first)
			{
				first = 0;
				bufferpos = 0;
   87090:	2400      	movs	r4, #0
   87092:	e001      	b.n	87098 <tft_GetInt+0x130>
				memset(buffer,0,sizeof(buffer));
			}
			if(bufferpos < 9)
   87094:	2c08      	cmp	r4, #8
   87096:	dc07      	bgt.n	870a8 <tft_GetInt+0x140>
			{
				buffer[bufferpos] = 48 + Action - 10;
   87098:	4b48      	ldr	r3, [pc, #288]	; (871bc <tft_GetInt+0x254>)
   8709a:	681b      	ldr	r3, [r3, #0]
   8709c:	aa20      	add	r2, sp, #128	; 0x80
   8709e:	4422      	add	r2, r4
   870a0:	3326      	adds	r3, #38	; 0x26
   870a2:	f802 3c64 	strb.w	r3, [r2, #-100]
				bufferpos++;
   870a6:	3401      	adds	r4, #1
			}
			tft_fillRect(500,100,150,50,RA8875_YELLOW);
   870a8:	f64f 77e0 	movw	r7, #65504	; 0xffe0
   870ac:	9700      	str	r7, [sp, #0]
   870ae:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   870b2:	2164      	movs	r1, #100	; 0x64
   870b4:	2296      	movs	r2, #150	; 0x96
   870b6:	2332      	movs	r3, #50	; 0x32
   870b8:	47c8      	blx	r9
			tft_textMode();
   870ba:	4b3d      	ldr	r3, [pc, #244]	; (871b0 <tft_GetInt+0x248>)
   870bc:	4798      	blx	r3
			tft_textColor(RA8875_BLACK,RA8875_YELLOW);
   870be:	2000      	movs	r0, #0
   870c0:	4639      	mov	r1, r7
   870c2:	4b3c      	ldr	r3, [pc, #240]	; (871b4 <tft_GetInt+0x24c>)
   870c4:	4798      	blx	r3
			tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
   870c6:	ab07      	add	r3, sp, #28
   870c8:	9300      	str	r3, [sp, #0]
   870ca:	2700      	movs	r7, #0
   870cc:	9701      	str	r7, [sp, #4]
   870ce:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   870d2:	2164      	movs	r1, #100	; 0x64
   870d4:	228c      	movs	r2, #140	; 0x8c
   870d6:	463b      	mov	r3, r7
   870d8:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 87198 <tft_GetInt+0x230>
   870dc:	47e0      	blx	ip
			Action1 = 0;
   870de:	602f      	str	r7, [r5, #0]
		}
		if(Action1 == 4)	//	  ciarka
   870e0:	682b      	ldr	r3, [r5, #0]
   870e2:	2b04      	cmp	r3, #4
   870e4:	d105      	bne.n	870f2 <tft_GetInt+0x18a>
		{
			beep(400);
   870e6:	f44f 70c8 	mov.w	r0, #400	; 0x190
   870ea:	4b35      	ldr	r3, [pc, #212]	; (871c0 <tft_GetInt+0x258>)
   870ec:	4798      	blx	r3
			Action1 = 0;
   870ee:	2300      	movs	r3, #0
   870f0:	602b      	str	r3, [r5, #0]
		}
		if(Action1 == 5)	//	  Minus
   870f2:	682b      	ldr	r3, [r5, #0]
   870f4:	2b05      	cmp	r3, #5
   870f6:	d12b      	bne.n	87150 <tft_GetInt+0x1e8>
		{
			if(first)
   870f8:	b137      	cbz	r7, 87108 <tft_GetInt+0x1a0>
			{
				first = 0;
				bufferpos = 0;
				memset(buffer,0,sizeof(buffer));
   870fa:	a807      	add	r0, sp, #28
   870fc:	2100      	movs	r1, #0
   870fe:	2264      	movs	r2, #100	; 0x64
   87100:	4b2d      	ldr	r3, [pc, #180]	; (871b8 <tft_GetInt+0x250>)
   87102:	4798      	blx	r3
		if(Action1 == 5)	//	  Minus
		{
			if(first)
			{
				first = 0;
				bufferpos = 0;
   87104:	2400      	movs	r4, #0
   87106:	e001      	b.n	8710c <tft_GetInt+0x1a4>
				memset(buffer,0,sizeof(buffer));
			}
			if(bufferpos < 9)
   87108:	2c08      	cmp	r4, #8
   8710a:	dc05      	bgt.n	87118 <tft_GetInt+0x1b0>
			{
				buffer[bufferpos] = '-';
   8710c:	ab20      	add	r3, sp, #128	; 0x80
   8710e:	4423      	add	r3, r4
   87110:	222d      	movs	r2, #45	; 0x2d
   87112:	f803 2c64 	strb.w	r2, [r3, #-100]
				bufferpos++;
   87116:	3401      	adds	r4, #1
			}
			tft_fillRect(500,100,150,50,RA8875_YELLOW);
   87118:	f64f 77e0 	movw	r7, #65504	; 0xffe0
   8711c:	9700      	str	r7, [sp, #0]
   8711e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   87122:	2164      	movs	r1, #100	; 0x64
   87124:	2296      	movs	r2, #150	; 0x96
   87126:	2332      	movs	r3, #50	; 0x32
   87128:	47c8      	blx	r9
			tft_textMode();
   8712a:	4b21      	ldr	r3, [pc, #132]	; (871b0 <tft_GetInt+0x248>)
   8712c:	4798      	blx	r3
			tft_textColor(RA8875_BLACK,RA8875_YELLOW);
   8712e:	2000      	movs	r0, #0
   87130:	4639      	mov	r1, r7
   87132:	4b20      	ldr	r3, [pc, #128]	; (871b4 <tft_GetInt+0x24c>)
   87134:	4798      	blx	r3
			tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
   87136:	ab07      	add	r3, sp, #28
   87138:	9300      	str	r3, [sp, #0]
   8713a:	2700      	movs	r7, #0
   8713c:	9701      	str	r7, [sp, #4]
   8713e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   87142:	2164      	movs	r1, #100	; 0x64
   87144:	228c      	movs	r2, #140	; 0x8c
   87146:	463b      	mov	r3, r7
   87148:	f8df c04c 	ldr.w	ip, [pc, #76]	; 87198 <tft_GetInt+0x230>
   8714c:	47e0      	blx	ip
			Action1 = 0;
   8714e:	602f      	str	r7, [r5, #0]
		}
		if(Action1 == 2)	//	Cancel
   87150:	682b      	ldr	r3, [r5, #0]
   87152:	2b02      	cmp	r3, #2
   87154:	d010      	beq.n	87178 <tft_GetInt+0x210>
		{
			return defval;
		}
		if(Action1 == 1)	//	OK
   87156:	682b      	ldr	r3, [r5, #0]
   87158:	2b01      	cmp	r3, #1
   8715a:	f47f af64 	bne.w	87026 <tft_GetInt+0xbe>
		{
			int val=atol(buffer);
   8715e:	a807      	add	r0, sp, #28
   87160:	4b18      	ldr	r3, [pc, #96]	; (871c4 <tft_GetInt+0x25c>)
   87162:	4798      	blx	r3
			if((val < min) || (val > max))
   87164:	4286      	cmp	r6, r0
   87166:	dc01      	bgt.n	8716c <tft_GetInt+0x204>
   87168:	4558      	cmp	r0, fp
   8716a:	dd06      	ble.n	8717a <tft_GetInt+0x212>
			{
				beep(100);
   8716c:	2064      	movs	r0, #100	; 0x64
   8716e:	4b14      	ldr	r3, [pc, #80]	; (871c0 <tft_GetInt+0x258>)
   87170:	4798      	blx	r3
				Action1 = 0;
   87172:	2300      	movs	r3, #0
   87174:	602b      	str	r3, [r5, #0]
   87176:	e756      	b.n	87026 <tft_GetInt+0xbe>
			tft_textWrite(500,100,140,0, buffer, ALINE_LEFT);
			Action1 = 0;
		}
		if(Action1 == 2)	//	Cancel
		{
			return defval;
   87178:	9805      	ldr	r0, [sp, #20]
				beep(100);
				Action1 = 0;
			} else return val;
		}
	}
}
   8717a:	b021      	add	sp, #132	; 0x84
   8717c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   87180:	00086769 	.word	0x00086769
   87184:	00085e2d 	.word	0x00085e2d
   87188:	000868d1 	.word	0x000868d1
   8718c:	00091794 	.word	0x00091794
   87190:	0008688d 	.word	0x0008688d
   87194:	000855b1 	.word	0x000855b1
   87198:	00085679 	.word	0x00085679
   8719c:	00085875 	.word	0x00085875
   871a0:	00085ddd 	.word	0x00085ddd
   871a4:	000917a0 	.word	0x000917a0
   871a8:	0008d291 	.word	0x0008d291
   871ac:	200014fc 	.word	0x200014fc
   871b0:	000854dd 	.word	0x000854dd
   871b4:	00085551 	.word	0x00085551
   871b8:	0008d1c9 	.word	0x0008d1c9
   871bc:	20001500 	.word	0x20001500
   871c0:	00086c79 	.word	0x00086c79
   871c4:	0008cb4d 	.word	0x0008cb4d
   871c8:	00086eb5 	.word	0x00086eb5

000871cc <tft_calibrate_touch>:
	memcpy(&TouchCalibration,buffer,28);
}


void tft_calibrate_touch(void) 
{
   871cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   871d0:	b097      	sub	sp, #92	; 0x5c
	int no;
	POINT screenSample[3];   //array of input points
	POINT displaySample[3] = { { 30, 30 }, { 770, 240 }, { 400, 450 } }; //array of expected correct answers  TS.getMatrix();
   871d2:	ac0a      	add	r4, sp, #40	; 0x28
   871d4:	4d38      	ldr	r5, [pc, #224]	; (872b8 <tft_calibrate_touch+0xec>)
   871d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   871d8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   871da:	e895 0003 	ldmia.w	r5, {r0, r1}
   871de:	e884 0003 	stmia.w	r4, {r0, r1}
	Calibrating = 1;
   871e2:	2201      	movs	r2, #1
   871e4:	4b35      	ldr	r3, [pc, #212]	; (872bc <tft_calibrate_touch+0xf0>)
   871e6:	709a      	strb	r2, [r3, #2]
	tft_delete_all_objects();
   871e8:	4b35      	ldr	r3, [pc, #212]	; (872c0 <tft_calibrate_touch+0xf4>)
   871ea:	4798      	blx	r3
	tft_fillScreen(RA8875_LIME);
   871ec:	f64c 70e0 	movw	r0, #53216	; 0xcfe0
   871f0:	4b34      	ldr	r3, [pc, #208]	; (872c4 <tft_calibrate_touch+0xf8>)
   871f2:	4798      	blx	r3
   871f4:	2700      	movs	r7, #0
//	delay(500);
	for (no = 0; no < 3; no++) {
		tft_fillScreen(RA8875_LIME);
   871f6:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 872c4 <tft_calibrate_touch+0xf8>
		tft_fillRectRound(displaySample[no].x - 10, displaySample[no].y - 10,20,20, RA8875_RED,10);
   871fa:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 872ec <tft_calibrate_touch+0x120>
		TouchXPos = -1234;
   871fe:	4e32      	ldr	r6, [pc, #200]	; (872c8 <tft_calibrate_touch+0xfc>)
		while (TouchXPos == -1234)	tft_GetTouch();	//	Pockam na stlacenie touch
   87200:	4d32      	ldr	r5, [pc, #200]	; (872cc <tft_calibrate_touch+0x100>)
	Calibrating = 1;
	tft_delete_all_objects();
	tft_fillScreen(RA8875_LIME);
//	delay(500);
	for (no = 0; no < 3; no++) {
		tft_fillScreen(RA8875_LIME);
   87202:	f64c 70e0 	movw	r0, #53216	; 0xcfe0
   87206:	47c0      	blx	r8
		tft_fillRectRound(displaySample[no].x - 10, displaySample[no].y - 10,20,20, RA8875_RED,10);
   87208:	ab0a      	add	r3, sp, #40	; 0x28
   8720a:	58f8      	ldr	r0, [r7, r3]
   8720c:	380a      	subs	r0, #10
   8720e:	443b      	add	r3, r7
   87210:	6859      	ldr	r1, [r3, #4]
   87212:	390a      	subs	r1, #10
   87214:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   87218:	9300      	str	r3, [sp, #0]
   8721a:	230a      	movs	r3, #10
   8721c:	9301      	str	r3, [sp, #4]
   8721e:	b200      	sxth	r0, r0
   87220:	b209      	sxth	r1, r1
   87222:	2214      	movs	r2, #20
   87224:	4613      	mov	r3, r2
   87226:	47c8      	blx	r9
		TouchXPos = -1234;
   87228:	4b29      	ldr	r3, [pc, #164]	; (872d0 <tft_calibrate_touch+0x104>)
   8722a:	6033      	str	r3, [r6, #0]
		while (TouchXPos == -1234)	tft_GetTouch();	//	Pockam na stlacenie touch
   8722c:	6832      	ldr	r2, [r6, #0]
   8722e:	429a      	cmp	r2, r3
   87230:	d104      	bne.n	8723c <tft_calibrate_touch+0x70>
   87232:	461c      	mov	r4, r3
   87234:	47a8      	blx	r5
   87236:	6833      	ldr	r3, [r6, #0]
   87238:	42a3      	cmp	r3, r4
   8723a:	d0fb      	beq.n	87234 <tft_calibrate_touch+0x68>
		screenSample[no].x = TouchXPos;
   8723c:	6832      	ldr	r2, [r6, #0]
   8723e:	ab10      	add	r3, sp, #64	; 0x40
   87240:	50fa      	str	r2, [r7, r3]
		screenSample[no].y = TouchYPos;
   87242:	4a24      	ldr	r2, [pc, #144]	; (872d4 <tft_calibrate_touch+0x108>)
   87244:	6812      	ldr	r2, [r2, #0]
   87246:	443b      	add	r3, r7
   87248:	605a      	str	r2, [r3, #4]
//		NVIC_DisableIRQ((IRQn_Type) ID_TC0);
		beep(10);
   8724a:	200a      	movs	r0, #10
   8724c:	4b22      	ldr	r3, [pc, #136]	; (872d8 <tft_calibrate_touch+0x10c>)
   8724e:	4798      	blx	r3
		tft_fillScreen(RA8875_LIME);
   87250:	f64c 70e0 	movw	r0, #53216	; 0xcfe0
   87254:	47c0      	blx	r8
		delay_ms(200);
   87256:	20c8      	movs	r0, #200	; 0xc8
   87258:	4b20      	ldr	r3, [pc, #128]	; (872dc <tft_calibrate_touch+0x110>)
   8725a:	4798      	blx	r3
#if CAPACITIVE_TOUCH != 1
		needtouch = 1;
   8725c:	2201      	movs	r2, #1
   8725e:	4b17      	ldr	r3, [pc, #92]	; (872bc <tft_calibrate_touch+0xf0>)
   87260:	705a      	strb	r2, [r3, #1]
		tft_GetTouch();
   87262:	47a8      	blx	r5
   87264:	240a      	movs	r4, #10
		for(int i = 0;i < 10;i++)
		{
			needtouch = 1;
   87266:	f8df b054 	ldr.w	fp, [pc, #84]	; 872bc <tft_calibrate_touch+0xf0>
   8726a:	f04f 0a01 	mov.w	sl, #1
   8726e:	f88b a001 	strb.w	sl, [fp, #1]
			tft_GetTouch();
   87272:	47a8      	blx	r5
		tft_fillScreen(RA8875_LIME);
		delay_ms(200);
#if CAPACITIVE_TOUCH != 1
		needtouch = 1;
		tft_GetTouch();
		for(int i = 0;i < 10;i++)
   87274:	3c01      	subs	r4, #1
   87276:	d1fa      	bne.n	8726e <tft_calibrate_touch+0xa2>
   87278:	3708      	adds	r7, #8
	POINT displaySample[3] = { { 30, 30 }, { 770, 240 }, { 400, 450 } }; //array of expected correct answers  TS.getMatrix();
	Calibrating = 1;
	tft_delete_all_objects();
	tft_fillScreen(RA8875_LIME);
//	delay(500);
	for (no = 0; no < 3; no++) {
   8727a:	2f18      	cmp	r7, #24
   8727c:	d1c1      	bne.n	87202 <tft_calibrate_touch+0x36>
			tft_GetTouch();
		}
#endif
//		NVIC_EnableIRQ((IRQn_Type) ID_TC0);
	}
	if (setCalibrationMatrix(&displaySample[0], &screenSample[0],&TouchCalibration))
   8727e:	a80a      	add	r0, sp, #40	; 0x28
   87280:	a910      	add	r1, sp, #64	; 0x40
   87282:	4a17      	ldr	r2, [pc, #92]	; (872e0 <tft_calibrate_touch+0x114>)
   87284:	4b17      	ldr	r3, [pc, #92]	; (872e4 <tft_calibrate_touch+0x118>)
   87286:	4798      	blx	r3
   87288:	b110      	cbz	r0, 87290 <tft_calibrate_touch+0xc4>
		beep(10);
   8728a:	200a      	movs	r0, #10
   8728c:	4b12      	ldr	r3, [pc, #72]	; (872d8 <tft_calibrate_touch+0x10c>)
   8728e:	4798      	blx	r3
	Calibrating = 0;
   87290:	2200      	movs	r2, #0
   87292:	4b0a      	ldr	r3, [pc, #40]	; (872bc <tft_calibrate_touch+0xf0>)
   87294:	709a      	strb	r2, [r3, #2]
	uint8_t buffer[28];
	memcpy(&buffer,&TouchCalibration,28);
   87296:	ac03      	add	r4, sp, #12
   87298:	4d11      	ldr	r5, [pc, #68]	; (872e0 <tft_calibrate_touch+0x114>)
   8729a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   8729c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   8729e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   872a2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	flash_write_buffer(4,buffer,28);
   872a6:	2004      	movs	r0, #4
   872a8:	a903      	add	r1, sp, #12
   872aa:	221c      	movs	r2, #28
   872ac:	4b0e      	ldr	r3, [pc, #56]	; (872e8 <tft_calibrate_touch+0x11c>)
   872ae:	4798      	blx	r3
}
   872b0:	b017      	add	sp, #92	; 0x5c
   872b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   872b6:	bf00      	nop
   872b8:	000916f8 	.word	0x000916f8
   872bc:	20000f49 	.word	0x20000f49
   872c0:	00086769 	.word	0x00086769
   872c4:	00085e2d 	.word	0x00085e2d
   872c8:	20001504 	.word	0x20001504
   872cc:	00086e19 	.word	0x00086e19
   872d0:	fffffb2e 	.word	0xfffffb2e
   872d4:	200014f8 	.word	0x200014f8
   872d8:	00086c79 	.word	0x00086c79
   872dc:	00089689 	.word	0x00089689
   872e0:	200014d0 	.word	0x200014d0
   872e4:	00086ca9 	.word	0x00086ca9
   872e8:	0008246d 	.word	0x0008246d
   872ec:	00085e05 	.word	0x00085e05

000872f0 <report_status_message>:
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
// NOTE: In silent mode, all error codes are greater than zero.
// TODO: Install silent mode to return only numeric values, primarily for GUIs.
void report_status_message(uint8_t status_code) 
{
   872f0:	b510      	push	{r4, lr}
  if (status_code == 0) { // STATUS_OK
   872f2:	b918      	cbnz	r0, 872fc <report_status_message+0xc>
    printString(("ok\r\n"));
   872f4:	482c      	ldr	r0, [pc, #176]	; (873a8 <report_status_message+0xb8>)
   872f6:	4b2d      	ldr	r3, [pc, #180]	; (873ac <report_status_message+0xbc>)
   872f8:	4798      	blx	r3
   872fa:	bd10      	pop	{r4, pc}
   872fc:	4604      	mov	r4, r0
  } else {
    printString(("error: "));
   872fe:	482c      	ldr	r0, [pc, #176]	; (873b0 <report_status_message+0xc0>)
   87300:	4b2a      	ldr	r3, [pc, #168]	; (873ac <report_status_message+0xbc>)
   87302:	4798      	blx	r3
    #ifdef REPORT_GUI_MODE
      print_uint8_base10(status_code);
    #else
      switch(status_code) {          
   87304:	1e63      	subs	r3, r4, #1
   87306:	2b15      	cmp	r3, #21
   87308:	d844      	bhi.n	87394 <report_status_message+0xa4>
   8730a:	e8df f003 	tbb	[pc, r3]
   8730e:	0f0b      	.short	0x0f0b
   87310:	1f1b1713 	.word	0x1f1b1713
   87314:	2f2b2723 	.word	0x2f2b2723
   87318:	43434333 	.word	0x43434333
   8731c:	43434343 	.word	0x43434343
   87320:	3f373b43 	.word	0x3f373b43
        case STATUS_EXPECTED_COMMAND_LETTER:
        printString(("Expected command letter")); break;
   87324:	4823      	ldr	r0, [pc, #140]	; (873b4 <report_status_message+0xc4>)
   87326:	4b21      	ldr	r3, [pc, #132]	; (873ac <report_status_message+0xbc>)
   87328:	4798      	blx	r3
   8732a:	e039      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_BAD_NUMBER_FORMAT:
        printString(("Bad number format")); break;
   8732c:	4822      	ldr	r0, [pc, #136]	; (873b8 <report_status_message+0xc8>)
   8732e:	4b1f      	ldr	r3, [pc, #124]	; (873ac <report_status_message+0xbc>)
   87330:	4798      	blx	r3
   87332:	e035      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_INVALID_STATEMENT:
        printString(("Invalid statement")); break;
   87334:	4821      	ldr	r0, [pc, #132]	; (873bc <report_status_message+0xcc>)
   87336:	4b1d      	ldr	r3, [pc, #116]	; (873ac <report_status_message+0xbc>)
   87338:	4798      	blx	r3
   8733a:	e031      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_NEGATIVE_VALUE:
        printString(("Value < 0")); break;
   8733c:	4820      	ldr	r0, [pc, #128]	; (873c0 <report_status_message+0xd0>)
   8733e:	4b1b      	ldr	r3, [pc, #108]	; (873ac <report_status_message+0xbc>)
   87340:	4798      	blx	r3
   87342:	e02d      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_SETTING_DISABLED:
        printString(("Setting disabled")); break;
   87344:	481f      	ldr	r0, [pc, #124]	; (873c4 <report_status_message+0xd4>)
   87346:	4b19      	ldr	r3, [pc, #100]	; (873ac <report_status_message+0xbc>)
   87348:	4798      	blx	r3
   8734a:	e029      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_SETTING_STEP_PULSE_MIN:
        printString(("Value < 3 usec")); break;
   8734c:	481e      	ldr	r0, [pc, #120]	; (873c8 <report_status_message+0xd8>)
   8734e:	4b17      	ldr	r3, [pc, #92]	; (873ac <report_status_message+0xbc>)
   87350:	4798      	blx	r3
   87352:	e025      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_SETTING_READ_FAIL:
        printString(("EEPROM read fail. Using defaults")); break;
   87354:	481d      	ldr	r0, [pc, #116]	; (873cc <report_status_message+0xdc>)
   87356:	4b15      	ldr	r3, [pc, #84]	; (873ac <report_status_message+0xbc>)
   87358:	4798      	blx	r3
   8735a:	e021      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_IDLE_ERROR:
        printString(("Not idle")); break;
   8735c:	481c      	ldr	r0, [pc, #112]	; (873d0 <report_status_message+0xe0>)
   8735e:	4b13      	ldr	r3, [pc, #76]	; (873ac <report_status_message+0xbc>)
   87360:	4798      	blx	r3
   87362:	e01d      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_ALARM_LOCK:
        printString(("Alarm lock")); break;
   87364:	481b      	ldr	r0, [pc, #108]	; (873d4 <report_status_message+0xe4>)
   87366:	4b11      	ldr	r3, [pc, #68]	; (873ac <report_status_message+0xbc>)
   87368:	4798      	blx	r3
   8736a:	e019      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_SOFT_LIMIT_ERROR:
        printString(("Homing not enabled")); break;
   8736c:	481a      	ldr	r0, [pc, #104]	; (873d8 <report_status_message+0xe8>)
   8736e:	4b0f      	ldr	r3, [pc, #60]	; (873ac <report_status_message+0xbc>)
   87370:	4798      	blx	r3
   87372:	e015      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_OVERFLOW:
        printString(("Line overflow")); break;
   87374:	4819      	ldr	r0, [pc, #100]	; (873dc <report_status_message+0xec>)
   87376:	4b0d      	ldr	r3, [pc, #52]	; (873ac <report_status_message+0xbc>)
   87378:	4798      	blx	r3
   8737a:	e011      	b.n	873a0 <report_status_message+0xb0>
          case STATUS_MAX_STEP_RATE_EXCEEDED: 
          printString(("Step rate > 30kHz")); break;
        #endif      
        // Common g-code parser errors.
        case STATUS_GCODE_MODAL_GROUP_VIOLATION:
        printString(("Modal group violation")); break;
   8737c:	4818      	ldr	r0, [pc, #96]	; (873e0 <report_status_message+0xf0>)
   8737e:	4b0b      	ldr	r3, [pc, #44]	; (873ac <report_status_message+0xbc>)
   87380:	4798      	blx	r3
   87382:	e00d      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_GCODE_UNSUPPORTED_COMMAND:
        printString(("Unsupported command")); break;
   87384:	4817      	ldr	r0, [pc, #92]	; (873e4 <report_status_message+0xf4>)
   87386:	4b09      	ldr	r3, [pc, #36]	; (873ac <report_status_message+0xbc>)
   87388:	4798      	blx	r3
   8738a:	e009      	b.n	873a0 <report_status_message+0xb0>
        case STATUS_GCODE_UNDEFINED_FEED_RATE:
        printString(("Undefined feed rate")); break;
   8738c:	4816      	ldr	r0, [pc, #88]	; (873e8 <report_status_message+0xf8>)
   8738e:	4b07      	ldr	r3, [pc, #28]	; (873ac <report_status_message+0xbc>)
   87390:	4798      	blx	r3
   87392:	e005      	b.n	873a0 <report_status_message+0xb0>
        default:
          // Remaining g-code parser errors with error codes
          printString(("Invalid gcode ID:"));
   87394:	4815      	ldr	r0, [pc, #84]	; (873ec <report_status_message+0xfc>)
   87396:	4b05      	ldr	r3, [pc, #20]	; (873ac <report_status_message+0xbc>)
   87398:	4798      	blx	r3
          print_uint8_base10(status_code); // Print error code for user reference
   8739a:	4620      	mov	r0, r4
   8739c:	4b14      	ldr	r3, [pc, #80]	; (873f0 <report_status_message+0x100>)
   8739e:	4798      	blx	r3
      }
    #endif  
    printString(("\r\n"));
   873a0:	4814      	ldr	r0, [pc, #80]	; (873f4 <report_status_message+0x104>)
   873a2:	4b02      	ldr	r3, [pc, #8]	; (873ac <report_status_message+0xbc>)
   873a4:	4798      	blx	r3
   873a6:	bd10      	pop	{r4, pc}
   873a8:	000917a4 	.word	0x000917a4
   873ac:	00084d15 	.word	0x00084d15
   873b0:	000917ac 	.word	0x000917ac
   873b4:	000917b4 	.word	0x000917b4
   873b8:	000917cc 	.word	0x000917cc
   873bc:	000917e0 	.word	0x000917e0
   873c0:	000917f4 	.word	0x000917f4
   873c4:	00091800 	.word	0x00091800
   873c8:	00091814 	.word	0x00091814
   873cc:	00091824 	.word	0x00091824
   873d0:	00091848 	.word	0x00091848
   873d4:	00091854 	.word	0x00091854
   873d8:	00091860 	.word	0x00091860
   873dc:	00091874 	.word	0x00091874
   873e0:	00091884 	.word	0x00091884
   873e4:	0009189c 	.word	0x0009189c
   873e8:	000918b0 	.word	0x000918b0
   873ec:	000918c4 	.word	0x000918c4
   873f0:	00084d91 	.word	0x00084d91
   873f4:	000918d8 	.word	0x000918d8

000873f8 <report_alarm_message>:
  }
}

// Prints alarm messages.
void report_alarm_message(int8_t alarm_code)
{
   873f8:	b510      	push	{r4, lr}
   873fa:	4604      	mov	r4, r0
  printString(("ALARM: "));
   873fc:	4812      	ldr	r0, [pc, #72]	; (87448 <report_alarm_message+0x50>)
   873fe:	4b13      	ldr	r3, [pc, #76]	; (8744c <report_alarm_message+0x54>)
   87400:	4798      	blx	r3
  #ifdef REPORT_GUI_MODE
    print_uint8_base10(alarm_code);
  #else
    switch (alarm_code) {
   87402:	1e60      	subs	r0, r4, #1
   87404:	2804      	cmp	r0, #4
   87406:	d817      	bhi.n	87438 <report_alarm_message+0x40>
   87408:	e8df f000 	tbb	[pc, r0]
   8740c:	0f0b0703 	.word	0x0f0b0703
   87410:	13          	.byte	0x13
   87411:	00          	.byte	0x00
      case ALARM_HARD_LIMIT_ERROR: 
      printString(("Hard limit")); break;
   87412:	480f      	ldr	r0, [pc, #60]	; (87450 <report_alarm_message+0x58>)
   87414:	4b0d      	ldr	r3, [pc, #52]	; (8744c <report_alarm_message+0x54>)
   87416:	4798      	blx	r3
   87418:	e00e      	b.n	87438 <report_alarm_message+0x40>
      case ALARM_SOFT_LIMIT_ERROR:
      printString(("Soft limit")); break;
   8741a:	480e      	ldr	r0, [pc, #56]	; (87454 <report_alarm_message+0x5c>)
   8741c:	4b0b      	ldr	r3, [pc, #44]	; (8744c <report_alarm_message+0x54>)
   8741e:	4798      	blx	r3
   87420:	e00a      	b.n	87438 <report_alarm_message+0x40>
      case ALARM_ABORT_CYCLE: 
      printString(("Abort during cycle")); break;
   87422:	480d      	ldr	r0, [pc, #52]	; (87458 <report_alarm_message+0x60>)
   87424:	4b09      	ldr	r3, [pc, #36]	; (8744c <report_alarm_message+0x54>)
   87426:	4798      	blx	r3
   87428:	e006      	b.n	87438 <report_alarm_message+0x40>
      case ALARM_PROBE_FAIL:
      printString(("Probe fail")); break;
   8742a:	480c      	ldr	r0, [pc, #48]	; (8745c <report_alarm_message+0x64>)
   8742c:	4b07      	ldr	r3, [pc, #28]	; (8744c <report_alarm_message+0x54>)
   8742e:	4798      	blx	r3
   87430:	e002      	b.n	87438 <report_alarm_message+0x40>
      case ALARM_HOMING_FAIL:
      printString(("Homing fail")); break;
   87432:	480b      	ldr	r0, [pc, #44]	; (87460 <report_alarm_message+0x68>)
   87434:	4b05      	ldr	r3, [pc, #20]	; (8744c <report_alarm_message+0x54>)
   87436:	4798      	blx	r3
    }
  #endif
  printString(("\r\n"));
   87438:	480a      	ldr	r0, [pc, #40]	; (87464 <report_alarm_message+0x6c>)
   8743a:	4b04      	ldr	r3, [pc, #16]	; (8744c <report_alarm_message+0x54>)
   8743c:	4798      	blx	r3
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
   8743e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   87442:	4b09      	ldr	r3, [pc, #36]	; (87468 <report_alarm_message+0x70>)
   87444:	4798      	blx	r3
   87446:	bd10      	pop	{r4, pc}
   87448:	000918dc 	.word	0x000918dc
   8744c:	00084d15 	.word	0x00084d15
   87450:	000918e4 	.word	0x000918e4
   87454:	000918f0 	.word	0x000918f0
   87458:	000918fc 	.word	0x000918fc
   8745c:	00091910 	.word	0x00091910
   87460:	0009191c 	.word	0x0009191c
   87464:	000918d8 	.word	0x000918d8
   87468:	00089689 	.word	0x00089689

0008746c <report_feedback_message>:
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
// TODO: Install silence feedback messages option in settings
void report_feedback_message(uint8_t message_code)
{
   8746c:	b510      	push	{r4, lr}
   8746e:	4604      	mov	r4, r0
  printString(("["));
   87470:	4817      	ldr	r0, [pc, #92]	; (874d0 <report_feedback_message+0x64>)
   87472:	4b18      	ldr	r3, [pc, #96]	; (874d4 <report_feedback_message+0x68>)
   87474:	4798      	blx	r3
  switch(message_code) {
   87476:	1e60      	subs	r0, r4, #1
   87478:	2807      	cmp	r0, #7
   8747a:	d824      	bhi.n	874c6 <report_feedback_message+0x5a>
   8747c:	e8df f000 	tbb	[pc, r0]
   87480:	100c0804 	.word	0x100c0804
   87484:	201c1814 	.word	0x201c1814
    case MESSAGE_CRITICAL_EVENT:
    printString(("Reset to continue")); break;
   87488:	4813      	ldr	r0, [pc, #76]	; (874d8 <report_feedback_message+0x6c>)
   8748a:	4b12      	ldr	r3, [pc, #72]	; (874d4 <report_feedback_message+0x68>)
   8748c:	4798      	blx	r3
   8748e:	e01a      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_ALARM_LOCK:
    printString(("'$H'|'$X' to unlock")); break;
   87490:	4812      	ldr	r0, [pc, #72]	; (874dc <report_feedback_message+0x70>)
   87492:	4b10      	ldr	r3, [pc, #64]	; (874d4 <report_feedback_message+0x68>)
   87494:	4798      	blx	r3
   87496:	e016      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_ALARM_UNLOCK:
    printString(("Caution: Unlocked")); break;
   87498:	4811      	ldr	r0, [pc, #68]	; (874e0 <report_feedback_message+0x74>)
   8749a:	4b0e      	ldr	r3, [pc, #56]	; (874d4 <report_feedback_message+0x68>)
   8749c:	4798      	blx	r3
   8749e:	e012      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_ENABLED:
    printString(("Enabled")); break;
   874a0:	4810      	ldr	r0, [pc, #64]	; (874e4 <report_feedback_message+0x78>)
   874a2:	4b0c      	ldr	r3, [pc, #48]	; (874d4 <report_feedback_message+0x68>)
   874a4:	4798      	blx	r3
   874a6:	e00e      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_DISABLED:
    printString(("Disabled")); break; 
   874a8:	480f      	ldr	r0, [pc, #60]	; (874e8 <report_feedback_message+0x7c>)
   874aa:	4b0a      	ldr	r3, [pc, #40]	; (874d4 <report_feedback_message+0x68>)
   874ac:	4798      	blx	r3
   874ae:	e00a      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_SAFETY_DOOR_AJAR:
    printString(("Check Door")); break;
   874b0:	480e      	ldr	r0, [pc, #56]	; (874ec <report_feedback_message+0x80>)
   874b2:	4b08      	ldr	r3, [pc, #32]	; (874d4 <report_feedback_message+0x68>)
   874b4:	4798      	blx	r3
   874b6:	e006      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_PROGRAM_END:
    printString(("Pgm End")); break;
   874b8:	480d      	ldr	r0, [pc, #52]	; (874f0 <report_feedback_message+0x84>)
   874ba:	4b06      	ldr	r3, [pc, #24]	; (874d4 <report_feedback_message+0x68>)
   874bc:	4798      	blx	r3
   874be:	e002      	b.n	874c6 <report_feedback_message+0x5a>
    case MESSAGE_RESTORE_DEFAULTS:
    printString(("Restoring defaults")); break;
   874c0:	480c      	ldr	r0, [pc, #48]	; (874f4 <report_feedback_message+0x88>)
   874c2:	4b04      	ldr	r3, [pc, #16]	; (874d4 <report_feedback_message+0x68>)
   874c4:	4798      	blx	r3
  }
  printString(("]\r\n"));
   874c6:	480c      	ldr	r0, [pc, #48]	; (874f8 <report_feedback_message+0x8c>)
   874c8:	4b02      	ldr	r3, [pc, #8]	; (874d4 <report_feedback_message+0x68>)
   874ca:	4798      	blx	r3
   874cc:	bd10      	pop	{r4, pc}
   874ce:	bf00      	nop
   874d0:	00091928 	.word	0x00091928
   874d4:	00084d15 	.word	0x00084d15
   874d8:	0009192c 	.word	0x0009192c
   874dc:	00091940 	.word	0x00091940
   874e0:	00091954 	.word	0x00091954
   874e4:	00091968 	.word	0x00091968
   874e8:	00091970 	.word	0x00091970
   874ec:	0009197c 	.word	0x0009197c
   874f0:	00091988 	.word	0x00091988
   874f4:	00091990 	.word	0x00091990
   874f8:	000919a4 	.word	0x000919a4

000874fc <report_grbl_help>:
{
  printString(("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
}

// Grbl help message
void report_grbl_help() {
   874fc:	b508      	push	{r3, lr}
  #ifndef REPORT_GUI_MODE
    printString(("$$ (view Grbl settings)\r\n"
   874fe:	4802      	ldr	r0, [pc, #8]	; (87508 <report_grbl_help+0xc>)
   87500:	4b02      	ldr	r3, [pc, #8]	; (8750c <report_grbl_help+0x10>)
   87502:	4798      	blx	r3
   87504:	bd08      	pop	{r3, pc}
   87506:	bf00      	nop
   87508:	000919c8 	.word	0x000919c8
   8750c:	00084d15 	.word	0x00084d15

00087510 <report_grbl_settings>:
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
   87510:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    printString(("\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
    printString(("\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
    printString(("\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
    printString(("\r\n"));
  #else      
    printString(("$0=")); print_uint8_base10(settings.pulse_microseconds);
   87514:	4890      	ldr	r0, [pc, #576]	; (87758 <report_grbl_settings+0x248>)
   87516:	4c91      	ldr	r4, [pc, #580]	; (8775c <report_grbl_settings+0x24c>)
   87518:	47a0      	blx	r4
   8751a:	4d91      	ldr	r5, [pc, #580]	; (87760 <report_grbl_settings+0x250>)
   8751c:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
   87520:	4e90      	ldr	r6, [pc, #576]	; (87764 <report_grbl_settings+0x254>)
   87522:	47b0      	blx	r6
    printString((" (step pulse, usec)\r\n$1=")); print_uint8_base10(settings.stepper_idle_lock_time);
   87524:	4890      	ldr	r0, [pc, #576]	; (87768 <report_grbl_settings+0x258>)
   87526:	47a0      	blx	r4
   87528:	f895 0033 	ldrb.w	r0, [r5, #51]	; 0x33
   8752c:	47b0      	blx	r6
    printString((" (step idle delay, msec)\r\n$2=")); print_uint8_base10(settings.step_invert_mask); 
   8752e:	488f      	ldr	r0, [pc, #572]	; (8776c <report_grbl_settings+0x25c>)
   87530:	47a0      	blx	r4
   87532:	f895 0031 	ldrb.w	r0, [r5, #49]	; 0x31
   87536:	47b0      	blx	r6
    printString((" (step port invert mask:")); print_uint8_base2(settings.step_invert_mask);  
   87538:	488d      	ldr	r0, [pc, #564]	; (87770 <report_grbl_settings+0x260>)
   8753a:	47a0      	blx	r4
   8753c:	f895 0031 	ldrb.w	r0, [r5, #49]	; 0x31
   87540:	f8df 82b0 	ldr.w	r8, [pc, #688]	; 877f4 <report_grbl_settings+0x2e4>
   87544:	47c0      	blx	r8
    printString((")\r\n$3=")); print_uint8_base10(settings.dir_invert_mask); 
   87546:	488b      	ldr	r0, [pc, #556]	; (87774 <report_grbl_settings+0x264>)
   87548:	47a0      	blx	r4
   8754a:	f895 0032 	ldrb.w	r0, [r5, #50]	; 0x32
   8754e:	47b0      	blx	r6
    printString((" (dir port invert mask:")); print_uint8_base2(settings.dir_invert_mask);  
   87550:	4889      	ldr	r0, [pc, #548]	; (87778 <report_grbl_settings+0x268>)
   87552:	47a0      	blx	r4
   87554:	f895 0032 	ldrb.w	r0, [r5, #50]	; 0x32
   87558:	47c0      	blx	r8
    printString((")\r\n$4=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
   8755a:	4888      	ldr	r0, [pc, #544]	; (8777c <report_grbl_settings+0x26c>)
   8755c:	47a0      	blx	r4
   8755e:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   87562:	f3c0 0080 	ubfx	r0, r0, #2, #1
   87566:	47b0      	blx	r6
    printString((" (step enable invert, bool)\r\n$5=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
   87568:	4885      	ldr	r0, [pc, #532]	; (87780 <report_grbl_settings+0x270>)
   8756a:	47a0      	blx	r4
   8756c:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   87570:	f3c0 1080 	ubfx	r0, r0, #6, #1
   87574:	47b0      	blx	r6
    printString((" (limit pins invert, bool)\r\n$6=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
   87576:	4883      	ldr	r0, [pc, #524]	; (87784 <report_grbl_settings+0x274>)
   87578:	47a0      	blx	r4
   8757a:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   8757e:	09c0      	lsrs	r0, r0, #7
   87580:	47b0      	blx	r6
    printString((" (probe pin invert, bool)\r\n$10=")); print_uint8_base10(settings.status_report_mask);
   87582:	4881      	ldr	r0, [pc, #516]	; (87788 <report_grbl_settings+0x278>)
   87584:	47a0      	blx	r4
   87586:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
   8758a:	47b0      	blx	r6
    printString((" (status report mask:")); print_uint8_base2(settings.status_report_mask);
   8758c:	487f      	ldr	r0, [pc, #508]	; (8778c <report_grbl_settings+0x27c>)
   8758e:	47a0      	blx	r4
   87590:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
   87594:	47c0      	blx	r8
    printString((")\r\n$11=")); printFloat_SettingValue(settings.junction_deviation);
   87596:	487e      	ldr	r0, [pc, #504]	; (87790 <report_grbl_settings+0x280>)
   87598:	47a0      	blx	r4
   8759a:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   8759c:	4f7d      	ldr	r7, [pc, #500]	; (87794 <report_grbl_settings+0x284>)
   8759e:	47b8      	blx	r7
    printString((" (junction deviation, mm)\r\n$12=")); printFloat_SettingValue(settings.arc_tolerance);
   875a0:	487d      	ldr	r0, [pc, #500]	; (87798 <report_grbl_settings+0x288>)
   875a2:	47a0      	blx	r4
   875a4:	6be8      	ldr	r0, [r5, #60]	; 0x3c
   875a6:	47b8      	blx	r7
    printString((" (arc tolerance, mm)\r\n$13=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
   875a8:	487c      	ldr	r0, [pc, #496]	; (8779c <report_grbl_settings+0x28c>)
   875aa:	47a0      	blx	r4
   875ac:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   875b0:	f000 0001 	and.w	r0, r0, #1
   875b4:	47b0      	blx	r6
    printString((" (report inches, bool)\r\n$20=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
   875b6:	487a      	ldr	r0, [pc, #488]	; (877a0 <report_grbl_settings+0x290>)
   875b8:	47a0      	blx	r4
   875ba:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   875be:	f3c0 1040 	ubfx	r0, r0, #5, #1
   875c2:	47b0      	blx	r6
    printString((" (soft limits, bool)\r\n$21=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
   875c4:	4877      	ldr	r0, [pc, #476]	; (877a4 <report_grbl_settings+0x294>)
   875c6:	47a0      	blx	r4
   875c8:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   875cc:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   875d0:	47b0      	blx	r6
    printString((" (hard limits, bool)\r\n$22=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
   875d2:	4875      	ldr	r0, [pc, #468]	; (877a8 <report_grbl_settings+0x298>)
   875d4:	47a0      	blx	r4
   875d6:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
   875da:	f3c0 1000 	ubfx	r0, r0, #4, #1
   875de:	47b0      	blx	r6
    printString((" (homing cycle, bool)\r\n$23=")); print_uint8_base10(settings.homing_dir_mask);
   875e0:	4872      	ldr	r0, [pc, #456]	; (877ac <report_grbl_settings+0x29c>)
   875e2:	47a0      	blx	r4
   875e4:	f895 0041 	ldrb.w	r0, [r5, #65]	; 0x41
   875e8:	47b0      	blx	r6
    printString((" (homing dir invert mask:")); print_uint8_base2(settings.homing_dir_mask);  
   875ea:	4871      	ldr	r0, [pc, #452]	; (877b0 <report_grbl_settings+0x2a0>)
   875ec:	47a0      	blx	r4
   875ee:	f895 0041 	ldrb.w	r0, [r5, #65]	; 0x41
   875f2:	47c0      	blx	r8
    printString((")\r\n$24=")); printFloat_SettingValue(settings.homing_feed_rate);
   875f4:	486f      	ldr	r0, [pc, #444]	; (877b4 <report_grbl_settings+0x2a4>)
   875f6:	47a0      	blx	r4
   875f8:	6c68      	ldr	r0, [r5, #68]	; 0x44
   875fa:	47b8      	blx	r7
    printString((" (homing feed, mm/min)\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
   875fc:	486e      	ldr	r0, [pc, #440]	; (877b8 <report_grbl_settings+0x2a8>)
   875fe:	47a0      	blx	r4
   87600:	6ca8      	ldr	r0, [r5, #72]	; 0x48
   87602:	47b8      	blx	r7
    printString((" (homing seek, mm/min)\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
   87604:	486d      	ldr	r0, [pc, #436]	; (877bc <report_grbl_settings+0x2ac>)
   87606:	47a0      	blx	r4
   87608:	f895 004c 	ldrb.w	r0, [r5, #76]	; 0x4c
   8760c:	47b0      	blx	r6
    printString((" (homing debounce, msec)\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
   8760e:	486c      	ldr	r0, [pc, #432]	; (877c0 <report_grbl_settings+0x2b0>)
   87610:	47a0      	blx	r4
   87612:	6d28      	ldr	r0, [r5, #80]	; 0x50
   87614:	47b8      	blx	r7
    printString((" (homing pull-off, mm)\r\n"));
   87616:	486b      	ldr	r0, [pc, #428]	; (877c4 <report_grbl_settings+0x2b4>)
   87618:	47a0      	blx	r4
  #endif
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
   8761a:	2764      	movs	r7, #100	; 0x64
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
   8761c:	2600      	movs	r6, #0
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8761e:	4625      	mov	r5, r4
      print_uint8_base10(val+idx);
      printString(("="));
      switch (set_idx) {
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
   87620:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 877f8 <report_grbl_settings+0x2e8>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   87624:	f8df 91d4 	ldr.w	r9, [pc, #468]	; 877fc <report_grbl_settings+0x2ec>
      print_uint8_base10(val+idx);
   87628:	f8df 8138 	ldr.w	r8, [pc, #312]	; 87764 <report_grbl_settings+0x254>
   8762c:	e0f5      	b.n	8781a <report_grbl_settings+0x30a>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8762e:	4648      	mov	r0, r9
   87630:	47a8      	blx	r5
      print_uint8_base10(val+idx);
   87632:	19e0      	adds	r0, r4, r7
   87634:	b2c0      	uxtb	r0, r0
   87636:	47c0      	blx	r8
      printString(("="));
   87638:	4863      	ldr	r0, [pc, #396]	; (877c8 <report_grbl_settings+0x2b8>)
   8763a:	47a8      	blx	r5
      switch (set_idx) {
   8763c:	2e03      	cmp	r6, #3
   8763e:	d840      	bhi.n	876c2 <report_grbl_settings+0x1b2>
   87640:	e8df f006 	tbb	[pc, r6]
   87644:	2f1e1002 	.word	0x2f1e1002
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
   87648:	4b45      	ldr	r3, [pc, #276]	; (87760 <report_grbl_settings+0x250>)
   8764a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   8764e:	4b51      	ldr	r3, [pc, #324]	; (87794 <report_grbl_settings+0x284>)
   87650:	4798      	blx	r3
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
      }
      #ifdef REPORT_GUI_MODE
        printString(("\r\n"));
      #else
        printString((" ("));
   87652:	485e      	ldr	r0, [pc, #376]	; (877cc <report_grbl_settings+0x2bc>)
   87654:	47a8      	blx	r5
        switch (idx) {
   87656:	2c01      	cmp	r4, #1
   87658:	d03f      	beq.n	876da <report_grbl_settings+0x1ca>
   8765a:	2c00      	cmp	r4, #0
   8765c:	d039      	beq.n	876d2 <report_grbl_settings+0x1c2>
   8765e:	2c02      	cmp	r4, #2
   87660:	d03f      	beq.n	876e2 <report_grbl_settings+0x1d2>
   87662:	e04f      	b.n	87704 <report_grbl_settings+0x1f4>
      printString(("$"));
      print_uint8_base10(val+idx);
      printString(("="));
      switch (set_idx) {
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
   87664:	4b3e      	ldr	r3, [pc, #248]	; (87760 <report_grbl_settings+0x250>)
   87666:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   8766a:	68d8      	ldr	r0, [r3, #12]
   8766c:	4b49      	ldr	r3, [pc, #292]	; (87794 <report_grbl_settings+0x284>)
   8766e:	4798      	blx	r3
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
      }
      #ifdef REPORT_GUI_MODE
        printString(("\r\n"));
      #else
        printString((" ("));
   87670:	4856      	ldr	r0, [pc, #344]	; (877cc <report_grbl_settings+0x2bc>)
   87672:	47a8      	blx	r5
        switch (idx) {
   87674:	2c01      	cmp	r4, #1
   87676:	d030      	beq.n	876da <report_grbl_settings+0x1ca>
   87678:	b35c      	cbz	r4, 876d2 <report_grbl_settings+0x1c2>
   8767a:	2c02      	cmp	r4, #2
   8767c:	d031      	beq.n	876e2 <report_grbl_settings+0x1d2>
   8767e:	e04b      	b.n	87718 <report_grbl_settings+0x208>
      print_uint8_base10(val+idx);
      printString(("="));
      switch (set_idx) {
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
   87680:	1da3      	adds	r3, r4, #6
   87682:	4a37      	ldr	r2, [pc, #220]	; (87760 <report_grbl_settings+0x250>)
   87684:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
   87688:	4651      	mov	r1, sl
   8768a:	4b51      	ldr	r3, [pc, #324]	; (877d0 <report_grbl_settings+0x2c0>)
   8768c:	4798      	blx	r3
   8768e:	4b41      	ldr	r3, [pc, #260]	; (87794 <report_grbl_settings+0x284>)
   87690:	4798      	blx	r3
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
      }
      #ifdef REPORT_GUI_MODE
        printString(("\r\n"));
      #else
        printString((" ("));
   87692:	484e      	ldr	r0, [pc, #312]	; (877cc <report_grbl_settings+0x2bc>)
   87694:	47a8      	blx	r5
        switch (idx) {
   87696:	2c01      	cmp	r4, #1
   87698:	d01f      	beq.n	876da <report_grbl_settings+0x1ca>
   8769a:	b1d4      	cbz	r4, 876d2 <report_grbl_settings+0x1c2>
   8769c:	2c02      	cmp	r4, #2
   8769e:	d020      	beq.n	876e2 <report_grbl_settings+0x1d2>
   876a0:	e045      	b.n	8772e <report_grbl_settings+0x21e>
      printString(("="));
      switch (set_idx) {
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
   876a2:	4b2f      	ldr	r3, [pc, #188]	; (87760 <report_grbl_settings+0x250>)
   876a4:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   876a8:	6a58      	ldr	r0, [r3, #36]	; 0x24
   876aa:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   876ae:	4b39      	ldr	r3, [pc, #228]	; (87794 <report_grbl_settings+0x284>)
   876b0:	4798      	blx	r3
      }
      #ifdef REPORT_GUI_MODE
        printString(("\r\n"));
      #else
        printString((" ("));
   876b2:	4846      	ldr	r0, [pc, #280]	; (877cc <report_grbl_settings+0x2bc>)
   876b4:	47a8      	blx	r5
        switch (idx) {
   876b6:	2c01      	cmp	r4, #1
   876b8:	d00f      	beq.n	876da <report_grbl_settings+0x1ca>
   876ba:	b154      	cbz	r4, 876d2 <report_grbl_settings+0x1c2>
   876bc:	2c02      	cmp	r4, #2
   876be:	d010      	beq.n	876e2 <report_grbl_settings+0x1d2>
   876c0:	e040      	b.n	87744 <report_grbl_settings+0x234>
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
      }
      #ifdef REPORT_GUI_MODE
        printString(("\r\n"));
      #else
        printString((" ("));
   876c2:	4842      	ldr	r0, [pc, #264]	; (877cc <report_grbl_settings+0x2bc>)
   876c4:	47a8      	blx	r5
        switch (idx) {
   876c6:	2c01      	cmp	r4, #1
   876c8:	d007      	beq.n	876da <report_grbl_settings+0x1ca>
   876ca:	b114      	cbz	r4, 876d2 <report_grbl_settings+0x1c2>
   876cc:	2c02      	cmp	r4, #2
   876ce:	d008      	beq.n	876e2 <report_grbl_settings+0x1d2>
   876d0:	e011      	b.n	876f6 <report_grbl_settings+0x1e6>
          case X_AXIS: printString(("x")); break;
   876d2:	4840      	ldr	r0, [pc, #256]	; (877d4 <report_grbl_settings+0x2c4>)
   876d4:	47a8      	blx	r5
   876d6:	2400      	movs	r4, #0
   876d8:	e0a6      	b.n	87828 <report_grbl_settings+0x318>
          case Y_AXIS: printString(("y")); break;
   876da:	483f      	ldr	r0, [pc, #252]	; (877d8 <report_grbl_settings+0x2c8>)
   876dc:	47a8      	blx	r5
   876de:	2401      	movs	r4, #1
   876e0:	e0a2      	b.n	87828 <report_grbl_settings+0x318>
          case Z_AXIS: printString(("z")); break;
   876e2:	483e      	ldr	r0, [pc, #248]	; (877dc <report_grbl_settings+0x2cc>)
   876e4:	47a8      	blx	r5
   876e6:	2402      	movs	r4, #2
        }
        switch (set_idx) {
   876e8:	2e03      	cmp	r6, #3
   876ea:	f200 80ab 	bhi.w	87844 <report_grbl_settings+0x334>
   876ee:	e8df f006 	tbb	[pc, r6]
   876f2:	1309      	.short	0x1309
   876f4:	281d      	.short	0x281d
   876f6:	2e03      	cmp	r6, #3
   876f8:	f200 8082 	bhi.w	87800 <report_grbl_settings+0x2f0>
   876fc:	e8df f006 	tbb	[pc, r6]
   87700:	22170c02 	.word	0x22170c02
          case 0: printString((", step/mm")); break;
   87704:	4836      	ldr	r0, [pc, #216]	; (877e0 <report_grbl_settings+0x2d0>)
   87706:	47a8      	blx	r5
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   87708:	4836      	ldr	r0, [pc, #216]	; (877e4 <report_grbl_settings+0x2d4>)
   8770a:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   8770c:	3401      	adds	r4, #1
   8770e:	b2e4      	uxtb	r4, r4
   87710:	2c02      	cmp	r4, #2
   87712:	f240 80a2 	bls.w	8785a <report_grbl_settings+0x34a>
   87716:	e07a      	b.n	8780e <report_grbl_settings+0x2fe>
          case Y_AXIS: printString(("y")); break;
          case Z_AXIS: printString(("z")); break;
        }
        switch (set_idx) {
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
   87718:	4833      	ldr	r0, [pc, #204]	; (877e8 <report_grbl_settings+0x2d8>)
   8771a:	47a8      	blx	r5
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   8771c:	4831      	ldr	r0, [pc, #196]	; (877e4 <report_grbl_settings+0x2d4>)
   8771e:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   87720:	3401      	adds	r4, #1
   87722:	b2e4      	uxtb	r4, r4
   87724:	2c02      	cmp	r4, #2
   87726:	f240 80a0 	bls.w	8786a <report_grbl_settings+0x35a>
   8772a:	e070      	b.n	8780e <report_grbl_settings+0x2fe>
        switch (idx) {
          case X_AXIS: printString(("x")); break;
          case Y_AXIS: printString(("y")); break;
          case Z_AXIS: printString(("z")); break;
        }
        switch (set_idx) {
   8772c:	2402      	movs	r4, #2
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
   8772e:	482f      	ldr	r0, [pc, #188]	; (877ec <report_grbl_settings+0x2dc>)
   87730:	47a8      	blx	r5
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   87732:	482c      	ldr	r0, [pc, #176]	; (877e4 <report_grbl_settings+0x2d4>)
   87734:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   87736:	3401      	adds	r4, #1
   87738:	b2e4      	uxtb	r4, r4
   8773a:	2c02      	cmp	r4, #2
   8773c:	f240 809d 	bls.w	8787a <report_grbl_settings+0x36a>
   87740:	e065      	b.n	8780e <report_grbl_settings+0x2fe>
        switch (idx) {
          case X_AXIS: printString(("x")); break;
          case Y_AXIS: printString(("y")); break;
          case Z_AXIS: printString(("z")); break;
        }
        switch (set_idx) {
   87742:	2402      	movs	r4, #2
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
   87744:	482a      	ldr	r0, [pc, #168]	; (877f0 <report_grbl_settings+0x2e0>)
   87746:	47a8      	blx	r5
        }      
        printString((")\r\n"));
   87748:	4826      	ldr	r0, [pc, #152]	; (877e4 <report_grbl_settings+0x2d4>)
   8774a:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   8774c:	3401      	adds	r4, #1
   8774e:	b2e4      	uxtb	r4, r4
   87750:	2c02      	cmp	r4, #2
   87752:	d97a      	bls.n	8784a <report_grbl_settings+0x33a>
   87754:	e05b      	b.n	8780e <report_grbl_settings+0x2fe>
   87756:	bf00      	nop
   87758:	00091b0c 	.word	0x00091b0c
   8775c:	00084d15 	.word	0x00084d15
   87760:	20001510 	.word	0x20001510
   87764:	00084d91 	.word	0x00084d91
   87768:	00091b10 	.word	0x00091b10
   8776c:	00091b2c 	.word	0x00091b2c
   87770:	00091b4c 	.word	0x00091b4c
   87774:	00091b68 	.word	0x00091b68
   87778:	00091b70 	.word	0x00091b70
   8777c:	00091b88 	.word	0x00091b88
   87780:	00091b90 	.word	0x00091b90
   87784:	00091bb4 	.word	0x00091bb4
   87788:	00091bd4 	.word	0x00091bd4
   8778c:	00091bf4 	.word	0x00091bf4
   87790:	00091c0c 	.word	0x00091c0c
   87794:	00084f5d 	.word	0x00084f5d
   87798:	00091c14 	.word	0x00091c14
   8779c:	00091c34 	.word	0x00091c34
   877a0:	00091c50 	.word	0x00091c50
   877a4:	00091c70 	.word	0x00091c70
   877a8:	00091c8c 	.word	0x00091c8c
   877ac:	00091ca8 	.word	0x00091ca8
   877b0:	00091cc4 	.word	0x00091cc4
   877b4:	00091ce0 	.word	0x00091ce0
   877b8:	00091ce8 	.word	0x00091ce8
   877bc:	00091d08 	.word	0x00091d08
   877c0:	00091d28 	.word	0x00091d28
   877c4:	00091d48 	.word	0x00091d48
   877c8:	00091b48 	.word	0x00091b48
   877cc:	00091d68 	.word	0x00091d68
   877d0:	0008c89d 	.word	0x0008c89d
   877d4:	00091d6c 	.word	0x00091d6c
   877d8:	00091d70 	.word	0x00091d70
   877dc:	00091d74 	.word	0x00091d74
   877e0:	00091d78 	.word	0x00091d78
   877e4:	00091b08 	.word	0x00091b08
   877e8:	00091d84 	.word	0x00091d84
   877ec:	00091d98 	.word	0x00091d98
   877f0:	00091dac 	.word	0x00091dac
   877f4:	00084d81 	.word	0x00084d81
   877f8:	45610000 	.word	0x45610000
   877fc:	00091d64 	.word	0x00091d64
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   87800:	4823      	ldr	r0, [pc, #140]	; (87890 <report_grbl_settings+0x380>)
   87802:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   87804:	3401      	adds	r4, #1
   87806:	b2e4      	uxtb	r4, r4
   87808:	2c02      	cmp	r4, #2
   8780a:	f67f af10 	bls.w	8762e <report_grbl_settings+0x11e>
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
      #endif
    }
    val += AXIS_SETTINGS_INCREMENT;
   8780e:	370a      	adds	r7, #10
   87810:	b2ff      	uxtb	r7, r7
  #endif
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
   87812:	3601      	adds	r6, #1
   87814:	b2f6      	uxtb	r6, r6
   87816:	2f8c      	cmp	r7, #140	; 0x8c
   87818:	d037      	beq.n	8788a <report_grbl_settings+0x37a>
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
   8781a:	2400      	movs	r4, #0
   8781c:	e707      	b.n	8762e <report_grbl_settings+0x11e>
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   8781e:	481c      	ldr	r0, [pc, #112]	; (87890 <report_grbl_settings+0x380>)
   87820:	47a8      	blx	r5
  
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
   87822:	3401      	adds	r4, #1
   87824:	b2e4      	uxtb	r4, r4
   87826:	e702      	b.n	8762e <report_grbl_settings+0x11e>
        switch (idx) {
          case X_AXIS: printString(("x")); break;
          case Y_AXIS: printString(("y")); break;
          case Z_AXIS: printString(("z")); break;
        }
        switch (set_idx) {
   87828:	2e03      	cmp	r6, #3
   8782a:	d8f8      	bhi.n	8781e <report_grbl_settings+0x30e>
   8782c:	a301      	add	r3, pc, #4	; (adr r3, 87834 <report_grbl_settings+0x324>)
   8782e:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   87832:	bf00      	nop
   87834:	00087705 	.word	0x00087705
   87838:	00087719 	.word	0x00087719
   8783c:	0008772f 	.word	0x0008772f
   87840:	00087745 	.word	0x00087745
          case 0: printString((", step/mm")); break;
          case 1: printString((" max rate, mm/min")); break;
          case 2: printString((" accel, mm/sec^2")); break;
          case 3: printString((" max travel, mm")); break;
        }      
        printString((")\r\n"));
   87844:	4812      	ldr	r0, [pc, #72]	; (87890 <report_grbl_settings+0x380>)
   87846:	47a8      	blx	r5
   87848:	e7e1      	b.n	8780e <report_grbl_settings+0x2fe>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8784a:	4648      	mov	r0, r9
   8784c:	47a8      	blx	r5
      print_uint8_base10(val+idx);
   8784e:	19e0      	adds	r0, r4, r7
   87850:	b2c0      	uxtb	r0, r0
   87852:	47c0      	blx	r8
      printString(("="));
   87854:	480f      	ldr	r0, [pc, #60]	; (87894 <report_grbl_settings+0x384>)
   87856:	47a8      	blx	r5
   87858:	e723      	b.n	876a2 <report_grbl_settings+0x192>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8785a:	4648      	mov	r0, r9
   8785c:	47a8      	blx	r5
      print_uint8_base10(val+idx);
   8785e:	19e0      	adds	r0, r4, r7
   87860:	b2c0      	uxtb	r0, r0
   87862:	47c0      	blx	r8
      printString(("="));
   87864:	480b      	ldr	r0, [pc, #44]	; (87894 <report_grbl_settings+0x384>)
   87866:	47a8      	blx	r5
   87868:	e6ee      	b.n	87648 <report_grbl_settings+0x138>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8786a:	4648      	mov	r0, r9
   8786c:	47a8      	blx	r5
      print_uint8_base10(val+idx);
   8786e:	19e0      	adds	r0, r4, r7
   87870:	b2c0      	uxtb	r0, r0
   87872:	47c0      	blx	r8
      printString(("="));
   87874:	4807      	ldr	r0, [pc, #28]	; (87894 <report_grbl_settings+0x384>)
   87876:	47a8      	blx	r5
   87878:	e6f4      	b.n	87664 <report_grbl_settings+0x154>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printString(("$"));
   8787a:	4648      	mov	r0, r9
   8787c:	47a8      	blx	r5
      print_uint8_base10(val+idx);
   8787e:	19e0      	adds	r0, r4, r7
   87880:	b2c0      	uxtb	r0, r0
   87882:	47c0      	blx	r8
      printString(("="));
   87884:	4803      	ldr	r0, [pc, #12]	; (87894 <report_grbl_settings+0x384>)
   87886:	47a8      	blx	r5
   87888:	e6fa      	b.n	87680 <report_grbl_settings+0x170>
   8788a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   8788e:	bf00      	nop
   87890:	00091b08 	.word	0x00091b08
   87894:	00091b48 	.word	0x00091b48

00087898 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported). 
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
   87898:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printString(("[PRB:"));
   8789c:	480f      	ldr	r0, [pc, #60]	; (878dc <report_probe_parameters+0x44>)
   8789e:	4b10      	ldr	r3, [pc, #64]	; (878e0 <report_probe_parameters+0x48>)
   878a0:	4798      	blx	r3
   878a2:	2500      	movs	r5, #0
  for (i=0; i< N_AXIS; i++) {
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
   878a4:	f8df 8058 	ldr.w	r8, [pc, #88]	; 87900 <report_probe_parameters+0x68>
   878a8:	4f0e      	ldr	r7, [pc, #56]	; (878e4 <report_probe_parameters+0x4c>)
    printFloat_CoordValue(print_position[i]);
   878aa:	4e0f      	ldr	r6, [pc, #60]	; (878e8 <report_probe_parameters+0x50>)
   878ac:	b2ec      	uxtb	r4, r5
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printString(("[PRB:"));
  for (i=0; i< N_AXIS; i++) {
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
   878ae:	4640      	mov	r0, r8
   878b0:	4621      	mov	r1, r4
   878b2:	47b8      	blx	r7
    printFloat_CoordValue(print_position[i]);
   878b4:	47b0      	blx	r6
    if (i < (N_AXIS-1)) { printString((",")); }
   878b6:	2c01      	cmp	r4, #1
   878b8:	d802      	bhi.n	878c0 <report_probe_parameters+0x28>
   878ba:	480c      	ldr	r0, [pc, #48]	; (878ec <report_probe_parameters+0x54>)
   878bc:	4b08      	ldr	r3, [pc, #32]	; (878e0 <report_probe_parameters+0x48>)
   878be:	4798      	blx	r3
   878c0:	3501      	adds	r5, #1
  uint8_t i;
  float print_position[N_AXIS];
 
  // Report in terms of machine position.
  printString(("[PRB:"));
  for (i=0; i< N_AXIS; i++) {
   878c2:	2d03      	cmp	r5, #3
   878c4:	d1f2      	bne.n	878ac <report_probe_parameters+0x14>
    print_position[i] = system_convert_axis_steps_to_mpos(sys.probe_position,i);
    printFloat_CoordValue(print_position[i]);
    if (i < (N_AXIS-1)) { printString((",")); }
  }
  printString((":"));
   878c6:	480a      	ldr	r0, [pc, #40]	; (878f0 <report_probe_parameters+0x58>)
   878c8:	4c05      	ldr	r4, [pc, #20]	; (878e0 <report_probe_parameters+0x48>)
   878ca:	47a0      	blx	r4
  print_uint8_base10(sys.probe_succeeded);
   878cc:	4b09      	ldr	r3, [pc, #36]	; (878f4 <report_probe_parameters+0x5c>)
   878ce:	7f18      	ldrb	r0, [r3, #28]
   878d0:	4b09      	ldr	r3, [pc, #36]	; (878f8 <report_probe_parameters+0x60>)
   878d2:	4798      	blx	r3
  printString(("]\r\n"));
   878d4:	4809      	ldr	r0, [pc, #36]	; (878fc <report_probe_parameters+0x64>)
   878d6:	47a0      	blx	r4
   878d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   878dc:	00091dbc 	.word	0x00091dbc
   878e0:	00084d15 	.word	0x00084d15
   878e4:	00089625 	.word	0x00089625
   878e8:	00084ec1 	.word	0x00084ec1
   878ec:	00091790 	.word	0x00091790
   878f0:	00091dd4 	.word	0x00091dd4
   878f4:	20001484 	.word	0x20001484
   878f8:	00084d91 	.word	0x00084d91
   878fc:	000919a4 	.word	0x000919a4
   87900:	20001494 	.word	0x20001494

00087904 <report_ngc_parameters>:
}


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
   87904:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   87908:	b084      	sub	sp, #16
   8790a:	2500      	movs	r5, #0
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    if (!(settings_read_coord_data(coord_select,coord_data))) { 
   8790c:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 87a00 <report_ngc_parameters+0xfc>
      report_status_message(STATUS_SETTING_READ_FAIL); 
      return;
    } 
    printString(("[G"));
   87910:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 87a04 <report_ngc_parameters+0x100>
      case 7: printString(("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printString((":"));         
    for (i=0; i<N_AXIS; i++) {
      printFloat_CoordValue(coord_data[i]);
   87914:	4f2c      	ldr	r7, [pc, #176]	; (879c8 <report_ngc_parameters+0xc4>)
      if (i < (N_AXIS-1)) { printString((",")); }
      else { printString(("]\r\n")); }
   87916:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 879f8 <report_ngc_parameters+0xf4>
   8791a:	b2ec      	uxtb	r4, r5
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
    if (!(settings_read_coord_data(coord_select,coord_data))) { 
   8791c:	4620      	mov	r0, r4
   8791e:	a901      	add	r1, sp, #4
   87920:	47c8      	blx	r9
   87922:	b918      	cbnz	r0, 8792c <report_ngc_parameters+0x28>
      report_status_message(STATUS_SETTING_READ_FAIL); 
   87924:	2007      	movs	r0, #7
   87926:	4b29      	ldr	r3, [pc, #164]	; (879cc <report_ngc_parameters+0xc8>)
   87928:	4798      	blx	r3
   8792a:	e049      	b.n	879c0 <report_ngc_parameters+0xbc>
      return;
    } 
    printString(("[G"));
   8792c:	4650      	mov	r0, sl
   8792e:	4b28      	ldr	r3, [pc, #160]	; (879d0 <report_ngc_parameters+0xcc>)
   87930:	4798      	blx	r3
    switch (coord_select) {
   87932:	2c06      	cmp	r4, #6
   87934:	d002      	beq.n	8793c <report_ngc_parameters+0x38>
   87936:	2c07      	cmp	r4, #7
   87938:	d004      	beq.n	87944 <report_ngc_parameters+0x40>
   8793a:	e007      	b.n	8794c <report_ngc_parameters+0x48>
      case 6: printString(("28")); break;
   8793c:	4825      	ldr	r0, [pc, #148]	; (879d4 <report_ngc_parameters+0xd0>)
   8793e:	4b24      	ldr	r3, [pc, #144]	; (879d0 <report_ngc_parameters+0xcc>)
   87940:	4798      	blx	r3
   87942:	e008      	b.n	87956 <report_ngc_parameters+0x52>
      case 7: printString(("30")); break;
   87944:	4824      	ldr	r0, [pc, #144]	; (879d8 <report_ngc_parameters+0xd4>)
   87946:	4b22      	ldr	r3, [pc, #136]	; (879d0 <report_ngc_parameters+0xcc>)
   87948:	4798      	blx	r3
   8794a:	e004      	b.n	87956 <report_ngc_parameters+0x52>
   8794c:	f104 0036 	add.w	r0, r4, #54	; 0x36
      default: print_uint8_base10(coord_select+54); break; // G54-G59
   87950:	b2c0      	uxtb	r0, r0
   87952:	4b22      	ldr	r3, [pc, #136]	; (879dc <report_ngc_parameters+0xd8>)
   87954:	4798      	blx	r3
    }  
    printString((":"));         
   87956:	4822      	ldr	r0, [pc, #136]	; (879e0 <report_ngc_parameters+0xdc>)
   87958:	4b1d      	ldr	r3, [pc, #116]	; (879d0 <report_ngc_parameters+0xcc>)
   8795a:	4798      	blx	r3
   8795c:	2400      	movs	r4, #0
    for (i=0; i<N_AXIS; i++) {
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printString((",")); }
      else { printString(("]\r\n")); }
   8795e:	4e1c      	ldr	r6, [pc, #112]	; (879d0 <report_ngc_parameters+0xcc>)
      case 7: printString(("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printString((":"));         
    for (i=0; i<N_AXIS; i++) {
      printFloat_CoordValue(coord_data[i]);
   87960:	ab01      	add	r3, sp, #4
   87962:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   87966:	47b8      	blx	r7
      if (i < (N_AXIS-1)) { printString((",")); }
   87968:	b2e3      	uxtb	r3, r4
   8796a:	2b01      	cmp	r3, #1
   8796c:	bf94      	ite	ls
   8796e:	481d      	ldrls	r0, [pc, #116]	; (879e4 <report_ngc_parameters+0xe0>)
      else { printString(("]\r\n")); }
   87970:	4640      	movhi	r0, r8
   87972:	47b0      	blx	r6
   87974:	3401      	adds	r4, #1
      case 6: printString(("28")); break;
      case 7: printString(("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }  
    printString((":"));         
    for (i=0; i<N_AXIS; i++) {
   87976:	2c03      	cmp	r4, #3
   87978:	d1f2      	bne.n	87960 <report_ngc_parameters+0x5c>
   8797a:	3501      	adds	r5, #1
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) { 
   8797c:	2d08      	cmp	r5, #8
   8797e:	d1cc      	bne.n	8791a <report_ngc_parameters+0x16>
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printString((",")); }
      else { printString(("]\r\n")); }
    } 
  }
  printString(("[G92:")); // Print G92,G92.1 which are not persistent in memory
   87980:	4819      	ldr	r0, [pc, #100]	; (879e8 <report_ngc_parameters+0xe4>)
   87982:	4b13      	ldr	r3, [pc, #76]	; (879d0 <report_ngc_parameters+0xcc>)
   87984:	4798      	blx	r3
   87986:	4d19      	ldr	r5, [pc, #100]	; (879ec <report_ngc_parameters+0xe8>)
   87988:	2400      	movs	r4, #0
  for (i=0; i<N_AXIS; i++) {
    printFloat_CoordValue(gc_state.coord_offset[i]);
   8798a:	4e0f      	ldr	r6, [pc, #60]	; (879c8 <report_ngc_parameters+0xc4>)
    if (i < (N_AXIS-1)) { printString((",")); }
    else { printString(("]\r\n")); }
   8798c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 879f8 <report_ngc_parameters+0xf4>
   87990:	4f0f      	ldr	r7, [pc, #60]	; (879d0 <report_ngc_parameters+0xcc>)
      else { printString(("]\r\n")); }
    } 
  }
  printString(("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
    printFloat_CoordValue(gc_state.coord_offset[i]);
   87992:	f855 0f04 	ldr.w	r0, [r5, #4]!
   87996:	47b0      	blx	r6
    if (i < (N_AXIS-1)) { printString((",")); }
   87998:	b2e3      	uxtb	r3, r4
   8799a:	2b01      	cmp	r3, #1
   8799c:	bf94      	ite	ls
   8799e:	4811      	ldrls	r0, [pc, #68]	; (879e4 <report_ngc_parameters+0xe0>)
    else { printString(("]\r\n")); }
   879a0:	4640      	movhi	r0, r8
   879a2:	47b8      	blx	r7
   879a4:	3401      	adds	r4, #1
      if (i < (N_AXIS-1)) { printString((",")); }
      else { printString(("]\r\n")); }
    } 
  }
  printString(("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
   879a6:	2c03      	cmp	r4, #3
   879a8:	d1f3      	bne.n	87992 <report_ngc_parameters+0x8e>
    printFloat_CoordValue(gc_state.coord_offset[i]);
    if (i < (N_AXIS-1)) { printString((",")); }
    else { printString(("]\r\n")); }
  } 
  printString(("[TLO:")); // Print tool length offset value
   879aa:	4811      	ldr	r0, [pc, #68]	; (879f0 <report_ngc_parameters+0xec>)
   879ac:	4c08      	ldr	r4, [pc, #32]	; (879d0 <report_ngc_parameters+0xcc>)
   879ae:	47a0      	blx	r4
  printFloat_CoordValue(gc_state.tool_length_offset);
   879b0:	4b10      	ldr	r3, [pc, #64]	; (879f4 <report_ngc_parameters+0xf0>)
   879b2:	6c18      	ldr	r0, [r3, #64]	; 0x40
   879b4:	4b04      	ldr	r3, [pc, #16]	; (879c8 <report_ngc_parameters+0xc4>)
   879b6:	4798      	blx	r3
  printString(("]\r\n"));
   879b8:	480f      	ldr	r0, [pc, #60]	; (879f8 <report_ngc_parameters+0xf4>)
   879ba:	47a0      	blx	r4
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
   879bc:	4b0f      	ldr	r3, [pc, #60]	; (879fc <report_ngc_parameters+0xf8>)
   879be:	4798      	blx	r3
}
   879c0:	b004      	add	sp, #16
   879c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   879c6:	bf00      	nop
   879c8:	00084ec1 	.word	0x00084ec1
   879cc:	000872f1 	.word	0x000872f1
   879d0:	00084d15 	.word	0x00084d15
   879d4:	00091dc8 	.word	0x00091dc8
   879d8:	00091dcc 	.word	0x00091dcc
   879dc:	00084d91 	.word	0x00084d91
   879e0:	00091dd4 	.word	0x00091dd4
   879e4:	00091790 	.word	0x00091790
   879e8:	00091dd0 	.word	0x00091dd0
   879ec:	200011f8 	.word	0x200011f8
   879f0:	00091dd8 	.word	0x00091dd8
   879f4:	200011c8 	.word	0x200011c8
   879f8:	000919a4 	.word	0x000919a4
   879fc:	00087899 	.word	0x00087899
   87a00:	00088021 	.word	0x00088021
   87a04:	00091dc4 	.word	0x00091dc4

00087a08 <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
   87a08:	b538      	push	{r3, r4, r5, lr}
  printString(("["));
   87a0a:	4852      	ldr	r0, [pc, #328]	; (87b54 <report_gcode_modes+0x14c>)
   87a0c:	4b52      	ldr	r3, [pc, #328]	; (87b58 <report_gcode_modes+0x150>)
   87a0e:	4798      	blx	r3
  
  switch (gc_state.modal.motion) {
   87a10:	4b52      	ldr	r3, [pc, #328]	; (87b5c <report_gcode_modes+0x154>)
   87a12:	781b      	ldrb	r3, [r3, #0]
   87a14:	2b08      	cmp	r3, #8
   87a16:	d81a      	bhi.n	87a4e <report_gcode_modes+0x46>
   87a18:	e8df f003 	tbb	[pc, r3]
   87a1c:	110d0905 	.word	0x110d0905
   87a20:	19191919 	.word	0x19191919
   87a24:	15          	.byte	0x15
   87a25:	00          	.byte	0x00
    case MOTION_MODE_SEEK : printString(("G0")); break;
   87a26:	484e      	ldr	r0, [pc, #312]	; (87b60 <report_gcode_modes+0x158>)
   87a28:	4b4b      	ldr	r3, [pc, #300]	; (87b58 <report_gcode_modes+0x150>)
   87a2a:	4798      	blx	r3
   87a2c:	e018      	b.n	87a60 <report_gcode_modes+0x58>
    case MOTION_MODE_LINEAR : printString(("G1")); break;
   87a2e:	484d      	ldr	r0, [pc, #308]	; (87b64 <report_gcode_modes+0x15c>)
   87a30:	4b49      	ldr	r3, [pc, #292]	; (87b58 <report_gcode_modes+0x150>)
   87a32:	4798      	blx	r3
   87a34:	e014      	b.n	87a60 <report_gcode_modes+0x58>
    case MOTION_MODE_CW_ARC : printString(("G2")); break;
   87a36:	484c      	ldr	r0, [pc, #304]	; (87b68 <report_gcode_modes+0x160>)
   87a38:	4b47      	ldr	r3, [pc, #284]	; (87b58 <report_gcode_modes+0x150>)
   87a3a:	4798      	blx	r3
   87a3c:	e010      	b.n	87a60 <report_gcode_modes+0x58>
    case MOTION_MODE_CCW_ARC : printString(("G3")); break;
   87a3e:	484b      	ldr	r0, [pc, #300]	; (87b6c <report_gcode_modes+0x164>)
   87a40:	4b45      	ldr	r3, [pc, #276]	; (87b58 <report_gcode_modes+0x150>)
   87a42:	4798      	blx	r3
   87a44:	e00c      	b.n	87a60 <report_gcode_modes+0x58>
    case MOTION_MODE_NONE : printString(("G80")); break;
   87a46:	484a      	ldr	r0, [pc, #296]	; (87b70 <report_gcode_modes+0x168>)
   87a48:	4b43      	ldr	r3, [pc, #268]	; (87b58 <report_gcode_modes+0x150>)
   87a4a:	4798      	blx	r3
   87a4c:	e008      	b.n	87a60 <report_gcode_modes+0x58>
    default: 
      printString(("G38."));
   87a4e:	4849      	ldr	r0, [pc, #292]	; (87b74 <report_gcode_modes+0x16c>)
   87a50:	4b41      	ldr	r3, [pc, #260]	; (87b58 <report_gcode_modes+0x150>)
   87a52:	4798      	blx	r3
      print_uint8_base10(gc_state.modal.motion - (MOTION_MODE_PROBE_TOWARD-2));
   87a54:	4b41      	ldr	r3, [pc, #260]	; (87b5c <report_gcode_modes+0x154>)
   87a56:	7818      	ldrb	r0, [r3, #0]
   87a58:	3802      	subs	r0, #2
   87a5a:	b2c0      	uxtb	r0, r0
   87a5c:	4b46      	ldr	r3, [pc, #280]	; (87b78 <report_gcode_modes+0x170>)
   87a5e:	4798      	blx	r3
  }

  printString((" G"));
   87a60:	4846      	ldr	r0, [pc, #280]	; (87b7c <report_gcode_modes+0x174>)
   87a62:	4b3d      	ldr	r3, [pc, #244]	; (87b58 <report_gcode_modes+0x150>)
   87a64:	4798      	blx	r3
  print_uint8_base10(gc_state.modal.coord_select+54);
   87a66:	4c3d      	ldr	r4, [pc, #244]	; (87b5c <report_gcode_modes+0x154>)
   87a68:	79a0      	ldrb	r0, [r4, #6]
   87a6a:	3036      	adds	r0, #54	; 0x36
   87a6c:	b2c0      	uxtb	r0, r0
   87a6e:	4b42      	ldr	r3, [pc, #264]	; (87b78 <report_gcode_modes+0x170>)
   87a70:	4798      	blx	r3
  
  switch (gc_state.modal.plane_select) {
   87a72:	7923      	ldrb	r3, [r4, #4]
   87a74:	2b01      	cmp	r3, #1
   87a76:	d007      	beq.n	87a88 <report_gcode_modes+0x80>
   87a78:	b113      	cbz	r3, 87a80 <report_gcode_modes+0x78>
   87a7a:	2b02      	cmp	r3, #2
   87a7c:	d008      	beq.n	87a90 <report_gcode_modes+0x88>
   87a7e:	e00a      	b.n	87a96 <report_gcode_modes+0x8e>
    case PLANE_SELECT_XY : printString((" G17")); break;
   87a80:	483f      	ldr	r0, [pc, #252]	; (87b80 <report_gcode_modes+0x178>)
   87a82:	4b35      	ldr	r3, [pc, #212]	; (87b58 <report_gcode_modes+0x150>)
   87a84:	4798      	blx	r3
   87a86:	e006      	b.n	87a96 <report_gcode_modes+0x8e>
    case PLANE_SELECT_ZX : printString((" G18")); break;
   87a88:	483e      	ldr	r0, [pc, #248]	; (87b84 <report_gcode_modes+0x17c>)
   87a8a:	4b33      	ldr	r3, [pc, #204]	; (87b58 <report_gcode_modes+0x150>)
   87a8c:	4798      	blx	r3
   87a8e:	e002      	b.n	87a96 <report_gcode_modes+0x8e>
    case PLANE_SELECT_YZ : printString((" G19")); break;
   87a90:	483d      	ldr	r0, [pc, #244]	; (87b88 <report_gcode_modes+0x180>)
   87a92:	4b31      	ldr	r3, [pc, #196]	; (87b58 <report_gcode_modes+0x150>)
   87a94:	4798      	blx	r3
  }
  
  if (gc_state.modal.units == UNITS_MODE_MM) { printString((" G21")); }
   87a96:	4b31      	ldr	r3, [pc, #196]	; (87b5c <report_gcode_modes+0x154>)
   87a98:	789b      	ldrb	r3, [r3, #2]
   87a9a:	b91b      	cbnz	r3, 87aa4 <report_gcode_modes+0x9c>
   87a9c:	483b      	ldr	r0, [pc, #236]	; (87b8c <report_gcode_modes+0x184>)
   87a9e:	4b2e      	ldr	r3, [pc, #184]	; (87b58 <report_gcode_modes+0x150>)
   87aa0:	4798      	blx	r3
   87aa2:	e002      	b.n	87aaa <report_gcode_modes+0xa2>
  else { printString((" G20")); }
   87aa4:	483a      	ldr	r0, [pc, #232]	; (87b90 <report_gcode_modes+0x188>)
   87aa6:	4b2c      	ldr	r3, [pc, #176]	; (87b58 <report_gcode_modes+0x150>)
   87aa8:	4798      	blx	r3
  
  if (gc_state.modal.distance == DISTANCE_MODE_ABSOLUTE) { printString((" G90")); }
   87aaa:	4b2c      	ldr	r3, [pc, #176]	; (87b5c <report_gcode_modes+0x154>)
   87aac:	78db      	ldrb	r3, [r3, #3]
   87aae:	b91b      	cbnz	r3, 87ab8 <report_gcode_modes+0xb0>
   87ab0:	4838      	ldr	r0, [pc, #224]	; (87b94 <report_gcode_modes+0x18c>)
   87ab2:	4b29      	ldr	r3, [pc, #164]	; (87b58 <report_gcode_modes+0x150>)
   87ab4:	4798      	blx	r3
   87ab6:	e002      	b.n	87abe <report_gcode_modes+0xb6>
  else { printString((" G91")); }
   87ab8:	4837      	ldr	r0, [pc, #220]	; (87b98 <report_gcode_modes+0x190>)
   87aba:	4b27      	ldr	r3, [pc, #156]	; (87b58 <report_gcode_modes+0x150>)
   87abc:	4798      	blx	r3
  
  if (gc_state.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { printString((" G93")); }
   87abe:	4b27      	ldr	r3, [pc, #156]	; (87b5c <report_gcode_modes+0x154>)
   87ac0:	785b      	ldrb	r3, [r3, #1]
   87ac2:	2b01      	cmp	r3, #1
   87ac4:	bf0c      	ite	eq
   87ac6:	4835      	ldreq	r0, [pc, #212]	; (87b9c <report_gcode_modes+0x194>)
  else { printString((" G94")); }
   87ac8:	4835      	ldrne	r0, [pc, #212]	; (87ba0 <report_gcode_modes+0x198>)
   87aca:	4b23      	ldr	r3, [pc, #140]	; (87b58 <report_gcode_modes+0x150>)
   87acc:	4798      	blx	r3
    
  switch (gc_state.modal.program_flow) {
   87ace:	4b23      	ldr	r3, [pc, #140]	; (87b5c <report_gcode_modes+0x154>)
   87ad0:	79db      	ldrb	r3, [r3, #7]
   87ad2:	2b01      	cmp	r3, #1
   87ad4:	d007      	beq.n	87ae6 <report_gcode_modes+0xde>
   87ad6:	b113      	cbz	r3, 87ade <report_gcode_modes+0xd6>
   87ad8:	2b02      	cmp	r3, #2
   87ada:	d008      	beq.n	87aee <report_gcode_modes+0xe6>
   87adc:	e00a      	b.n	87af4 <report_gcode_modes+0xec>
    case PROGRAM_FLOW_RUNNING : printString((" M0")); break;
   87ade:	4831      	ldr	r0, [pc, #196]	; (87ba4 <report_gcode_modes+0x19c>)
   87ae0:	4b1d      	ldr	r3, [pc, #116]	; (87b58 <report_gcode_modes+0x150>)
   87ae2:	4798      	blx	r3
   87ae4:	e006      	b.n	87af4 <report_gcode_modes+0xec>
    case PROGRAM_FLOW_PAUSED : printString((" M1")); break;
   87ae6:	4830      	ldr	r0, [pc, #192]	; (87ba8 <report_gcode_modes+0x1a0>)
   87ae8:	4b1b      	ldr	r3, [pc, #108]	; (87b58 <report_gcode_modes+0x150>)
   87aea:	4798      	blx	r3
   87aec:	e002      	b.n	87af4 <report_gcode_modes+0xec>
    case PROGRAM_FLOW_COMPLETED : printString((" M2")); break;
   87aee:	482f      	ldr	r0, [pc, #188]	; (87bac <report_gcode_modes+0x1a4>)
   87af0:	4b19      	ldr	r3, [pc, #100]	; (87b58 <report_gcode_modes+0x150>)
   87af2:	4798      	blx	r3
  }

  switch (gc_state.modal.spindle) {
   87af4:	4b19      	ldr	r3, [pc, #100]	; (87b5c <report_gcode_modes+0x154>)
   87af6:	7a5b      	ldrb	r3, [r3, #9]
   87af8:	2b01      	cmp	r3, #1
   87afa:	d003      	beq.n	87b04 <report_gcode_modes+0xfc>
   87afc:	b153      	cbz	r3, 87b14 <report_gcode_modes+0x10c>
   87afe:	2b02      	cmp	r3, #2
   87b00:	d004      	beq.n	87b0c <report_gcode_modes+0x104>
   87b02:	e00a      	b.n	87b1a <report_gcode_modes+0x112>
    case SPINDLE_ENABLE_CW : printString((" M3")); break;
   87b04:	482a      	ldr	r0, [pc, #168]	; (87bb0 <report_gcode_modes+0x1a8>)
   87b06:	4b14      	ldr	r3, [pc, #80]	; (87b58 <report_gcode_modes+0x150>)
   87b08:	4798      	blx	r3
   87b0a:	e006      	b.n	87b1a <report_gcode_modes+0x112>
    case SPINDLE_ENABLE_CCW : printString((" M4")); break;
   87b0c:	4829      	ldr	r0, [pc, #164]	; (87bb4 <report_gcode_modes+0x1ac>)
   87b0e:	4b12      	ldr	r3, [pc, #72]	; (87b58 <report_gcode_modes+0x150>)
   87b10:	4798      	blx	r3
   87b12:	e002      	b.n	87b1a <report_gcode_modes+0x112>
    case SPINDLE_DISABLE : printString((" M5")); break;
   87b14:	4828      	ldr	r0, [pc, #160]	; (87bb8 <report_gcode_modes+0x1b0>)
   87b16:	4b10      	ldr	r3, [pc, #64]	; (87b58 <report_gcode_modes+0x150>)
   87b18:	4798      	blx	r3
  }
  
  switch (gc_state.modal.coolant) {
   87b1a:	4b10      	ldr	r3, [pc, #64]	; (87b5c <report_gcode_modes+0x154>)
   87b1c:	7a1b      	ldrb	r3, [r3, #8]
   87b1e:	b113      	cbz	r3, 87b26 <report_gcode_modes+0x11e>
   87b20:	2b02      	cmp	r3, #2
   87b22:	d004      	beq.n	87b2e <report_gcode_modes+0x126>
   87b24:	e006      	b.n	87b34 <report_gcode_modes+0x12c>
    case COOLANT_DISABLE : printString((" M9")); break;
   87b26:	4825      	ldr	r0, [pc, #148]	; (87bbc <report_gcode_modes+0x1b4>)
   87b28:	4b0b      	ldr	r3, [pc, #44]	; (87b58 <report_gcode_modes+0x150>)
   87b2a:	4798      	blx	r3
   87b2c:	e002      	b.n	87b34 <report_gcode_modes+0x12c>
    case COOLANT_FLOOD_ENABLE : printString((" M8")); break;
   87b2e:	4824      	ldr	r0, [pc, #144]	; (87bc0 <report_gcode_modes+0x1b8>)
   87b30:	4b09      	ldr	r3, [pc, #36]	; (87b58 <report_gcode_modes+0x150>)
   87b32:	4798      	blx	r3
    #ifdef ENABLE_M7
      case COOLANT_MIST_ENABLE : printString((" M7")); break;
    #endif
  }
  
  printString((" T"));
   87b34:	4823      	ldr	r0, [pc, #140]	; (87bc4 <report_gcode_modes+0x1bc>)
   87b36:	4c08      	ldr	r4, [pc, #32]	; (87b58 <report_gcode_modes+0x150>)
   87b38:	47a0      	blx	r4
  print_uint8_base10(gc_state.tool);
   87b3a:	4d08      	ldr	r5, [pc, #32]	; (87b5c <report_gcode_modes+0x154>)
   87b3c:	7d28      	ldrb	r0, [r5, #20]
   87b3e:	4b0e      	ldr	r3, [pc, #56]	; (87b78 <report_gcode_modes+0x170>)
   87b40:	4798      	blx	r3
  
  printString((" F"));
   87b42:	4821      	ldr	r0, [pc, #132]	; (87bc8 <report_gcode_modes+0x1c0>)
   87b44:	47a0      	blx	r4
  printFloat_RateValue(gc_state.feed_rate);
   87b46:	6928      	ldr	r0, [r5, #16]
   87b48:	4b20      	ldr	r3, [pc, #128]	; (87bcc <report_gcode_modes+0x1c4>)
   87b4a:	4798      	blx	r3
  #ifdef VARIABLE_SPINDLE
    printString((" S"));
    printFloat_RateValue(gc_state.spindle_speed);
  #endif

  printString(("]\r\n"));
   87b4c:	4820      	ldr	r0, [pc, #128]	; (87bd0 <report_gcode_modes+0x1c8>)
   87b4e:	47a0      	blx	r4
   87b50:	bd38      	pop	{r3, r4, r5, pc}
   87b52:	bf00      	nop
   87b54:	00091928 	.word	0x00091928
   87b58:	00084d15 	.word	0x00084d15
   87b5c:	200011c8 	.word	0x200011c8
   87b60:	00091de0 	.word	0x00091de0
   87b64:	00091de4 	.word	0x00091de4
   87b68:	00091de8 	.word	0x00091de8
   87b6c:	00091dec 	.word	0x00091dec
   87b70:	00091df0 	.word	0x00091df0
   87b74:	00091df4 	.word	0x00091df4
   87b78:	00084d91 	.word	0x00084d91
   87b7c:	00091dfc 	.word	0x00091dfc
   87b80:	00091e00 	.word	0x00091e00
   87b84:	00091e08 	.word	0x00091e08
   87b88:	00091e10 	.word	0x00091e10
   87b8c:	00091e18 	.word	0x00091e18
   87b90:	00091e20 	.word	0x00091e20
   87b94:	00091e28 	.word	0x00091e28
   87b98:	00091e30 	.word	0x00091e30
   87b9c:	00091e38 	.word	0x00091e38
   87ba0:	00091e40 	.word	0x00091e40
   87ba4:	00091e48 	.word	0x00091e48
   87ba8:	00091e4c 	.word	0x00091e4c
   87bac:	00091e50 	.word	0x00091e50
   87bb0:	00091e54 	.word	0x00091e54
   87bb4:	00091e58 	.word	0x00091e58
   87bb8:	00091e5c 	.word	0x00091e5c
   87bbc:	00091e60 	.word	0x00091e60
   87bc0:	00091e64 	.word	0x00091e64
   87bc4:	00091e68 	.word	0x00091e68
   87bc8:	00091e6c 	.word	0x00091e6c
   87bcc:	00084f11 	.word	0x00084f11
   87bd0:	000919a4 	.word	0x000919a4

00087bd4 <report_startup_line>:
}

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
   87bd4:	b570      	push	{r4, r5, r6, lr}
   87bd6:	4606      	mov	r6, r0
   87bd8:	460d      	mov	r5, r1
  printString(("$N")); print_uint8_base10(n);
   87bda:	4806      	ldr	r0, [pc, #24]	; (87bf4 <report_startup_line+0x20>)
   87bdc:	4c06      	ldr	r4, [pc, #24]	; (87bf8 <report_startup_line+0x24>)
   87bde:	47a0      	blx	r4
   87be0:	4630      	mov	r0, r6
   87be2:	4b06      	ldr	r3, [pc, #24]	; (87bfc <report_startup_line+0x28>)
   87be4:	4798      	blx	r3
  printString(("=")); printString(line);
   87be6:	4806      	ldr	r0, [pc, #24]	; (87c00 <report_startup_line+0x2c>)
   87be8:	47a0      	blx	r4
   87bea:	4628      	mov	r0, r5
   87bec:	47a0      	blx	r4
  printString(("\r\n"));
   87bee:	4805      	ldr	r0, [pc, #20]	; (87c04 <report_startup_line+0x30>)
   87bf0:	47a0      	blx	r4
   87bf2:	bd70      	pop	{r4, r5, r6, pc}
   87bf4:	00091e70 	.word	0x00091e70
   87bf8:	00084d15 	.word	0x00084d15
   87bfc:	00084d91 	.word	0x00084d91
   87c00:	00091b48 	.word	0x00091b48
   87c04:	000918d8 	.word	0x000918d8

00087c08 <report_build_info>:
}


// Prints build info line
void report_build_info(char *line)
{
   87c08:	b538      	push	{r3, r4, r5, lr}
   87c0a:	4605      	mov	r5, r0
  printString(("[" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
   87c0c:	4803      	ldr	r0, [pc, #12]	; (87c1c <report_build_info+0x14>)
   87c0e:	4c04      	ldr	r4, [pc, #16]	; (87c20 <report_build_info+0x18>)
   87c10:	47a0      	blx	r4
  printString(line);
   87c12:	4628      	mov	r0, r5
   87c14:	47a0      	blx	r4
  printString(("]\r\n"));
   87c16:	4803      	ldr	r0, [pc, #12]	; (87c24 <report_build_info+0x1c>)
   87c18:	47a0      	blx	r4
   87c1a:	bd38      	pop	{r3, r4, r5, pc}
   87c1c:	00091e74 	.word	0x00091e74
   87c20:	00084d15 	.word	0x00084d15
   87c24:	000919a4 	.word	0x000919a4

00087c28 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
   87c28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   87c2c:	b086      	sub	sp, #24
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
   87c2e:	4c63      	ldr	r4, [pc, #396]	; (87dbc <report_realtime_status+0x194>)
   87c30:	1d23      	adds	r3, r4, #4
   87c32:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   87c36:	ab06      	add	r3, sp, #24
   87c38:	e903 0007 	stmdb	r3, {r0, r1, r2}
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
   87c3c:	7863      	ldrb	r3, [r4, #1]
   87c3e:	2b40      	cmp	r3, #64	; 0x40
   87c40:	d83d      	bhi.n	87cbe <report_realtime_status+0x96>
   87c42:	e8df f003 	tbb	[pc, r3]
   87c46:	3121      	.short	0x3121
   87c48:	3c2d3c35 	.word	0x3c2d3c35
   87c4c:	3c253c3c 	.word	0x3c253c3c
   87c50:	3c3c3c3c 	.word	0x3c3c3c3c
   87c54:	3c293c3c 	.word	0x3c293c3c
   87c58:	3c3c3c3c 	.word	0x3c3c3c3c
   87c5c:	3c3c3c3c 	.word	0x3c3c3c3c
   87c60:	3c3c3c3c 	.word	0x3c3c3c3c
   87c64:	3c393c3c 	.word	0x3c393c3c
   87c68:	3c3c3c3c 	.word	0x3c3c3c3c
   87c6c:	3c3c3c3c 	.word	0x3c3c3c3c
   87c70:	3c3c3c3c 	.word	0x3c3c3c3c
   87c74:	3c3c3c3c 	.word	0x3c3c3c3c
   87c78:	3c3c3c3c 	.word	0x3c3c3c3c
   87c7c:	3c3c3c3c 	.word	0x3c3c3c3c
   87c80:	3c3c3c3c 	.word	0x3c3c3c3c
   87c84:	3c3c      	.short	0x3c3c
   87c86:	25          	.byte	0x25
   87c87:	00          	.byte	0x00
    case STATE_IDLE: printString(("<Idle")); break;
   87c88:	484d      	ldr	r0, [pc, #308]	; (87dc0 <report_realtime_status+0x198>)
   87c8a:	4b4e      	ldr	r3, [pc, #312]	; (87dc4 <report_realtime_status+0x19c>)
   87c8c:	4798      	blx	r3
   87c8e:	e016      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printString(("<Run")); break;
   87c90:	484d      	ldr	r0, [pc, #308]	; (87dc8 <report_realtime_status+0x1a0>)
   87c92:	4b4c      	ldr	r3, [pc, #304]	; (87dc4 <report_realtime_status+0x19c>)
   87c94:	4798      	blx	r3
   87c96:	e012      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_HOLD: printString(("<Hold")); break;
   87c98:	484c      	ldr	r0, [pc, #304]	; (87dcc <report_realtime_status+0x1a4>)
   87c9a:	4b4a      	ldr	r3, [pc, #296]	; (87dc4 <report_realtime_status+0x19c>)
   87c9c:	4798      	blx	r3
   87c9e:	e00e      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_HOMING: printString(("<Home")); break;
   87ca0:	484b      	ldr	r0, [pc, #300]	; (87dd0 <report_realtime_status+0x1a8>)
   87ca2:	4b48      	ldr	r3, [pc, #288]	; (87dc4 <report_realtime_status+0x19c>)
   87ca4:	4798      	blx	r3
   87ca6:	e00a      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_ALARM: printString(("<Alarm")); break;
   87ca8:	484a      	ldr	r0, [pc, #296]	; (87dd4 <report_realtime_status+0x1ac>)
   87caa:	4b46      	ldr	r3, [pc, #280]	; (87dc4 <report_realtime_status+0x19c>)
   87cac:	4798      	blx	r3
   87cae:	e006      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_CHECK_MODE: printString(("<Check")); break;
   87cb0:	4849      	ldr	r0, [pc, #292]	; (87dd8 <report_realtime_status+0x1b0>)
   87cb2:	4b44      	ldr	r3, [pc, #272]	; (87dc4 <report_realtime_status+0x19c>)
   87cb4:	4798      	blx	r3
   87cb6:	e002      	b.n	87cbe <report_realtime_status+0x96>
    case STATE_SAFETY_DOOR: printString(("<Door")); break;
   87cb8:	4848      	ldr	r0, [pc, #288]	; (87ddc <report_realtime_status+0x1b4>)
   87cba:	4b42      	ldr	r3, [pc, #264]	; (87dc4 <report_realtime_status+0x19c>)
   87cbc:	4798      	blx	r3
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
   87cbe:	4b48      	ldr	r3, [pc, #288]	; (87de0 <report_realtime_status+0x1b8>)
   87cc0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87cc4:	f013 0f03 	tst.w	r3, #3
   87cc8:	d06e      	beq.n	87da8 <report_realtime_status+0x180>
    system_convert_array_steps_to_mpos(print_position,current_position);
   87cca:	4668      	mov	r0, sp
   87ccc:	a903      	add	r1, sp, #12
   87cce:	4b45      	ldr	r3, [pc, #276]	; (87de4 <report_realtime_status+0x1bc>)
   87cd0:	4798      	blx	r3
   87cd2:	e069      	b.n	87da8 <report_realtime_status+0x180>
      if (idx < (N_AXIS-1)) { printString((",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
   87cd4:	4b42      	ldr	r3, [pc, #264]	; (87de0 <report_realtime_status+0x1b8>)
   87cd6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87cda:	f013 0f02 	tst.w	r3, #2
   87cde:	d026      	beq.n	87d2e <report_realtime_status+0x106>
    printString((",WPos:")); 
   87ce0:	4841      	ldr	r0, [pc, #260]	; (87de8 <report_realtime_status+0x1c0>)
   87ce2:	4b38      	ldr	r3, [pc, #224]	; (87dc4 <report_realtime_status+0x19c>)
   87ce4:	4798      	blx	r3
   87ce6:	466c      	mov	r4, sp
   87ce8:	4e40      	ldr	r6, [pc, #256]	; (87dec <report_realtime_status+0x1c4>)
   87cea:	2500      	movs	r5, #0
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[idx] -= gc_state.coord_system[idx]+gc_state.coord_offset[idx];
   87cec:	f8df a130 	ldr.w	sl, [pc, #304]	; 87e20 <report_realtime_status+0x1f8>
   87cf0:	f8df 8130 	ldr.w	r8, [pc, #304]	; 87e24 <report_realtime_status+0x1fc>
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { print_position[idx] -= gc_state.tool_length_offset; }    
      printFloat_CoordValue(print_position[idx]);
   87cf4:	f8df 9124 	ldr.w	r9, [pc, #292]	; 87e1c <report_realtime_status+0x1f4>
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printString((",WPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[idx] -= gc_state.coord_system[idx]+gc_state.coord_offset[idx];
   87cf8:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   87cfa:	6b71      	ldr	r1, [r6, #52]	; 0x34
   87cfc:	47d0      	blx	sl
   87cfe:	4601      	mov	r1, r0
   87d00:	6820      	ldr	r0, [r4, #0]
   87d02:	47c0      	blx	r8
   87d04:	6020      	str	r0, [r4, #0]
   87d06:	b2ef      	uxtb	r7, r5
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { print_position[idx] -= gc_state.tool_length_offset; }    
   87d08:	2f02      	cmp	r7, #2
   87d0a:	d105      	bne.n	87d18 <report_realtime_status+0xf0>
   87d0c:	4b37      	ldr	r3, [pc, #220]	; (87dec <report_realtime_status+0x1c4>)
   87d0e:	6c19      	ldr	r1, [r3, #64]	; 0x40
   87d10:	47c0      	blx	r8
   87d12:	6020      	str	r0, [r4, #0]
      printFloat_CoordValue(print_position[idx]);
   87d14:	47c8      	blx	r9
   87d16:	e005      	b.n	87d24 <report_realtime_status+0xfc>
   87d18:	47c8      	blx	r9
      if (idx < (N_AXIS-1)) { printString((",")); }
   87d1a:	2f01      	cmp	r7, #1
   87d1c:	d802      	bhi.n	87d24 <report_realtime_status+0xfc>
   87d1e:	4834      	ldr	r0, [pc, #208]	; (87df0 <report_realtime_status+0x1c8>)
   87d20:	4b28      	ldr	r3, [pc, #160]	; (87dc4 <report_realtime_status+0x19c>)
   87d22:	4798      	blx	r3
   87d24:	3501      	adds	r5, #1
   87d26:	3404      	adds	r4, #4
   87d28:	3604      	adds	r6, #4
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printString((",WPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
   87d2a:	2d03      	cmp	r5, #3
   87d2c:	d1e4      	bne.n	87cf8 <report_realtime_status+0xd0>
      if (idx < (N_AXIS-1)) { printString((",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
   87d2e:	4b2c      	ldr	r3, [pc, #176]	; (87de0 <report_realtime_status+0x1b8>)
   87d30:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87d34:	f013 0f04 	tst.w	r3, #4
   87d38:	d006      	beq.n	87d48 <report_realtime_status+0x120>
    printString((",Buf:"));
   87d3a:	482e      	ldr	r0, [pc, #184]	; (87df4 <report_realtime_status+0x1cc>)
   87d3c:	4b21      	ldr	r3, [pc, #132]	; (87dc4 <report_realtime_status+0x19c>)
   87d3e:	4798      	blx	r3
    print_uint8_base10(plan_get_block_buffer_count());
   87d40:	4b2d      	ldr	r3, [pc, #180]	; (87df8 <report_realtime_status+0x1d0>)
   87d42:	4798      	blx	r3
   87d44:	4b2d      	ldr	r3, [pc, #180]	; (87dfc <report_realtime_status+0x1d4>)
   87d46:	4798      	blx	r3
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
   87d48:	4b25      	ldr	r3, [pc, #148]	; (87de0 <report_realtime_status+0x1b8>)
   87d4a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87d4e:	f013 0f08 	tst.w	r3, #8
   87d52:	d006      	beq.n	87d62 <report_realtime_status+0x13a>
    printString((",RX:"));
   87d54:	482a      	ldr	r0, [pc, #168]	; (87e00 <report_realtime_status+0x1d8>)
   87d56:	4b1b      	ldr	r3, [pc, #108]	; (87dc4 <report_realtime_status+0x19c>)
   87d58:	4798      	blx	r3
    print_uint8_base10(serial_get_rx_buffer_count());
   87d5a:	4b2a      	ldr	r3, [pc, #168]	; (87e04 <report_realtime_status+0x1dc>)
   87d5c:	4798      	blx	r3
   87d5e:	4b27      	ldr	r3, [pc, #156]	; (87dfc <report_realtime_status+0x1d4>)
   87d60:	4798      	blx	r3
    // Report realtime rate 
    printString((",F:")); 
    printFloat_RateValue(st_get_realtime_rate());
  #endif    
  
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_LIMIT_PINS)) {
   87d62:	4b1f      	ldr	r3, [pc, #124]	; (87de0 <report_realtime_status+0x1b8>)
   87d64:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87d68:	f013 0f10 	tst.w	r3, #16
   87d6c:	d008      	beq.n	87d80 <report_realtime_status+0x158>
    printString((",Lim:"));
   87d6e:	4826      	ldr	r0, [pc, #152]	; (87e08 <report_realtime_status+0x1e0>)
   87d70:	4b14      	ldr	r3, [pc, #80]	; (87dc4 <report_realtime_status+0x19c>)
   87d72:	4798      	blx	r3
    print_unsigned_int8(limits_get_state(),2,N_AXIS);
   87d74:	4b25      	ldr	r3, [pc, #148]	; (87e0c <report_realtime_status+0x1e4>)
   87d76:	4798      	blx	r3
   87d78:	2102      	movs	r1, #2
   87d7a:	2203      	movs	r2, #3
   87d7c:	4b24      	ldr	r3, [pc, #144]	; (87e10 <report_realtime_status+0x1e8>)
   87d7e:	4798      	blx	r3
  #ifdef REPORT_CONTROL_PIN_STATE 
    printString((",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printString((">\r\n"));
   87d80:	4824      	ldr	r0, [pc, #144]	; (87e14 <report_realtime_status+0x1ec>)
   87d82:	4b10      	ldr	r3, [pc, #64]	; (87dc4 <report_realtime_status+0x19c>)
   87d84:	4798      	blx	r3
   87d86:	e016      	b.n	87db6 <report_realtime_status+0x18e>
    system_convert_array_steps_to_mpos(print_position,current_position);
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printString((",MPos:")); 
   87d88:	4823      	ldr	r0, [pc, #140]	; (87e18 <report_realtime_status+0x1f0>)
   87d8a:	4d0e      	ldr	r5, [pc, #56]	; (87dc4 <report_realtime_status+0x19c>)
   87d8c:	47a8      	blx	r5
    for (idx=0; idx< N_AXIS; idx++) {
      printFloat_CoordValue(print_position[idx]);
   87d8e:	9800      	ldr	r0, [sp, #0]
   87d90:	4c22      	ldr	r4, [pc, #136]	; (87e1c <report_realtime_status+0x1f4>)
   87d92:	47a0      	blx	r4
      if (idx < (N_AXIS-1)) { printString((",")); }
   87d94:	4e16      	ldr	r6, [pc, #88]	; (87df0 <report_realtime_status+0x1c8>)
   87d96:	4630      	mov	r0, r6
   87d98:	47a8      	blx	r5
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printString((",MPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
      printFloat_CoordValue(print_position[idx]);
   87d9a:	9801      	ldr	r0, [sp, #4]
   87d9c:	47a0      	blx	r4
      if (idx < (N_AXIS-1)) { printString((",")); }
   87d9e:	4630      	mov	r0, r6
   87da0:	47a8      	blx	r5
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printString((",MPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
      printFloat_CoordValue(print_position[idx]);
   87da2:	9802      	ldr	r0, [sp, #8]
   87da4:	47a0      	blx	r4
   87da6:	e795      	b.n	87cd4 <report_realtime_status+0xac>
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    system_convert_array_steps_to_mpos(print_position,current_position);
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
   87da8:	4b0d      	ldr	r3, [pc, #52]	; (87de0 <report_realtime_status+0x1b8>)
   87daa:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   87dae:	f013 0f01 	tst.w	r3, #1
   87db2:	d08f      	beq.n	87cd4 <report_realtime_status+0xac>
   87db4:	e7e8      	b.n	87d88 <report_realtime_status+0x160>
    printString((",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printString((">\r\n"));
}
   87db6:	b006      	add	sp, #24
   87db8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   87dbc:	20001484 	.word	0x20001484
   87dc0:	00091e8c 	.word	0x00091e8c
   87dc4:	00084d15 	.word	0x00084d15
   87dc8:	00091e94 	.word	0x00091e94
   87dcc:	00091e9c 	.word	0x00091e9c
   87dd0:	00091ea4 	.word	0x00091ea4
   87dd4:	00091eac 	.word	0x00091eac
   87dd8:	00091eb4 	.word	0x00091eb4
   87ddc:	00091ebc 	.word	0x00091ebc
   87de0:	20001510 	.word	0x20001510
   87de4:	00089649 	.word	0x00089649
   87de8:	00091ec4 	.word	0x00091ec4
   87dec:	200011c8 	.word	0x200011c8
   87df0:	00091790 	.word	0x00091790
   87df4:	00091ecc 	.word	0x00091ecc
   87df8:	00084cdd 	.word	0x00084cdd
   87dfc:	00084d91 	.word	0x00084d91
   87e00:	00091ed4 	.word	0x00091ed4
   87e04:	00087e29 	.word	0x00087e29
   87e08:	00091edc 	.word	0x00091edc
   87e0c:	00083751 	.word	0x00083751
   87e10:	00084d31 	.word	0x00084d31
   87e14:	00091ee4 	.word	0x00091ee4
   87e18:	00091ee8 	.word	0x00091ee8
   87e1c:	00084ec1 	.word	0x00084ec1
   87e20:	0008c525 	.word	0x0008c525
   87e24:	0008c521 	.word	0x0008c521

00087e28 <serial_get_rx_buffer_count>:
  

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count()
{
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
   87e28:	4b04      	ldr	r3, [pc, #16]	; (87e3c <serial_get_rx_buffer_count+0x14>)
   87e2a:	7818      	ldrb	r0, [r3, #0]
   87e2c:	b2c0      	uxtb	r0, r0
  if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
   87e2e:	785b      	ldrb	r3, [r3, #1]
   87e30:	4298      	cmp	r0, r3
   87e32:	bf88      	it	hi
   87e34:	3b80      	subhi	r3, #128	; 0x80
  return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
   87e36:	1a18      	subs	r0, r3, r0
   87e38:	b2c0      	uxtb	r0, r0
}
   87e3a:	4770      	bx	lr
   87e3c:	20000f4d 	.word	0x20000f4d

00087e40 <serial_write>:
}


// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
   87e40:	4770      	bx	lr
   87e42:	bf00      	nop

00087e44 <serial_reset_read_buffer>:
}*/


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
   87e44:	4b01      	ldr	r3, [pc, #4]	; (87e4c <serial_reset_read_buffer+0x8>)
   87e46:	785a      	ldrb	r2, [r3, #1]
   87e48:	701a      	strb	r2, [r3, #0]
   87e4a:	4770      	bx	lr
   87e4c:	20000f4d 	.word	0x20000f4d

00087e50 <settings_store_startup_line>:
settings_t settings;


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
   87e50:	b508      	push	{r3, lr}
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
   87e52:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   87e56:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
   87e5a:	f500 7040 	add.w	r0, r0, #768	; 0x300
   87e5e:	2250      	movs	r2, #80	; 0x50
   87e60:	4b01      	ldr	r3, [pc, #4]	; (87e68 <settings_store_startup_line+0x18>)
   87e62:	4798      	blx	r3
   87e64:	bd08      	pop	{r3, pc}
   87e66:	bf00      	nop
   87e68:	00080311 	.word	0x00080311

00087e6c <settings_store_build_info>:
}


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
   87e6c:	b508      	push	{r3, lr}
   87e6e:	4601      	mov	r1, r0
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
   87e70:	f240 30ae 	movw	r0, #942	; 0x3ae
   87e74:	2250      	movs	r2, #80	; 0x50
   87e76:	4b01      	ldr	r3, [pc, #4]	; (87e7c <settings_store_build_info+0x10>)
   87e78:	4798      	blx	r3
   87e7a:	bd08      	pop	{r3, pc}
   87e7c:	00080311 	.word	0x00080311

00087e80 <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
   87e80:	b508      	push	{r3, lr}
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
   87e82:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   87e86:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
   87e8a:	f500 7000 	add.w	r0, r0, #512	; 0x200
   87e8e:	220c      	movs	r2, #12
   87e90:	4b01      	ldr	r3, [pc, #4]	; (87e98 <settings_write_coord_data+0x18>)
   87e92:	4798      	blx	r3
   87e94:	bd08      	pop	{r3, pc}
   87e96:	bf00      	nop
   87e98:	00080311 	.word	0x00080311

00087e9c <write_global_settings>:
}  


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
   87e9c:	b508      	push	{r3, lr}
  eeprom_put_char(0, SETTINGS_VERSION);
   87e9e:	2000      	movs	r0, #0
   87ea0:	2109      	movs	r1, #9
   87ea2:	4b04      	ldr	r3, [pc, #16]	; (87eb4 <write_global_settings+0x18>)
   87ea4:	4798      	blx	r3
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
   87ea6:	2001      	movs	r0, #1
   87ea8:	4903      	ldr	r1, [pc, #12]	; (87eb8 <write_global_settings+0x1c>)
   87eaa:	2254      	movs	r2, #84	; 0x54
   87eac:	4b03      	ldr	r3, [pc, #12]	; (87ebc <write_global_settings+0x20>)
   87eae:	4798      	blx	r3
   87eb0:	bd08      	pop	{r3, pc}
   87eb2:	bf00      	nop
   87eb4:	0008030d 	.word	0x0008030d
   87eb8:	20001510 	.word	0x20001510
   87ebc:	00080311 	.word	0x00080311

00087ec0 <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore(uint8_t restore_flag) {  
   87ec0:	b570      	push	{r4, r5, r6, lr}
   87ec2:	b084      	sub	sp, #16
   87ec4:	4605      	mov	r5, r0
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
   87ec6:	f010 0f01 	tst.w	r0, #1
   87eca:	d035      	beq.n	87f38 <settings_restore+0x78>
	settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
   87ecc:	4b2c      	ldr	r3, [pc, #176]	; (87f80 <settings_restore+0xc0>)
   87ece:	220a      	movs	r2, #10
   87ed0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
   87ed4:	2219      	movs	r2, #25
   87ed6:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
	settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
   87eda:	2200      	movs	r2, #0
   87edc:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
   87ee0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
   87ee4:	2103      	movs	r1, #3
   87ee6:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
	settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
   87eea:	4926      	ldr	r1, [pc, #152]	; (87f84 <settings_restore+0xc4>)
   87eec:	6399      	str	r1, [r3, #56]	; 0x38
	settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
   87eee:	4926      	ldr	r1, [pc, #152]	; (87f88 <settings_restore+0xc8>)
   87ef0:	63d9      	str	r1, [r3, #60]	; 0x3c
	settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
   87ef2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
	settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
   87ef6:	4925      	ldr	r1, [pc, #148]	; (87f8c <settings_restore+0xcc>)
   87ef8:	6459      	str	r1, [r3, #68]	; 0x44
	settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
   87efa:	4925      	ldr	r1, [pc, #148]	; (87f90 <settings_restore+0xd0>)
   87efc:	6499      	str	r1, [r3, #72]	; 0x48
	settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
   87efe:	21fa      	movs	r1, #250	; 0xfa
   87f00:	f8a3 104c 	strh.w	r1, [r3, #76]	; 0x4c
	settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
   87f04:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
   87f08:	6519      	str	r1, [r3, #80]	; 0x50

	settings.flags = 0;
   87f0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
	if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
	if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
	if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
	if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
  
	settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
   87f0e:	4a21      	ldr	r2, [pc, #132]	; (87f94 <settings_restore+0xd4>)
   87f10:	601a      	str	r2, [r3, #0]
	settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
   87f12:	605a      	str	r2, [r3, #4]
	settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
   87f14:	4a20      	ldr	r2, [pc, #128]	; (87f98 <settings_restore+0xd8>)
   87f16:	609a      	str	r2, [r3, #8]
	settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
   87f18:	4a20      	ldr	r2, [pc, #128]	; (87f9c <settings_restore+0xdc>)
   87f1a:	60da      	str	r2, [r3, #12]
	settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
   87f1c:	611a      	str	r2, [r3, #16]
	settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
   87f1e:	615a      	str	r2, [r3, #20]
	settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
   87f20:	4a1f      	ldr	r2, [pc, #124]	; (87fa0 <settings_restore+0xe0>)
   87f22:	619a      	str	r2, [r3, #24]
	settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
   87f24:	61da      	str	r2, [r3, #28]
	settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
   87f26:	621a      	str	r2, [r3, #32]
	settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
   87f28:	4a1e      	ldr	r2, [pc, #120]	; (87fa4 <settings_restore+0xe4>)
   87f2a:	625a      	str	r2, [r3, #36]	; 0x24
	settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
   87f2c:	4a1e      	ldr	r2, [pc, #120]	; (87fa8 <settings_restore+0xe8>)
   87f2e:	629a      	str	r2, [r3, #40]	; 0x28
	settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
   87f30:	4a1e      	ldr	r2, [pc, #120]	; (87fac <settings_restore+0xec>)
   87f32:	62da      	str	r2, [r3, #44]	; 0x2c

	write_global_settings();
   87f34:	4b1e      	ldr	r3, [pc, #120]	; (87fb0 <settings_restore+0xf0>)
   87f36:	4798      	blx	r3
  }
  
  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
   87f38:	f015 0f02 	tst.w	r5, #2
   87f3c:	d00a      	beq.n	87f54 <settings_restore+0x94>
	uint8_t idx;
	float coord_data[N_AXIS];
	memset(&coord_data, 0, sizeof(coord_data));
   87f3e:	2400      	movs	r4, #0
   87f40:	9401      	str	r4, [sp, #4]
   87f42:	9402      	str	r4, [sp, #8]
   87f44:	9403      	str	r4, [sp, #12]
	for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
   87f46:	4e1b      	ldr	r6, [pc, #108]	; (87fb4 <settings_restore+0xf4>)
   87f48:	b2e0      	uxtb	r0, r4
   87f4a:	a901      	add	r1, sp, #4
   87f4c:	47b0      	blx	r6
   87f4e:	3401      	adds	r4, #1
   87f50:	2c08      	cmp	r4, #8
   87f52:	d1f9      	bne.n	87f48 <settings_restore+0x88>
  }
  
  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
   87f54:	f015 0f04 	tst.w	r5, #4
   87f58:	d008      	beq.n	87f6c <settings_restore+0xac>
	#if N_STARTUP_LINE > 0
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
   87f5a:	f44f 7040 	mov.w	r0, #768	; 0x300
   87f5e:	2100      	movs	r1, #0
   87f60:	4c15      	ldr	r4, [pc, #84]	; (87fb8 <settings_restore+0xf8>)
   87f62:	47a0      	blx	r4
	#endif
	#if N_STARTUP_LINE > 1
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
   87f64:	f240 3051 	movw	r0, #849	; 0x351
   87f68:	2100      	movs	r1, #0
   87f6a:	47a0      	blx	r4
	#endif
  }
  
  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
   87f6c:	f015 0f08 	tst.w	r5, #8
   87f70:	d004      	beq.n	87f7c <settings_restore+0xbc>
   87f72:	f240 30ae 	movw	r0, #942	; 0x3ae
   87f76:	2100      	movs	r1, #0
   87f78:	4b0f      	ldr	r3, [pc, #60]	; (87fb8 <settings_restore+0xf8>)
   87f7a:	4798      	blx	r3
}
   87f7c:	b004      	add	sp, #16
   87f7e:	bd70      	pop	{r4, r5, r6, pc}
   87f80:	20001510 	.word	0x20001510
   87f84:	3c23d70a 	.word	0x3c23d70a
   87f88:	3b03126f 	.word	0x3b03126f
   87f8c:	41c80000 	.word	0x41c80000
   87f90:	43fa0000 	.word	0x43fa0000
   87f94:	43a00000 	.word	0x43a00000
   87f98:	43f00000 	.word	0x43f00000
   87f9c:	46c35000 	.word	0x46c35000
   87fa0:	482fc800 	.word	0x482fc800
   87fa4:	c4480000 	.word	0xc4480000
   87fa8:	c3960000 	.word	0xc3960000
   87fac:	c3480000 	.word	0xc3480000
   87fb0:	00087e9d 	.word	0x00087e9d
   87fb4:	00087e81 	.word	0x00087e81
   87fb8:	0008030d 	.word	0x0008030d

00087fbc <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
   87fbc:	b570      	push	{r4, r5, r6, lr}
   87fbe:	4604      	mov	r4, r0
   87fc0:	460e      	mov	r6, r1
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
   87fc2:	eb00 01c0 	add.w	r1, r0, r0, lsl #3
   87fc6:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
   87fca:	4630      	mov	r0, r6
   87fcc:	f501 7140 	add.w	r1, r1, #768	; 0x300
   87fd0:	2250      	movs	r2, #80	; 0x50
   87fd2:	4b06      	ldr	r3, [pc, #24]	; (87fec <settings_read_startup_line+0x30>)
   87fd4:	4798      	blx	r3
   87fd6:	b938      	cbnz	r0, 87fe8 <settings_read_startup_line+0x2c>
    // Reset line with default value
    line[0] = 0; // Empty line
   87fd8:	2500      	movs	r5, #0
   87fda:	7035      	strb	r5, [r6, #0]
    settings_store_startup_line(n, line);
   87fdc:	4620      	mov	r0, r4
   87fde:	4631      	mov	r1, r6
   87fe0:	4b03      	ldr	r3, [pc, #12]	; (87ff0 <settings_read_startup_line+0x34>)
   87fe2:	4798      	blx	r3
    return(false);
   87fe4:	4628      	mov	r0, r5
   87fe6:	bd70      	pop	{r4, r5, r6, pc}
  }
  return(true);
   87fe8:	2001      	movs	r0, #1
}
   87fea:	bd70      	pop	{r4, r5, r6, pc}
   87fec:	00080335 	.word	0x00080335
   87ff0:	00087e51 	.word	0x00087e51

00087ff4 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
   87ff4:	b538      	push	{r3, r4, r5, lr}
   87ff6:	4605      	mov	r5, r0
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
   87ff8:	f240 31ae 	movw	r1, #942	; 0x3ae
   87ffc:	2250      	movs	r2, #80	; 0x50
   87ffe:	4b06      	ldr	r3, [pc, #24]	; (88018 <settings_read_build_info+0x24>)
   88000:	4798      	blx	r3
   88002:	b930      	cbnz	r0, 88012 <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
   88004:	2400      	movs	r4, #0
   88006:	702c      	strb	r4, [r5, #0]
    settings_store_build_info(line);
   88008:	4628      	mov	r0, r5
   8800a:	4b04      	ldr	r3, [pc, #16]	; (8801c <settings_read_build_info+0x28>)
   8800c:	4798      	blx	r3
    return(false);
   8800e:	4620      	mov	r0, r4
   88010:	bd38      	pop	{r3, r4, r5, pc}
  }
  return(true);
   88012:	2001      	movs	r0, #1
}
   88014:	bd38      	pop	{r3, r4, r5, pc}
   88016:	bf00      	nop
   88018:	00080335 	.word	0x00080335
   8801c:	00087e6d 	.word	0x00087e6d

00088020 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
   88020:	b570      	push	{r4, r5, r6, lr}
   88022:	4605      	mov	r5, r0
   88024:	460e      	mov	r6, r1
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
   88026:	eb00 0140 	add.w	r1, r0, r0, lsl #1
   8802a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
   8802e:	4630      	mov	r0, r6
   88030:	f501 7100 	add.w	r1, r1, #512	; 0x200
   88034:	220c      	movs	r2, #12
   88036:	4b12      	ldr	r3, [pc, #72]	; (88080 <settings_read_coord_data+0x60>)
   88038:	4798      	blx	r3
   8803a:	b9f0      	cbnz	r0, 8807a <settings_read_coord_data+0x5a>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
   8803c:	2400      	movs	r4, #0
   8803e:	4633      	mov	r3, r6
   88040:	f803 4b01 	strb.w	r4, [r3], #1
   88044:	7074      	strb	r4, [r6, #1]
   88046:	3301      	adds	r3, #1
   88048:	f803 4b01 	strb.w	r4, [r3], #1
   8804c:	f803 4b01 	strb.w	r4, [r3], #1
   88050:	f803 4b01 	strb.w	r4, [r3], #1
   88054:	f803 4b01 	strb.w	r4, [r3], #1
   88058:	f803 4b01 	strb.w	r4, [r3], #1
   8805c:	f803 4b01 	strb.w	r4, [r3], #1
   88060:	f803 4b01 	strb.w	r4, [r3], #1
   88064:	f803 4b01 	strb.w	r4, [r3], #1
   88068:	f803 4b01 	strb.w	r4, [r3], #1
   8806c:	701c      	strb	r4, [r3, #0]
    settings_write_coord_data(coord_select,coord_data);
   8806e:	4628      	mov	r0, r5
   88070:	4631      	mov	r1, r6
   88072:	4b04      	ldr	r3, [pc, #16]	; (88084 <settings_read_coord_data+0x64>)
   88074:	4798      	blx	r3
    return(false);
   88076:	4620      	mov	r0, r4
   88078:	bd70      	pop	{r4, r5, r6, pc}
  }
  return(true);
   8807a:	2001      	movs	r0, #1
}  
   8807c:	bd70      	pop	{r4, r5, r6, pc}
   8807e:	bf00      	nop
   88080:	00080335 	.word	0x00080335
   88084:	00087e81 	.word	0x00087e81

00088088 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
   88088:	b508      	push	{r3, lr}
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
   8808a:	2000      	movs	r0, #0
   8808c:	4b07      	ldr	r3, [pc, #28]	; (880ac <read_global_settings+0x24>)
   8808e:	4798      	blx	r3
  if (version == SETTINGS_VERSION) {
   88090:	2809      	cmp	r0, #9
   88092:	d108      	bne.n	880a6 <read_global_settings+0x1e>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
   88094:	4806      	ldr	r0, [pc, #24]	; (880b0 <read_global_settings+0x28>)
   88096:	2101      	movs	r1, #1
   88098:	2254      	movs	r2, #84	; 0x54
   8809a:	4b06      	ldr	r3, [pc, #24]	; (880b4 <read_global_settings+0x2c>)
   8809c:	4798      	blx	r3
      return(false);
   8809e:	3000      	adds	r0, #0
   880a0:	bf18      	it	ne
   880a2:	2001      	movne	r0, #1
   880a4:	bd08      	pop	{r3, pc}
    }
  } else {
    return(false); 
   880a6:	2000      	movs	r0, #0
  }
  return(true);
}
   880a8:	bd08      	pop	{r3, pc}
   880aa:	bf00      	nop
   880ac:	00080309 	.word	0x00080309
   880b0:	20001510 	.word	0x20001510
   880b4:	00080335 	.word	0x00080335

000880b8 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
   880b8:	b570      	push	{r4, r5, r6, lr}
   880ba:	4604      	mov	r4, r0
   880bc:	460d      	mov	r5, r1
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
   880be:	4608      	mov	r0, r1
   880c0:	2100      	movs	r1, #0
   880c2:	4b8d      	ldr	r3, [pc, #564]	; (882f8 <settings_store_global_setting+0x240>)
   880c4:	4798      	blx	r3
   880c6:	2800      	cmp	r0, #0
   880c8:	f040 80dc 	bne.w	88284 <settings_store_global_setting+0x1cc>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
   880cc:	2c63      	cmp	r4, #99	; 0x63
   880ce:	d90c      	bls.n	880ea <settings_store_global_setting+0x32>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
   880d0:	f1a4 0364 	sub.w	r3, r4, #100	; 0x64
   880d4:	b2db      	uxtb	r3, r3
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
   880d6:	2b02      	cmp	r3, #2
   880d8:	d903      	bls.n	880e2 <settings_store_global_setting+0x2a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   880da:	2b09      	cmp	r3, #9
   880dc:	f200 80e0 	bhi.w	882a0 <settings_store_global_setting+0x1e8>
   880e0:	e0d2      	b.n	88288 <settings_store_global_setting+0x1d0>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
   880e2:	4a86      	ldr	r2, [pc, #536]	; (882fc <settings_store_global_setting+0x244>)
   880e4:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
            break;
   880e8:	e0c8      	b.n	8827c <settings_store_global_setting+0x1c4>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
   880ea:	4628      	mov	r0, r5
   880ec:	4b84      	ldr	r3, [pc, #528]	; (88300 <settings_store_global_setting+0x248>)
   880ee:	4798      	blx	r3
   880f0:	4b84      	ldr	r3, [pc, #528]	; (88304 <settings_store_global_setting+0x24c>)
   880f2:	4798      	blx	r3
   880f4:	4b84      	ldr	r3, [pc, #528]	; (88308 <settings_store_global_setting+0x250>)
   880f6:	4798      	blx	r3
   880f8:	b2c0      	uxtb	r0, r0
    switch(parameter) {
   880fa:	2c1b      	cmp	r4, #27
   880fc:	f200 80c6 	bhi.w	8828c <settings_store_global_setting+0x1d4>
   88100:	e8df f004 	tbb	[pc, r4]
   88104:	1f19150e 	.word	0x1f19150e
   88108:	c4473625 	.word	0xc4473625
   8810c:	5c58c4c4 	.word	0x5c58c4c4
   88110:	c4c4625f 	.word	0xc4c4625f
   88114:	c4c4c4c4 	.word	0xc4c4c4c4
   88118:	ac9b8873 	.word	0xac9b8873
   8811c:	bab6b3b0 	.word	0xbab6b3b0
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
   88120:	2802      	cmp	r0, #2
   88122:	f240 80b5 	bls.w	88290 <settings_store_global_setting+0x1d8>
        settings.pulse_microseconds = int_value; break;
   88126:	4b75      	ldr	r3, [pc, #468]	; (882fc <settings_store_global_setting+0x244>)
   88128:	f883 0030 	strb.w	r0, [r3, #48]	; 0x30
   8812c:	e0a6      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 1: settings.stepper_idle_lock_time = int_value; break;
   8812e:	4b73      	ldr	r3, [pc, #460]	; (882fc <settings_store_global_setting+0x244>)
   88130:	f883 0033 	strb.w	r0, [r3, #51]	; 0x33
   88134:	e0a2      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 2: 
        settings.step_invert_mask = int_value; 
   88136:	4b71      	ldr	r3, [pc, #452]	; (882fc <settings_store_global_setting+0x244>)
   88138:	f883 0031 	strb.w	r0, [r3, #49]	; 0x31
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
   8813c:	4b73      	ldr	r3, [pc, #460]	; (8830c <settings_store_global_setting+0x254>)
   8813e:	4798      	blx	r3
        break;
   88140:	e09c      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 3: 
        settings.dir_invert_mask = int_value; 
   88142:	4b6e      	ldr	r3, [pc, #440]	; (882fc <settings_store_global_setting+0x244>)
   88144:	f883 0032 	strb.w	r0, [r3, #50]	; 0x32
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
   88148:	4b70      	ldr	r3, [pc, #448]	; (8830c <settings_store_global_setting+0x254>)
   8814a:	4798      	blx	r3
        break;
   8814c:	e096      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
   8814e:	b138      	cbz	r0, 88160 <settings_store_global_setting+0xa8>
   88150:	4a6a      	ldr	r2, [pc, #424]	; (882fc <settings_store_global_setting+0x244>)
   88152:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88156:	f043 0304 	orr.w	r3, r3, #4
   8815a:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   8815e:	e08d      	b.n	8827c <settings_store_global_setting+0x1c4>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
   88160:	4a66      	ldr	r2, [pc, #408]	; (882fc <settings_store_global_setting+0x244>)
   88162:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88166:	f023 0304 	bic.w	r3, r3, #4
   8816a:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   8816e:	e085      	b.n	8827c <settings_store_global_setting+0x1c4>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
   88170:	b138      	cbz	r0, 88182 <settings_store_global_setting+0xca>
   88172:	4a62      	ldr	r2, [pc, #392]	; (882fc <settings_store_global_setting+0x244>)
   88174:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88178:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   8817c:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   88180:	e07c      	b.n	8827c <settings_store_global_setting+0x1c4>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
   88182:	4a5e      	ldr	r2, [pc, #376]	; (882fc <settings_store_global_setting+0x244>)
   88184:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88188:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   8818c:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   88190:	e074      	b.n	8827c <settings_store_global_setting+0x1c4>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
   88192:	b138      	cbz	r0, 881a4 <settings_store_global_setting+0xec>
   88194:	4a59      	ldr	r2, [pc, #356]	; (882fc <settings_store_global_setting+0x244>)
   88196:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   8819a:	f063 037f 	orn	r3, r3, #127	; 0x7f
   8819e:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   881a2:	e06b      	b.n	8827c <settings_store_global_setting+0x1c4>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
   881a4:	4a55      	ldr	r2, [pc, #340]	; (882fc <settings_store_global_setting+0x244>)
   881a6:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   881aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   881ae:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   881b2:	e063      	b.n	8827c <settings_store_global_setting+0x1c4>
        break;
      case 10: settings.status_report_mask = int_value; break;
   881b4:	4b51      	ldr	r3, [pc, #324]	; (882fc <settings_store_global_setting+0x244>)
   881b6:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
   881ba:	e05f      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 11: settings.junction_deviation = value; break;
   881bc:	4b4f      	ldr	r3, [pc, #316]	; (882fc <settings_store_global_setting+0x244>)
   881be:	639d      	str	r5, [r3, #56]	; 0x38
   881c0:	e05c      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 12: settings.arc_tolerance = value; break;
   881c2:	4b4e      	ldr	r3, [pc, #312]	; (882fc <settings_store_global_setting+0x244>)
   881c4:	63dd      	str	r5, [r3, #60]	; 0x3c
   881c6:	e059      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
   881c8:	b138      	cbz	r0, 881da <settings_store_global_setting+0x122>
   881ca:	4a4c      	ldr	r2, [pc, #304]	; (882fc <settings_store_global_setting+0x244>)
   881cc:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   881d0:	f043 0301 	orr.w	r3, r3, #1
   881d4:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   881d8:	e050      	b.n	8827c <settings_store_global_setting+0x1c4>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
   881da:	4a48      	ldr	r2, [pc, #288]	; (882fc <settings_store_global_setting+0x244>)
   881dc:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   881e0:	f023 0301 	bic.w	r3, r3, #1
   881e4:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   881e8:	e048      	b.n	8827c <settings_store_global_setting+0x1c4>
        break;
      case 20:
        if (int_value) { 
   881ea:	b158      	cbz	r0, 88204 <settings_store_global_setting+0x14c>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
   881ec:	4b43      	ldr	r3, [pc, #268]	; (882fc <settings_store_global_setting+0x244>)
   881ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   881f2:	f013 0f10 	tst.w	r3, #16
   881f6:	d04d      	beq.n	88294 <settings_store_global_setting+0x1dc>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
   881f8:	f043 0320 	orr.w	r3, r3, #32
   881fc:	4a3f      	ldr	r2, [pc, #252]	; (882fc <settings_store_global_setting+0x244>)
   881fe:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   88202:	e03b      	b.n	8827c <settings_store_global_setting+0x1c4>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
   88204:	4a3d      	ldr	r2, [pc, #244]	; (882fc <settings_store_global_setting+0x244>)
   88206:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   8820a:	f023 0320 	bic.w	r3, r3, #32
   8820e:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   88212:	e033      	b.n	8827c <settings_store_global_setting+0x1c4>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
   88214:	b138      	cbz	r0, 88226 <settings_store_global_setting+0x16e>
   88216:	4a39      	ldr	r2, [pc, #228]	; (882fc <settings_store_global_setting+0x244>)
   88218:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   8821c:	f043 0308 	orr.w	r3, r3, #8
   88220:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   88224:	e006      	b.n	88234 <settings_store_global_setting+0x17c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
   88226:	4a35      	ldr	r2, [pc, #212]	; (882fc <settings_store_global_setting+0x244>)
   88228:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   8822c:	f023 0308 	bic.w	r3, r3, #8
   88230:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
   88234:	4b36      	ldr	r3, [pc, #216]	; (88310 <settings_store_global_setting+0x258>)
   88236:	4798      	blx	r3
        break;
   88238:	e020      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
   8823a:	b138      	cbz	r0, 8824c <settings_store_global_setting+0x194>
   8823c:	4a2f      	ldr	r2, [pc, #188]	; (882fc <settings_store_global_setting+0x244>)
   8823e:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88242:	f043 0310 	orr.w	r3, r3, #16
   88246:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   8824a:	e017      	b.n	8827c <settings_store_global_setting+0x1c4>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
   8824c:	4a2b      	ldr	r2, [pc, #172]	; (882fc <settings_store_global_setting+0x244>)
   8824e:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   88252:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   88256:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
   8825a:	e00f      	b.n	8827c <settings_store_global_setting+0x1c4>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
   8825c:	4b27      	ldr	r3, [pc, #156]	; (882fc <settings_store_global_setting+0x244>)
   8825e:	f883 0041 	strb.w	r0, [r3, #65]	; 0x41
   88262:	e00b      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 24: settings.homing_feed_rate = value; break;
   88264:	4b25      	ldr	r3, [pc, #148]	; (882fc <settings_store_global_setting+0x244>)
   88266:	645d      	str	r5, [r3, #68]	; 0x44
   88268:	e008      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 25: settings.homing_seek_rate = value; break;
   8826a:	4b24      	ldr	r3, [pc, #144]	; (882fc <settings_store_global_setting+0x244>)
   8826c:	649d      	str	r5, [r3, #72]	; 0x48
   8826e:	e005      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 26: settings.homing_debounce_delay = int_value; break;
   88270:	4b22      	ldr	r3, [pc, #136]	; (882fc <settings_store_global_setting+0x244>)
   88272:	f8a3 004c 	strh.w	r0, [r3, #76]	; 0x4c
   88276:	e001      	b.n	8827c <settings_store_global_setting+0x1c4>
      case 27: settings.homing_pulloff = value; break;
   88278:	4b20      	ldr	r3, [pc, #128]	; (882fc <settings_store_global_setting+0x244>)
   8827a:	651d      	str	r5, [r3, #80]	; 0x50
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
   8827c:	4b25      	ldr	r3, [pc, #148]	; (88314 <settings_store_global_setting+0x25c>)
   8827e:	4798      	blx	r3
  return(STATUS_OK);
   88280:	2000      	movs	r0, #0
   88282:	bd70      	pop	{r4, r5, r6, pc}
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
   88284:	2004      	movs	r0, #4
   88286:	bd70      	pop	{r4, r5, r6, pc}
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   88288:	2003      	movs	r0, #3
   8828a:	bd70      	pop	{r4, r5, r6, pc}
      case 24: settings.homing_feed_rate = value; break;
      case 25: settings.homing_seek_rate = value; break;
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
   8828c:	2003      	movs	r0, #3
   8828e:	bd70      	pop	{r4, r5, r6, pc}
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
   88290:	2006      	movs	r0, #6
   88292:	bd70      	pop	{r4, r5, r6, pc}
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
   88294:	200a      	movs	r0, #10
   88296:	bd70      	pop	{r4, r5, r6, pc}
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   88298:	2003      	movs	r0, #3
   8829a:	bd70      	pop	{r4, r5, r6, pc}
   8829c:	2003      	movs	r0, #3
   8829e:	bd70      	pop	{r4, r5, r6, pc}
        parameter -= AXIS_SETTINGS_INCREMENT;
   882a0:	f1a4 036e 	sub.w	r3, r4, #110	; 0x6e
   882a4:	b2db      	uxtb	r3, r3
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
   882a6:	2b02      	cmp	r3, #2
   882a8:	d90e      	bls.n	882c8 <settings_store_global_setting+0x210>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   882aa:	2b09      	cmp	r3, #9
   882ac:	d9f4      	bls.n	88298 <settings_store_global_setting+0x1e0>
        parameter -= AXIS_SETTINGS_INCREMENT;
   882ae:	f1a4 0378 	sub.w	r3, r4, #120	; 0x78
   882b2:	b2db      	uxtb	r3, r3
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
   882b4:	2b02      	cmp	r3, #2
   882b6:	d90c      	bls.n	882d2 <settings_store_global_setting+0x21a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   882b8:	2b09      	cmp	r3, #9
   882ba:	d9ef      	bls.n	8829c <settings_store_global_setting+0x1e4>
        parameter -= AXIS_SETTINGS_INCREMENT;
   882bc:	347e      	adds	r4, #126	; 0x7e
   882be:	b2e4      	uxtb	r4, r4
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
   882c0:	2c02      	cmp	r4, #2
   882c2:	d911      	bls.n	882e8 <settings_store_global_setting+0x230>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
   882c4:	2003      	movs	r0, #3
   882c6:	bd70      	pop	{r4, r5, r6, pc}
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
   882c8:	4a0c      	ldr	r2, [pc, #48]	; (882fc <settings_store_global_setting+0x244>)
   882ca:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   882ce:	60dd      	str	r5, [r3, #12]
            break;
   882d0:	e7d4      	b.n	8827c <settings_store_global_setting+0x1c4>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
   882d2:	1d9c      	adds	r4, r3, #6
   882d4:	4e10      	ldr	r6, [pc, #64]	; (88318 <settings_store_global_setting+0x260>)
   882d6:	4628      	mov	r0, r5
   882d8:	4910      	ldr	r1, [pc, #64]	; (8831c <settings_store_global_setting+0x264>)
   882da:	47b0      	blx	r6
   882dc:	490f      	ldr	r1, [pc, #60]	; (8831c <settings_store_global_setting+0x264>)
   882de:	47b0      	blx	r6
   882e0:	4b06      	ldr	r3, [pc, #24]	; (882fc <settings_store_global_setting+0x244>)
   882e2:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
   882e6:	e7c9      	b.n	8827c <settings_store_global_setting+0x1c4>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
   882e8:	4b04      	ldr	r3, [pc, #16]	; (882fc <settings_store_global_setting+0x244>)
   882ea:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   882ee:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   882f2:	6265      	str	r5, [r4, #36]	; 0x24
   882f4:	e7c2      	b.n	8827c <settings_store_global_setting+0x1c4>
   882f6:	bf00      	nop
   882f8:	0008ca71 	.word	0x0008ca71
   882fc:	20001510 	.word	0x20001510
   88300:	0008be0d 	.word	0x0008be0d
   88304:	0008a265 	.word	0x0008a265
   88308:	0008c439 	.word	0x0008c439
   8830c:	00088809 	.word	0x00088809
   88310:	00083749 	.word	0x00083749
   88314:	00087e9d 	.word	0x00087e9d
   88318:	0008c735 	.word	0x0008c735
   8831c:	42700000 	.word	0x42700000

00088320 <settings_init>:
  return(STATUS_OK);
}


// Initialize the config subsystem
void settings_init() {
   88320:	b508      	push	{r3, lr}
  if(!read_global_settings()) {
   88322:	4b06      	ldr	r3, [pc, #24]	; (8833c <settings_init+0x1c>)
   88324:	4798      	blx	r3
   88326:	b938      	cbnz	r0, 88338 <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
   88328:	2007      	movs	r0, #7
   8832a:	4b05      	ldr	r3, [pc, #20]	; (88340 <settings_init+0x20>)
   8832c:	4798      	blx	r3
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
   8832e:	20ff      	movs	r0, #255	; 0xff
   88330:	4b04      	ldr	r3, [pc, #16]	; (88344 <settings_init+0x24>)
   88332:	4798      	blx	r3
    report_grbl_settings();
   88334:	4b04      	ldr	r3, [pc, #16]	; (88348 <settings_init+0x28>)
   88336:	4798      	blx	r3
   88338:	bd08      	pop	{r3, pc}
   8833a:	bf00      	nop
   8833c:	00088089 	.word	0x00088089
   88340:	000872f1 	.word	0x000872f1
   88344:	00087ec1 	.word	0x00087ec1
   88348:	00087511 	.word	0x00087511

0008834c <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
   8834c:	b120      	cbz	r0, 88358 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
   8834e:	2801      	cmp	r0, #1
   88350:	bf0c      	ite	eq
   88352:	2008      	moveq	r0, #8
   88354:	2010      	movne	r0, #16
   88356:	4770      	bx	lr


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
   88358:	2004      	movs	r0, #4
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
}
   8835a:	4770      	bx	lr

0008835c <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
   8835c:	b120      	cbz	r0, 88368 <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
   8835e:	2801      	cmp	r0, #1
   88360:	bf0c      	ite	eq
   88362:	2040      	moveq	r0, #64	; 0x40
   88364:	2080      	movne	r0, #128	; 0x80
   88366:	4770      	bx	lr


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
   88368:	2020      	movs	r0, #32
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
}
   8836a:	4770      	bx	lr

0008836c <spindle_stop>:
    #endif
  #else
    #ifdef INVERT_SPINDLE_ENABLE_PIN
	  SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
	#else
	  SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
   8836c:	4a02      	ldr	r2, [pc, #8]	; (88378 <spindle_stop+0xc>)
   8836e:	6b93      	ldr	r3, [r2, #56]	; 0x38
   88370:	f023 0310 	bic.w	r3, r3, #16
   88374:	6393      	str	r3, [r2, #56]	; 0x38
   88376:	4770      	bx	lr
   88378:	400e0e00 	.word	0x400e0e00

0008837c <spindle_init>:

#include "grbl.h"


void spindle_init()
{    
   8837c:	b508      	push	{r3, lr}
    #if defined(CPU_MAP_ATMEGA2560) || defined(USE_SPINDLE_DIR_AS_ENABLE_PIN)
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #endif     
  // Configure no variable spindle and only enable pin.
  #else  
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
   8837e:	4b06      	ldr	r3, [pc, #24]	; (88398 <spindle_init+0x1c>)
   88380:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   88382:	f042 0210 	orr.w	r2, r2, #16
   88386:	639a      	str	r2, [r3, #56]	; 0x38
  #endif
  
  #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
    SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
   88388:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8838a:	f042 0220 	orr.w	r2, r2, #32
   8838e:	639a      	str	r2, [r3, #56]	; 0x38
  #endif
  spindle_stop();
   88390:	4b02      	ldr	r3, [pc, #8]	; (8839c <spindle_init+0x20>)
   88392:	4798      	blx	r3
   88394:	bd08      	pop	{r3, pc}
   88396:	bf00      	nop
   88398:	400e0e00 	.word	0x400e0e00
   8839c:	0008836d 	.word	0x0008836d

000883a0 <spindle_set_state>:
  #endif  
}


void spindle_set_state(uint8_t state, float rpm)
{
   883a0:	b508      	push	{r3, lr}
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
   883a2:	b910      	cbnz	r0, 883aa <spindle_set_state+0xa>

    spindle_stop();
   883a4:	4b08      	ldr	r3, [pc, #32]	; (883c8 <spindle_set_state+0x28>)
   883a6:	4798      	blx	r3
   883a8:	bd08      	pop	{r3, pc}

  } else {

    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
   883aa:	2801      	cmp	r0, #1
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
   883ac:	4a07      	ldr	r2, [pc, #28]	; (883cc <spindle_set_state+0x2c>)
   883ae:	6b93      	ldr	r3, [r2, #56]	; 0x38
   883b0:	bf0c      	ite	eq
   883b2:	f023 0320 	biceq.w	r3, r3, #32
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
   883b6:	f043 0320 	orrne.w	r3, r3, #32
   883ba:	6393      	str	r3, [r2, #56]	; 0x38
      
    #else   
      #ifdef INVERT_SPINDLE_ENABLE_PIN
		SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
	  #else
		SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
   883bc:	4a03      	ldr	r2, [pc, #12]	; (883cc <spindle_set_state+0x2c>)
   883be:	6b93      	ldr	r3, [r2, #56]	; 0x38
   883c0:	f043 0310 	orr.w	r3, r3, #16
   883c4:	6393      	str	r3, [r2, #56]	; 0x38
   883c6:	bd08      	pop	{r3, pc}
   883c8:	0008836d 	.word	0x0008836d
   883cc:	400e0e00 	.word	0x400e0e00

000883d0 <spindle_run>:
  }
}


void spindle_run(uint8_t state, float rpm)
{
   883d0:	b538      	push	{r3, r4, r5, lr}
  if (sys.state == STATE_CHECK_MODE) { return; }
   883d2:	4b06      	ldr	r3, [pc, #24]	; (883ec <spindle_run+0x1c>)
   883d4:	785b      	ldrb	r3, [r3, #1]
   883d6:	2b02      	cmp	r3, #2
   883d8:	d007      	beq.n	883ea <spindle_run+0x1a>
   883da:	460c      	mov	r4, r1
   883dc:	4605      	mov	r5, r0
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
   883de:	4b04      	ldr	r3, [pc, #16]	; (883f0 <spindle_run+0x20>)
   883e0:	4798      	blx	r3
  spindle_set_state(state, rpm);
   883e2:	4628      	mov	r0, r5
   883e4:	4621      	mov	r1, r4
   883e6:	4b03      	ldr	r3, [pc, #12]	; (883f4 <spindle_run+0x24>)
   883e8:	4798      	blx	r3
   883ea:	bd38      	pop	{r3, r4, r5, pc}
   883ec:	20001484 	.word	0x20001484
   883f0:	00085369 	.word	0x00085369
   883f4:	000883a1 	.word	0x000883a1

000883f8 <DoOutPort>:
  are shown and defined in the above illustration.
*/


void DoOutPort(char out, char cmd)
{
   883f8:	b538      	push	{r3, r4, r5, lr}
   883fa:	4604      	mov	r4, r0
   883fc:	460d      	mov	r5, r1
	static char LastPort;
	static long int x_pos=0;
	static long int y_pos=0;
	static long int z_pos=0;

	if(cmd & 0x01)	//	Nastavit smer
   883fe:	f011 0f01 	tst.w	r1, #1
   88402:	d022      	beq.n	8844a <DoOutPort+0x52>
	{
		if(out & 0x20)	MOTORX_RIGHT;
   88404:	f010 0f20 	tst.w	r0, #32
   88408:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   8840c:	4b2e      	ldr	r3, [pc, #184]	; (884c8 <DoOutPort+0xd0>)
   8840e:	bf14      	ite	ne
   88410:	631a      	strne	r2, [r3, #48]	; 0x30
		else		MOTORX_LEFT;
   88412:	635a      	streq	r2, [r3, #52]	; 0x34
		if(out & 0x40)	MOTORY_RIGHT;
   88414:	f010 0f40 	tst.w	r0, #64	; 0x40
   88418:	f44f 7200 	mov.w	r2, #512	; 0x200
   8841c:	4b2b      	ldr	r3, [pc, #172]	; (884cc <DoOutPort+0xd4>)
   8841e:	bf14      	ite	ne
   88420:	631a      	strne	r2, [r3, #48]	; 0x30
		else		MOTORY_LEFT;
   88422:	635a      	streq	r2, [r3, #52]	; 0x34
		if(out & 0x80)	MOTORZ_RIGHT;
   88424:	f010 0f80 	tst.w	r0, #128	; 0x80
   88428:	f04f 0210 	mov.w	r2, #16
   8842c:	4b28      	ldr	r3, [pc, #160]	; (884d0 <DoOutPort+0xd8>)
   8842e:	bf14      	ite	ne
   88430:	631a      	strne	r2, [r3, #48]	; 0x30
		else		MOTORZ_LEFT;
   88432:	635a      	streq	r2, [r3, #52]	; 0x34
		if((LastPort & 0xE0) != (out & 0xE0))	//	Ak doslo k zmene smeru !!!
   88434:	4b27      	ldr	r3, [pc, #156]	; (884d4 <DoOutPort+0xdc>)
   88436:	781b      	ldrb	r3, [r3, #0]
   88438:	4043      	eors	r3, r0
   8843a:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   8843e:	d002      	beq.n	88446 <DoOutPort+0x4e>
			_delay_us(5);
   88440:	2005      	movs	r0, #5
   88442:	4b25      	ldr	r3, [pc, #148]	; (884d8 <DoOutPort+0xe0>)
   88444:	4798      	blx	r3
		LastPort = out;
   88446:	4b23      	ldr	r3, [pc, #140]	; (884d4 <DoOutPort+0xdc>)
   88448:	701c      	strb	r4, [r3, #0]
	}
	if(cmd & 0x02)	//	Step pulse
   8844a:	f015 0f02 	tst.w	r5, #2
   8844e:	d03a      	beq.n	884c6 <DoOutPort+0xce>
	{
		if(out & 0x04)
   88450:	f014 0f04 	tst.w	r4, #4
   88454:	d00d      	beq.n	88472 <DoOutPort+0x7a>
		{
			X_STEP_SET;
   88456:	f44f 7280 	mov.w	r2, #256	; 0x100
   8845a:	4b1d      	ldr	r3, [pc, #116]	; (884d0 <DoOutPort+0xd8>)
   8845c:	631a      	str	r2, [r3, #48]	; 0x30
			if(out & 0x20)	x_pos--;
   8845e:	f014 0f20 	tst.w	r4, #32
   88462:	4a1c      	ldr	r2, [pc, #112]	; (884d4 <DoOutPort+0xdc>)
   88464:	6853      	ldr	r3, [r2, #4]
   88466:	bf14      	ite	ne
   88468:	f103 33ff 	addne.w	r3, r3, #4294967295
			else x_pos++;
   8846c:	3301      	addeq	r3, #1
   8846e:	6053      	str	r3, [r2, #4]
   88470:	e003      	b.n	8847a <DoOutPort+0x82>
		}else
			X_STEP_CLEAR;
   88472:	f44f 7280 	mov.w	r2, #256	; 0x100
   88476:	4b16      	ldr	r3, [pc, #88]	; (884d0 <DoOutPort+0xd8>)
   88478:	635a      	str	r2, [r3, #52]	; 0x34
		if(out & 0x08)
   8847a:	f014 0f08 	tst.w	r4, #8
   8847e:	d00c      	beq.n	8849a <DoOutPort+0xa2>
		{
			Y_STEP_SET;
   88480:	2208      	movs	r2, #8
   88482:	4b12      	ldr	r3, [pc, #72]	; (884cc <DoOutPort+0xd4>)
   88484:	631a      	str	r2, [r3, #48]	; 0x30
			if(out & 0x40)	y_pos--;
   88486:	f014 0f40 	tst.w	r4, #64	; 0x40
   8848a:	4a12      	ldr	r2, [pc, #72]	; (884d4 <DoOutPort+0xdc>)
   8848c:	6893      	ldr	r3, [r2, #8]
   8848e:	bf14      	ite	ne
   88490:	f103 33ff 	addne.w	r3, r3, #4294967295
			else y_pos++;
   88494:	3301      	addeq	r3, #1
   88496:	6093      	str	r3, [r2, #8]
   88498:	e002      	b.n	884a0 <DoOutPort+0xa8>
		}	else
			Y_STEP_CLEAR;
   8849a:	2208      	movs	r2, #8
   8849c:	4b0b      	ldr	r3, [pc, #44]	; (884cc <DoOutPort+0xd4>)
   8849e:	635a      	str	r2, [r3, #52]	; 0x34
		if(out & 0x10)
   884a0:	f014 0f10 	tst.w	r4, #16
   884a4:	d00c      	beq.n	884c0 <DoOutPort+0xc8>
		{
			Z_STEP_SET;
   884a6:	2204      	movs	r2, #4
   884a8:	4b09      	ldr	r3, [pc, #36]	; (884d0 <DoOutPort+0xd8>)
   884aa:	631a      	str	r2, [r3, #48]	; 0x30
			if(out & 0x80)	z_pos--;
   884ac:	f014 0f80 	tst.w	r4, #128	; 0x80
   884b0:	4a08      	ldr	r2, [pc, #32]	; (884d4 <DoOutPort+0xdc>)
   884b2:	68d3      	ldr	r3, [r2, #12]
   884b4:	bf14      	ite	ne
   884b6:	f103 33ff 	addne.w	r3, r3, #4294967295
			else z_pos++;
   884ba:	3301      	addeq	r3, #1
   884bc:	60d3      	str	r3, [r2, #12]
   884be:	bd38      	pop	{r3, r4, r5, pc}
		}
		else
			Z_STEP_CLEAR;
   884c0:	2204      	movs	r2, #4
   884c2:	4b03      	ldr	r3, [pc, #12]	; (884d0 <DoOutPort+0xd8>)
   884c4:	635a      	str	r2, [r3, #52]	; 0x34
   884c6:	bd38      	pop	{r3, r4, r5, pc}
   884c8:	400e0e00 	.word	0x400e0e00
   884cc:	400e1400 	.word	0x400e1400
   884d0:	400e1200 	.word	0x400e1200
   884d4:	20000f54 	.word	0x20000f54
   884d8:	00089669 	.word	0x00089669

000884dc <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  stepper_status = 1;
   884dc:	2201      	movs	r2, #1
   884de:	4b19      	ldr	r3, [pc, #100]	; (88544 <st_wake_up+0x68>)
   884e0:	611a      	str	r2, [r3, #16]
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
   884e2:	4b19      	ldr	r3, [pc, #100]	; (88548 <st_wake_up+0x6c>)
   884e4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   884e8:	f013 0f04 	tst.w	r3, #4
   884ec:	4a17      	ldr	r2, [pc, #92]	; (8854c <st_wake_up+0x70>)
   884ee:	6b93      	ldr	r3, [r2, #56]	; 0x38
   884f0:	bf14      	ite	ne
   884f2:	f043 0301 	orrne.w	r3, r3, #1
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
   884f6:	f023 0301 	biceq.w	r3, r3, #1
   884fa:	6393      	str	r3, [r2, #56]	; 0x38

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
   884fc:	4b14      	ldr	r3, [pc, #80]	; (88550 <st_wake_up+0x74>)
   884fe:	785b      	ldrb	r3, [r3, #1]
   88500:	f013 0f0c 	tst.w	r3, #12
   88504:	d01d      	beq.n	88542 <st_wake_up+0x66>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
   88506:	490f      	ldr	r1, [pc, #60]	; (88544 <st_wake_up+0x68>)
   88508:	f891 3030 	ldrb.w	r3, [r1, #48]	; 0x30
   8850c:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
    st.step_outbits = step_port_invert_mask;
   88510:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
   88514:	f881 3022 	strb.w	r3, [r1, #34]	; 0x22
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
   88518:	4b0b      	ldr	r3, [pc, #44]	; (88548 <st_wake_up+0x6c>)
   8851a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   8851e:	3b02      	subs	r3, #2
   88520:	2254      	movs	r2, #84	; 0x54
   88522:	fb02 f303 	mul.w	r3, r2, r3
   88526:	08db      	lsrs	r3, r3, #3
   88528:	425b      	negs	r3, r3
   8852a:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   8852e:	4b09      	ldr	r3, [pc, #36]	; (88554 <st_wake_up+0x78>)
   88530:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   88534:	601a      	str	r2, [r3, #0]
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   88536:	2230      	movs	r2, #48	; 0x30
   88538:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
    #endif

    // Enable Stepper Driver Interrupt
    NVIC_EnableIRQ (TC3_IRQn);  
	NVIC_SetPriority(TC3_IRQn, 3);
	realtime = 1;
   8853c:	2201      	movs	r2, #1
   8853e:	4b06      	ldr	r3, [pc, #24]	; (88558 <st_wake_up+0x7c>)
   88540:	701a      	strb	r2, [r3, #0]
   88542:	4770      	bx	lr
   88544:	20000f54 	.word	0x20000f54
   88548:	20001510 	.word	0x20001510
   8854c:	400e0e00 	.word	0x400e0e00
   88550:	20001484 	.word	0x20001484
   88554:	e000e100 	.word	0xe000e100
   88558:	2000117c 	.word	0x2000117c

0008855c <st_go_idle>:
}


// Stepper shutdown
void st_go_idle() 
{
   8855c:	b508      	push	{r3, lr}
	stepper_status = -1;
   8855e:	4b1c      	ldr	r3, [pc, #112]	; (885d0 <st_go_idle+0x74>)
   88560:	f04f 32ff 	mov.w	r2, #4294967295
   88564:	611a      	str	r2, [r3, #16]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   88566:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   8856a:	4a1a      	ldr	r2, [pc, #104]	; (885d4 <st_go_idle+0x78>)
   8856c:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
    NVIC_DisableIRQ (TC3_IRQn);  
//ja  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;
   88570:	2200      	movs	r2, #0
   88572:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm) && sys.state != STATE_HOMING) {
   88576:	4b18      	ldr	r3, [pc, #96]	; (885d8 <st_go_idle+0x7c>)
   88578:	f893 0033 	ldrb.w	r0, [r3, #51]	; 0x33
   8857c:	28ff      	cmp	r0, #255	; 0xff
   8857e:	d104      	bne.n	8858a <st_go_idle+0x2e>
   88580:	4b16      	ldr	r3, [pc, #88]	; (885dc <st_go_idle+0x80>)
   88582:	781b      	ldrb	r3, [r3, #0]
   88584:	f013 0fff 	tst.w	r3, #255	; 0xff
   88588:	d01a      	beq.n	885c0 <st_go_idle+0x64>
   8858a:	4b15      	ldr	r3, [pc, #84]	; (885e0 <st_go_idle+0x84>)
   8858c:	785b      	ldrb	r3, [r3, #1]
   8858e:	2b04      	cmp	r3, #4
   88590:	d016      	beq.n	885c0 <st_go_idle+0x64>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
   88592:	4b14      	ldr	r3, [pc, #80]	; (885e4 <st_go_idle+0x88>)
   88594:	4798      	blx	r3
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
   88596:	4b10      	ldr	r3, [pc, #64]	; (885d8 <st_go_idle+0x7c>)
   88598:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   8859c:	f013 0f04 	tst.w	r3, #4
   885a0:	d105      	bne.n	885ae <st_go_idle+0x52>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
   885a2:	4a11      	ldr	r2, [pc, #68]	; (885e8 <st_go_idle+0x8c>)
   885a4:	6b93      	ldr	r3, [r2, #56]	; 0x38
   885a6:	f043 0301 	orr.w	r3, r3, #1
   885aa:	6393      	str	r3, [r2, #56]	; 0x38
   885ac:	e004      	b.n	885b8 <st_go_idle+0x5c>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
   885ae:	4a0e      	ldr	r2, [pc, #56]	; (885e8 <st_go_idle+0x8c>)
   885b0:	6b93      	ldr	r3, [r2, #56]	; 0x38
   885b2:	f023 0301 	bic.w	r3, r3, #1
   885b6:	6393      	str	r3, [r2, #56]	; 0x38
	 realtime = 0;
   885b8:	2200      	movs	r2, #0
   885ba:	4b0c      	ldr	r3, [pc, #48]	; (885ec <st_go_idle+0x90>)
   885bc:	701a      	strb	r2, [r3, #0]
   885be:	bd08      	pop	{r3, pc}
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
   885c0:	4b05      	ldr	r3, [pc, #20]	; (885d8 <st_go_idle+0x7c>)
   885c2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   885c6:	f013 0f04 	tst.w	r3, #4
   885ca:	d1ea      	bne.n	885a2 <st_go_idle+0x46>
   885cc:	e7ef      	b.n	885ae <st_go_idle+0x52>
   885ce:	bf00      	nop
   885d0:	20000f54 	.word	0x20000f54
   885d4:	e000e100 	.word	0xe000e100
   885d8:	20001510 	.word	0x20001510
   885dc:	200011b6 	.word	0x200011b6
   885e0:	20001484 	.word	0x20001484
   885e4:	00089689 	.word	0x00089689
   885e8:	400e0e00 	.word	0x400e0e00
   885ec:	2000117c 	.word	0x2000117c

000885f0 <TC3_Handler>:
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
//jaISR(TIMER1_COMPA_vect)
void TC3_Handler(void)
{
   885f0:	b530      	push	{r4, r5, lr}
   885f2:	b083      	sub	sp, #12
	volatile uint32_t ul_status;
	ul_status = TC1->TC_CHANNEL[0].TC_SR;	//	vynulujem priznak prerusenie
   885f4:	4b77      	ldr	r3, [pc, #476]	; (887d4 <TC3_Handler+0x1e4>)
   885f6:	6a1b      	ldr	r3, [r3, #32]
   885f8:	9301      	str	r3, [sp, #4]
	if(!ul_status) return;
   885fa:	9b01      	ldr	r3, [sp, #4]
   885fc:	2b00      	cmp	r3, #0
   885fe:	f000 80e7 	beq.w	887d0 <TC3_Handler+0x1e0>
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
   88602:	4b75      	ldr	r3, [pc, #468]	; (887d8 <TC3_Handler+0x1e8>)
   88604:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
   88608:	f013 0fff 	tst.w	r3, #255	; 0xff
   8860c:	f040 80e0 	bne.w	887d0 <TC3_Handler+0x1e0>
  if(stepper_status > 0)
   88610:	4b71      	ldr	r3, [pc, #452]	; (887d8 <TC3_Handler+0x1e8>)
   88612:	691b      	ldr	r3, [r3, #16]
   88614:	2b00      	cmp	r3, #0
   88616:	dd03      	ble.n	88620 <TC3_Handler+0x30>
	stepper_status++;
   88618:	4a6f      	ldr	r2, [pc, #444]	; (887d8 <TC3_Handler+0x1e8>)
   8861a:	6913      	ldr	r3, [r2, #16]
   8861c:	3301      	adds	r3, #1
   8861e:	6113      	str	r3, [r2, #16]
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DoOutPort(st.dir_outbits,0x01);	//	nastavim spravny smer
   88620:	4c6d      	ldr	r4, [pc, #436]	; (887d8 <TC3_Handler+0x1e8>)
   88622:	f894 0023 	ldrb.w	r0, [r4, #35]	; 0x23
   88626:	2101      	movs	r1, #1
   88628:	4d6c      	ldr	r5, [pc, #432]	; (887dc <TC3_Handler+0x1ec>)
   8862a:	47a8      	blx	r5

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
	DoOutPort(st.step_outbits,0x02);	//	nastavim piny STEP
   8862c:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
   88630:	2102      	movs	r1, #2
   88632:	47a8      	blx	r5
 //   STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
  #endif  
	  _delay_us(1);
   88634:	2001      	movs	r0, #1
   88636:	4b6a      	ldr	r3, [pc, #424]	; (887e0 <TC3_Handler+0x1f0>)
   88638:	4798      	blx	r3
	  DoOutPort(0,0x02);	//	nastavim piny STEP
   8863a:	2000      	movs	r0, #0
   8863c:	2102      	movs	r1, #2
   8863e:	47a8      	blx	r5
  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
//ja  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
//ja  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler

  busy = true;
   88640:	2301      	movs	r3, #1
   88642:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
//ja  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
   88646:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   88648:	2b00      	cmp	r3, #0
   8864a:	d146      	bne.n	886da <TC3_Handler+0xea>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
   8864c:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
   88650:	b2db      	uxtb	r3, r3
   88652:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
   88656:	429a      	cmp	r2, r3
   88658:	d037      	beq.n	886ca <TC3_Handler+0xda>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
   8865a:	4622      	mov	r2, r4
   8865c:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
   88660:	b2db      	uxtb	r3, r3
   88662:	3438      	adds	r4, #56	; 0x38
   88664:	005d      	lsls	r5, r3, #1
   88666:	18e9      	adds	r1, r5, r3
   88668:	0089      	lsls	r1, r1, #2
   8866a:	1860      	adds	r0, r4, r1
   8866c:	62d0      	str	r0, [r2, #44]	; 0x2c
//ja        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
//ja      OCR1A = st.exec_segment->cycles_per_tick;
	  TC1->TC_CHANNEL[0].TC_RC = st.exec_segment->cycles_per_tick;
   8866e:	442b      	add	r3, r5
   88670:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   88674:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   88676:	4b57      	ldr	r3, [pc, #348]	; (887d4 <TC3_Handler+0x1e4>)
   88678:	61dd      	str	r5, [r3, #28]
	  // Reset counter (SWTRG) and enable counter clock (CLKEN)
	  TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
   8867a:	2505      	movs	r5, #5
   8867c:	601d      	str	r5, [r3, #0]
	  last_delay = st.exec_segment->cycles_per_tick;
   8867e:	6843      	ldr	r3, [r0, #4]
   88680:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
   88684:	5a63      	ldrh	r3, [r4, r1]
   88686:	8493      	strh	r3, [r2, #36]	; 0x24
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
   88688:	7883      	ldrb	r3, [r0, #2]
   8868a:	f892 2026 	ldrb.w	r2, [r2, #38]	; 0x26
   8868e:	429a      	cmp	r2, r3
   88690:	d012      	beq.n	886b8 <TC3_Handler+0xc8>
        st.exec_block_index = st.exec_segment->st_block_index;
   88692:	f1a4 0238 	sub.w	r2, r4, #56	; 0x38
   88696:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
        st.exec_block = &st_block_buffer[st.exec_block_index];
   8869a:	f102 0184 	add.w	r1, r2, #132	; 0x84
   8869e:	0098      	lsls	r0, r3, #2
   886a0:	18c4      	adds	r4, r0, r3
   886a2:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   886a6:	6291      	str	r1, [r2, #40]	; 0x28
        
        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
   886a8:	eb02 0384 	add.w	r3, r2, r4, lsl #2
   886ac:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   886b0:	085b      	lsrs	r3, r3, #1
   886b2:	61d3      	str	r3, [r2, #28]
   886b4:	6193      	str	r3, [r2, #24]
   886b6:	6153      	str	r3, [r2, #20]
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
   886b8:	4b47      	ldr	r3, [pc, #284]	; (887d8 <TC3_Handler+0x1e8>)
   886ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   886bc:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
   886c0:	7812      	ldrb	r2, [r2, #0]
   886c2:	404a      	eors	r2, r1
   886c4:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
   886c8:	e007      	b.n	886da <TC3_Handler+0xea>
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
   886ca:	4b46      	ldr	r3, [pc, #280]	; (887e4 <TC3_Handler+0x1f4>)
   886cc:	4798      	blx	r3
      bit_true_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
   886ce:	4a46      	ldr	r2, [pc, #280]	; (887e8 <TC3_Handler+0x1f8>)
   886d0:	7813      	ldrb	r3, [r2, #0]
   886d2:	f043 0304 	orr.w	r3, r3, #4
   886d6:	7013      	strb	r3, [r2, #0]
      return; // Nothing to do but exit.
   886d8:	e07a      	b.n	887d0 <TC3_Handler+0x1e0>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
   886da:	4b44      	ldr	r3, [pc, #272]	; (887ec <TC3_Handler+0x1fc>)
   886dc:	4798      	blx	r3
   
  // Reset step out bits.
  st.step_outbits = 0; 
   886de:	483e      	ldr	r0, [pc, #248]	; (887d8 <TC3_Handler+0x1e8>)
   886e0:	2300      	movs	r3, #0
   886e2:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
   886e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
   886e8:	6859      	ldr	r1, [r3, #4]
   886ea:	6942      	ldr	r2, [r0, #20]
   886ec:	4411      	add	r1, r2
   886ee:	6141      	str	r1, [r0, #20]
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
   886f0:	6918      	ldr	r0, [r3, #16]
   886f2:	4281      	cmp	r1, r0
   886f4:	d90f      	bls.n	88716 <TC3_Handler+0x126>
    st.step_outbits |= (1<<X_STEP_BIT);
   886f6:	4a38      	ldr	r2, [pc, #224]	; (887d8 <TC3_Handler+0x1e8>)
   886f8:	2404      	movs	r4, #4
   886fa:	f882 4022 	strb.w	r4, [r2, #34]	; 0x22
    st.counter_x -= st.exec_block->step_event_count;
   886fe:	1a09      	subs	r1, r1, r0
   88700:	6151      	str	r1, [r2, #20]
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
   88702:	781a      	ldrb	r2, [r3, #0]
   88704:	f012 0f20 	tst.w	r2, #32
   88708:	4939      	ldr	r1, [pc, #228]	; (887f0 <TC3_Handler+0x200>)
   8870a:	684a      	ldr	r2, [r1, #4]
   8870c:	bf14      	ite	ne
   8870e:	f102 32ff 	addne.w	r2, r2, #4294967295
    else { sys.position[X_AXIS]++; }
   88712:	3201      	addeq	r2, #1
   88714:	604a      	str	r2, [r1, #4]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
   88716:	4a30      	ldr	r2, [pc, #192]	; (887d8 <TC3_Handler+0x1e8>)
   88718:	689c      	ldr	r4, [r3, #8]
   8871a:	6991      	ldr	r1, [r2, #24]
   8871c:	4421      	add	r1, r4
   8871e:	6191      	str	r1, [r2, #24]
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
   88720:	4288      	cmp	r0, r1
   88722:	d211      	bcs.n	88748 <TC3_Handler+0x158>
    st.step_outbits |= (1<<Y_STEP_BIT);
   88724:	f892 4022 	ldrb.w	r4, [r2, #34]	; 0x22
   88728:	f044 0408 	orr.w	r4, r4, #8
   8872c:	f882 4022 	strb.w	r4, [r2, #34]	; 0x22
    st.counter_y -= st.exec_block->step_event_count;
   88730:	1a09      	subs	r1, r1, r0
   88732:	6191      	str	r1, [r2, #24]
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
   88734:	781a      	ldrb	r2, [r3, #0]
   88736:	f012 0f40 	tst.w	r2, #64	; 0x40
   8873a:	492d      	ldr	r1, [pc, #180]	; (887f0 <TC3_Handler+0x200>)
   8873c:	688a      	ldr	r2, [r1, #8]
   8873e:	bf14      	ite	ne
   88740:	f102 32ff 	addne.w	r2, r2, #4294967295
    else { sys.position[Y_AXIS]++; }
   88744:	3201      	addeq	r2, #1
   88746:	608a      	str	r2, [r1, #8]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
   88748:	4c23      	ldr	r4, [pc, #140]	; (887d8 <TC3_Handler+0x1e8>)
   8874a:	68da      	ldr	r2, [r3, #12]
   8874c:	69e1      	ldr	r1, [r4, #28]
   8874e:	440a      	add	r2, r1
   88750:	61e2      	str	r2, [r4, #28]
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
   88752:	4290      	cmp	r0, r2
   88754:	d212      	bcs.n	8877c <TC3_Handler+0x18c>
    st.step_outbits |= (1<<Z_STEP_BIT);
   88756:	4621      	mov	r1, r4
   88758:	f894 4022 	ldrb.w	r4, [r4, #34]	; 0x22
   8875c:	f044 0410 	orr.w	r4, r4, #16
   88760:	f881 4022 	strb.w	r4, [r1, #34]	; 0x22
    st.counter_z -= st.exec_block->step_event_count;
   88764:	1a12      	subs	r2, r2, r0
   88766:	61ca      	str	r2, [r1, #28]
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
   88768:	f993 3000 	ldrsb.w	r3, [r3]
   8876c:	2b00      	cmp	r3, #0
   8876e:	4a20      	ldr	r2, [pc, #128]	; (887f0 <TC3_Handler+0x200>)
   88770:	68d3      	ldr	r3, [r2, #12]
   88772:	bfb4      	ite	lt
   88774:	f103 33ff 	addlt.w	r3, r3, #4294967295
    else { sys.position[Z_AXIS]++; }
   88778:	3301      	addge	r3, #1
   8877a:	60d3      	str	r3, [r2, #12]
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
   8877c:	4b1c      	ldr	r3, [pc, #112]	; (887f0 <TC3_Handler+0x200>)
   8877e:	785b      	ldrb	r3, [r3, #1]
   88780:	2b04      	cmp	r3, #4
   88782:	d107      	bne.n	88794 <TC3_Handler+0x1a4>
   88784:	4a14      	ldr	r2, [pc, #80]	; (887d8 <TC3_Handler+0x1e8>)
   88786:	4b1a      	ldr	r3, [pc, #104]	; (887f0 <TC3_Handler+0x200>)
   88788:	7f59      	ldrb	r1, [r3, #29]
   8878a:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
   8878e:	400b      	ands	r3, r1
   88790:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22

  st.step_count--; // Decrement step events count 
   88794:	4a10      	ldr	r2, [pc, #64]	; (887d8 <TC3_Handler+0x1e8>)
   88796:	8c93      	ldrh	r3, [r2, #36]	; 0x24
   88798:	3b01      	subs	r3, #1
   8879a:	b29b      	uxth	r3, r3
   8879c:	8493      	strh	r3, [r2, #36]	; 0x24
  if (st.step_count == 0) {
   8879e:	b963      	cbnz	r3, 887ba <TC3_Handler+0x1ca>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
   887a0:	62d3      	str	r3, [r2, #44]	; 0x2c
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
   887a2:	f892 3033 	ldrb.w	r3, [r2, #51]	; 0x33
   887a6:	3301      	adds	r3, #1
   887a8:	b2db      	uxtb	r3, r3
   887aa:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
   887ae:	2b06      	cmp	r3, #6
   887b0:	d103      	bne.n	887ba <TC3_Handler+0x1ca>
   887b2:	2200      	movs	r2, #0
   887b4:	4b08      	ldr	r3, [pc, #32]	; (887d8 <TC3_Handler+0x1e8>)
   887b6:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
   887ba:	4b07      	ldr	r3, [pc, #28]	; (887d8 <TC3_Handler+0x1e8>)
   887bc:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
   887c0:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
   887c4:	404a      	eors	r2, r1
   887c6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  busy = false;
   887ca:	2200      	movs	r2, #0
   887cc:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
   887d0:	b003      	add	sp, #12
   887d2:	bd30      	pop	{r4, r5, pc}
   887d4:	40084000 	.word	0x40084000
   887d8:	20000f54 	.word	0x20000f54
   887dc:	000883f9 	.word	0x000883f9
   887e0:	00089669 	.word	0x00089669
   887e4:	0008855d 	.word	0x0008855d
   887e8:	200011b4 	.word	0x200011b4
   887ec:	00084fc9 	.word	0x00084fc9
   887f0:	20001484 	.word	0x20001484

000887f4 <TC2_Handler>:
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
//jaISR(TIMER0_OVF_vect)
void TC2_Handler(void)
{
   887f4:	b082      	sub	sp, #8
	volatile uint32_t ul_status;
	ul_status = TC2->TC_CHANNEL[0].TC_SR;	//	vynulujem priznak prerusenia
   887f6:	4b03      	ldr	r3, [pc, #12]	; (88804 <TC2_Handler+0x10>)
   887f8:	6a1b      	ldr	r3, [r3, #32]
   887fa:	9301      	str	r3, [sp, #4]
	if(!ul_status) return;
   887fc:	9b01      	ldr	r3, [sp, #4]
//    NVIC_DisableIRQ (TC2_IRQn);			// Disable Timer to prevent re-entering this interrupt when it's not needed. 
	// Reset stepping pins (leave the direction pins)
//	DoOutPort(0x00,0x02);	//	Pulse set low
}
   887fe:	b002      	add	sp, #8
   88800:	4770      	bx	lr
   88802:	bf00      	nop
   88804:	40088000 	.word	0x40088000

00088808 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
   88808:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint8_t idx;
  step_port_invert_mask = 0;
   8880c:	4b16      	ldr	r3, [pc, #88]	; (88868 <st_generate_step_dir_invert_masks+0x60>)
   8880e:	2400      	movs	r4, #0
   88810:	f883 4031 	strb.w	r4, [r3, #49]	; 0x31
  dir_port_invert_mask = 0;
   88814:	f883 4030 	strb.w	r4, [r3, #48]	; 0x30
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
   88818:	4d14      	ldr	r5, [pc, #80]	; (8886c <st_generate_step_dir_invert_masks+0x64>)
   8881a:	f8df 8058 	ldr.w	r8, [pc, #88]	; 88874 <st_generate_step_dir_invert_masks+0x6c>
   8881e:	461f      	mov	r7, r3
   88820:	b2e6      	uxtb	r6, r4
   88822:	46a1      	mov	r9, r4
   88824:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   88828:	4123      	asrs	r3, r4
   8882a:	f013 0f01 	tst.w	r3, #1
   8882e:	d006      	beq.n	8883e <st_generate_step_dir_invert_masks+0x36>
   88830:	4630      	mov	r0, r6
   88832:	47c0      	blx	r8
   88834:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
   88838:	4318      	orrs	r0, r3
   8883a:	f887 0031 	strb.w	r0, [r7, #49]	; 0x31
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
   8883e:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
   88842:	fa43 f309 	asr.w	r3, r3, r9
   88846:	f013 0f01 	tst.w	r3, #1
   8884a:	d007      	beq.n	8885c <st_generate_step_dir_invert_masks+0x54>
   8884c:	4630      	mov	r0, r6
   8884e:	4b08      	ldr	r3, [pc, #32]	; (88870 <st_generate_step_dir_invert_masks+0x68>)
   88850:	4798      	blx	r3
   88852:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
   88856:	4318      	orrs	r0, r3
   88858:	f887 0030 	strb.w	r0, [r7, #48]	; 0x30
   8885c:	3401      	adds	r4, #1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
   8885e:	2c03      	cmp	r4, #3
   88860:	d1de      	bne.n	88820 <st_generate_step_dir_invert_masks+0x18>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
   88862:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   88866:	bf00      	nop
   88868:	20000f54 	.word	0x20000f54
   8886c:	20001510 	.word	0x20001510
   88870:	0008835d 	.word	0x0008835d
   88874:	0008834d 	.word	0x0008834d

00088878 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
   88878:	b510      	push	{r4, lr}
  // Initialize stepper driver idle state.
  st_go_idle();
   8887a:	4b1a      	ldr	r3, [pc, #104]	; (888e4 <st_reset+0x6c>)
   8887c:	4798      	blx	r3
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(prep));
   8887e:	4b1a      	ldr	r3, [pc, #104]	; (888e8 <st_reset+0x70>)
   88880:	2400      	movs	r4, #0
   88882:	f8c3 40e8 	str.w	r4, [r3, #232]	; 0xe8
   88886:	f8c3 40ec 	str.w	r4, [r3, #236]	; 0xec
   8888a:	f8c3 40f0 	str.w	r4, [r3, #240]	; 0xf0
   8888e:	f8c3 40f4 	str.w	r4, [r3, #244]	; 0xf4
   88892:	f8c3 40f8 	str.w	r4, [r3, #248]	; 0xf8
   88896:	f8c3 40fc 	str.w	r4, [r3, #252]	; 0xfc
   8889a:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
   8889e:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
   888a2:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
   888a6:	f8c3 410c 	str.w	r4, [r3, #268]	; 0x10c
   888aa:	f8c3 4110 	str.w	r4, [r3, #272]	; 0x110
   888ae:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
  memset(&st, 0, sizeof(st));
   888b2:	615c      	str	r4, [r3, #20]
   888b4:	619c      	str	r4, [r3, #24]
   888b6:	61dc      	str	r4, [r3, #28]
   888b8:	621c      	str	r4, [r3, #32]
   888ba:	625c      	str	r4, [r3, #36]	; 0x24
   888bc:	629c      	str	r4, [r3, #40]	; 0x28
   888be:	62dc      	str	r4, [r3, #44]	; 0x2c
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
   888c0:	f8c3 4118 	str.w	r4, [r3, #280]	; 0x118
  segment_buffer_tail = 0;
   888c4:	f883 4033 	strb.w	r4, [r3, #51]	; 0x33
  segment_buffer_head = 0; // empty = tail
   888c8:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
  segment_next_head = 1;
   888cc:	2201      	movs	r2, #1
   888ce:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c
  busy = false;
   888d2:	f883 4032 	strb.w	r4, [r3, #50]	; 0x32
  
  st_generate_step_dir_invert_masks();
   888d6:	4b05      	ldr	r3, [pc, #20]	; (888ec <st_reset+0x74>)
   888d8:	4798      	blx	r3
      
  // Initialize step and direction port pins.
//  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
//  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
  DoOutPort(0x00,0x03);
   888da:	4620      	mov	r0, r4
   888dc:	2103      	movs	r1, #3
   888de:	4b04      	ldr	r3, [pc, #16]	; (888f0 <st_reset+0x78>)
   888e0:	4798      	blx	r3
   888e2:	bd10      	pop	{r4, pc}
   888e4:	0008855d 	.word	0x0008855d
   888e8:	20000f54 	.word	0x20000f54
   888ec:	00088809 	.word	0x00088809
   888f0:	000883f9 	.word	0x000883f9

000888f4 <stepper_init>:
}


// Initialize and start the stepper motor subsystem
void stepper_init()
{
   888f4:	b508      	push	{r3, lr}
  // Configure step and direction interface pins
  X_STEP_PORT->PIO_OER |= X_STEP_PIN;	//	Je to vystup
   888f6:	4a36      	ldr	r2, [pc, #216]	; (889d0 <stepper_init+0xdc>)
   888f8:	6913      	ldr	r3, [r2, #16]
   888fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   888fe:	6113      	str	r3, [r2, #16]
  X_STEP_PORT->PIO_CODR|= X_STEP_PIN;	//	v hodnote 0
   88900:	6b53      	ldr	r3, [r2, #52]	; 0x34
   88902:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   88906:	6353      	str	r3, [r2, #52]	; 0x34
  Y_STEP_PORT->PIO_OER |= Y_STEP_PIN;	//	Je to vystup
   88908:	4b32      	ldr	r3, [pc, #200]	; (889d4 <stepper_init+0xe0>)
   8890a:	6919      	ldr	r1, [r3, #16]
   8890c:	f041 0108 	orr.w	r1, r1, #8
   88910:	6119      	str	r1, [r3, #16]
  Y_STEP_PORT->PIO_CODR|= Y_STEP_PIN;	//	v hodnote 0
   88912:	6b59      	ldr	r1, [r3, #52]	; 0x34
   88914:	f041 0108 	orr.w	r1, r1, #8
   88918:	6359      	str	r1, [r3, #52]	; 0x34
  Y_STEP_PORT->PIO_OER |= Y_STEP_PIN;	//	Je to vystup
   8891a:	6919      	ldr	r1, [r3, #16]
   8891c:	f041 0108 	orr.w	r1, r1, #8
   88920:	6119      	str	r1, [r3, #16]
  Y_STEP_PORT->PIO_CODR|= Y_STEP_PIN;	//	v hodnote 0
   88922:	6b59      	ldr	r1, [r3, #52]	; 0x34
   88924:	f041 0108 	orr.w	r1, r1, #8
   88928:	6359      	str	r1, [r3, #52]	; 0x34
  
  X_DIR_PORT->PIO_OER |= X_DIR_PIN;	//	Je to vystup
   8892a:	492b      	ldr	r1, [pc, #172]	; (889d8 <stepper_init+0xe4>)
   8892c:	6908      	ldr	r0, [r1, #16]
   8892e:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   88932:	6108      	str	r0, [r1, #16]
  X_DIR_PORT->PIO_CODR|= X_DIR_PIN;	//	v hodnote 0
   88934:	6b48      	ldr	r0, [r1, #52]	; 0x34
   88936:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   8893a:	6348      	str	r0, [r1, #52]	; 0x34
  Y_DIR_PORT->PIO_OER |= Y_DIR_PIN;	//	Je to vystup
   8893c:	6919      	ldr	r1, [r3, #16]
   8893e:	f441 7100 	orr.w	r1, r1, #512	; 0x200
   88942:	6119      	str	r1, [r3, #16]
  Y_DIR_PORT->PIO_CODR|= Y_DIR_PIN;	//	v hodnote 0
   88944:	6b59      	ldr	r1, [r3, #52]	; 0x34
   88946:	f441 7100 	orr.w	r1, r1, #512	; 0x200
   8894a:	6359      	str	r1, [r3, #52]	; 0x34
  Z_DIR_PORT->PIO_OER |= Z_DIR_PIN;	//	Je to vystup
   8894c:	6911      	ldr	r1, [r2, #16]
   8894e:	f041 0110 	orr.w	r1, r1, #16
   88952:	6111      	str	r1, [r2, #16]
  Z_DIR_PORT->PIO_CODR|= Z_DIR_PIN;	//	v hodnote 0
   88954:	6b51      	ldr	r1, [r2, #52]	; 0x34
   88956:	f041 0110 	orr.w	r1, r1, #16
   8895a:	6351      	str	r1, [r2, #52]	; 0x34
  
  X_ENA_PORT->PIO_OER |= X_ENA_PIN;	//	Je to vystup
   8895c:	691a      	ldr	r2, [r3, #16]
   8895e:	f042 0202 	orr.w	r2, r2, #2
   88962:	611a      	str	r2, [r3, #16]
  X_ENA_PORT->PIO_CODR|= X_ENA_PIN;	//	v hodnote 0
   88964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   88966:	f042 0202 	orr.w	r2, r2, #2
   8896a:	635a      	str	r2, [r3, #52]	; 0x34
  Y_ENA_PORT->PIO_OER |= Y_ENA_PIN;	//	Je to vystup
   8896c:	691a      	ldr	r2, [r3, #16]
   8896e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   88972:	611a      	str	r2, [r3, #16]
  Y_ENA_PORT->PIO_CODR|= Y_ENA_PIN;	//	v hodnote 0
   88974:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   88976:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   8897a:	635a      	str	r2, [r3, #52]	; 0x34
  Y_ENA_PORT->PIO_OER |= Z_ENA_PIN;	//	Je to vystup
   8897c:	691a      	ldr	r2, [r3, #16]
   8897e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   88982:	611a      	str	r2, [r3, #16]
  Y_ENA_PORT->PIO_CODR|= Z_ENA_PIN;	//	v hodnote 0
   88984:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   88986:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   8898a:	635a      	str	r2, [r3, #52]	; 0x34
  
/*  STEP_DDR |= STEP_MASK;
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
  DIRECTION_DDR |= DIRECTION_MASK;*/
	//	Enable TC1 power
	PMC->PMC_PCER0 |= 1 << ID_TC3;
   8898c:	4a13      	ldr	r2, [pc, #76]	; (889dc <stepper_init+0xe8>)
   8898e:	6913      	ldr	r3, [r2, #16]
   88990:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   88994:	6113      	str	r3, [r2, #16]
	// Disable TC clock
	TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKDIS;
   88996:	4b12      	ldr	r3, [pc, #72]	; (889e0 <stepper_init+0xec>)
   88998:	2202      	movs	r2, #2
   8899a:	601a      	str	r2, [r3, #0]
	// Disable interrupts
	TC1->TC_CHANNEL[0].TC_IDR = 0xFFFFFFFF;
   8899c:	f04f 32ff 	mov.w	r2, #4294967295
   889a0:	629a      	str	r2, [r3, #40]	; 0x28
	// Clear status register
	TC1->TC_CHANNEL[0].TC_SR;
   889a2:	6a1a      	ldr	r2, [r3, #32]
	// Set Mode
	TC1->TC_CHANNEL[0].TC_CMR = TC_CMR_CPCTRG | TC_CMR_TCCLKS_TIMER_CLOCK4;
   889a4:	f244 0203 	movw	r2, #16387	; 0x4003
   889a8:	605a      	str	r2, [r3, #4]
	// Compare Value
	TC1->TC_CHANNEL[0].TC_RC = 50; 
   889aa:	2232      	movs	r2, #50	; 0x32
   889ac:	61da      	str	r2, [r3, #28]
	// Configure and enable interrupt on RC compare
	TC1->TC_CHANNEL[0].TC_IER = TC_IER_CPCS;
   889ae:	2210      	movs	r2, #16
   889b0:	625a      	str	r2, [r3, #36]	; 0x24
	// Reset counter (SWTRG) and enable counter clock (CLKEN)
	TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
   889b2:	2205      	movs	r2, #5
   889b4:	601a      	str	r2, [r3, #0]
    DoOutPort(0,0x03);	//	Defaultne nastavenie 
   889b6:	2000      	movs	r0, #0
   889b8:	2103      	movs	r1, #3
   889ba:	4b0a      	ldr	r3, [pc, #40]	; (889e4 <stepper_init+0xf0>)
   889bc:	4798      	blx	r3

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   889be:	4b0a      	ldr	r3, [pc, #40]	; (889e8 <stepper_init+0xf4>)
   889c0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   889c4:	601a      	str	r2, [r3, #0]
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   889c6:	2230      	movs	r2, #48	; 0x30
   889c8:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
   889cc:	bd08      	pop	{r3, pc}
   889ce:	bf00      	nop
   889d0:	400e1200 	.word	0x400e1200
   889d4:	400e1400 	.word	0x400e1400
   889d8:	400e0e00 	.word	0x400e0e00
   889dc:	400e0600 	.word	0x400e0600
   889e0:	40084000 	.word	0x40084000
   889e4:	000883f9 	.word	0x000883f9
   889e8:	e000e100 	.word	0xe000e100

000889ec <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
   889ec:	b538      	push	{r3, r4, r5, lr}
  if (pl_block != NULL) { // Ignore if at start of a new block.
   889ee:	4b09      	ldr	r3, [pc, #36]	; (88a14 <st_update_plan_block_parameters+0x28>)
   889f0:	f8d3 5118 	ldr.w	r5, [r3, #280]	; 0x118
   889f4:	b165      	cbz	r5, 88a10 <st_update_plan_block_parameters+0x24>
    prep.flag_partial_block = true;
   889f6:	461c      	mov	r4, r3
   889f8:	2301      	movs	r3, #1
   889fa:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
   889fe:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
   88a02:	4601      	mov	r1, r0
   88a04:	4b04      	ldr	r3, [pc, #16]	; (88a18 <st_update_plan_block_parameters+0x2c>)
   88a06:	4798      	blx	r3
   88a08:	6168      	str	r0, [r5, #20]
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
   88a0a:	2300      	movs	r3, #0
   88a0c:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
   88a10:	bd38      	pop	{r3, r4, r5, pc}
   88a12:	bf00      	nop
   88a14:	20000f54 	.word	0x20000f54
   88a18:	0008c735 	.word	0x0008c735
   88a1c:	00000000 	.word	0x00000000

00088a20 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
   88a20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   88a24:	b099      	sub	sp, #100	; 0x64

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
   88a26:	4b94      	ldr	r3, [pc, #592]	; (88c78 <st_prep_buffer+0x258>)
   88a28:	785b      	ldrb	r3, [r3, #1]
   88a2a:	f013 0f70 	tst.w	r3, #112	; 0x70
   88a2e:	f000 83c2 	beq.w	891b6 <st_prep_buffer+0x796>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
   88a32:	4b92      	ldr	r3, [pc, #584]	; (88c7c <st_prep_buffer+0x25c>)
   88a34:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
   88a38:	2100      	movs	r1, #0
   88a3a:	4b91      	ldr	r3, [pc, #580]	; (88c80 <st_prep_buffer+0x260>)
   88a3c:	4798      	blx	r3
   88a3e:	2800      	cmp	r0, #0
   88a40:	f000 83b9 	beq.w	891b6 <st_prep_buffer+0x796>
   88a44:	e3c2      	b.n	891cc <st_prep_buffer+0x7ac>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
   88a46:	4b8d      	ldr	r3, [pc, #564]	; (88c7c <st_prep_buffer+0x25c>)
   88a48:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   88a4c:	2b00      	cmp	r3, #0
   88a4e:	f040 817a 	bne.w	88d46 <st_prep_buffer+0x326>
      pl_block = plan_get_current_block(); // Query planner for a queued block
   88a52:	4b8c      	ldr	r3, [pc, #560]	; (88c84 <st_prep_buffer+0x264>)
   88a54:	4798      	blx	r3
   88a56:	4604      	mov	r4, r0
   88a58:	4b88      	ldr	r3, [pc, #544]	; (88c7c <st_prep_buffer+0x25c>)
   88a5a:	f8c3 0118 	str.w	r0, [r3, #280]	; 0x118
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
   88a5e:	2800      	cmp	r0, #0
   88a60:	f000 83b4 	beq.w	891cc <st_prep_buffer+0x7ac>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
   88a64:	f893 30e9 	ldrb.w	r3, [r3, #233]	; 0xe9
   88a68:	b123      	cbz	r3, 88a74 <st_prep_buffer+0x54>
        prep.flag_partial_block = false; // Reset flag
   88a6a:	2200      	movs	r2, #0
   88a6c:	4b83      	ldr	r3, [pc, #524]	; (88c7c <st_prep_buffer+0x25c>)
   88a6e:	f883 20e9 	strb.w	r2, [r3, #233]	; 0xe9
   88a72:	e058      	b.n	88b26 <st_prep_buffer+0x106>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
   88a74:	4b81      	ldr	r3, [pc, #516]	; (88c7c <st_prep_buffer+0x25c>)
   88a76:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
   88a7a:	3301      	adds	r3, #1
   88a7c:	b2db      	uxtb	r3, r3
   88a7e:	2b05      	cmp	r3, #5
   88a80:	d003      	beq.n	88a8a <st_prep_buffer+0x6a>
   88a82:	4a7e      	ldr	r2, [pc, #504]	; (88c7c <st_prep_buffer+0x25c>)
   88a84:	f882 30e8 	strb.w	r3, [r2, #232]	; 0xe8
   88a88:	e003      	b.n	88a92 <st_prep_buffer+0x72>
   88a8a:	2200      	movs	r2, #0
   88a8c:	4b7b      	ldr	r3, [pc, #492]	; (88c7c <st_prep_buffer+0x25c>)
   88a8e:	f883 20e8 	strb.w	r2, [r3, #232]	; 0xe8
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
   88a92:	4d7a      	ldr	r5, [pc, #488]	; (88c7c <st_prep_buffer+0x25c>)
   88a94:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
   88a98:	f105 0284 	add.w	r2, r5, #132	; 0x84
   88a9c:	0099      	lsls	r1, r3, #2
   88a9e:	18c8      	adds	r0, r1, r3
   88aa0:	eb02 0280 	add.w	r2, r2, r0, lsl #2
   88aa4:	f8c5 2120 	str.w	r2, [r5, #288]	; 0x120
        st_prep_block->direction_bits = pl_block->direction_bits;
   88aa8:	7820      	ldrb	r0, [r4, #0]
   88aaa:	18ca      	adds	r2, r1, r3
   88aac:	eb05 0282 	add.w	r2, r5, r2, lsl #2
   88ab0:	f882 0084 	strb.w	r0, [r2, #132]	; 0x84
        #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS];
   88ab4:	6860      	ldr	r0, [r4, #4]
   88ab6:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS];
   88aba:	68a0      	ldr	r0, [r4, #8]
   88abc:	f8c2 008c 	str.w	r0, [r2, #140]	; 0x8c
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS];
   88ac0:	68e0      	ldr	r0, [r4, #12]
   88ac2:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
          st_prep_block->step_event_count = pl_block->step_event_count;
   88ac6:	6922      	ldr	r2, [r4, #16]
   88ac8:	440b      	add	r3, r1
   88aca:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   88ace:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
   88ad2:	6920      	ldr	r0, [r4, #16]
   88ad4:	4b6c      	ldr	r3, [pc, #432]	; (88c88 <st_prep_buffer+0x268>)
   88ad6:	4798      	blx	r3
   88ad8:	f8c5 00ec 	str.w	r0, [r5, #236]	; 0xec
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
   88adc:	4e6b      	ldr	r6, [pc, #428]	; (88c8c <st_prep_buffer+0x26c>)
   88ade:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   88ae0:	47b0      	blx	r6
   88ae2:	4601      	mov	r1, r0
   88ae4:	f8c5 00f0 	str.w	r0, [r5, #240]	; 0xf0
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
   88ae8:	4869      	ldr	r0, [pc, #420]	; (88c90 <st_prep_buffer+0x270>)
   88aea:	47b0      	blx	r6
   88aec:	f8c5 00f4 	str.w	r0, [r5, #244]	; 0xf4
        
        prep.dt_remainder = 0.0; // Reset for new planner block
   88af0:	2300      	movs	r3, #0
   88af2:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
   88af6:	4b60      	ldr	r3, [pc, #384]	; (88c78 <st_prep_buffer+0x258>)
   88af8:	785b      	ldrb	r3, [r3, #1]
   88afa:	f013 0f70 	tst.w	r3, #112	; 0x70
   88afe:	d008      	beq.n	88b12 <st_prep_buffer+0xf2>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
   88b00:	f8d5 110c 	ldr.w	r1, [r5, #268]	; 0x10c
   88b04:	f8c5 1104 	str.w	r1, [r5, #260]	; 0x104
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
   88b08:	4608      	mov	r0, r1
   88b0a:	4b62      	ldr	r3, [pc, #392]	; (88c94 <st_prep_buffer+0x274>)
   88b0c:	4798      	blx	r3
   88b0e:	6160      	str	r0, [r4, #20]
   88b10:	e009      	b.n	88b26 <st_prep_buffer+0x106>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
   88b12:	4d61      	ldr	r5, [pc, #388]	; (88c98 <st_prep_buffer+0x278>)
   88b14:	6960      	ldr	r0, [r4, #20]
   88b16:	47a8      	blx	r5
   88b18:	4b60      	ldr	r3, [pc, #384]	; (88c9c <st_prep_buffer+0x27c>)
   88b1a:	4798      	blx	r3
   88b1c:	4b60      	ldr	r3, [pc, #384]	; (88ca0 <st_prep_buffer+0x280>)
   88b1e:	4798      	blx	r3
   88b20:	4b56      	ldr	r3, [pc, #344]	; (88c7c <st_prep_buffer+0x25c>)
   88b22:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
   88b26:	4b55      	ldr	r3, [pc, #340]	; (88c7c <st_prep_buffer+0x25c>)
   88b28:	2200      	movs	r2, #0
   88b2a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
      float inv_2_accel = 0.5/pl_block->acceleration;
   88b2e:	f8d3 4118 	ldr.w	r4, [r3, #280]	; 0x118
   88b32:	6a65      	ldr	r5, [r4, #36]	; 0x24
   88b34:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
   88b38:	4629      	mov	r1, r5
   88b3a:	4b54      	ldr	r3, [pc, #336]	; (88c8c <st_prep_buffer+0x26c>)
   88b3c:	4798      	blx	r3
   88b3e:	4607      	mov	r7, r0
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
   88b40:	4b4d      	ldr	r3, [pc, #308]	; (88c78 <st_prep_buffer+0x258>)
   88b42:	785b      	ldrb	r3, [r3, #1]
   88b44:	f013 0f70 	tst.w	r3, #112	; 0x70
   88b48:	d032      	beq.n	88bb0 <st_prep_buffer+0x190>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
   88b4a:	2202      	movs	r2, #2
   88b4c:	4b4b      	ldr	r3, [pc, #300]	; (88c7c <st_prep_buffer+0x25c>)
   88b4e:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
   88b52:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   88b54:	6964      	ldr	r4, [r4, #20]
   88b56:	4620      	mov	r0, r4
   88b58:	4639      	mov	r1, r7
   88b5a:	4b4e      	ldr	r3, [pc, #312]	; (88c94 <st_prep_buffer+0x274>)
   88b5c:	4798      	blx	r3
   88b5e:	4601      	mov	r1, r0
   88b60:	4630      	mov	r0, r6
   88b62:	4b50      	ldr	r3, [pc, #320]	; (88ca4 <st_prep_buffer+0x284>)
   88b64:	4798      	blx	r3
   88b66:	4607      	mov	r7, r0
        if (decel_dist < 0.0) {
   88b68:	2100      	movs	r1, #0
   88b6a:	4b4f      	ldr	r3, [pc, #316]	; (88ca8 <st_prep_buffer+0x288>)
   88b6c:	4798      	blx	r3
   88b6e:	b1c0      	cbz	r0, 88ba2 <st_prep_buffer+0x182>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
   88b70:	f8df a13c 	ldr.w	sl, [pc, #316]	; 88cb0 <st_prep_buffer+0x290>
   88b74:	f8df 911c 	ldr.w	r9, [pc, #284]	; 88c94 <st_prep_buffer+0x274>
   88b78:	f8df 8128 	ldr.w	r8, [pc, #296]	; 88ca4 <st_prep_buffer+0x284>
   88b7c:	4f46      	ldr	r7, [pc, #280]	; (88c98 <st_prep_buffer+0x278>)
   88b7e:	4628      	mov	r0, r5
   88b80:	4629      	mov	r1, r5
   88b82:	47d0      	blx	sl
   88b84:	4601      	mov	r1, r0
   88b86:	4630      	mov	r0, r6
   88b88:	47c8      	blx	r9
   88b8a:	4601      	mov	r1, r0
   88b8c:	4620      	mov	r0, r4
   88b8e:	47c0      	blx	r8
   88b90:	47b8      	blx	r7
   88b92:	4b42      	ldr	r3, [pc, #264]	; (88c9c <st_prep_buffer+0x27c>)
   88b94:	4798      	blx	r3
   88b96:	4b42      	ldr	r3, [pc, #264]	; (88ca0 <st_prep_buffer+0x280>)
   88b98:	4798      	blx	r3
   88b9a:	4b38      	ldr	r3, [pc, #224]	; (88c7c <st_prep_buffer+0x25c>)
   88b9c:	f8c3 010c 	str.w	r0, [r3, #268]	; 0x10c
   88ba0:	e0d1      	b.n	88d46 <st_prep_buffer+0x326>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
   88ba2:	4b36      	ldr	r3, [pc, #216]	; (88c7c <st_prep_buffer+0x25c>)
   88ba4:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
          prep.exit_speed = 0.0;
   88ba8:	2200      	movs	r2, #0
   88baa:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   88bae:	e0ca      	b.n	88d46 <st_prep_buffer+0x326>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
   88bb0:	4d32      	ldr	r5, [pc, #200]	; (88c7c <st_prep_buffer+0x25c>)
   88bb2:	2300      	movs	r3, #0
   88bb4:	f885 30fc 	strb.w	r3, [r5, #252]	; 0xfc
        prep.accelerate_until = pl_block->millimeters; 
   88bb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   88bba:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
        prep.exit_speed = plan_get_exec_block_exit_speed();   
   88bbe:	4b3b      	ldr	r3, [pc, #236]	; (88cac <st_prep_buffer+0x28c>)
   88bc0:	4798      	blx	r3
   88bc2:	4680      	mov	r8, r0
   88bc4:	f8c5 010c 	str.w	r0, [r5, #268]	; 0x10c
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
   88bc8:	4e32      	ldr	r6, [pc, #200]	; (88c94 <st_prep_buffer+0x274>)
   88bca:	4601      	mov	r1, r0
   88bcc:	47b0      	blx	r6
   88bce:	4682      	mov	sl, r0
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
   88bd0:	f8d5 4118 	ldr.w	r4, [r5, #280]	; 0x118
   88bd4:	6aa5      	ldr	r5, [r4, #40]	; 0x28
   88bd6:	6960      	ldr	r0, [r4, #20]
   88bd8:	4651      	mov	r1, sl
   88bda:	4b32      	ldr	r3, [pc, #200]	; (88ca4 <st_prep_buffer+0x284>)
   88bdc:	4798      	blx	r3
   88bde:	4639      	mov	r1, r7
   88be0:	47b0      	blx	r6
   88be2:	4601      	mov	r1, r0
   88be4:	4628      	mov	r0, r5
   88be6:	4b32      	ldr	r3, [pc, #200]	; (88cb0 <st_prep_buffer+0x290>)
   88be8:	4798      	blx	r3
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
   88bea:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   88bee:	47b0      	blx	r6
   88bf0:	4606      	mov	r6, r0
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
   88bf2:	2100      	movs	r1, #0
   88bf4:	4b2f      	ldr	r3, [pc, #188]	; (88cb4 <st_prep_buffer+0x294>)
   88bf6:	4798      	blx	r3
   88bf8:	2800      	cmp	r0, #0
   88bfa:	f000 809e 	beq.w	88d3a <st_prep_buffer+0x31a>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
   88bfe:	4628      	mov	r0, r5
   88c00:	4631      	mov	r1, r6
   88c02:	4b2c      	ldr	r3, [pc, #176]	; (88cb4 <st_prep_buffer+0x294>)
   88c04:	4798      	blx	r3
   88c06:	2800      	cmp	r0, #0
   88c08:	f000 808e 	beq.w	88d28 <st_prep_buffer+0x308>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
   88c0c:	6a20      	ldr	r0, [r4, #32]
   88c0e:	4651      	mov	r1, sl
   88c10:	4b24      	ldr	r3, [pc, #144]	; (88ca4 <st_prep_buffer+0x284>)
   88c12:	4798      	blx	r3
   88c14:	4639      	mov	r1, r7
   88c16:	4b1f      	ldr	r3, [pc, #124]	; (88c94 <st_prep_buffer+0x274>)
   88c18:	4798      	blx	r3
   88c1a:	4601      	mov	r1, r0
   88c1c:	4b17      	ldr	r3, [pc, #92]	; (88c7c <st_prep_buffer+0x25c>)
   88c1e:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
   88c22:	4630      	mov	r0, r6
   88c24:	4b23      	ldr	r3, [pc, #140]	; (88cb4 <st_prep_buffer+0x294>)
   88c26:	4798      	blx	r3
   88c28:	2800      	cmp	r0, #0
   88c2a:	d045      	beq.n	88cb8 <st_prep_buffer+0x298>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
   88c2c:	4d1a      	ldr	r5, [pc, #104]	; (88c98 <st_prep_buffer+0x278>)
   88c2e:	6a20      	ldr	r0, [r4, #32]
   88c30:	47a8      	blx	r5
   88c32:	4b1a      	ldr	r3, [pc, #104]	; (88c9c <st_prep_buffer+0x27c>)
   88c34:	4798      	blx	r3
   88c36:	4b1a      	ldr	r3, [pc, #104]	; (88ca0 <st_prep_buffer+0x280>)
   88c38:	4798      	blx	r3
   88c3a:	4b10      	ldr	r3, [pc, #64]	; (88c7c <st_prep_buffer+0x25c>)
   88c3c:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
   88c40:	6966      	ldr	r6, [r4, #20]
   88c42:	f8d4 8020 	ldr.w	r8, [r4, #32]
   88c46:	4630      	mov	r0, r6
   88c48:	4641      	mov	r1, r8
   88c4a:	4b0d      	ldr	r3, [pc, #52]	; (88c80 <st_prep_buffer+0x260>)
   88c4c:	4798      	blx	r3
   88c4e:	b120      	cbz	r0, 88c5a <st_prep_buffer+0x23a>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
   88c50:	2201      	movs	r2, #1
   88c52:	4b0a      	ldr	r3, [pc, #40]	; (88c7c <st_prep_buffer+0x25c>)
   88c54:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
   88c58:	e075      	b.n	88d46 <st_prep_buffer+0x326>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
   88c5a:	4c08      	ldr	r4, [pc, #32]	; (88c7c <st_prep_buffer+0x25c>)
   88c5c:	4d11      	ldr	r5, [pc, #68]	; (88ca4 <st_prep_buffer+0x284>)
   88c5e:	4640      	mov	r0, r8
   88c60:	4631      	mov	r1, r6
   88c62:	47a8      	blx	r5
   88c64:	4639      	mov	r1, r7
   88c66:	4b0b      	ldr	r3, [pc, #44]	; (88c94 <st_prep_buffer+0x274>)
   88c68:	4798      	blx	r3
   88c6a:	4601      	mov	r1, r0
   88c6c:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
   88c70:	47a8      	blx	r5
   88c72:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
   88c76:	e066      	b.n	88d46 <st_prep_buffer+0x326>
   88c78:	20001484 	.word	0x20001484
   88c7c:	20000f54 	.word	0x20000f54
   88c80:	0008ca5d 	.word	0x0008ca5d
   88c84:	00084885 	.word	0x00084885
   88c88:	0008c685 	.word	0x0008c685
   88c8c:	0008c89d 	.word	0x0008c89d
   88c90:	3fa00000 	.word	0x3fa00000
   88c94:	0008c735 	.word	0x0008c735
   88c98:	0008be0d 	.word	0x0008be0d
   88c9c:	0008a2dd 	.word	0x0008a2dd
   88ca0:	0008c479 	.word	0x0008c479
   88ca4:	0008c521 	.word	0x0008c521
   88ca8:	0008ca71 	.word	0x0008ca71
   88cac:	000848a5 	.word	0x000848a5
   88cb0:	0008c525 	.word	0x0008c525
   88cb4:	0008caad 	.word	0x0008caad
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
   88cb8:	f8df b21c 	ldr.w	fp, [pc, #540]	; 88ed8 <st_prep_buffer+0x4b8>
   88cbc:	f8cb 6110 	str.w	r6, [fp, #272]	; 0x110
              prep.decelerate_after = intersect_distance;
   88cc0:	f8cb 6114 	str.w	r6, [fp, #276]	; 0x114
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
   88cc4:	4d80      	ldr	r5, [pc, #512]	; (88ec8 <st_prep_buffer+0x4a8>)
   88cc6:	6a60      	ldr	r0, [r4, #36]	; 0x24
   88cc8:	47a8      	blx	r5
   88cca:	4f80      	ldr	r7, [pc, #512]	; (88ecc <st_prep_buffer+0x4ac>)
   88ccc:	4602      	mov	r2, r0
   88cce:	460b      	mov	r3, r1
   88cd0:	47b8      	blx	r7
   88cd2:	e9cd 0100 	strd	r0, r1, [sp]
   88cd6:	4630      	mov	r0, r6
   88cd8:	47a8      	blx	r5
   88cda:	4602      	mov	r2, r0
   88cdc:	460b      	mov	r3, r1
   88cde:	f8df 8224 	ldr.w	r8, [pc, #548]	; 88f04 <st_prep_buffer+0x4e4>
   88ce2:	e9dd 0100 	ldrd	r0, r1, [sp]
   88ce6:	47c0      	blx	r8
   88ce8:	e9cd 0100 	strd	r0, r1, [sp]
   88cec:	6a60      	ldr	r0, [r4, #36]	; 0x24
   88cee:	47a8      	blx	r5
   88cf0:	4602      	mov	r2, r0
   88cf2:	460b      	mov	r3, r1
   88cf4:	47b8      	blx	r7
   88cf6:	e9cd 0100 	strd	r0, r1, [sp]
   88cfa:	4630      	mov	r0, r6
   88cfc:	47a8      	blx	r5
   88cfe:	4602      	mov	r2, r0
   88d00:	460b      	mov	r3, r1
   88d02:	e9dd 0100 	ldrd	r0, r1, [sp]
   88d06:	47c0      	blx	r8
   88d08:	4680      	mov	r8, r0
   88d0a:	4689      	mov	r9, r1
   88d0c:	4650      	mov	r0, sl
   88d0e:	47a8      	blx	r5
   88d10:	4602      	mov	r2, r0
   88d12:	460b      	mov	r3, r1
   88d14:	4640      	mov	r0, r8
   88d16:	4649      	mov	r1, r9
   88d18:	47b8      	blx	r7
   88d1a:	4b6d      	ldr	r3, [pc, #436]	; (88ed0 <st_prep_buffer+0x4b0>)
   88d1c:	4798      	blx	r3
   88d1e:	4b6d      	ldr	r3, [pc, #436]	; (88ed4 <st_prep_buffer+0x4b4>)
   88d20:	4798      	blx	r3
   88d22:	f8cb 0108 	str.w	r0, [fp, #264]	; 0x108
   88d26:	e00e      	b.n	88d46 <st_prep_buffer+0x326>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
   88d28:	4b6b      	ldr	r3, [pc, #428]	; (88ed8 <st_prep_buffer+0x4b8>)
   88d2a:	2202      	movs	r2, #2
   88d2c:	f883 20fc 	strb.w	r2, [r3, #252]	; 0xfc
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
   88d30:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   88d34:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   88d38:	e005      	b.n	88d46 <st_prep_buffer+0x326>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
   88d3a:	4b67      	ldr	r3, [pc, #412]	; (88ed8 <st_prep_buffer+0x4b8>)
   88d3c:	2200      	movs	r2, #0
   88d3e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
   88d42:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
   88d46:	4b64      	ldr	r3, [pc, #400]	; (88ed8 <st_prep_buffer+0x4b8>)
   88d48:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
   88d4c:	9216      	str	r2, [sp, #88]	; 0x58

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
   88d4e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   88d52:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   88d56:	f893 10e8 	ldrb.w	r1, [r3, #232]	; 0xe8
   88d5a:	f882 103a 	strb.w	r1, [r2, #58]	; 0x3a
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
   88d5e:	f8d3 8118 	ldr.w	r8, [r3, #280]	; 0x118
   88d62:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
   88d66:	9215      	str	r2, [sp, #84]	; 0x54
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
   88d68:	4610      	mov	r0, r2
   88d6a:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
   88d6e:	4b5b      	ldr	r3, [pc, #364]	; (88edc <st_prep_buffer+0x4bc>)
   88d70:	4798      	blx	r3
   88d72:	900e      	str	r0, [sp, #56]	; 0x38
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
   88d74:	2100      	movs	r1, #0
   88d76:	4b5a      	ldr	r3, [pc, #360]	; (88ee0 <st_prep_buffer+0x4c0>)
   88d78:	4798      	blx	r3
   88d7a:	b108      	cbz	r0, 88d80 <st_prep_buffer+0x360>
   88d7c:	2300      	movs	r3, #0
   88d7e:	930e      	str	r3, [sp, #56]	; 0x38
   88d80:	4b55      	ldr	r3, [pc, #340]	; (88ed8 <st_prep_buffer+0x4b8>)
   88d82:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   88d86:	9205      	str	r2, [sp, #20]
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
   88d88:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
   88d8c:	920f      	str	r2, [sp, #60]	; 0x3c
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
   88d8e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   88d92:	9207      	str	r2, [sp, #28]
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
   88d94:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
   88d98:	9209      	str	r2, [sp, #36]	; 0x24
   88d9a:	f893 50fc 	ldrb.w	r5, [r3, #252]	; 0xfc
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
   88d9e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   88da2:	9206      	str	r2, [sp, #24]
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
   88da4:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   88da8:	9314      	str	r3, [sp, #80]	; 0x50
   88daa:	9b15      	ldr	r3, [sp, #84]	; 0x54
   88dac:	9300      	str	r3, [sp, #0]
   88dae:	4c4d      	ldr	r4, [pc, #308]	; (88ee4 <st_prep_buffer+0x4c4>)
   88db0:	2300      	movs	r3, #0
   88db2:	9303      	str	r3, [sp, #12]
   88db4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   88db6:	9304      	str	r3, [sp, #16]

    do {
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
   88db8:	f8df b14c 	ldr.w	fp, [pc, #332]	; 88f08 <st_prep_buffer+0x4e8>
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
   88dbc:	f8df a108 	ldr.w	sl, [pc, #264]	; 88ec8 <st_prep_buffer+0x4a8>
   88dc0:	f8df 9140 	ldr.w	r9, [pc, #320]	; 88f04 <st_prep_buffer+0x4e4>
   88dc4:	4e41      	ldr	r6, [pc, #260]	; (88ecc <st_prep_buffer+0x4ac>)
   88dc6:	4f43      	ldr	r7, [pc, #268]	; (88ed4 <st_prep_buffer+0x4b4>)
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
   88dc8:	f8cd 8020 	str.w	r8, [sp, #32]
   88dcc:	46a8      	mov	r8, r5
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
   88dce:	f1b8 0f00 	cmp.w	r8, #0
   88dd2:	d003      	beq.n	88ddc <st_prep_buffer+0x3bc>
   88dd4:	f1b8 0f01 	cmp.w	r8, #1
   88dd8:	d05a      	beq.n	88e90 <st_prep_buffer+0x470>
   88dda:	e097      	b.n	88f0c <st_prep_buffer+0x4ec>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
   88ddc:	4620      	mov	r0, r4
   88dde:	9b08      	ldr	r3, [sp, #32]
   88de0:	6a59      	ldr	r1, [r3, #36]	; 0x24
   88de2:	47d8      	blx	fp
   88de4:	4605      	mov	r5, r0
   88de6:	9010      	str	r0, [sp, #64]	; 0x40
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
   88de8:	9800      	ldr	r0, [sp, #0]
   88dea:	47d0      	blx	sl
   88dec:	e9cd 0100 	strd	r0, r1, [sp]
   88df0:	4620      	mov	r0, r4
   88df2:	47d0      	blx	sl
   88df4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   88df8:	9805      	ldr	r0, [sp, #20]
   88dfa:	47d0      	blx	sl
   88dfc:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   88e00:	4628      	mov	r0, r5
   88e02:	47d0      	blx	sl
   88e04:	2200      	movs	r2, #0
   88e06:	4b38      	ldr	r3, [pc, #224]	; (88ee8 <st_prep_buffer+0x4c8>)
   88e08:	47c8      	blx	r9
   88e0a:	4602      	mov	r2, r0
   88e0c:	460b      	mov	r3, r1
   88e0e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   88e12:	47b0      	blx	r6
   88e14:	4602      	mov	r2, r0
   88e16:	460b      	mov	r3, r1
   88e18:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   88e1c:	47c8      	blx	r9
   88e1e:	4602      	mov	r2, r0
   88e20:	460b      	mov	r3, r1
   88e22:	e9dd 0100 	ldrd	r0, r1, [sp]
   88e26:	4d31      	ldr	r5, [pc, #196]	; (88eec <st_prep_buffer+0x4cc>)
   88e28:	47a8      	blx	r5
   88e2a:	47b8      	blx	r7
   88e2c:	9000      	str	r0, [sp, #0]
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
   88e2e:	990f      	ldr	r1, [sp, #60]	; 0x3c
   88e30:	4b2b      	ldr	r3, [pc, #172]	; (88ee0 <st_prep_buffer+0x4c0>)
   88e32:	4798      	blx	r3
   88e34:	2800      	cmp	r0, #0
   88e36:	d025      	beq.n	88e84 <st_prep_buffer+0x464>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
   88e38:	9815      	ldr	r0, [sp, #84]	; 0x54
   88e3a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   88e3c:	4629      	mov	r1, r5
   88e3e:	4b27      	ldr	r3, [pc, #156]	; (88edc <st_prep_buffer+0x4bc>)
   88e40:	4798      	blx	r3
   88e42:	47d0      	blx	sl
   88e44:	4602      	mov	r2, r0
   88e46:	460b      	mov	r3, r1
   88e48:	47b0      	blx	r6
   88e4a:	e9cd 0100 	strd	r0, r1, [sp]
   88e4e:	9807      	ldr	r0, [sp, #28]
   88e50:	9905      	ldr	r1, [sp, #20]
   88e52:	4b27      	ldr	r3, [pc, #156]	; (88ef0 <st_prep_buffer+0x4d0>)
   88e54:	4798      	blx	r3
   88e56:	47d0      	blx	sl
   88e58:	4602      	mov	r2, r0
   88e5a:	460b      	mov	r3, r1
   88e5c:	e9dd 0100 	ldrd	r0, r1, [sp]
   88e60:	4c24      	ldr	r4, [pc, #144]	; (88ef4 <st_prep_buffer+0x4d4>)
   88e62:	47a0      	blx	r4
   88e64:	47b8      	blx	r7
   88e66:	4604      	mov	r4, r0
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
   88e68:	4628      	mov	r0, r5
   88e6a:	9909      	ldr	r1, [sp, #36]	; 0x24
   88e6c:	4b22      	ldr	r3, [pc, #136]	; (88ef8 <st_prep_buffer+0x4d8>)
   88e6e:	4798      	blx	r3
   88e70:	2800      	cmp	r0, #0
            else { prep.ramp_type = RAMP_CRUISE; }
   88e72:	bf14      	ite	ne
   88e74:	f04f 0802 	movne.w	r8, #2
   88e78:	f04f 0801 	moveq.w	r8, #1
            prep.current_speed = prep.maximum_speed;
   88e7c:	9b07      	ldr	r3, [sp, #28]
   88e7e:	9305      	str	r3, [sp, #20]
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
   88e80:	9500      	str	r5, [sp, #0]
   88e82:	e097      	b.n	88fb4 <st_prep_buffer+0x594>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
   88e84:	9805      	ldr	r0, [sp, #20]
   88e86:	9910      	ldr	r1, [sp, #64]	; 0x40
   88e88:	4b19      	ldr	r3, [pc, #100]	; (88ef0 <st_prep_buffer+0x4d0>)
   88e8a:	4798      	blx	r3
   88e8c:	9005      	str	r0, [sp, #20]
   88e8e:	e091      	b.n	88fb4 <st_prep_buffer+0x594>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
   88e90:	4620      	mov	r0, r4
   88e92:	9907      	ldr	r1, [sp, #28]
   88e94:	47d8      	blx	fp
   88e96:	4601      	mov	r1, r0
   88e98:	9800      	ldr	r0, [sp, #0]
   88e9a:	4b10      	ldr	r3, [pc, #64]	; (88edc <st_prep_buffer+0x4bc>)
   88e9c:	4798      	blx	r3
   88e9e:	4601      	mov	r1, r0
   88ea0:	4605      	mov	r5, r0
          if (mm_var < prep.decelerate_after) { // End of cruise. 
   88ea2:	9809      	ldr	r0, [sp, #36]	; 0x24
   88ea4:	4b15      	ldr	r3, [pc, #84]	; (88efc <st_prep_buffer+0x4dc>)
   88ea6:	4798      	blx	r3
   88ea8:	2800      	cmp	r0, #0
   88eaa:	f000 8082 	beq.w	88fb2 <st_prep_buffer+0x592>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
   88eae:	9800      	ldr	r0, [sp, #0]
   88eb0:	9d09      	ldr	r5, [sp, #36]	; 0x24
   88eb2:	4629      	mov	r1, r5
   88eb4:	4b09      	ldr	r3, [pc, #36]	; (88edc <st_prep_buffer+0x4bc>)
   88eb6:	4798      	blx	r3
   88eb8:	9907      	ldr	r1, [sp, #28]
   88eba:	4b11      	ldr	r3, [pc, #68]	; (88f00 <st_prep_buffer+0x4e0>)
   88ebc:	4798      	blx	r3
   88ebe:	4604      	mov	r4, r0
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
   88ec0:	9500      	str	r5, [sp, #0]
            prep.ramp_type = RAMP_DECEL;
   88ec2:	f04f 0802 	mov.w	r8, #2
   88ec6:	e075      	b.n	88fb4 <st_prep_buffer+0x594>
   88ec8:	0008be0d 	.word	0x0008be0d
   88ecc:	0008bb51 	.word	0x0008bb51
   88ed0:	0008a2dd 	.word	0x0008a2dd
   88ed4:	0008c479 	.word	0x0008c479
   88ed8:	20000f54 	.word	0x20000f54
   88edc:	0008c521 	.word	0x0008c521
   88ee0:	0008ca71 	.word	0x0008ca71
   88ee4:	38690453 	.word	0x38690453
   88ee8:	3fe00000 	.word	0x3fe00000
   88eec:	0008bb4d 	.word	0x0008bb4d
   88ef0:	0008c525 	.word	0x0008c525
   88ef4:	0008c109 	.word	0x0008c109
   88ef8:	0008ca5d 	.word	0x0008ca5d
   88efc:	0008caad 	.word	0x0008caad
   88f00:	0008c89d 	.word	0x0008c89d
   88f04:	0008beb5 	.word	0x0008beb5
   88f08:	0008c735 	.word	0x0008c735
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
   88f0c:	4620      	mov	r0, r4
   88f0e:	9b08      	ldr	r3, [sp, #32]
   88f10:	6a59      	ldr	r1, [r3, #36]	; 0x24
   88f12:	47d8      	blx	fp
   88f14:	4601      	mov	r1, r0
   88f16:	900a      	str	r0, [sp, #40]	; 0x28
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
   88f18:	9805      	ldr	r0, [sp, #20]
   88f1a:	4b91      	ldr	r3, [pc, #580]	; (89160 <st_prep_buffer+0x740>)
   88f1c:	4798      	blx	r3
   88f1e:	2800      	cmp	r0, #0
   88f20:	d02d      	beq.n	88f7e <st_prep_buffer+0x55e>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
   88f22:	9800      	ldr	r0, [sp, #0]
   88f24:	47d0      	blx	sl
   88f26:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   88f2a:	4620      	mov	r0, r4
   88f2c:	47d0      	blx	sl
   88f2e:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   88f32:	9805      	ldr	r0, [sp, #20]
   88f34:	47d0      	blx	sl
   88f36:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   88f3a:	980a      	ldr	r0, [sp, #40]	; 0x28
   88f3c:	47d0      	blx	sl
   88f3e:	2200      	movs	r2, #0
   88f40:	4b88      	ldr	r3, [pc, #544]	; (89164 <st_prep_buffer+0x744>)
   88f42:	47c8      	blx	r9
   88f44:	4602      	mov	r2, r0
   88f46:	460b      	mov	r3, r1
   88f48:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   88f4c:	4d86      	ldr	r5, [pc, #536]	; (89168 <st_prep_buffer+0x748>)
   88f4e:	47a8      	blx	r5
   88f50:	4602      	mov	r2, r0
   88f52:	460b      	mov	r3, r1
   88f54:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   88f58:	47c8      	blx	r9
   88f5a:	4602      	mov	r2, r0
   88f5c:	460b      	mov	r3, r1
   88f5e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   88f62:	47a8      	blx	r5
   88f64:	47b8      	blx	r7
   88f66:	4605      	mov	r5, r0
            if (mm_var > prep.mm_complete) { // Deceleration only.
   88f68:	9906      	ldr	r1, [sp, #24]
   88f6a:	4b7d      	ldr	r3, [pc, #500]	; (89160 <st_prep_buffer+0x740>)
   88f6c:	4798      	blx	r3
   88f6e:	b130      	cbz	r0, 88f7e <st_prep_buffer+0x55e>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
   88f70:	9805      	ldr	r0, [sp, #20]
   88f72:	990a      	ldr	r1, [sp, #40]	; 0x28
   88f74:	4b7d      	ldr	r3, [pc, #500]	; (8916c <st_prep_buffer+0x74c>)
   88f76:	4798      	blx	r3
   88f78:	9005      	str	r0, [sp, #20]
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
   88f7a:	9500      	str	r5, [sp, #0]
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
   88f7c:	e01a      	b.n	88fb4 <st_prep_buffer+0x594>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
   88f7e:	9800      	ldr	r0, [sp, #0]
   88f80:	9d06      	ldr	r5, [sp, #24]
   88f82:	4629      	mov	r1, r5
   88f84:	4b79      	ldr	r3, [pc, #484]	; (8916c <st_prep_buffer+0x74c>)
   88f86:	4798      	blx	r3
   88f88:	47d0      	blx	sl
   88f8a:	4602      	mov	r2, r0
   88f8c:	460b      	mov	r3, r1
   88f8e:	47b0      	blx	r6
   88f90:	e9cd 0100 	strd	r0, r1, [sp]
   88f94:	9805      	ldr	r0, [sp, #20]
   88f96:	9914      	ldr	r1, [sp, #80]	; 0x50
   88f98:	4b75      	ldr	r3, [pc, #468]	; (89170 <st_prep_buffer+0x750>)
   88f9a:	4798      	blx	r3
   88f9c:	47d0      	blx	sl
   88f9e:	4602      	mov	r2, r0
   88fa0:	460b      	mov	r3, r1
   88fa2:	e9dd 0100 	ldrd	r0, r1, [sp]
   88fa6:	4c73      	ldr	r4, [pc, #460]	; (89174 <st_prep_buffer+0x754>)
   88fa8:	47a0      	blx	r4
   88faa:	47b8      	blx	r7
   88fac:	4604      	mov	r4, r0
          mm_remaining = prep.mm_complete; 
   88fae:	9500      	str	r5, [sp, #0]
   88fb0:	e000      	b.n	88fb4 <st_prep_buffer+0x594>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
   88fb2:	9500      	str	r5, [sp, #0]
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
   88fb4:	9803      	ldr	r0, [sp, #12]
   88fb6:	4621      	mov	r1, r4
   88fb8:	4b6d      	ldr	r3, [pc, #436]	; (89170 <st_prep_buffer+0x750>)
   88fba:	4798      	blx	r3
   88fbc:	4601      	mov	r1, r0
   88fbe:	9003      	str	r0, [sp, #12]
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
   88fc0:	9804      	ldr	r0, [sp, #16]
   88fc2:	4b67      	ldr	r3, [pc, #412]	; (89160 <st_prep_buffer+0x740>)
   88fc4:	4798      	blx	r3
   88fc6:	b128      	cbz	r0, 88fd4 <st_prep_buffer+0x5b4>
   88fc8:	9804      	ldr	r0, [sp, #16]
   88fca:	9903      	ldr	r1, [sp, #12]
   88fcc:	4b67      	ldr	r3, [pc, #412]	; (8916c <st_prep_buffer+0x74c>)
   88fce:	4798      	blx	r3
   88fd0:	4604      	mov	r4, r0
   88fd2:	e01a      	b.n	8900a <st_prep_buffer+0x5ea>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
   88fd4:	9800      	ldr	r0, [sp, #0]
   88fd6:	990e      	ldr	r1, [sp, #56]	; 0x38
   88fd8:	4b61      	ldr	r3, [pc, #388]	; (89160 <st_prep_buffer+0x740>)
   88fda:	4798      	blx	r3
   88fdc:	b948      	cbnz	r0, 88ff2 <st_prep_buffer+0x5d2>
   88fde:	4645      	mov	r5, r8
   88fe0:	f8dd 8020 	ldr.w	r8, [sp, #32]
   88fe4:	4b64      	ldr	r3, [pc, #400]	; (89178 <st_prep_buffer+0x758>)
   88fe6:	f883 50fc 	strb.w	r5, [r3, #252]	; 0xfc
   88fea:	9a05      	ldr	r2, [sp, #20]
   88fec:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   88ff0:	e01b      	b.n	8902a <st_prep_buffer+0x60a>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
   88ff2:	9804      	ldr	r0, [sp, #16]
   88ff4:	47d0      	blx	sl
   88ff6:	a358      	add	r3, pc, #352	; (adr r3, 89158 <st_prep_buffer+0x738>)
   88ff8:	e9d3 2300 	ldrd	r2, r3, [r3]
   88ffc:	47b0      	blx	r6
   88ffe:	47b8      	blx	r7
   89000:	9004      	str	r0, [sp, #16]
          time_var = dt_max - dt;
   89002:	9903      	ldr	r1, [sp, #12]
   89004:	4b59      	ldr	r3, [pc, #356]	; (8916c <st_prep_buffer+0x74c>)
   89006:	4798      	blx	r3
   89008:	4604      	mov	r4, r0
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
   8900a:	9800      	ldr	r0, [sp, #0]
   8900c:	9906      	ldr	r1, [sp, #24]
   8900e:	4b54      	ldr	r3, [pc, #336]	; (89160 <st_prep_buffer+0x740>)
   89010:	4798      	blx	r3
   89012:	2800      	cmp	r0, #0
   89014:	f47f aedb 	bne.w	88dce <st_prep_buffer+0x3ae>
   89018:	4645      	mov	r5, r8
   8901a:	f8dd 8020 	ldr.w	r8, [sp, #32]
   8901e:	4b56      	ldr	r3, [pc, #344]	; (89178 <st_prep_buffer+0x758>)
   89020:	f883 50fc 	strb.w	r5, [r3, #252]	; 0xfc
   89024:	9a05      	ldr	r2, [sp, #20]
   89026:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
   8902a:	4c53      	ldr	r4, [pc, #332]	; (89178 <st_prep_buffer+0x758>)
   8902c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   89030:	469a      	mov	sl, r3
   89032:	4618      	mov	r0, r3
   89034:	9900      	ldr	r1, [sp, #0]
   89036:	4b51      	ldr	r3, [pc, #324]	; (8917c <st_prep_buffer+0x75c>)
   89038:	4798      	blx	r3
   8903a:	4681      	mov	r9, r0
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
   8903c:	4f50      	ldr	r7, [pc, #320]	; (89180 <st_prep_buffer+0x760>)
   8903e:	47b8      	blx	r7
   89040:	4e50      	ldr	r6, [pc, #320]	; (89184 <st_prep_buffer+0x764>)
   89042:	47b0      	blx	r6
   89044:	4d50      	ldr	r5, [pc, #320]	; (89188 <st_prep_buffer+0x768>)
   89046:	47a8      	blx	r5
   89048:	4683      	mov	fp, r0
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
   8904a:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   8904e:	47b8      	blx	r7
   89050:	47b0      	blx	r6
   89052:	47a8      	blx	r5
   89054:	4605      	mov	r5, r0
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
   89056:	4659      	mov	r1, fp
   89058:	4b44      	ldr	r3, [pc, #272]	; (8916c <st_prep_buffer+0x74c>)
   8905a:	4798      	blx	r3
   8905c:	4b4b      	ldr	r3, [pc, #300]	; (8918c <st_prep_buffer+0x76c>)
   8905e:	4798      	blx	r3
   89060:	b280      	uxth	r0, r0
   89062:	9b16      	ldr	r3, [sp, #88]	; 0x58
   89064:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   89068:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   8906c:	8720      	strh	r0, [r4, #56]	; 0x38
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
   8906e:	b9b0      	cbnz	r0, 8909e <st_prep_buffer+0x67e>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
   89070:	4b47      	ldr	r3, [pc, #284]	; (89190 <st_prep_buffer+0x770>)
   89072:	785b      	ldrb	r3, [r3, #1]
   89074:	f013 0f70 	tst.w	r3, #112	; 0x70
   89078:	d011      	beq.n	8909e <st_prep_buffer+0x67e>
   8907a:	4659      	mov	r1, fp
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
   8907c:	4b3e      	ldr	r3, [pc, #248]	; (89178 <st_prep_buffer+0x758>)
   8907e:	2200      	movs	r2, #0
   89080:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        prep.dt_remainder = 0.0;
   89084:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
        prep.steps_remaining = n_steps_remaining;
   89088:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
   8908c:	4608      	mov	r0, r1
   8908e:	4651      	mov	r1, sl
   89090:	4b40      	ldr	r3, [pc, #256]	; (89194 <st_prep_buffer+0x774>)
   89092:	4798      	blx	r3
   89094:	f8c8 0028 	str.w	r0, [r8, #40]	; 0x28
        plan_cycle_reinitialize();         
   89098:	4b3f      	ldr	r3, [pc, #252]	; (89198 <st_prep_buffer+0x778>)
   8909a:	4798      	blx	r3
        return; // Segment not generated, but current step data still retained.
   8909c:	e096      	b.n	891cc <st_prep_buffer+0x7ac>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
   8909e:	4c36      	ldr	r4, [pc, #216]	; (89178 <st_prep_buffer+0x758>)
   890a0:	9803      	ldr	r0, [sp, #12]
   890a2:	f8d4 10f8 	ldr.w	r1, [r4, #248]	; 0xf8
   890a6:	4b32      	ldr	r3, [pc, #200]	; (89170 <st_prep_buffer+0x750>)
   890a8:	4798      	blx	r3
   890aa:	4607      	mov	r7, r0
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
   890ac:	4e2f      	ldr	r6, [pc, #188]	; (8916c <st_prep_buffer+0x74c>)
   890ae:	4628      	mov	r0, r5
   890b0:	4649      	mov	r1, r9
   890b2:	47b0      	blx	r6
   890b4:	4601      	mov	r1, r0
   890b6:	4638      	mov	r0, r7
   890b8:	4b36      	ldr	r3, [pc, #216]	; (89194 <st_prep_buffer+0x774>)
   890ba:	4798      	blx	r3
   890bc:	4605      	mov	r5, r0
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
   890be:	4658      	mov	r0, fp
   890c0:	4649      	mov	r1, r9
   890c2:	47b0      	blx	r6
   890c4:	4e2d      	ldr	r6, [pc, #180]	; (8917c <st_prep_buffer+0x75c>)
   890c6:	4629      	mov	r1, r5
   890c8:	47b0      	blx	r6
   890ca:	f8c4 00f8 	str.w	r0, [r4, #248]	; 0xf8

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*(1000000/128)*60)*inv_rate ); // (cycles/step)    
   890ce:	4628      	mov	r0, r5
   890d0:	4932      	ldr	r1, [pc, #200]	; (8919c <st_prep_buffer+0x77c>)
   890d2:	47b0      	blx	r6
   890d4:	4b2a      	ldr	r3, [pc, #168]	; (89180 <st_prep_buffer+0x760>)
   890d6:	4798      	blx	r3
   890d8:	4b2a      	ldr	r3, [pc, #168]	; (89184 <st_prep_buffer+0x764>)
   890da:	4798      	blx	r3
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    #else 
      // Compute step timing and timer prescalar for normal step generation.
        prep_segment->cycles_per_tick = cycles;
   890dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   890de:	eb03 0543 	add.w	r5, r3, r3, lsl #1
   890e2:	eb04 0585 	add.w	r5, r4, r5, lsl #2
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*(1000000/128)*60)*inv_rate ); // (cycles/step)    
   890e6:	4b2e      	ldr	r3, [pc, #184]	; (891a0 <st_prep_buffer+0x780>)
   890e8:	4798      	blx	r3
   890ea:	63e8      	str	r0, [r5, #60]	; 0x3c
        }
      }*/
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
   890ec:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
   890f0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
   890f4:	3301      	adds	r3, #1
   890f6:	b2db      	uxtb	r3, r3
   890f8:	2b06      	cmp	r3, #6
   890fa:	d002      	beq.n	89102 <st_prep_buffer+0x6e2>
   890fc:	f884 311c 	strb.w	r3, [r4, #284]	; 0x11c
   89100:	e003      	b.n	8910a <st_prep_buffer+0x6ea>
   89102:	2200      	movs	r2, #0
   89104:	4b1c      	ldr	r3, [pc, #112]	; (89178 <st_prep_buffer+0x758>)
   89106:	f883 211c 	strb.w	r2, [r3, #284]	; 0x11c

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
   8910a:	4b1b      	ldr	r3, [pc, #108]	; (89178 <st_prep_buffer+0x758>)
   8910c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
   89110:	9900      	ldr	r1, [sp, #0]
   89112:	4b24      	ldr	r3, [pc, #144]	; (891a4 <st_prep_buffer+0x784>)
   89114:	4798      	blx	r3
   89116:	b130      	cbz	r0, 89126 <st_prep_buffer+0x706>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
   89118:	9b00      	ldr	r3, [sp, #0]
   8911a:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
      prep.steps_remaining = steps_remaining;  
   8911e:	4b16      	ldr	r3, [pc, #88]	; (89178 <st_prep_buffer+0x758>)
   89120:	f8c3 90ec 	str.w	r9, [r3, #236]	; 0xec
   89124:	e049      	b.n	891ba <st_prep_buffer+0x79a>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
   89126:	9800      	ldr	r0, [sp, #0]
   89128:	2100      	movs	r1, #0
   8912a:	4b0d      	ldr	r3, [pc, #52]	; (89160 <st_prep_buffer+0x740>)
   8912c:	4798      	blx	r3
   8912e:	2800      	cmp	r0, #0
   89130:	d03a      	beq.n	891a8 <st_prep_buffer+0x788>
   89132:	4659      	mov	r1, fp
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
   89134:	4b10      	ldr	r3, [pc, #64]	; (89178 <st_prep_buffer+0x758>)
   89136:	2200      	movs	r2, #0
   89138:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        prep.dt_remainder = 0.0;
   8913c:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
        prep.steps_remaining = ceil(steps_remaining);
   89140:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
   89144:	4608      	mov	r0, r1
   89146:	4651      	mov	r1, sl
   89148:	4b12      	ldr	r3, [pc, #72]	; (89194 <st_prep_buffer+0x774>)
   8914a:	4798      	blx	r3
   8914c:	f8c8 0028 	str.w	r0, [r8, #40]	; 0x28
        plan_cycle_reinitialize(); 
   89150:	4b11      	ldr	r3, [pc, #68]	; (89198 <st_prep_buffer+0x778>)
   89152:	4798      	blx	r3
        return; // Bail!
   89154:	e03a      	b.n	891cc <st_prep_buffer+0x7ac>
   89156:	bf00      	nop
   89158:	5a912e32 	.word	0x5a912e32
   8915c:	3f0d208a 	.word	0x3f0d208a
   89160:	0008caad 	.word	0x0008caad
   89164:	3fe00000 	.word	0x3fe00000
   89168:	0008bb4d 	.word	0x0008bb4d
   8916c:	0008c521 	.word	0x0008c521
   89170:	0008c525 	.word	0x0008c525
   89174:	0008c109 	.word	0x0008c109
   89178:	20000f54 	.word	0x20000f54
   8917c:	0008c735 	.word	0x0008c735
   89180:	0008be0d 	.word	0x0008be0d
   89184:	00089de9 	.word	0x00089de9
   89188:	0008c479 	.word	0x0008c479
   8918c:	0008cb0d 	.word	0x0008cb0d
   89190:	20001484 	.word	0x20001484
   89194:	0008c89d 	.word	0x0008c89d
   89198:	00084cf5 	.word	0x00084cf5
   8919c:	4c1631b0 	.word	0x4c1631b0
   891a0:	0008c439 	.word	0x0008c439
   891a4:	0008ca71 	.word	0x0008ca71
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
   891a8:	2200      	movs	r2, #0
   891aa:	4b0a      	ldr	r3, [pc, #40]	; (891d4 <st_prep_buffer+0x7b4>)
   891ac:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
        plan_discard_current_block();
   891b0:	4b09      	ldr	r3, [pc, #36]	; (891d8 <st_prep_buffer+0x7b8>)
   891b2:	4798      	blx	r3
   891b4:	e001      	b.n	891ba <st_prep_buffer+0x79a>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
   891b6:	4b09      	ldr	r3, [pc, #36]	; (891dc <st_prep_buffer+0x7bc>)
   891b8:	9317      	str	r3, [sp, #92]	; 0x5c
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
   891ba:	4a06      	ldr	r2, [pc, #24]	; (891d4 <st_prep_buffer+0x7b4>)
   891bc:	f892 3033 	ldrb.w	r3, [r2, #51]	; 0x33
   891c0:	b2db      	uxtb	r3, r3
   891c2:	f892 211c 	ldrb.w	r2, [r2, #284]	; 0x11c
   891c6:	429a      	cmp	r2, r3
   891c8:	f47f ac3d 	bne.w	88a46 <st_prep_buffer+0x26>
        plan_discard_current_block();
      }
    }

  } 
}      
   891cc:	b019      	add	sp, #100	; 0x64
   891ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   891d2:	bf00      	nop
   891d4:	20000f54 	.word	0x20000f54
   891d8:	00084855 	.word	0x00084855
   891dc:	38690453 	.word	0x38690453

000891e0 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&_ram_end_;

	if (heap == NULL) {
   891e0:	4b09      	ldr	r3, [pc, #36]	; (89208 <_sbrk+0x28>)
   891e2:	681b      	ldr	r3, [r3, #0]
   891e4:	b913      	cbnz	r3, 891ec <_sbrk+0xc>
		heap = (unsigned char *)&_end;
   891e6:	4a09      	ldr	r2, [pc, #36]	; (8920c <_sbrk+0x2c>)
   891e8:	4b07      	ldr	r3, [pc, #28]	; (89208 <_sbrk+0x28>)
   891ea:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
   891ec:	4b06      	ldr	r3, [pc, #24]	; (89208 <_sbrk+0x28>)
   891ee:	681b      	ldr	r3, [r3, #0]

	if (((int)prev_heap + incr) > ramend) {
   891f0:	181a      	adds	r2, r3, r0
   891f2:	4907      	ldr	r1, [pc, #28]	; (89210 <_sbrk+0x30>)
   891f4:	4291      	cmp	r1, r2
   891f6:	db04      	blt.n	89202 <_sbrk+0x22>
		return (caddr_t) -1;	
	}

	heap += incr;
   891f8:	4610      	mov	r0, r2
   891fa:	4a03      	ldr	r2, [pc, #12]	; (89208 <_sbrk+0x28>)
   891fc:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
   891fe:	4618      	mov	r0, r3
   89200:	4770      	bx	lr
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
   89202:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
   89206:	4770      	bx	lr
   89208:	20001078 	.word	0x20001078
   8920c:	20003ae8 	.word	0x20003ae8
   89210:	20017fff 	.word	0x20017fff

00089214 <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
   89214:	4b04      	ldr	r3, [pc, #16]	; (89228 <system_init+0x14>)
   89216:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   89218:	f022 0207 	bic.w	r2, r2, #7
   8921c:	639a      	str	r2, [r3, #56]	; 0x38
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
   8921e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   89220:	f042 0207 	orr.w	r2, r2, #7
   89224:	639a      	str	r2, [r3, #56]	; 0x38
   89226:	4770      	bx	lr
   89228:	400e0e00 	.word	0x400e0e00

0008922c <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
   8922c:	2000      	movs	r0, #0
   8922e:	4770      	bx	lr

00089230 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
   89230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   89234:	4605      	mov	r5, r0
   89236:	2400      	movs	r4, #0
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    if (!(settings_read_startup_line(n, line))) {
   89238:	4e0c      	ldr	r6, [pc, #48]	; (8926c <system_execute_startup+0x3c>)
      report_status_message(STATUS_SETTING_READ_FAIL);
    } else {
      if (line[0] != 0) {
        printString(line); // Echo startup line to indicate execution.
   8923a:	f8df 803c 	ldr.w	r8, [pc, #60]	; 89278 <system_execute_startup+0x48>
        report_status_message(gc_execute_line(line));
   8923e:	4f0c      	ldr	r7, [pc, #48]	; (89270 <system_execute_startup+0x40>)
// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    if (!(settings_read_startup_line(n, line))) {
   89240:	b2e0      	uxtb	r0, r4
   89242:	4629      	mov	r1, r5
   89244:	47b0      	blx	r6
   89246:	b918      	cbnz	r0, 89250 <system_execute_startup+0x20>
      report_status_message(STATUS_SETTING_READ_FAIL);
   89248:	2007      	movs	r0, #7
   8924a:	4b0a      	ldr	r3, [pc, #40]	; (89274 <system_execute_startup+0x44>)
   8924c:	4798      	blx	r3
   8924e:	e007      	b.n	89260 <system_execute_startup+0x30>
    } else {
      if (line[0] != 0) {
   89250:	782b      	ldrb	r3, [r5, #0]
   89252:	b12b      	cbz	r3, 89260 <system_execute_startup+0x30>
        printString(line); // Echo startup line to indicate execution.
   89254:	4628      	mov	r0, r5
   89256:	47c0      	blx	r8
        report_status_message(gc_execute_line(line));
   89258:	4628      	mov	r0, r5
   8925a:	47b8      	blx	r7
   8925c:	4b05      	ldr	r3, [pc, #20]	; (89274 <system_execute_startup+0x44>)
   8925e:	4798      	blx	r3
   89260:	3401      	adds	r4, #1

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
   89262:	2c02      	cmp	r4, #2
   89264:	d1ec      	bne.n	89240 <system_execute_startup+0x10>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
   89266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8926a:	bf00      	nop
   8926c:	00087fbd 	.word	0x00087fbd
   89270:	00082531 	.word	0x00082531
   89274:	000872f1 	.word	0x000872f1
   89278:	00084d15 	.word	0x00084d15

0008927c <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
   8927c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   89280:	b085      	sub	sp, #20
   89282:	4604      	mov	r4, r0
  uint8_t char_counter = 1; 
   89284:	2301      	movs	r3, #1
   89286:	f88d 300f 	strb.w	r3, [sp, #15]
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
   8928a:	7843      	ldrb	r3, [r0, #1]
   8928c:	2b43      	cmp	r3, #67	; 0x43
   8928e:	d00d      	beq.n	892ac <system_execute_line+0x30>
   89290:	d803      	bhi.n	8929a <system_execute_line+0x1e>
   89292:	b13b      	cbz	r3, 892a4 <system_execute_line+0x28>
   89294:	2b24      	cmp	r3, #36	; 0x24
   89296:	d146      	bne.n	89326 <system_execute_line+0xaa>
   89298:	e008      	b.n	892ac <system_execute_line+0x30>
   8929a:	2b47      	cmp	r3, #71	; 0x47
   8929c:	d006      	beq.n	892ac <system_execute_line+0x30>
   8929e:	2b58      	cmp	r3, #88	; 0x58
   892a0:	d141      	bne.n	89326 <system_execute_line+0xaa>
   892a2:	e003      	b.n	892ac <system_execute_line+0x30>
    case 0 : report_grbl_help(); break;
   892a4:	4b86      	ldr	r3, [pc, #536]	; (894c0 <system_execute_line+0x244>)
   892a6:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   892a8:	2500      	movs	r5, #0
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
   892aa:	e1a3      	b.n	895f4 <system_execute_line+0x378>
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
   892ac:	78a2      	ldrb	r2, [r4, #2]
   892ae:	2a00      	cmp	r2, #0
   892b0:	f040 8177 	bne.w	895a2 <system_execute_line+0x326>
      switch( line[char_counter] ) {
   892b4:	2b43      	cmp	r3, #67	; 0x43
   892b6:	d015      	beq.n	892e4 <system_execute_line+0x68>
   892b8:	d802      	bhi.n	892c0 <system_execute_line+0x44>
   892ba:	2b24      	cmp	r3, #36	; 0x24
   892bc:	d005      	beq.n	892ca <system_execute_line+0x4e>
   892be:	e172      	b.n	895a6 <system_execute_line+0x32a>
   892c0:	2b47      	cmp	r3, #71	; 0x47
   892c2:	d00b      	beq.n	892dc <system_execute_line+0x60>
   892c4:	2b58      	cmp	r3, #88	; 0x58
   892c6:	d022      	beq.n	8930e <system_execute_line+0x92>
   892c8:	e16d      	b.n	895a6 <system_execute_line+0x32a>
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
   892ca:	4b7e      	ldr	r3, [pc, #504]	; (894c4 <system_execute_line+0x248>)
   892cc:	785d      	ldrb	r5, [r3, #1]
   892ce:	f015 0518 	ands.w	r5, r5, #24
   892d2:	f040 816a 	bne.w	895aa <system_execute_line+0x32e>
          else { report_grbl_settings(); }
   892d6:	4b7c      	ldr	r3, [pc, #496]	; (894c8 <system_execute_line+0x24c>)
   892d8:	4798      	blx	r3
          break;
   892da:	e18b      	b.n	895f4 <system_execute_line+0x378>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
   892dc:	4b7b      	ldr	r3, [pc, #492]	; (894cc <system_execute_line+0x250>)
   892de:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   892e0:	2500      	movs	r5, #0
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;   
   892e2:	e187      	b.n	895f4 <system_execute_line+0x378>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
   892e4:	4b77      	ldr	r3, [pc, #476]	; (894c4 <system_execute_line+0x248>)
   892e6:	785d      	ldrb	r5, [r3, #1]
   892e8:	2d02      	cmp	r5, #2
   892ea:	d106      	bne.n	892fa <system_execute_line+0x7e>
            mc_reset(); 
   892ec:	4b78      	ldr	r3, [pc, #480]	; (894d0 <system_execute_line+0x254>)
   892ee:	4798      	blx	r3
            report_feedback_message(MESSAGE_DISABLED);
   892f0:	2005      	movs	r0, #5
   892f2:	4b78      	ldr	r3, [pc, #480]	; (894d4 <system_execute_line+0x258>)
   892f4:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   892f6:	2500      	movs	r5, #0
   892f8:	e17c      	b.n	895f4 <system_execute_line+0x378>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
   892fa:	2d00      	cmp	r5, #0
   892fc:	f040 8157 	bne.w	895ae <system_execute_line+0x332>
            sys.state = STATE_CHECK_MODE;
   89300:	2202      	movs	r2, #2
   89302:	4b70      	ldr	r3, [pc, #448]	; (894c4 <system_execute_line+0x248>)
   89304:	705a      	strb	r2, [r3, #1]
            report_feedback_message(MESSAGE_ENABLED);
   89306:	2004      	movs	r0, #4
   89308:	4b72      	ldr	r3, [pc, #456]	; (894d4 <system_execute_line+0x258>)
   8930a:	4798      	blx	r3
   8930c:	e172      	b.n	895f4 <system_execute_line+0x378>
          }
          break; 
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) { 
   8930e:	4b6d      	ldr	r3, [pc, #436]	; (894c4 <system_execute_line+0x248>)
   89310:	785b      	ldrb	r3, [r3, #1]
   89312:	2b01      	cmp	r3, #1
   89314:	f040 814d 	bne.w	895b2 <system_execute_line+0x336>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
   89318:	2003      	movs	r0, #3
   8931a:	4b6e      	ldr	r3, [pc, #440]	; (894d4 <system_execute_line+0x258>)
   8931c:	4798      	blx	r3
            sys.state = STATE_IDLE;
   8931e:	2500      	movs	r5, #0
   89320:	4b68      	ldr	r3, [pc, #416]	; (894c4 <system_execute_line+0x248>)
   89322:	705d      	strb	r5, [r3, #1]
   89324:	e166      	b.n	895f4 <system_execute_line+0x378>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
   89326:	4a67      	ldr	r2, [pc, #412]	; (894c4 <system_execute_line+0x248>)
   89328:	7852      	ldrb	r2, [r2, #1]
   8932a:	2a01      	cmp	r2, #1
   8932c:	f200 8143 	bhi.w	895b6 <system_execute_line+0x33a>
      switch( line[char_counter] ) {
   89330:	3b23      	subs	r3, #35	; 0x23
   89332:	2b2f      	cmp	r3, #47	; 0x2f
   89334:	f200 80e8 	bhi.w	89508 <system_execute_line+0x28c>
   89338:	e8df f013 	tbh	[pc, r3, lsl #1]
   8933c:	00e60030 	.word	0x00e60030
   89340:	00e600e6 	.word	0x00e600e6
   89344:	00e600e6 	.word	0x00e600e6
   89348:	00e600e6 	.word	0x00e600e6
   8934c:	00e600e6 	.word	0x00e600e6
   89350:	00e600e6 	.word	0x00e600e6
   89354:	00e600e6 	.word	0x00e600e6
   89358:	00e600e6 	.word	0x00e600e6
   8935c:	00e600e6 	.word	0x00e600e6
   89360:	00e600e6 	.word	0x00e600e6
   89364:	00e600e6 	.word	0x00e600e6
   89368:	00e600e6 	.word	0x00e600e6
   8936c:	00e600e6 	.word	0x00e600e6
   89370:	00e600e6 	.word	0x00e600e6
   89374:	00e600e6 	.word	0x00e600e6
   89378:	00e600e6 	.word	0x00e600e6
   8937c:	00e600e6 	.word	0x00e600e6
   89380:	00e600e6 	.word	0x00e600e6
   89384:	003b00e6 	.word	0x003b00e6
   89388:	00e60054 	.word	0x00e60054
   8938c:	00e600e6 	.word	0x00e600e6
   89390:	00a200e6 	.word	0x00a200e6
   89394:	00e600e6 	.word	0x00e600e6
   89398:	007400e6 	.word	0x007400e6
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
   8939c:	2302      	movs	r3, #2
   8939e:	f88d 300f 	strb.w	r3, [sp, #15]
   893a2:	78a3      	ldrb	r3, [r4, #2]
   893a4:	2b00      	cmp	r3, #0
   893a6:	f040 8108 	bne.w	895ba <system_execute_line+0x33e>
          else { report_ngc_parameters(); }
   893aa:	4b4b      	ldr	r3, [pc, #300]	; (894d8 <system_execute_line+0x25c>)
   893ac:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   893ae:	2500      	movs	r5, #0
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
   893b0:	e120      	b.n	895f4 <system_execute_line+0x378>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
   893b2:	4b4a      	ldr	r3, [pc, #296]	; (894dc <system_execute_line+0x260>)
   893b4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   893b8:	f013 0f10 	tst.w	r3, #16
   893bc:	f000 80ff 	beq.w	895be <system_execute_line+0x342>
            sys.state = STATE_HOMING; // Set system state variable
   893c0:	4d40      	ldr	r5, [pc, #256]	; (894c4 <system_execute_line+0x248>)
   893c2:	2304      	movs	r3, #4
   893c4:	706b      	strb	r3, [r5, #1]
              bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
   893c6:	4b46      	ldr	r3, [pc, #280]	; (894e0 <system_execute_line+0x264>)
   893c8:	4798      	blx	r3
            if (!sys.abort) {  // Execute startup scripts after successful homing.
   893ca:	782d      	ldrb	r5, [r5, #0]
   893cc:	2d00      	cmp	r5, #0
   893ce:	f040 80f8 	bne.w	895c2 <system_execute_line+0x346>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
   893d2:	2200      	movs	r2, #0
   893d4:	4b3b      	ldr	r3, [pc, #236]	; (894c4 <system_execute_line+0x248>)
   893d6:	705a      	strb	r2, [r3, #1]
              st_go_idle(); // Set steppers to the settings idle state before returning.
   893d8:	4b42      	ldr	r3, [pc, #264]	; (894e4 <system_execute_line+0x268>)
   893da:	4798      	blx	r3
              system_execute_startup(line); 
   893dc:	4620      	mov	r0, r4
   893de:	4b42      	ldr	r3, [pc, #264]	; (894e8 <system_execute_line+0x26c>)
   893e0:	4798      	blx	r3
   893e2:	e107      	b.n	895f4 <system_execute_line+0x378>
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
   893e4:	2302      	movs	r3, #2
   893e6:	f88d 300f 	strb.w	r3, [sp, #15]
   893ea:	78a3      	ldrb	r3, [r4, #2]
   893ec:	b93b      	cbnz	r3, 893fe <system_execute_line+0x182>
            settings_read_build_info(line);
   893ee:	4620      	mov	r0, r4
   893f0:	4b3e      	ldr	r3, [pc, #248]	; (894ec <system_execute_line+0x270>)
   893f2:	4798      	blx	r3
            report_build_info(line);
   893f4:	4620      	mov	r0, r4
   893f6:	4b3e      	ldr	r3, [pc, #248]	; (894f0 <system_execute_line+0x274>)
   893f8:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   893fa:	2500      	movs	r5, #0
   893fc:	e0fa      	b.n	895f4 <system_execute_line+0x378>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
   893fe:	2b3d      	cmp	r3, #61	; 0x3d
   89400:	f040 80e1 	bne.w	895c6 <system_execute_line+0x34a>
   89404:	2303      	movs	r3, #3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
   89406:	18e1      	adds	r1, r4, r3
   89408:	5ce2      	ldrb	r2, [r4, r3]
   8940a:	f801 2c03 	strb.w	r2, [r1, #-3]
            } while (line[char_counter++] != 0);
   8940e:	3301      	adds	r3, #1
   89410:	b2db      	uxtb	r3, r3
   89412:	2a00      	cmp	r2, #0
   89414:	d1f7      	bne.n	89406 <system_execute_line+0x18a>
   89416:	f88d 300f 	strb.w	r3, [sp, #15]
            settings_store_build_info(line);
   8941a:	4620      	mov	r0, r4
   8941c:	4b35      	ldr	r3, [pc, #212]	; (894f4 <system_execute_line+0x278>)
   8941e:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   89420:	2500      	movs	r5, #0
   89422:	e0e7      	b.n	895f4 <system_execute_line+0x378>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
   89424:	78a3      	ldrb	r3, [r4, #2]
   89426:	2b53      	cmp	r3, #83	; 0x53
   89428:	f040 80cf 	bne.w	895ca <system_execute_line+0x34e>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
   8942c:	78e3      	ldrb	r3, [r4, #3]
   8942e:	2b54      	cmp	r3, #84	; 0x54
   89430:	f040 80cd 	bne.w	895ce <system_execute_line+0x352>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
   89434:	7923      	ldrb	r3, [r4, #4]
   89436:	2b3d      	cmp	r3, #61	; 0x3d
   89438:	f040 80cb 	bne.w	895d2 <system_execute_line+0x356>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
   8943c:	79a3      	ldrb	r3, [r4, #6]
   8943e:	2b00      	cmp	r3, #0
   89440:	f040 80c9 	bne.w	895d6 <system_execute_line+0x35a>
          switch (line[++char_counter]) {
   89444:	2305      	movs	r3, #5
   89446:	f88d 300f 	strb.w	r3, [sp, #15]
   8944a:	7963      	ldrb	r3, [r4, #5]
   8944c:	2b24      	cmp	r3, #36	; 0x24
   8944e:	d005      	beq.n	8945c <system_execute_line+0x1e0>
   89450:	2b2a      	cmp	r3, #42	; 0x2a
   89452:	d00b      	beq.n	8946c <system_execute_line+0x1f0>
   89454:	2b23      	cmp	r3, #35	; 0x23
   89456:	f040 80c0 	bne.w	895da <system_execute_line+0x35e>
   8945a:	e003      	b.n	89464 <system_execute_line+0x1e8>
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
   8945c:	2001      	movs	r0, #1
   8945e:	4b26      	ldr	r3, [pc, #152]	; (894f8 <system_execute_line+0x27c>)
   89460:	4798      	blx	r3
   89462:	e006      	b.n	89472 <system_execute_line+0x1f6>
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
   89464:	2002      	movs	r0, #2
   89466:	4b24      	ldr	r3, [pc, #144]	; (894f8 <system_execute_line+0x27c>)
   89468:	4798      	blx	r3
   8946a:	e002      	b.n	89472 <system_execute_line+0x1f6>
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
   8946c:	20ff      	movs	r0, #255	; 0xff
   8946e:	4b22      	ldr	r3, [pc, #136]	; (894f8 <system_execute_line+0x27c>)
   89470:	4798      	blx	r3
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
   89472:	2008      	movs	r0, #8
   89474:	4b17      	ldr	r3, [pc, #92]	; (894d4 <system_execute_line+0x258>)
   89476:	4798      	blx	r3
          mc_reset(); // Force reset to ensure settings are initialized correctly.
   89478:	4b15      	ldr	r3, [pc, #84]	; (894d0 <system_execute_line+0x254>)
   8947a:	4798      	blx	r3
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   8947c:	2500      	movs	r5, #0
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
   8947e:	e0b9      	b.n	895f4 <system_execute_line+0x378>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
   89480:	2302      	movs	r3, #2
   89482:	f88d 300f 	strb.w	r3, [sp, #15]
   89486:	78a3      	ldrb	r3, [r4, #2]
   89488:	b9ab      	cbnz	r3, 894b6 <system_execute_line+0x23a>
   8948a:	2500      	movs	r5, #0
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
   8948c:	4f1b      	ldr	r7, [pc, #108]	; (894fc <system_execute_line+0x280>)
                report_status_message(STATUS_SETTING_READ_FAIL);
              } else {
                report_startup_line(helper_var,line);
   8948e:	f8df 9070 	ldr.w	r9, [pc, #112]	; 89500 <system_execute_line+0x284>
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
                report_status_message(STATUS_SETTING_READ_FAIL);
   89492:	f8df 8070 	ldr.w	r8, [pc, #112]	; 89504 <system_execute_line+0x288>
   89496:	b2ee      	uxtb	r6, r5
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
   89498:	4630      	mov	r0, r6
   8949a:	4621      	mov	r1, r4
   8949c:	47b8      	blx	r7
   8949e:	b910      	cbnz	r0, 894a6 <system_execute_line+0x22a>
                report_status_message(STATUS_SETTING_READ_FAIL);
   894a0:	2007      	movs	r0, #7
   894a2:	47c0      	blx	r8
   894a4:	e002      	b.n	894ac <system_execute_line+0x230>
              } else {
                report_startup_line(helper_var,line);
   894a6:	4630      	mov	r0, r6
   894a8:	4621      	mov	r1, r4
   894aa:	47c8      	blx	r9
   894ac:	3501      	adds	r5, #1
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
   894ae:	2d02      	cmp	r5, #2
   894b0:	d1f1      	bne.n	89496 <system_execute_line+0x21a>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   894b2:	2500      	movs	r5, #0
   894b4:	e09e      	b.n	895f4 <system_execute_line+0x378>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
   894b6:	2a00      	cmp	r2, #0
   894b8:	f040 8091 	bne.w	895de <system_execute_line+0x362>
            helper_var = true;  // Set helper_var to flag storing method. 
   894bc:	2501      	movs	r5, #1
   894be:	e024      	b.n	8950a <system_execute_line+0x28e>
   894c0:	000874fd 	.word	0x000874fd
   894c4:	20001484 	.word	0x20001484
   894c8:	00087511 	.word	0x00087511
   894cc:	00087a09 	.word	0x00087a09
   894d0:	0008446d 	.word	0x0008446d
   894d4:	0008746d 	.word	0x0008746d
   894d8:	00087905 	.word	0x00087905
   894dc:	20001510 	.word	0x20001510
   894e0:	0008432d 	.word	0x0008432d
   894e4:	0008855d 	.word	0x0008855d
   894e8:	00089231 	.word	0x00089231
   894ec:	00087ff5 	.word	0x00087ff5
   894f0:	00087c09 	.word	0x00087c09
   894f4:	00087e6d 	.word	0x00087e6d
   894f8:	00087ec1 	.word	0x00087ec1
   894fc:	00087fbd 	.word	0x00087fbd
   89500:	00087bd5 	.word	0x00087bd5
   89504:	000872f1 	.word	0x000872f1
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
   89508:	2500      	movs	r5, #0
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
   8950a:	4620      	mov	r0, r4
   8950c:	f10d 010f 	add.w	r1, sp, #15
   89510:	aa02      	add	r2, sp, #8
   89512:	4b3a      	ldr	r3, [pc, #232]	; (895fc <system_execute_line+0x380>)
   89514:	4798      	blx	r3
   89516:	2800      	cmp	r0, #0
   89518:	d063      	beq.n	895e2 <system_execute_line+0x366>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
   8951a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   8951e:	1c5a      	adds	r2, r3, #1
   89520:	b2d2      	uxtb	r2, r2
   89522:	f88d 200f 	strb.w	r2, [sp, #15]
   89526:	5ce3      	ldrb	r3, [r4, r3]
   89528:	2b3d      	cmp	r3, #61	; 0x3d
   8952a:	d15c      	bne.n	895e6 <system_execute_line+0x36a>
          if (helper_var) { // Store startup line
   8952c:	b1ed      	cbz	r5, 8956a <system_execute_line+0x2ee>
   8952e:	4613      	mov	r3, r2
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
   89530:	18e1      	adds	r1, r4, r3
   89532:	5ce5      	ldrb	r5, [r4, r3]
   89534:	1a98      	subs	r0, r3, r2
   89536:	5425      	strb	r5, [r4, r0]
            } while (line[char_counter++] != 0);
   89538:	3301      	adds	r3, #1
   8953a:	b2db      	uxtb	r3, r3
   8953c:	7809      	ldrb	r1, [r1, #0]
   8953e:	2900      	cmp	r1, #0
   89540:	d1f6      	bne.n	89530 <system_execute_line+0x2b4>
   89542:	f88d 300f 	strb.w	r3, [sp, #15]
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
   89546:	4620      	mov	r0, r4
   89548:	4b2d      	ldr	r3, [pc, #180]	; (89600 <system_execute_line+0x384>)
   8954a:	4798      	blx	r3
            if (helper_var) { return(helper_var); }
   8954c:	4605      	mov	r5, r0
   8954e:	2800      	cmp	r0, #0
   89550:	d150      	bne.n	895f4 <system_execute_line+0x378>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
   89552:	9802      	ldr	r0, [sp, #8]
   89554:	4b2b      	ldr	r3, [pc, #172]	; (89604 <system_execute_line+0x388>)
   89556:	4798      	blx	r3
   89558:	4b2b      	ldr	r3, [pc, #172]	; (89608 <system_execute_line+0x38c>)
   8955a:	4798      	blx	r3
   8955c:	4b2b      	ldr	r3, [pc, #172]	; (8960c <system_execute_line+0x390>)
   8955e:	4798      	blx	r3
              settings_store_startup_line(helper_var,line);
   89560:	b2c0      	uxtb	r0, r0
   89562:	4621      	mov	r1, r4
   89564:	4b2a      	ldr	r3, [pc, #168]	; (89610 <system_execute_line+0x394>)
   89566:	4798      	blx	r3
   89568:	e044      	b.n	895f4 <system_execute_line+0x378>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
   8956a:	4620      	mov	r0, r4
   8956c:	f10d 010f 	add.w	r1, sp, #15
   89570:	aa01      	add	r2, sp, #4
   89572:	4b22      	ldr	r3, [pc, #136]	; (895fc <system_execute_line+0x380>)
   89574:	4798      	blx	r3
   89576:	2800      	cmp	r0, #0
   89578:	d037      	beq.n	895ea <system_execute_line+0x36e>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
   8957a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   8957e:	5ce3      	ldrb	r3, [r4, r3]
   89580:	2b00      	cmp	r3, #0
   89582:	d134      	bne.n	895ee <system_execute_line+0x372>
   89584:	9c02      	ldr	r4, [sp, #8]
   89586:	4620      	mov	r0, r4
   89588:	4922      	ldr	r1, [pc, #136]	; (89614 <system_execute_line+0x398>)
   8958a:	4b23      	ldr	r3, [pc, #140]	; (89618 <system_execute_line+0x39c>)
   8958c:	4798      	blx	r3
   8958e:	bb80      	cbnz	r0, 895f2 <system_execute_line+0x376>
            return(settings_store_global_setting((uint8_t)parameter, value));
   89590:	4620      	mov	r0, r4
   89592:	4b22      	ldr	r3, [pc, #136]	; (8961c <system_execute_line+0x3a0>)
   89594:	4798      	blx	r3
   89596:	b2c0      	uxtb	r0, r0
   89598:	9901      	ldr	r1, [sp, #4]
   8959a:	4b21      	ldr	r3, [pc, #132]	; (89620 <system_execute_line+0x3a4>)
   8959c:	4798      	blx	r3
   8959e:	4605      	mov	r5, r0
   895a0:	e028      	b.n	895f4 <system_execute_line+0x378>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
   895a2:	2503      	movs	r5, #3
   895a4:	e026      	b.n	895f4 <system_execute_line+0x378>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   895a6:	2500      	movs	r5, #0
   895a8:	e024      	b.n	895f4 <system_execute_line+0x378>
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
   895aa:	2508      	movs	r5, #8
   895ac:	e022      	b.n	895f4 <system_execute_line+0x378>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
   895ae:	2508      	movs	r5, #8
   895b0:	e020      	b.n	895f4 <system_execute_line+0x378>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   895b2:	2500      	movs	r5, #0
   895b4:	e01e      	b.n	895f4 <system_execute_line+0x378>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
   895b6:	2508      	movs	r5, #8
   895b8:	e01c      	b.n	895f4 <system_execute_line+0x378>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
   895ba:	2503      	movs	r5, #3
   895bc:	e01a      	b.n	895f4 <system_execute_line+0x378>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
   895be:	2505      	movs	r5, #5
   895c0:	e018      	b.n	895f4 <system_execute_line+0x378>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
   895c2:	2500      	movs	r5, #0
   895c4:	e016      	b.n	895f4 <system_execute_line+0x378>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
   895c6:	2503      	movs	r5, #3
   895c8:	e014      	b.n	895f4 <system_execute_line+0x378>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
   895ca:	2503      	movs	r5, #3
   895cc:	e012      	b.n	895f4 <system_execute_line+0x378>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
   895ce:	2503      	movs	r5, #3
   895d0:	e010      	b.n	895f4 <system_execute_line+0x378>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
   895d2:	2503      	movs	r5, #3
   895d4:	e00e      	b.n	895f4 <system_execute_line+0x378>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
   895d6:	2503      	movs	r5, #3
   895d8:	e00c      	b.n	895f4 <system_execute_line+0x378>
          switch (line[++char_counter]) {
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
   895da:	2503      	movs	r5, #3
   895dc:	e00a      	b.n	895f4 <system_execute_line+0x378>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
   895de:	2508      	movs	r5, #8
   895e0:	e008      	b.n	895f4 <system_execute_line+0x378>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
   895e2:	2502      	movs	r5, #2
   895e4:	e006      	b.n	895f4 <system_execute_line+0x378>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
   895e6:	2503      	movs	r5, #3
   895e8:	e004      	b.n	895f4 <system_execute_line+0x378>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
   895ea:	2502      	movs	r5, #2
   895ec:	e002      	b.n	895f4 <system_execute_line+0x378>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
   895ee:	2503      	movs	r5, #3
   895f0:	e000      	b.n	895f4 <system_execute_line+0x378>
   895f2:	2503      	movs	r5, #3
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
   895f4:	4628      	mov	r0, r5
   895f6:	b005      	add	sp, #20
   895f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   895fc:	000844d1 	.word	0x000844d1
   89600:	00082531 	.word	0x00082531
   89604:	0008be0d 	.word	0x0008be0d
   89608:	0008a265 	.word	0x0008a265
   8960c:	0008c439 	.word	0x0008c439
   89610:	00087e51 	.word	0x00087e51
   89614:	437f0000 	.word	0x437f0000
   89618:	0008caad 	.word	0x0008caad
   8961c:	0008cb0d 	.word	0x0008cb0d
   89620:	000880b9 	.word	0x000880b9

00089624 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
   89624:	b510      	push	{r4, lr}
   89626:	460c      	mov	r4, r1
      pos = 0.5*((steps[A_MOTOR] - steps[B_MOTOR])/settings.steps_per_mm[idx]);
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
   89628:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
   8962c:	4b03      	ldr	r3, [pc, #12]	; (8963c <system_convert_axis_steps_to_mpos+0x18>)
   8962e:	4798      	blx	r3
   89630:	4b03      	ldr	r3, [pc, #12]	; (89640 <system_convert_axis_steps_to_mpos+0x1c>)
   89632:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
   89636:	4b03      	ldr	r3, [pc, #12]	; (89644 <system_convert_axis_steps_to_mpos+0x20>)
   89638:	4798      	blx	r3
  #endif
  return(pos);
}
   8963a:	bd10      	pop	{r4, pc}
   8963c:	0008c68d 	.word	0x0008c68d
   89640:	20001510 	.word	0x20001510
   89644:	0008c89d 	.word	0x0008c89d

00089648 <system_convert_array_steps_to_mpos>:
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
   89648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8964a:	460f      	mov	r7, r1
   8964c:	1f05      	subs	r5, r0, #4
   8964e:	2400      	movs	r4, #0
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
   89650:	4e04      	ldr	r6, [pc, #16]	; (89664 <system_convert_array_steps_to_mpos+0x1c>)
   89652:	4638      	mov	r0, r7
   89654:	b2e1      	uxtb	r1, r4
   89656:	47b0      	blx	r6
   89658:	f845 0f04 	str.w	r0, [r5, #4]!
   8965c:	3401      	adds	r4, #1
  

void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
   8965e:	2c03      	cmp	r4, #3
   89660:	d1f7      	bne.n	89652 <system_convert_array_steps_to_mpos+0xa>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
   89662:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   89664:	00089625 	.word	0x00089625

00089668 <_delay_us>:
	{
		_delay_us(1000);
	}
}
void _delay_us(int us)
{
   89668:	b082      	sub	sp, #8
	volatile int x;
	while(us--)
	{
		x = 8;
   8966a:	2108      	movs	r1, #8
	}
}
void _delay_us(int us)
{
	volatile int x;
	while(us--)
   8966c:	e005      	b.n	8967a <_delay_us+0x12>
	{
		x = 8;
   8966e:	9101      	str	r1, [sp, #4]
		while(x--);
   89670:	9b01      	ldr	r3, [sp, #4]
   89672:	1e5a      	subs	r2, r3, #1
   89674:	9201      	str	r2, [sp, #4]
   89676:	2b00      	cmp	r3, #0
   89678:	d1fa      	bne.n	89670 <_delay_us+0x8>
	}
}
void _delay_us(int us)
{
	volatile int x;
	while(us--)
   8967a:	3801      	subs	r0, #1
   8967c:	f1b0 3fff 	cmp.w	r0, #4294967295
   89680:	d1f5      	bne.n	8966e <_delay_us+0x6>
	{
		x = 8;
		while(x--);
	}
}
   89682:	b002      	add	sp, #8
   89684:	4770      	bx	lr
   89686:	bf00      	nop

00089688 <delay_ms>:



void delay_ms(int ms)
{
	while(ms--)
   89688:	b148      	cbz	r0, 8969e <delay_ms+0x16>
}



void delay_ms(int ms)
{
   8968a:	b570      	push	{r4, r5, r6, lr}
   8968c:	4604      	mov	r4, r0
	while(ms--)
	{
		_delay_us(1000);
   8968e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
   89692:	4d03      	ldr	r5, [pc, #12]	; (896a0 <delay_ms+0x18>)
   89694:	4630      	mov	r0, r6
   89696:	47a8      	blx	r5



void delay_ms(int ms)
{
	while(ms--)
   89698:	3c01      	subs	r4, #1
   8969a:	d1fb      	bne.n	89694 <delay_ms+0xc>
   8969c:	bd70      	pop	{r4, r5, r6, pc}
   8969e:	4770      	bx	lr
   896a0:	00089669 	.word	0x00089669

000896a4 <_delay_ms>:
		x = 8;
		while(x--);
	}
}
void _delay_ms(int ms)
{
   896a4:	b508      	push	{r3, lr}
	delay_ms(ms);
   896a6:	4b01      	ldr	r3, [pc, #4]	; (896ac <_delay_ms+0x8>)
   896a8:	4798      	blx	r3
   896aa:	bd08      	pop	{r3, pc}
   896ac:	00089689 	.word	0x00089689

000896b0 <get_heap_free_size1>:
}
uint32_t get_heap_free_size1( void )
{
   896b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t high_mark= 600000;
	uint32_t low_mark = 0;
	uint32_t size ;
	void* p_mem;

	size = (high_mark + low_mark)/2;
   896b4:	4c0a      	ldr	r4, [pc, #40]	; (896e0 <get_heap_free_size1+0x30>)
	delay_ms(ms);
}
uint32_t get_heap_free_size1( void )
{
	uint32_t high_mark= 600000;
	uint32_t low_mark = 0;
   896b6:	2500      	movs	r5, #0
{
	delay_ms(ms);
}
uint32_t get_heap_free_size1( void )
{
	uint32_t high_mark= 600000;
   896b8:	4e0a      	ldr	r6, [pc, #40]	; (896e4 <get_heap_free_size1+0x34>)

	size = (high_mark + low_mark)/2;

	do
	{
		p_mem = malloc(size);
   896ba:	4f0b      	ldr	r7, [pc, #44]	; (896e8 <get_heap_free_size1+0x38>)
		if( p_mem != NULL)
		{ // Can allocate memory
			free(p_mem);
   896bc:	f8df 802c 	ldr.w	r8, [pc, #44]	; 896ec <get_heap_free_size1+0x3c>

	size = (high_mark + low_mark)/2;

	do
	{
		p_mem = malloc(size);
   896c0:	4620      	mov	r0, r4
   896c2:	47b8      	blx	r7
		if( p_mem != NULL)
   896c4:	b110      	cbz	r0, 896cc <get_heap_free_size1+0x1c>
		{ // Can allocate memory
			free(p_mem);
   896c6:	47c0      	blx	r8
			low_mark = size;
   896c8:	4625      	mov	r5, r4
   896ca:	e000      	b.n	896ce <get_heap_free_size1+0x1e>
		}
		else
		{ // Can not allocate memory
			high_mark = size;
   896cc:	4626      	mov	r6, r4
		}

		size = (high_mark + low_mark)/2;
   896ce:	19ac      	adds	r4, r5, r6
   896d0:	0864      	lsrs	r4, r4, #1
	}
	while( (high_mark-low_mark) >1 );
   896d2:	1b73      	subs	r3, r6, r5
   896d4:	2b01      	cmp	r3, #1
   896d6:	d8f3      	bhi.n	896c0 <get_heap_free_size1+0x10>

	return size;
}
   896d8:	4620      	mov	r0, r4
   896da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   896de:	bf00      	nop
   896e0:	000493e0 	.word	0x000493e0
   896e4:	000927c0 	.word	0x000927c0
   896e8:	0008cbb1 	.word	0x0008cbb1
   896ec:	0008cbc1 	.word	0x0008cbc1

000896f0 <init_grbl>:
void init_grbl(void)
{
   896f0:	b508      	push	{r3, lr}
    serial_reset_read_buffer(); // Clear serial read buffer
   896f2:	4b0e      	ldr	r3, [pc, #56]	; (8972c <init_grbl+0x3c>)
   896f4:	4798      	blx	r3
    gc_init(); // Set g-code parser to default state
   896f6:	4b0e      	ldr	r3, [pc, #56]	; (89730 <init_grbl+0x40>)
   896f8:	4798      	blx	r3
    spindle_init();
   896fa:	4b0e      	ldr	r3, [pc, #56]	; (89734 <init_grbl+0x44>)
   896fc:	4798      	blx	r3
    coolant_init();
   896fe:	4b0e      	ldr	r3, [pc, #56]	; (89738 <init_grbl+0x48>)
   89700:	4798      	blx	r3
    limits_init();
   89702:	4b0e      	ldr	r3, [pc, #56]	; (8973c <init_grbl+0x4c>)
   89704:	4798      	blx	r3
    probe_init();
   89706:	4b0e      	ldr	r3, [pc, #56]	; (89740 <init_grbl+0x50>)
   89708:	4798      	blx	r3
    plan_reset(); // Clear block buffer and planner variables
   8970a:	4b0e      	ldr	r3, [pc, #56]	; (89744 <init_grbl+0x54>)
   8970c:	4798      	blx	r3
    st_reset(); // Clear stepper subsystem variables.
   8970e:	4b0e      	ldr	r3, [pc, #56]	; (89748 <init_grbl+0x58>)
   89710:	4798      	blx	r3

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
   89712:	4b0e      	ldr	r3, [pc, #56]	; (8974c <init_grbl+0x5c>)
   89714:	4798      	blx	r3
    gc_sync_position();
   89716:	4b0e      	ldr	r3, [pc, #56]	; (89750 <init_grbl+0x60>)
   89718:	4798      	blx	r3

    // Reset system variables.
    sys.abort = false;
   8971a:	4a0e      	ldr	r2, [pc, #56]	; (89754 <init_grbl+0x64>)
   8971c:	2300      	movs	r3, #0
   8971e:	7013      	strb	r3, [r2, #0]
    sys_rt_exec_state = 0;
   89720:	490d      	ldr	r1, [pc, #52]	; (89758 <init_grbl+0x68>)
   89722:	700b      	strb	r3, [r1, #0]
    sys_rt_exec_alarm = 0;
   89724:	490d      	ldr	r1, [pc, #52]	; (8975c <init_grbl+0x6c>)
   89726:	700b      	strb	r3, [r1, #0]
    sys.suspend = false;
   89728:	7093      	strb	r3, [r2, #2]
   8972a:	bd08      	pop	{r3, pc}
   8972c:	00087e45 	.word	0x00087e45
   89730:	000824e1 	.word	0x000824e1
   89734:	0008837d 	.word	0x0008837d
   89738:	00080161 	.word	0x00080161
   8973c:	00083749 	.word	0x00083749
   89740:	00084f6d 	.word	0x00084f6d
   89744:	00084821 	.word	0x00084821
   89748:	00088879 	.word	0x00088879
   8974c:	00084cbd 	.word	0x00084cbd
   89750:	00082515 	.word	0x00082515
   89754:	20001484 	.word	0x20001484
   89758:	200011b4 	.word	0x200011b4
   8975c:	200011b6 	.word	0x200011b6

00089760 <draw_pos>:
    // Start Grbl main loop. Processes program inputs and executes them.
}

void draw_pos()
{
   89760:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
   89764:	b087      	sub	sp, #28
	float x = sys.position[0] / DEFAULT_X_STEPS_PER_MM;
	float y = sys.position[1] / DEFAULT_Y_STEPS_PER_MM;
	float z = sys.position[2] / DEFAULT_Z_STEPS_PER_MM;
	sprintf(buffer," X=%10.3f Y=%10.3f Z=%10.3f",x,y,z);
   89766:	4e1f      	ldr	r6, [pc, #124]	; (897e4 <draw_pos+0x84>)
    // Start Grbl main loop. Processes program inputs and executes them.
}

void draw_pos()
{
	float x = sys.position[0] / DEFAULT_X_STEPS_PER_MM;
   89768:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 89810 <draw_pos+0xb0>
   8976c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 89814 <draw_pos+0xb4>
   89770:	f8da 0004 	ldr.w	r0, [sl, #4]
   89774:	47c8      	blx	r9
   89776:	4f1c      	ldr	r7, [pc, #112]	; (897e8 <draw_pos+0x88>)
   89778:	2200      	movs	r2, #0
   8977a:	4b1c      	ldr	r3, [pc, #112]	; (897ec <draw_pos+0x8c>)
   8977c:	47b8      	blx	r7
   8977e:	4d1c      	ldr	r5, [pc, #112]	; (897f0 <draw_pos+0x90>)
   89780:	47a8      	blx	r5
	float y = sys.position[1] / DEFAULT_Y_STEPS_PER_MM;
	float z = sys.position[2] / DEFAULT_Z_STEPS_PER_MM;
	sprintf(buffer," X=%10.3f Y=%10.3f Z=%10.3f",x,y,z);
   89782:	4c1c      	ldr	r4, [pc, #112]	; (897f4 <draw_pos+0x94>)
   89784:	47a0      	blx	r4
   89786:	e9cd 0104 	strd	r0, r1, [sp, #16]
}

void draw_pos()
{
	float x = sys.position[0] / DEFAULT_X_STEPS_PER_MM;
	float y = sys.position[1] / DEFAULT_Y_STEPS_PER_MM;
   8978a:	f8da 0008 	ldr.w	r0, [sl, #8]
   8978e:	47c8      	blx	r9
   89790:	2200      	movs	r2, #0
   89792:	4b16      	ldr	r3, [pc, #88]	; (897ec <draw_pos+0x8c>)
   89794:	47b8      	blx	r7
   89796:	47a8      	blx	r5
	float z = sys.position[2] / DEFAULT_Z_STEPS_PER_MM;
	sprintf(buffer," X=%10.3f Y=%10.3f Z=%10.3f",x,y,z);
   89798:	47a0      	blx	r4
   8979a:	e9cd 0100 	strd	r0, r1, [sp]

void draw_pos()
{
	float x = sys.position[0] / DEFAULT_X_STEPS_PER_MM;
	float y = sys.position[1] / DEFAULT_Y_STEPS_PER_MM;
	float z = sys.position[2] / DEFAULT_Z_STEPS_PER_MM;
   8979e:	f8da 000c 	ldr.w	r0, [sl, #12]
   897a2:	47c8      	blx	r9
   897a4:	2200      	movs	r2, #0
   897a6:	4b14      	ldr	r3, [pc, #80]	; (897f8 <draw_pos+0x98>)
   897a8:	47b8      	blx	r7
   897aa:	47a8      	blx	r5
	sprintf(buffer," X=%10.3f Y=%10.3f Z=%10.3f",x,y,z);
   897ac:	47a0      	blx	r4
   897ae:	e9cd 0102 	strd	r0, r1, [sp, #8]
   897b2:	4630      	mov	r0, r6
   897b4:	4911      	ldr	r1, [pc, #68]	; (897fc <draw_pos+0x9c>)
   897b6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   897ba:	4c11      	ldr	r4, [pc, #68]	; (89800 <draw_pos+0xa0>)
   897bc:	47a0      	blx	r4
	tft_textColor(RA8875_BLACK ,RA8875_LIME);
   897be:	2000      	movs	r0, #0
   897c0:	f64c 71e0 	movw	r1, #53216	; 0xcfe0
   897c4:	4b0f      	ldr	r3, [pc, #60]	; (89804 <draw_pos+0xa4>)
   897c6:	4798      	blx	r3
	tft_textWrite(1,1,0,0,buffer,ALINE_LEFT);
   897c8:	9600      	str	r6, [sp, #0]
   897ca:	2300      	movs	r3, #0
   897cc:	9301      	str	r3, [sp, #4]
   897ce:	2001      	movs	r0, #1
   897d0:	4601      	mov	r1, r0
   897d2:	461a      	mov	r2, r3
   897d4:	4c0c      	ldr	r4, [pc, #48]	; (89808 <draw_pos+0xa8>)
   897d6:	47a0      	blx	r4
	tft_draw_press_unpress();
   897d8:	4b0c      	ldr	r3, [pc, #48]	; (8980c <draw_pos+0xac>)
   897da:	4798      	blx	r3
}
   897dc:	b007      	add	sp, #28
   897de:	e8bd 86f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, pc}
   897e2:	bf00      	nop
   897e4:	20001664 	.word	0x20001664
   897e8:	0008c109 	.word	0x0008c109
   897ec:	40740000 	.word	0x40740000
   897f0:	0008c479 	.word	0x0008c479
   897f4:	0008be0d 	.word	0x0008be0d
   897f8:	407e0000 	.word	0x407e0000
   897fc:	00091ef0 	.word	0x00091ef0
   89800:	0008d291 	.word	0x0008d291
   89804:	00085551 	.word	0x00085551
   89808:	00085679 	.word	0x00085679
   8980c:	00086eb5 	.word	0x00086eb5
   89810:	20001484 	.word	0x20001484
   89814:	0008bde9 	.word	0x0008bde9

00089818 <scan_files>:


#define FILES_ON_SCREEN 10
FRESULT scan_files (char* path)
{
   89818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8981c:	b094      	sub	sp, #80	; 0x50
   8981e:	4680      	mov	r8, r0
	FILINFO fno;
	DIR dir;
	char *fn;   /* This function is assuming non-Unicode cfg. */
	#if _USE_LFN
	static char lfn[_MAX_LFN + 1];   /* Buffer to store the LFN */
	fno.lfname = lfn;
   89820:	4b2e      	ldr	r3, [pc, #184]	; (898dc <scan_files+0xc4>)
   89822:	9312      	str	r3, [sp, #72]	; 0x48
	fno.lfsize = sizeof lfn;
   89824:	f44f 7380 	mov.w	r3, #256	; 0x100
   89828:	9313      	str	r3, [sp, #76]	; 0x4c
	#endif
	res = f_opendir(&dir, path);                       /* Open the directory */
   8982a:	a803      	add	r0, sp, #12
   8982c:	4641      	mov	r1, r8
   8982e:	4b2c      	ldr	r3, [pc, #176]	; (898e0 <scan_files+0xc8>)
   89830:	4798      	blx	r3
	if (res == FR_OK) {
   89832:	2800      	cmp	r0, #0
   89834:	d140      	bne.n	898b8 <scan_files+0xa0>
		for (;;) {
			res = f_readdir(&dir, &fno);                   /* Read a directory item */
   89836:	4f2b      	ldr	r7, [pc, #172]	; (898e4 <scan_files+0xcc>)
				ll_add_ABC(temp);
				free(temp);
			} else
			{                                       /* It is a file. */
				char *temp;
				temp = (char*)malloc(strlen(path) + strlen(fn) + 3);
   89838:	4d2b      	ldr	r5, [pc, #172]	; (898e8 <scan_files+0xd0>)
	fno.lfsize = sizeof lfn;
	#endif
	res = f_opendir(&dir, path);                       /* Open the directory */
	if (res == FR_OK) {
		for (;;) {
			res = f_readdir(&dir, &fno);                   /* Read a directory item */
   8983a:	a803      	add	r0, sp, #12
   8983c:	a90c      	add	r1, sp, #48	; 0x30
   8983e:	47b8      	blx	r7
			if (res != FR_OK || fno.fname[0] == 0) break;  /* Break on error or end of dir */
   89840:	4604      	mov	r4, r0
   89842:	2800      	cmp	r0, #0
   89844:	d146      	bne.n	898d4 <scan_files+0xbc>
   89846:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
   8984a:	2b00      	cmp	r3, #0
   8984c:	d042      	beq.n	898d4 <scan_files+0xbc>
			if (fno.fname[0] == '.') continue;             /* Ignore dot entry */
   8984e:	2b2e      	cmp	r3, #46	; 0x2e
   89850:	d0f3      	beq.n	8983a <scan_files+0x22>
			#if _USE_LFN
			fn = *fno.lfname ? fno.lfname : fno.fname;
   89852:	9c12      	ldr	r4, [sp, #72]	; 0x48
   89854:	7823      	ldrb	r3, [r4, #0]
   89856:	b90b      	cbnz	r3, 8985c <scan_files+0x44>
   89858:	f10d 0439 	add.w	r4, sp, #57	; 0x39
			#else
			fn = fno.fname;
			#endif
			if (fno.fattrib & AM_DIR)
   8985c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   89860:	f013 0f10 	tst.w	r3, #16
   89864:	d014      	beq.n	89890 <scan_files+0x78>
			{                    /* It is a directory */
				char *temp;
				temp = (char*)malloc(strlen(path) + strlen(fn) + 3);
   89866:	4640      	mov	r0, r8
   89868:	47a8      	blx	r5
   8986a:	4606      	mov	r6, r0
   8986c:	4620      	mov	r0, r4
   8986e:	47a8      	blx	r5
   89870:	4430      	add	r0, r6
   89872:	3003      	adds	r0, #3
   89874:	4b1d      	ldr	r3, [pc, #116]	; (898ec <scan_files+0xd4>)
   89876:	4798      	blx	r3
   89878:	4606      	mov	r6, r0
				sprintf(temp," %s",fn);
   8987a:	491d      	ldr	r1, [pc, #116]	; (898f0 <scan_files+0xd8>)
   8987c:	4622      	mov	r2, r4
   8987e:	4b1d      	ldr	r3, [pc, #116]	; (898f4 <scan_files+0xdc>)
   89880:	4798      	blx	r3
				ll_add_ABC(temp);
   89882:	4630      	mov	r0, r6
   89884:	4b1c      	ldr	r3, [pc, #112]	; (898f8 <scan_files+0xe0>)
   89886:	4798      	blx	r3
				free(temp);
   89888:	4630      	mov	r0, r6
   8988a:	4b1c      	ldr	r3, [pc, #112]	; (898fc <scan_files+0xe4>)
   8988c:	4798      	blx	r3
   8988e:	e7d4      	b.n	8983a <scan_files+0x22>
			} else
			{                                       /* It is a file. */
				char *temp;
				temp = (char*)malloc(strlen(path) + strlen(fn) + 3);
   89890:	4640      	mov	r0, r8
   89892:	47a8      	blx	r5
   89894:	4606      	mov	r6, r0
   89896:	4620      	mov	r0, r4
   89898:	47a8      	blx	r5
   8989a:	4430      	add	r0, r6
   8989c:	3003      	adds	r0, #3
   8989e:	4b13      	ldr	r3, [pc, #76]	; (898ec <scan_files+0xd4>)
   898a0:	4798      	blx	r3
   898a2:	4606      	mov	r6, r0
				sprintf(temp,"%s",fn);
   898a4:	4621      	mov	r1, r4
   898a6:	4b16      	ldr	r3, [pc, #88]	; (89900 <scan_files+0xe8>)
   898a8:	4798      	blx	r3
				ll_add_ABC(temp);
   898aa:	4630      	mov	r0, r6
   898ac:	4b12      	ldr	r3, [pc, #72]	; (898f8 <scan_files+0xe0>)
   898ae:	4798      	blx	r3
				free(temp);
   898b0:	4630      	mov	r0, r6
   898b2:	4b12      	ldr	r3, [pc, #72]	; (898fc <scan_files+0xe4>)
   898b4:	4798      	blx	r3
   898b6:	e7c0      	b.n	8983a <scan_files+0x22>
   898b8:	4604      	mov	r4, r0
			}
		}
	} else
	if(res == 13)
   898ba:	280d      	cmp	r0, #13
   898bc:	d10a      	bne.n	898d4 <scan_files+0xbc>
		tft_textWrite(10,100,780,0,(char*)"NO FILESYSTEM",ALINE_CENTER);
   898be:	4b11      	ldr	r3, [pc, #68]	; (89904 <scan_files+0xec>)
   898c0:	9300      	str	r3, [sp, #0]
   898c2:	2301      	movs	r3, #1
   898c4:	9301      	str	r3, [sp, #4]
   898c6:	200a      	movs	r0, #10
   898c8:	2164      	movs	r1, #100	; 0x64
   898ca:	f44f 7243 	mov.w	r2, #780	; 0x30c
   898ce:	2300      	movs	r3, #0
   898d0:	4d0d      	ldr	r5, [pc, #52]	; (89908 <scan_files+0xf0>)
   898d2:	47a8      	blx	r5
	return res;
}
   898d4:	4620      	mov	r0, r4
   898d6:	b014      	add	sp, #80	; 0x50
   898d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   898dc:	2000107c 	.word	0x2000107c
   898e0:	00081fd9 	.word	0x00081fd9
   898e4:	0008205d 	.word	0x0008205d
   898e8:	0008d399 	.word	0x0008d399
   898ec:	0008cbb1 	.word	0x0008cbb1
   898f0:	00091f0c 	.word	0x00091f0c
   898f4:	0008d291 	.word	0x0008d291
   898f8:	000820d9 	.word	0x000820d9
   898fc:	0008cbc1 	.word	0x0008cbc1
   89900:	0008d2dd 	.word	0x0008d2dd
   89904:	00091f10 	.word	0x00091f10
   89908:	00085679 	.word	0x00085679

0008990c <select_file>:

FRESULT select_file( char*  path)
{
   8990c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   89910:	b0c7      	sub	sp, #284	; 0x11c
   89912:	9004      	str	r0, [sp, #16]
	FRESULT res;
	int a,FileOffset;
	f_mount(0,NULL);
   89914:	2000      	movs	r0, #0
   89916:	4601      	mov	r1, r0
   89918:	4caa      	ldr	r4, [pc, #680]	; (89bc4 <select_file+0x2b8>)
   8991a:	47a0      	blx	r4
	res = f_mount(0,&fs);
   8991c:	2000      	movs	r0, #0
   8991e:	49aa      	ldr	r1, [pc, #680]	; (89bc8 <select_file+0x2bc>)
   89920:	47a0      	blx	r4
	if(res != FR_OK)
   89922:	2800      	cmp	r0, #0
   89924:	f040 8229 	bne.w	89d7a <select_file+0x46e>
	return res;
	Action1 = 0;
   89928:	4ba8      	ldr	r3, [pc, #672]	; (89bcc <select_file+0x2c0>)
   8992a:	6018      	str	r0, [r3, #0]
	FileOffset = 0;
	tft_fillScreen(RA8875_BLACK);
   8992c:	4ba8      	ldr	r3, [pc, #672]	; (89bd0 <select_file+0x2c4>)
   8992e:	4798      	blx	r3
	tft_delete_all_objects();
   89930:	4ba8      	ldr	r3, [pc, #672]	; (89bd4 <select_file+0x2c8>)
   89932:	4798      	blx	r3
	tft_button(10,10,150,100,"Zrui",1,RA8875_LIME,10);
   89934:	4ba8      	ldr	r3, [pc, #672]	; (89bd8 <select_file+0x2cc>)
   89936:	9300      	str	r3, [sp, #0]
   89938:	2301      	movs	r3, #1
   8993a:	9301      	str	r3, [sp, #4]
   8993c:	f64c 73e0 	movw	r3, #53216	; 0xcfe0
   89940:	9302      	str	r3, [sp, #8]
   89942:	210a      	movs	r1, #10
   89944:	9103      	str	r1, [sp, #12]
   89946:	4608      	mov	r0, r1
   89948:	2296      	movs	r2, #150	; 0x96
   8994a:	2364      	movs	r3, #100	; 0x64
   8994c:	4ca3      	ldr	r4, [pc, #652]	; (89bdc <select_file+0x2d0>)
   8994e:	47a0      	blx	r4
	ll_clear();
   89950:	4ba3      	ldr	r3, [pc, #652]	; (89be0 <select_file+0x2d4>)
   89952:	4798      	blx	r3
//	debugclear();
	if(strlen(path))
   89954:	9b04      	ldr	r3, [sp, #16]
   89956:	781b      	ldrb	r3, [r3, #0]
   89958:	b113      	cbz	r3, 89960 <select_file+0x54>
	ll_add_ABC((char*)" ..");
   8995a:	48a2      	ldr	r0, [pc, #648]	; (89be4 <select_file+0x2d8>)
   8995c:	4ba2      	ldr	r3, [pc, #648]	; (89be8 <select_file+0x2dc>)
   8995e:	4798      	blx	r3
	scan_files(path);
   89960:	9804      	ldr	r0, [sp, #16]
   89962:	4ba2      	ldr	r3, [pc, #648]	; (89bec <select_file+0x2e0>)
   89964:	4798      	blx	r3
	if(ll_count() > FILES_ON_SCREEN )
   89966:	4ba2      	ldr	r3, [pc, #648]	; (89bf0 <select_file+0x2e4>)
   89968:	4798      	blx	r3
   8996a:	280a      	cmp	r0, #10
   8996c:	f240 8206 	bls.w	89d7c <select_file+0x470>
	tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,10);
   89970:	4ba0      	ldr	r3, [pc, #640]	; (89bf4 <select_file+0x2e8>)
   89972:	9300      	str	r3, [sp, #0]
   89974:	2302      	movs	r3, #2
   89976:	9301      	str	r3, [sp, #4]
   89978:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   8997c:	9302      	str	r3, [sp, #8]
   8997e:	200a      	movs	r0, #10
   89980:	9003      	str	r0, [sp, #12]
   89982:	f44f 71b9 	mov.w	r1, #370	; 0x172
   89986:	2296      	movs	r2, #150	; 0x96
   89988:	2364      	movs	r3, #100	; 0x64
   8998a:	4c94      	ldr	r4, [pc, #592]	; (89bdc <select_file+0x2d0>)
   8998c:	47a0      	blx	r4
   8998e:	e1f5      	b.n	89d7c <select_file+0x470>
	for(a = 0; a < FileOffset + FILES_ON_SCREEN; a++)
	{
		if(a >= ll_count()) break;
   89990:	47c0      	blx	r8
   89992:	42a0      	cmp	r0, r4
   89994:	dd2a      	ble.n	899ec <select_file+0xe0>
		if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
   89996:	fa1f fa84 	uxth.w	sl, r4
   8999a:	4650      	mov	r0, sl
   8999c:	47b8      	blx	r7
   8999e:	7803      	ldrb	r3, [r0, #0]
   899a0:	2b20      	cmp	r3, #32
   899a2:	d10e      	bne.n	899c2 <select_file+0xb6>
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
   899a4:	4650      	mov	r0, sl
   899a6:	47b8      	blx	r7
   899a8:	9000      	str	r0, [sp, #0]
   899aa:	9501      	str	r5, [sp, #4]
   899ac:	231f      	movs	r3, #31
   899ae:	9302      	str	r3, [sp, #8]
   899b0:	230a      	movs	r3, #10
   899b2:	9303      	str	r3, [sp, #12]
   899b4:	20c8      	movs	r0, #200	; 0xc8
   899b6:	4631      	mov	r1, r6
   899b8:	f240 224e 	movw	r2, #590	; 0x24e
   899bc:	2324      	movs	r3, #36	; 0x24
   899be:	47c8      	blx	r9
   899c0:	e00e      	b.n	899e0 <select_file+0xd4>
		else
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
   899c2:	4650      	mov	r0, sl
   899c4:	47b8      	blx	r7
   899c6:	9000      	str	r0, [sp, #0]
   899c8:	9501      	str	r5, [sp, #4]
   899ca:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   899ce:	9302      	str	r3, [sp, #8]
   899d0:	230a      	movs	r3, #10
   899d2:	9303      	str	r3, [sp, #12]
   899d4:	20c8      	movs	r0, #200	; 0xc8
   899d6:	4631      	mov	r1, r6
   899d8:	f240 224e 	movw	r2, #590	; 0x24e
   899dc:	2324      	movs	r3, #36	; 0x24
   899de:	47c8      	blx	r9
	if(strlen(path))
	ll_add_ABC((char*)" ..");
	scan_files(path);
	if(ll_count() > FILES_ON_SCREEN )
	tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,10);
	for(a = 0; a < FileOffset + FILES_ON_SCREEN; a++)
   899e0:	3401      	adds	r4, #1
   899e2:	3630      	adds	r6, #48	; 0x30
   899e4:	3501      	adds	r5, #1
   899e6:	b2ed      	uxtb	r5, r5
   899e8:	2c0a      	cmp	r4, #10
   899ea:	d1d1      	bne.n	89990 <select_file+0x84>
		tft_textWrite(10,100,780,0,(char*)"NO FILESYSTEM",ALINE_CENTER);
	return res;
}

FRESULT select_file( char*  path)
{
   899ec:	f04f 0800 	mov.w	r8, #0
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
	}
	while(1)
	{
		tft_draw_press_unpress();
		if(Action1 == 1)	//	CANCEL
   899f0:	4c76      	ldr	r4, [pc, #472]	; (89bcc <select_file+0x2c0>)
			Action1 = 0;
			break;
		}
		if(Action1 == 2)	//	NEXT
		{
			if(ll_count() > (FileOffset + FILES_ON_SCREEN))
   899f2:	f8df b1fc 	ldr.w	fp, [pc, #508]	; 89bf0 <select_file+0x2e4>
				tft_delete_all_objects();
				tft_fillScreen(RA8875_BLACK);
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
				{
					if(a == ll_count() - 1) break;
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
   899f6:	4e80      	ldr	r6, [pc, #512]	; (89bf8 <select_file+0x2ec>)
		else
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
	}
	while(1)
	{
		tft_draw_press_unpress();
   899f8:	4b80      	ldr	r3, [pc, #512]	; (89bfc <select_file+0x2f0>)
   899fa:	4798      	blx	r3
		if(Action1 == 1)	//	CANCEL
   899fc:	6823      	ldr	r3, [r4, #0]
   899fe:	2b01      	cmp	r3, #1
   89a00:	d104      	bne.n	89a0c <select_file+0x100>
		{
			Action1 = 0;
   89a02:	2200      	movs	r2, #0
   89a04:	4b71      	ldr	r3, [pc, #452]	; (89bcc <select_file+0x2c0>)
   89a06:	601a      	str	r2, [r3, #0]
			}while(p);
			Action1 = 0;
			return FR_OK;
		}
	}
	return FR_NO_FILE;
   89a08:	2004      	movs	r0, #4
   89a0a:	e1c0      	b.n	89d8e <select_file+0x482>
		if(Action1 == 1)	//	CANCEL
		{
			Action1 = 0;
			break;
		}
		if(Action1 == 2)	//	NEXT
   89a0c:	6823      	ldr	r3, [r4, #0]
   89a0e:	2b02      	cmp	r3, #2
   89a10:	f040 8096 	bne.w	89b40 <select_file+0x234>
		{
			if(ll_count() > (FileOffset + FILES_ON_SCREEN))
   89a14:	47d8      	blx	fp
   89a16:	f108 0a0a 	add.w	sl, r8, #10
   89a1a:	4550      	cmp	r0, sl
   89a1c:	f340 808a 	ble.w	89b34 <select_file+0x228>
			{
				FileOffset += FILES_ON_SCREEN;
				tft_delete_all_objects();
   89a20:	4b6c      	ldr	r3, [pc, #432]	; (89bd4 <select_file+0x2c8>)
   89a22:	4798      	blx	r3
				tft_fillScreen(RA8875_BLACK);
   89a24:	2000      	movs	r0, #0
   89a26:	4b6a      	ldr	r3, [pc, #424]	; (89bd0 <select_file+0x2c4>)
   89a28:	4798      	blx	r3
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
   89a2a:	f108 0314 	add.w	r3, r8, #20
   89a2e:	9305      	str	r3, [sp, #20]
   89a30:	459a      	cmp	sl, r3
   89a32:	da4f      	bge.n	89ad4 <select_file+0x1c8>
   89a34:	eb0a 054a 	add.w	r5, sl, sl, lsl #1
   89a38:	012d      	lsls	r5, r5, #4
   89a3a:	4698      	mov	r8, r3
   89a3c:	4657      	mov	r7, sl
				{
					if(a == ll_count() - 1) break;
   89a3e:	47d8      	blx	fp
   89a40:	3801      	subs	r0, #1
   89a42:	42b8      	cmp	r0, r7
   89a44:	d046      	beq.n	89ad4 <select_file+0x1c8>
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
   89a46:	fa1f f987 	uxth.w	r9, r7
   89a4a:	4648      	mov	r0, r9
   89a4c:	47b0      	blx	r6
   89a4e:	7803      	ldrb	r3, [r0, #0]
   89a50:	2b20      	cmp	r3, #32
   89a52:	d11d      	bne.n	89a90 <select_file+0x184>
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
   89a54:	4648      	mov	r0, r9
   89a56:	47b0      	blx	r6
   89a58:	4b69      	ldr	r3, [pc, #420]	; (89c00 <select_file+0x2f4>)
   89a5a:	fb85 2303 	smull	r2, r3, r5, r3
   89a5e:	18e9      	adds	r1, r5, r3
   89a60:	17eb      	asrs	r3, r5, #31
   89a62:	ebc3 2121 	rsb	r1, r3, r1, asr #8
   89a66:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   89a6a:	9000      	str	r0, [sp, #0]
   89a6c:	f107 030a 	add.w	r3, r7, #10
   89a70:	b2db      	uxtb	r3, r3
   89a72:	9301      	str	r3, [sp, #4]
   89a74:	231f      	movs	r3, #31
   89a76:	9302      	str	r3, [sp, #8]
   89a78:	230a      	movs	r3, #10
   89a7a:	9303      	str	r3, [sp, #12]
   89a7c:	20c8      	movs	r0, #200	; 0xc8
   89a7e:	eba5 1141 	sub.w	r1, r5, r1, lsl #5
   89a82:	f240 224e 	movw	r2, #590	; 0x24e
   89a86:	2324      	movs	r3, #36	; 0x24
   89a88:	f8df c150 	ldr.w	ip, [pc, #336]	; 89bdc <select_file+0x2d0>
   89a8c:	47e0      	blx	ip
   89a8e:	e01d      	b.n	89acc <select_file+0x1c0>
					else
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
   89a90:	4648      	mov	r0, r9
   89a92:	47b0      	blx	r6
   89a94:	4b5a      	ldr	r3, [pc, #360]	; (89c00 <select_file+0x2f4>)
   89a96:	fb85 2303 	smull	r2, r3, r5, r3
   89a9a:	18e9      	adds	r1, r5, r3
   89a9c:	17eb      	asrs	r3, r5, #31
   89a9e:	ebc3 2121 	rsb	r1, r3, r1, asr #8
   89aa2:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   89aa6:	9000      	str	r0, [sp, #0]
   89aa8:	f107 030a 	add.w	r3, r7, #10
   89aac:	b2db      	uxtb	r3, r3
   89aae:	9301      	str	r3, [sp, #4]
   89ab0:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   89ab4:	9302      	str	r3, [sp, #8]
   89ab6:	230a      	movs	r3, #10
   89ab8:	9303      	str	r3, [sp, #12]
   89aba:	20c8      	movs	r0, #200	; 0xc8
   89abc:	eba5 1141 	sub.w	r1, r5, r1, lsl #5
   89ac0:	f240 224e 	movw	r2, #590	; 0x24e
   89ac4:	2324      	movs	r3, #36	; 0x24
   89ac6:	f8df c114 	ldr.w	ip, [pc, #276]	; 89bdc <select_file+0x2d0>
   89aca:	47e0      	blx	ip
			if(ll_count() > (FileOffset + FILES_ON_SCREEN))
			{
				FileOffset += FILES_ON_SCREEN;
				tft_delete_all_objects();
				tft_fillScreen(RA8875_BLACK);
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
   89acc:	3701      	adds	r7, #1
   89ace:	3530      	adds	r5, #48	; 0x30
   89ad0:	4547      	cmp	r7, r8
   89ad2:	d1b4      	bne.n	89a3e <select_file+0x132>
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
					else
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
				}
				tft_button(10,10,150,100,"CANCEL",1,RA8875_LIME,BUTTONS_RADIUS);
   89ad4:	4b4b      	ldr	r3, [pc, #300]	; (89c04 <select_file+0x2f8>)
   89ad6:	9300      	str	r3, [sp, #0]
   89ad8:	2301      	movs	r3, #1
   89ada:	9301      	str	r3, [sp, #4]
   89adc:	f64c 73e0 	movw	r3, #53216	; 0xcfe0
   89ae0:	9302      	str	r3, [sp, #8]
   89ae2:	210a      	movs	r1, #10
   89ae4:	9103      	str	r1, [sp, #12]
   89ae6:	4608      	mov	r0, r1
   89ae8:	2296      	movs	r2, #150	; 0x96
   89aea:	2364      	movs	r3, #100	; 0x64
   89aec:	4d3b      	ldr	r5, [pc, #236]	; (89bdc <select_file+0x2d0>)
   89aee:	47a8      	blx	r5
				if(ll_count() > (FileOffset +FILES_ON_SCREEN))
   89af0:	47d8      	blx	fp
   89af2:	9b05      	ldr	r3, [sp, #20]
   89af4:	4298      	cmp	r0, r3
   89af6:	dd0d      	ble.n	89b14 <select_file+0x208>
				tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,BUTTONS_RADIUS);
   89af8:	4b3e      	ldr	r3, [pc, #248]	; (89bf4 <select_file+0x2e8>)
   89afa:	9300      	str	r3, [sp, #0]
   89afc:	2302      	movs	r3, #2
   89afe:	9301      	str	r3, [sp, #4]
   89b00:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   89b04:	9302      	str	r3, [sp, #8]
   89b06:	200a      	movs	r0, #10
   89b08:	9003      	str	r0, [sp, #12]
   89b0a:	f44f 71b9 	mov.w	r1, #370	; 0x172
   89b0e:	2296      	movs	r2, #150	; 0x96
   89b10:	2364      	movs	r3, #100	; 0x64
   89b12:	47a8      	blx	r5
				tft_button(10,220,150,100,"~UP",3,RA8875_YELLOW,BUTTONS_RADIUS);
   89b14:	4b3c      	ldr	r3, [pc, #240]	; (89c08 <select_file+0x2fc>)
   89b16:	9300      	str	r3, [sp, #0]
   89b18:	2303      	movs	r3, #3
   89b1a:	9301      	str	r3, [sp, #4]
   89b1c:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   89b20:	9302      	str	r3, [sp, #8]
   89b22:	200a      	movs	r0, #10
   89b24:	9003      	str	r0, [sp, #12]
   89b26:	21dc      	movs	r1, #220	; 0xdc
   89b28:	2296      	movs	r2, #150	; 0x96
   89b2a:	2364      	movs	r3, #100	; 0x64
   89b2c:	4d2b      	ldr	r5, [pc, #172]	; (89bdc <select_file+0x2d0>)
   89b2e:	47a8      	blx	r5
		}
		if(Action1 == 2)	//	NEXT
		{
			if(ll_count() > (FileOffset + FILES_ON_SCREEN))
			{
				FileOffset += FILES_ON_SCREEN;
   89b30:	46d0      	mov	r8, sl
   89b32:	e003      	b.n	89b3c <select_file+0x230>
				if(ll_count() > (FileOffset +FILES_ON_SCREEN))
				tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,BUTTONS_RADIUS);
				tft_button(10,220,150,100,"~UP",3,RA8875_YELLOW,BUTTONS_RADIUS);
			}
			else
			beep(600);
   89b34:	f44f 7016 	mov.w	r0, #600	; 0x258
   89b38:	4b34      	ldr	r3, [pc, #208]	; (89c0c <select_file+0x300>)
   89b3a:	4798      	blx	r3
			Action1 = 0;
   89b3c:	2300      	movs	r3, #0
   89b3e:	6023      	str	r3, [r4, #0]
		}
		if(Action1 == 3)	//	Previous
   89b40:	6823      	ldr	r3, [r4, #0]
   89b42:	2b03      	cmp	r3, #3
   89b44:	f040 80c0 	bne.w	89cc8 <select_file+0x3bc>
		{
			if(FileOffset >= FILES_ON_SCREEN)
   89b48:	f1b8 0f09 	cmp.w	r8, #9
   89b4c:	f340 80b3 	ble.w	89cb6 <select_file+0x3aa>
			{
				FileOffset -= FILES_ON_SCREEN;
   89b50:	f1a8 030a 	sub.w	r3, r8, #10
   89b54:	461d      	mov	r5, r3
   89b56:	9305      	str	r3, [sp, #20]
				tft_delete_all_objects();
   89b58:	4b1e      	ldr	r3, [pc, #120]	; (89bd4 <select_file+0x2c8>)
   89b5a:	4798      	blx	r3
				tft_fillScreen(RA8875_BLACK);
   89b5c:	2000      	movs	r0, #0
   89b5e:	4b1c      	ldr	r3, [pc, #112]	; (89bd0 <select_file+0x2c4>)
   89b60:	4798      	blx	r3
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
   89b62:	462f      	mov	r7, r5
   89b64:	45a8      	cmp	r8, r5
   89b66:	dd74      	ble.n	89c52 <select_file+0x346>
   89b68:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   89b6c:	012d      	lsls	r5, r5, #4
				{
					if(a == ll_count() - 1) break;
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
					else
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
   89b6e:	f8df a090 	ldr.w	sl, [pc, #144]	; 89c00 <select_file+0x2f4>
				FileOffset -= FILES_ON_SCREEN;
				tft_delete_all_objects();
				tft_fillScreen(RA8875_BLACK);
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
				{
					if(a == ll_count() - 1) break;
   89b72:	47d8      	blx	fp
   89b74:	3801      	subs	r0, #1
   89b76:	42b8      	cmp	r0, r7
   89b78:	d06b      	beq.n	89c52 <select_file+0x346>
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
   89b7a:	fa1f f987 	uxth.w	r9, r7
   89b7e:	4648      	mov	r0, r9
   89b80:	47b0      	blx	r6
   89b82:	7803      	ldrb	r3, [r0, #0]
   89b84:	2b20      	cmp	r3, #32
   89b86:	d143      	bne.n	89c10 <select_file+0x304>
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
   89b88:	4648      	mov	r0, r9
   89b8a:	47b0      	blx	r6
   89b8c:	fb85 230a 	smull	r2, r3, r5, sl
   89b90:	18e9      	adds	r1, r5, r3
   89b92:	17eb      	asrs	r3, r5, #31
   89b94:	ebc3 2121 	rsb	r1, r3, r1, asr #8
   89b98:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   89b9c:	9000      	str	r0, [sp, #0]
   89b9e:	f107 030a 	add.w	r3, r7, #10
   89ba2:	b2db      	uxtb	r3, r3
   89ba4:	9301      	str	r3, [sp, #4]
   89ba6:	231f      	movs	r3, #31
   89ba8:	9302      	str	r3, [sp, #8]
   89baa:	230a      	movs	r3, #10
   89bac:	9303      	str	r3, [sp, #12]
   89bae:	20c8      	movs	r0, #200	; 0xc8
   89bb0:	eba5 1141 	sub.w	r1, r5, r1, lsl #5
   89bb4:	f240 224e 	movw	r2, #590	; 0x24e
   89bb8:	2324      	movs	r3, #36	; 0x24
   89bba:	f8df c020 	ldr.w	ip, [pc, #32]	; 89bdc <select_file+0x2d0>
   89bbe:	47e0      	blx	ip
   89bc0:	e043      	b.n	89c4a <select_file+0x33e>
   89bc2:	bf00      	nop
   89bc4:	00081fb1 	.word	0x00081fb1
   89bc8:	20001250 	.word	0x20001250
   89bcc:	200014fc 	.word	0x200014fc
   89bd0:	00085e2d 	.word	0x00085e2d
   89bd4:	00086769 	.word	0x00086769
   89bd8:	00091788 	.word	0x00091788
   89bdc:	0008688d 	.word	0x0008688d
   89be0:	000821d1 	.word	0x000821d1
   89be4:	00091f20 	.word	0x00091f20
   89be8:	000820d9 	.word	0x000820d9
   89bec:	00089819 	.word	0x00089819
   89bf0:	0008219d 	.word	0x0008219d
   89bf4:	00091718 	.word	0x00091718
   89bf8:	000821a9 	.word	0x000821a9
   89bfc:	00086eb5 	.word	0x00086eb5
   89c00:	88888889 	.word	0x88888889
   89c04:	00091f24 	.word	0x00091f24
   89c08:	00091720 	.word	0x00091720
   89c0c:	00086c79 	.word	0x00086c79
					else
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
   89c10:	4648      	mov	r0, r9
   89c12:	47b0      	blx	r6
   89c14:	fb85 230a 	smull	r2, r3, r5, sl
   89c18:	18e9      	adds	r1, r5, r3
   89c1a:	17eb      	asrs	r3, r5, #31
   89c1c:	ebc3 2121 	rsb	r1, r3, r1, asr #8
   89c20:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   89c24:	9000      	str	r0, [sp, #0]
   89c26:	f107 030a 	add.w	r3, r7, #10
   89c2a:	b2db      	uxtb	r3, r3
   89c2c:	9301      	str	r3, [sp, #4]
   89c2e:	f44f 4378 	mov.w	r3, #63488	; 0xf800
   89c32:	9302      	str	r3, [sp, #8]
   89c34:	230a      	movs	r3, #10
   89c36:	9303      	str	r3, [sp, #12]
   89c38:	20c8      	movs	r0, #200	; 0xc8
   89c3a:	eba5 1141 	sub.w	r1, r5, r1, lsl #5
   89c3e:	f240 224e 	movw	r2, #590	; 0x24e
   89c42:	2324      	movs	r3, #36	; 0x24
   89c44:	f8df c150 	ldr.w	ip, [pc, #336]	; 89d98 <select_file+0x48c>
   89c48:	47e0      	blx	ip
			if(FileOffset >= FILES_ON_SCREEN)
			{
				FileOffset -= FILES_ON_SCREEN;
				tft_delete_all_objects();
				tft_fillScreen(RA8875_BLACK);
				for(a = FileOffset; a < FileOffset + FILES_ON_SCREEN; a++)
   89c4a:	3701      	adds	r7, #1
   89c4c:	3530      	adds	r5, #48	; 0x30
   89c4e:	45b8      	cmp	r8, r7
   89c50:	dc8f      	bgt.n	89b72 <select_file+0x266>
					if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
					else
						tft_button(200,(a * 48) % 480,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
				}
				tft_button(10,10,150,100,"CANCEL",1,RA8875_LIME,BUTTONS_RADIUS);
   89c52:	4b50      	ldr	r3, [pc, #320]	; (89d94 <select_file+0x488>)
   89c54:	9300      	str	r3, [sp, #0]
   89c56:	2301      	movs	r3, #1
   89c58:	9301      	str	r3, [sp, #4]
   89c5a:	f64c 73e0 	movw	r3, #53216	; 0xcfe0
   89c5e:	9302      	str	r3, [sp, #8]
   89c60:	210a      	movs	r1, #10
   89c62:	9103      	str	r1, [sp, #12]
   89c64:	4608      	mov	r0, r1
   89c66:	2296      	movs	r2, #150	; 0x96
   89c68:	2364      	movs	r3, #100	; 0x64
   89c6a:	4d4b      	ldr	r5, [pc, #300]	; (89d98 <select_file+0x48c>)
   89c6c:	47a8      	blx	r5
				if(ll_count() > (FileOffset +FILES_ON_SCREEN))
   89c6e:	47d8      	blx	fp
   89c70:	4580      	cmp	r8, r0
   89c72:	da0d      	bge.n	89c90 <select_file+0x384>
				tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,BUTTONS_RADIUS);
   89c74:	4b49      	ldr	r3, [pc, #292]	; (89d9c <select_file+0x490>)
   89c76:	9300      	str	r3, [sp, #0]
   89c78:	2302      	movs	r3, #2
   89c7a:	9301      	str	r3, [sp, #4]
   89c7c:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   89c80:	9302      	str	r3, [sp, #8]
   89c82:	200a      	movs	r0, #10
   89c84:	9003      	str	r0, [sp, #12]
   89c86:	f44f 71b9 	mov.w	r1, #370	; 0x172
   89c8a:	2296      	movs	r2, #150	; 0x96
   89c8c:	2364      	movs	r3, #100	; 0x64
   89c8e:	47a8      	blx	r5
				if(FileOffset)
   89c90:	9b05      	ldr	r3, [sp, #20]
   89c92:	b1ab      	cbz	r3, 89cc0 <select_file+0x3b4>
					tft_button(10,220,150,100,"~UP",3,RA8875_YELLOW,BUTTONS_RADIUS);
   89c94:	4b42      	ldr	r3, [pc, #264]	; (89da0 <select_file+0x494>)
   89c96:	9300      	str	r3, [sp, #0]
   89c98:	2303      	movs	r3, #3
   89c9a:	9301      	str	r3, [sp, #4]
   89c9c:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   89ca0:	9302      	str	r3, [sp, #8]
   89ca2:	200a      	movs	r0, #10
   89ca4:	9003      	str	r0, [sp, #12]
   89ca6:	21dc      	movs	r1, #220	; 0xdc
   89ca8:	2296      	movs	r2, #150	; 0x96
   89caa:	2364      	movs	r3, #100	; 0x64
   89cac:	4d3a      	ldr	r5, [pc, #232]	; (89d98 <select_file+0x48c>)
   89cae:	47a8      	blx	r5
		}
		if(Action1 == 3)	//	Previous
		{
			if(FileOffset >= FILES_ON_SCREEN)
			{
				FileOffset -= FILES_ON_SCREEN;
   89cb0:	f8dd 8014 	ldr.w	r8, [sp, #20]
   89cb4:	e006      	b.n	89cc4 <select_file+0x3b8>
				tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,BUTTONS_RADIUS);
				if(FileOffset)
					tft_button(10,220,150,100,"~UP",3,RA8875_YELLOW,BUTTONS_RADIUS);
			}
			else
			beep(600);
   89cb6:	f44f 7016 	mov.w	r0, #600	; 0x258
   89cba:	4b3a      	ldr	r3, [pc, #232]	; (89da4 <select_file+0x498>)
   89cbc:	4798      	blx	r3
   89cbe:	e001      	b.n	89cc4 <select_file+0x3b8>
		}
		if(Action1 == 3)	//	Previous
		{
			if(FileOffset >= FILES_ON_SCREEN)
			{
				FileOffset -= FILES_ON_SCREEN;
   89cc0:	f8dd 8014 	ldr.w	r8, [sp, #20]
				if(FileOffset)
					tft_button(10,220,150,100,"~UP",3,RA8875_YELLOW,BUTTONS_RADIUS);
			}
			else
			beep(600);
			Action1 = 0;
   89cc4:	2300      	movs	r3, #0
   89cc6:	6023      	str	r3, [r4, #0]
		}
		if(Action1 >= 10)
   89cc8:	6823      	ldr	r3, [r4, #0]
   89cca:	2b09      	cmp	r3, #9
   89ccc:	f77f ae94 	ble.w	899f8 <select_file+0xec>
		{
			TGraphics *p;
			p = Gall;
   89cd0:	4b35      	ldr	r3, [pc, #212]	; (89da8 <select_file+0x49c>)
   89cd2:	681c      	ldr	r4, [r3, #0]
			do
			{
				if(p->handle == Action1)
   89cd4:	4935      	ldr	r1, [pc, #212]	; (89dac <select_file+0x4a0>)
   89cd6:	680b      	ldr	r3, [r1, #0]
   89cd8:	7c22      	ldrb	r2, [r4, #16]
   89cda:	429a      	cmp	r2, r3
   89cdc:	d146      	bne.n	89d6c <select_file+0x460>
				{
					if(!strncmp(p->text," ",1))	//	je to adresar, nie subor lebo zacina medzerou
   89cde:	6a23      	ldr	r3, [r4, #32]
   89ce0:	781a      	ldrb	r2, [r3, #0]
   89ce2:	2a20      	cmp	r2, #32
   89ce4:	d13a      	bne.n	89d5c <select_file+0x450>
					{
						ll_clear();
   89ce6:	4b32      	ldr	r3, [pc, #200]	; (89db0 <select_file+0x4a4>)
   89ce8:	4798      	blx	r3
						if(!strncmp(p->text," ..",3))	//	Nadradeny adresa minimalne druhej urovne
   89cea:	6a24      	ldr	r4, [r4, #32]
   89cec:	4620      	mov	r0, r4
   89cee:	4931      	ldr	r1, [pc, #196]	; (89db4 <select_file+0x4a8>)
   89cf0:	2203      	movs	r2, #3
   89cf2:	4b31      	ldr	r3, [pc, #196]	; (89db8 <select_file+0x4ac>)
   89cf4:	4798      	blx	r3
   89cf6:	b9c8      	cbnz	r0, 89d2c <select_file+0x420>
						{
							if(PosR('/',path) > 1)
   89cf8:	202f      	movs	r0, #47	; 0x2f
   89cfa:	9d04      	ldr	r5, [sp, #16]
   89cfc:	4629      	mov	r1, r5
   89cfe:	4b2f      	ldr	r3, [pc, #188]	; (89dbc <select_file+0x4b0>)
   89d00:	4798      	blx	r3
   89d02:	2801      	cmp	r0, #1
   89d04:	d90e      	bls.n	89d24 <select_file+0x418>
							{
								char buffer[256];
								strcpy(buffer,path);
   89d06:	ac06      	add	r4, sp, #24
   89d08:	4620      	mov	r0, r4
   89d0a:	4629      	mov	r1, r5
   89d0c:	4b2c      	ldr	r3, [pc, #176]	; (89dc0 <select_file+0x4b4>)
   89d0e:	4798      	blx	r3
								buffer[PosR('/',path)] = 0;
   89d10:	202f      	movs	r0, #47	; 0x2f
   89d12:	4629      	mov	r1, r5
   89d14:	4b29      	ldr	r3, [pc, #164]	; (89dbc <select_file+0x4b0>)
   89d16:	4798      	blx	r3
   89d18:	2300      	movs	r3, #0
   89d1a:	5423      	strb	r3, [r4, r0]
								select_file((char*)buffer);
   89d1c:	4620      	mov	r0, r4
   89d1e:	f7ff fdf5 	bl	8990c <select_file>
   89d22:	e026      	b.n	89d72 <select_file+0x466>
							}
							else
							{
								select_file((char*)"");
   89d24:	4827      	ldr	r0, [pc, #156]	; (89dc4 <select_file+0x4b8>)
   89d26:	f7ff fdf1 	bl	8990c <select_file>
   89d2a:	e022      	b.n	89d72 <select_file+0x466>
							}
						} else
						{
							char *fn = (char*)malloc(strlen(path) + strlen(p->text) + 3);
   89d2c:	9f04      	ldr	r7, [sp, #16]
   89d2e:	4638      	mov	r0, r7
   89d30:	4e25      	ldr	r6, [pc, #148]	; (89dc8 <select_file+0x4bc>)
   89d32:	47b0      	blx	r6
   89d34:	4605      	mov	r5, r0
   89d36:	4620      	mov	r0, r4
   89d38:	47b0      	blx	r6
   89d3a:	4428      	add	r0, r5
   89d3c:	3003      	adds	r0, #3
   89d3e:	4b23      	ldr	r3, [pc, #140]	; (89dcc <select_file+0x4c0>)
   89d40:	4798      	blx	r3
   89d42:	4605      	mov	r5, r0
							sprintf(fn,"%s/%s",path,p->text + 1);
   89d44:	4922      	ldr	r1, [pc, #136]	; (89dd0 <select_file+0x4c4>)
   89d46:	463a      	mov	r2, r7
   89d48:	1c63      	adds	r3, r4, #1
   89d4a:	4c22      	ldr	r4, [pc, #136]	; (89dd4 <select_file+0x4c8>)
   89d4c:	47a0      	blx	r4
							select_file(fn);
   89d4e:	4628      	mov	r0, r5
   89d50:	f7ff fddc 	bl	8990c <select_file>
							free(fn);
   89d54:	4628      	mov	r0, r5
   89d56:	4b20      	ldr	r3, [pc, #128]	; (89dd8 <select_file+0x4cc>)
   89d58:	4798      	blx	r3
   89d5a:	e00a      	b.n	89d72 <select_file+0x466>
						}
					}else
					{
						sprintf(filename,"%s/%s",path,p->text);	//	Vybral som subor
   89d5c:	481f      	ldr	r0, [pc, #124]	; (89ddc <select_file+0x4d0>)
   89d5e:	491c      	ldr	r1, [pc, #112]	; (89dd0 <select_file+0x4c4>)
   89d60:	9a04      	ldr	r2, [sp, #16]
   89d62:	4c1c      	ldr	r4, [pc, #112]	; (89dd4 <select_file+0x4c8>)
   89d64:	47a0      	blx	r4
						ll_clear();								//	zoznam suborov uz nepotrebujem
   89d66:	4b12      	ldr	r3, [pc, #72]	; (89db0 <select_file+0x4a4>)
   89d68:	4798      	blx	r3
   89d6a:	e002      	b.n	89d72 <select_file+0x466>
					}
					break;
				}
				p = p->next;
   89d6c:	69e4      	ldr	r4, [r4, #28]
			}while(p);
   89d6e:	2c00      	cmp	r4, #0
   89d70:	d1b1      	bne.n	89cd6 <select_file+0x3ca>
			Action1 = 0;
   89d72:	2000      	movs	r0, #0
   89d74:	4b0d      	ldr	r3, [pc, #52]	; (89dac <select_file+0x4a0>)
   89d76:	6018      	str	r0, [r3, #0]
			return FR_OK;
   89d78:	e009      	b.n	89d8e <select_file+0x482>
   89d7a:	e008      	b.n	89d8e <select_file+0x482>
		tft_textWrite(10,100,780,0,(char*)"NO FILESYSTEM",ALINE_CENTER);
	return res;
}

FRESULT select_file( char*  path)
{
   89d7c:	250a      	movs	r5, #10
   89d7e:	2600      	movs	r6, #0
   89d80:	4634      	mov	r4, r6
	scan_files(path);
	if(ll_count() > FILES_ON_SCREEN )
	tft_button(10,370,150,100,"~DOWN",2,RA8875_YELLOW,10);
	for(a = 0; a < FileOffset + FILES_ON_SCREEN; a++)
	{
		if(a >= ll_count()) break;
   89d82:	f8df 8060 	ldr.w	r8, [pc, #96]	; 89de4 <select_file+0x4d8>
		if(!strncmp(ll_item(a)," ",1))	//	Adresar zacina medzerou
   89d86:	4f16      	ldr	r7, [pc, #88]	; (89de0 <select_file+0x4d4>)
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_BLUE,BUTTONS_RADIUS);
		else
			tft_button(200,a * 48,590,36,ll_item(a),10 + a,RA8875_RED,BUTTONS_RADIUS);
   89d88:	f8df 900c 	ldr.w	r9, [pc, #12]	; 89d98 <select_file+0x48c>
   89d8c:	e600      	b.n	89990 <select_file+0x84>
			Action1 = 0;
			return FR_OK;
		}
	}
	return FR_NO_FILE;
}
   89d8e:	b047      	add	sp, #284	; 0x11c
   89d90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89d94:	00091f24 	.word	0x00091f24
   89d98:	0008688d 	.word	0x0008688d
   89d9c:	00091718 	.word	0x00091718
   89da0:	00091720 	.word	0x00091720
   89da4:	00086c79 	.word	0x00086c79
   89da8:	200014f0 	.word	0x200014f0
   89dac:	200014fc 	.word	0x200014fc
   89db0:	000821d1 	.word	0x000821d1
   89db4:	00091f20 	.word	0x00091f20
   89db8:	0008d3f5 	.word	0x0008d3f5
   89dbc:	000853e1 	.word	0x000853e1
   89dc0:	0008d2dd 	.word	0x0008d2dd
   89dc4:	00091d60 	.word	0x00091d60
   89dc8:	0008d399 	.word	0x0008d399
   89dcc:	0008cbb1 	.word	0x0008cbb1
   89dd0:	00091f2c 	.word	0x00091f2c
   89dd4:	0008d291 	.word	0x0008d291
   89dd8:	0008cbc1 	.word	0x0008cbc1
   89ddc:	20001564 	.word	0x20001564
   89de0:	000821a9 	.word	0x000821a9
   89de4:	0008219d 	.word	0x0008219d

00089de8 <ceil>:
   89de8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   89dec:	f3c1 580a 	ubfx	r8, r1, #20, #11
   89df0:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
   89df4:	2e13      	cmp	r6, #19
   89df6:	460b      	mov	r3, r1
   89df8:	4604      	mov	r4, r0
   89dfa:	460d      	mov	r5, r1
   89dfc:	4602      	mov	r2, r0
   89dfe:	4689      	mov	r9, r1
   89e00:	4607      	mov	r7, r0
   89e02:	dc21      	bgt.n	89e48 <ceil+0x60>
   89e04:	2e00      	cmp	r6, #0
   89e06:	db51      	blt.n	89eac <ceil+0xc4>
   89e08:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 89ef4 <ceil+0x10c>
   89e0c:	fa48 f806 	asr.w	r8, r8, r6
   89e10:	ea08 0e01 	and.w	lr, r8, r1
   89e14:	ea5e 0202 	orrs.w	r2, lr, r2
   89e18:	d01b      	beq.n	89e52 <ceil+0x6a>
   89e1a:	a333      	add	r3, pc, #204	; (adr r3, 89ee8 <ceil+0x100>)
   89e1c:	e9d3 2300 	ldrd	r2, r3, [r3]
   89e20:	f001 fe96 	bl	8bb50 <__adddf3>
   89e24:	2200      	movs	r2, #0
   89e26:	2300      	movs	r3, #0
   89e28:	f002 fad4 	bl	8c3d4 <__aeabi_dcmpgt>
   89e2c:	b140      	cbz	r0, 89e40 <ceil+0x58>
   89e2e:	2d00      	cmp	r5, #0
   89e30:	dd03      	ble.n	89e3a <ceil+0x52>
   89e32:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   89e36:	4133      	asrs	r3, r6
   89e38:	4499      	add	r9, r3
   89e3a:	ea29 0508 	bic.w	r5, r9, r8
   89e3e:	2700      	movs	r7, #0
   89e40:	4638      	mov	r0, r7
   89e42:	4629      	mov	r1, r5
   89e44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89e48:	2e33      	cmp	r6, #51	; 0x33
   89e4a:	dd06      	ble.n	89e5a <ceil+0x72>
   89e4c:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   89e50:	d03f      	beq.n	89ed2 <ceil+0xea>
   89e52:	4620      	mov	r0, r4
   89e54:	4619      	mov	r1, r3
   89e56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89e5a:	f2a8 4213 	subw	r2, r8, #1043	; 0x413
   89e5e:	f04f 3aff 	mov.w	sl, #4294967295
   89e62:	fa2a fa02 	lsr.w	sl, sl, r2
   89e66:	ea1a 0f00 	tst.w	sl, r0
   89e6a:	d0f2      	beq.n	89e52 <ceil+0x6a>
   89e6c:	a31e      	add	r3, pc, #120	; (adr r3, 89ee8 <ceil+0x100>)
   89e6e:	e9d3 2300 	ldrd	r2, r3, [r3]
   89e72:	f001 fe6d 	bl	8bb50 <__adddf3>
   89e76:	2200      	movs	r2, #0
   89e78:	2300      	movs	r3, #0
   89e7a:	f002 faab 	bl	8c3d4 <__aeabi_dcmpgt>
   89e7e:	2800      	cmp	r0, #0
   89e80:	d0de      	beq.n	89e40 <ceil+0x58>
   89e82:	2d00      	cmp	r5, #0
   89e84:	dd0c      	ble.n	89ea0 <ceil+0xb8>
   89e86:	2e14      	cmp	r6, #20
   89e88:	d008      	beq.n	89e9c <ceil+0xb4>
   89e8a:	f5c8 6886 	rsb	r8, r8, #1072	; 0x430
   89e8e:	f108 0803 	add.w	r8, r8, #3
   89e92:	2501      	movs	r5, #1
   89e94:	fa05 f508 	lsl.w	r5, r5, r8
   89e98:	192f      	adds	r7, r5, r4
   89e9a:	d301      	bcc.n	89ea0 <ceil+0xb8>
   89e9c:	f109 0901 	add.w	r9, r9, #1
   89ea0:	464d      	mov	r5, r9
   89ea2:	ea27 070a 	bic.w	r7, r7, sl
   89ea6:	4638      	mov	r0, r7
   89ea8:	4629      	mov	r1, r5
   89eaa:	e7cb      	b.n	89e44 <ceil+0x5c>
   89eac:	a30e      	add	r3, pc, #56	; (adr r3, 89ee8 <ceil+0x100>)
   89eae:	e9d3 2300 	ldrd	r2, r3, [r3]
   89eb2:	f001 fe4d 	bl	8bb50 <__adddf3>
   89eb6:	2200      	movs	r2, #0
   89eb8:	2300      	movs	r3, #0
   89eba:	f002 fa8b 	bl	8c3d4 <__aeabi_dcmpgt>
   89ebe:	2800      	cmp	r0, #0
   89ec0:	d0be      	beq.n	89e40 <ceil+0x58>
   89ec2:	2d00      	cmp	r5, #0
   89ec4:	db0c      	blt.n	89ee0 <ceil+0xf8>
   89ec6:	ea54 0705 	orrs.w	r7, r4, r5
   89eca:	d007      	beq.n	89edc <ceil+0xf4>
   89ecc:	4d08      	ldr	r5, [pc, #32]	; (89ef0 <ceil+0x108>)
   89ece:	2700      	movs	r7, #0
   89ed0:	e7b6      	b.n	89e40 <ceil+0x58>
   89ed2:	4602      	mov	r2, r0
   89ed4:	460b      	mov	r3, r1
   89ed6:	f001 fe3b 	bl	8bb50 <__adddf3>
   89eda:	e7bc      	b.n	89e56 <ceil+0x6e>
   89edc:	463d      	mov	r5, r7
   89ede:	e7af      	b.n	89e40 <ceil+0x58>
   89ee0:	2700      	movs	r7, #0
   89ee2:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   89ee6:	e7ab      	b.n	89e40 <ceil+0x58>
   89ee8:	8800759c 	.word	0x8800759c
   89eec:	7e37e43c 	.word	0x7e37e43c
   89ef0:	3ff00000 	.word	0x3ff00000
   89ef4:	000fffff 	.word	0x000fffff

00089ef8 <cos>:
   89ef8:	b530      	push	{r4, r5, lr}
   89efa:	4a21      	ldr	r2, [pc, #132]	; (89f80 <cos+0x88>)
   89efc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   89f00:	4293      	cmp	r3, r2
   89f02:	b087      	sub	sp, #28
   89f04:	dd1b      	ble.n	89f3e <cos+0x46>
   89f06:	4a1f      	ldr	r2, [pc, #124]	; (89f84 <cos+0x8c>)
   89f08:	4293      	cmp	r3, r2
   89f0a:	dd05      	ble.n	89f18 <cos+0x20>
   89f0c:	4602      	mov	r2, r0
   89f0e:	460b      	mov	r3, r1
   89f10:	f001 fe1c 	bl	8bb4c <__aeabi_dsub>
   89f14:	b007      	add	sp, #28
   89f16:	bd30      	pop	{r4, r5, pc}
   89f18:	aa02      	add	r2, sp, #8
   89f1a:	f000 fb11 	bl	8a540 <__ieee754_rem_pio2>
   89f1e:	f000 0003 	and.w	r0, r0, #3
   89f22:	2801      	cmp	r0, #1
   89f24:	d01a      	beq.n	89f5c <cos+0x64>
   89f26:	2802      	cmp	r0, #2
   89f28:	d00f      	beq.n	89f4a <cos+0x52>
   89f2a:	b308      	cbz	r0, 89f70 <cos+0x78>
   89f2c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   89f30:	2301      	movs	r3, #1
   89f32:	9300      	str	r3, [sp, #0]
   89f34:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   89f38:	f001 fb02 	bl	8b540 <__kernel_sin>
   89f3c:	e7ea      	b.n	89f14 <cos+0x1c>
   89f3e:	2200      	movs	r2, #0
   89f40:	2300      	movs	r3, #0
   89f42:	f000 fdd5 	bl	8aaf0 <__kernel_cos>
   89f46:	b007      	add	sp, #28
   89f48:	bd30      	pop	{r4, r5, pc}
   89f4a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   89f4e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   89f52:	f000 fdcd 	bl	8aaf0 <__kernel_cos>
   89f56:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   89f5a:	e7db      	b.n	89f14 <cos+0x1c>
   89f5c:	9000      	str	r0, [sp, #0]
   89f5e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   89f62:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   89f66:	f001 faeb 	bl	8b540 <__kernel_sin>
   89f6a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   89f6e:	e7d1      	b.n	89f14 <cos+0x1c>
   89f70:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   89f74:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   89f78:	f000 fdba 	bl	8aaf0 <__kernel_cos>
   89f7c:	e7ca      	b.n	89f14 <cos+0x1c>
   89f7e:	bf00      	nop
   89f80:	3fe921fb 	.word	0x3fe921fb
   89f84:	7fefffff 	.word	0x7fefffff

00089f88 <floor>:
   89f88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   89f8c:	f3c1 580a 	ubfx	r8, r1, #20, #11
   89f90:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
   89f94:	2e13      	cmp	r6, #19
   89f96:	460b      	mov	r3, r1
   89f98:	4604      	mov	r4, r0
   89f9a:	460d      	mov	r5, r1
   89f9c:	4602      	mov	r2, r0
   89f9e:	4689      	mov	r9, r1
   89fa0:	4607      	mov	r7, r0
   89fa2:	dc1d      	bgt.n	89fe0 <floor+0x58>
   89fa4:	2e00      	cmp	r6, #0
   89fa6:	db40      	blt.n	8a02a <floor+0xa2>
   89fa8:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8a09c <floor+0x114>
   89fac:	fa48 f806 	asr.w	r8, r8, r6
   89fb0:	ea08 0e01 	and.w	lr, r8, r1
   89fb4:	ea5e 0202 	orrs.w	r2, lr, r2
   89fb8:	d017      	beq.n	89fea <floor+0x62>
   89fba:	a335      	add	r3, pc, #212	; (adr r3, 8a090 <floor+0x108>)
   89fbc:	e9d3 2300 	ldrd	r2, r3, [r3]
   89fc0:	f001 fdc6 	bl	8bb50 <__adddf3>
   89fc4:	2200      	movs	r2, #0
   89fc6:	2300      	movs	r3, #0
   89fc8:	f002 fa04 	bl	8c3d4 <__aeabi_dcmpgt>
   89fcc:	b120      	cbz	r0, 89fd8 <floor+0x50>
   89fce:	2d00      	cmp	r5, #0
   89fd0:	db40      	blt.n	8a054 <floor+0xcc>
   89fd2:	ea29 0508 	bic.w	r5, r9, r8
   89fd6:	2700      	movs	r7, #0
   89fd8:	4638      	mov	r0, r7
   89fda:	4629      	mov	r1, r5
   89fdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89fe0:	2e33      	cmp	r6, #51	; 0x33
   89fe2:	dd06      	ble.n	89ff2 <floor+0x6a>
   89fe4:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   89fe8:	d02f      	beq.n	8a04a <floor+0xc2>
   89fea:	4620      	mov	r0, r4
   89fec:	4619      	mov	r1, r3
   89fee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89ff2:	f2a8 4213 	subw	r2, r8, #1043	; 0x413
   89ff6:	f04f 3aff 	mov.w	sl, #4294967295
   89ffa:	fa2a fa02 	lsr.w	sl, sl, r2
   89ffe:	ea1a 0f00 	tst.w	sl, r0
   8a002:	d0f2      	beq.n	89fea <floor+0x62>
   8a004:	a322      	add	r3, pc, #136	; (adr r3, 8a090 <floor+0x108>)
   8a006:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a00a:	f001 fda1 	bl	8bb50 <__adddf3>
   8a00e:	2200      	movs	r2, #0
   8a010:	2300      	movs	r3, #0
   8a012:	f002 f9df 	bl	8c3d4 <__aeabi_dcmpgt>
   8a016:	2800      	cmp	r0, #0
   8a018:	d0de      	beq.n	89fd8 <floor+0x50>
   8a01a:	2d00      	cmp	r5, #0
   8a01c:	db1f      	blt.n	8a05e <floor+0xd6>
   8a01e:	464d      	mov	r5, r9
   8a020:	ea27 070a 	bic.w	r7, r7, sl
   8a024:	4638      	mov	r0, r7
   8a026:	4629      	mov	r1, r5
   8a028:	e7d8      	b.n	89fdc <floor+0x54>
   8a02a:	a319      	add	r3, pc, #100	; (adr r3, 8a090 <floor+0x108>)
   8a02c:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a030:	f001 fd8e 	bl	8bb50 <__adddf3>
   8a034:	2200      	movs	r2, #0
   8a036:	2300      	movs	r3, #0
   8a038:	f002 f9cc 	bl	8c3d4 <__aeabi_dcmpgt>
   8a03c:	2800      	cmp	r0, #0
   8a03e:	d0cb      	beq.n	89fd8 <floor+0x50>
   8a040:	2d00      	cmp	r5, #0
   8a042:	db1a      	blt.n	8a07a <floor+0xf2>
   8a044:	2700      	movs	r7, #0
   8a046:	463d      	mov	r5, r7
   8a048:	e7c6      	b.n	89fd8 <floor+0x50>
   8a04a:	4602      	mov	r2, r0
   8a04c:	460b      	mov	r3, r1
   8a04e:	f001 fd7f 	bl	8bb50 <__adddf3>
   8a052:	e7cc      	b.n	89fee <floor+0x66>
   8a054:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   8a058:	4133      	asrs	r3, r6
   8a05a:	4499      	add	r9, r3
   8a05c:	e7b9      	b.n	89fd2 <floor+0x4a>
   8a05e:	2e14      	cmp	r6, #20
   8a060:	d008      	beq.n	8a074 <floor+0xec>
   8a062:	f5c8 6886 	rsb	r8, r8, #1072	; 0x430
   8a066:	f108 0803 	add.w	r8, r8, #3
   8a06a:	2301      	movs	r3, #1
   8a06c:	fa03 f308 	lsl.w	r3, r3, r8
   8a070:	191f      	adds	r7, r3, r4
   8a072:	d3d4      	bcc.n	8a01e <floor+0x96>
   8a074:	f109 0901 	add.w	r9, r9, #1
   8a078:	e7d1      	b.n	8a01e <floor+0x96>
   8a07a:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   8a07e:	4b06      	ldr	r3, [pc, #24]	; (8a098 <floor+0x110>)
   8a080:	4322      	orrs	r2, r4
   8a082:	bf18      	it	ne
   8a084:	461d      	movne	r5, r3
   8a086:	2700      	movs	r7, #0
   8a088:	e7a6      	b.n	89fd8 <floor+0x50>
   8a08a:	bf00      	nop
   8a08c:	f3af 8000 	nop.w
   8a090:	8800759c 	.word	0x8800759c
   8a094:	7e37e43c 	.word	0x7e37e43c
   8a098:	bff00000 	.word	0xbff00000
   8a09c:	000fffff 	.word	0x000fffff

0008a0a0 <lround>:
   8a0a0:	460b      	mov	r3, r1
   8a0a2:	2b00      	cmp	r3, #0
   8a0a4:	b570      	push	{r4, r5, r6, lr}
   8a0a6:	f3c3 560a 	ubfx	r6, r3, #20, #11
   8a0aa:	f2a6 32ff 	subw	r2, r6, #1023	; 0x3ff
   8a0ae:	f3c3 0313 	ubfx	r3, r3, #0, #20
   8a0b2:	bfb4      	ite	lt
   8a0b4:	f04f 34ff 	movlt.w	r4, #4294967295
   8a0b8:	2401      	movge	r4, #1
   8a0ba:	2a13      	cmp	r2, #19
   8a0bc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8a0c0:	dc0b      	bgt.n	8a0da <lround+0x3a>
   8a0c2:	2a00      	cmp	r2, #0
   8a0c4:	db2f      	blt.n	8a126 <lround+0x86>
   8a0c6:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   8a0ca:	4111      	asrs	r1, r2
   8a0cc:	440b      	add	r3, r1
   8a0ce:	f1c2 0214 	rsb	r2, r2, #20
   8a0d2:	40d3      	lsrs	r3, r2
   8a0d4:	fb04 f003 	mul.w	r0, r4, r3
   8a0d8:	bd70      	pop	{r4, r5, r6, pc}
   8a0da:	2a1e      	cmp	r2, #30
   8a0dc:	d80c      	bhi.n	8a0f8 <lround+0x58>
   8a0de:	2a33      	cmp	r2, #51	; 0x33
   8a0e0:	4605      	mov	r5, r0
   8a0e2:	dd0c      	ble.n	8a0fe <lround+0x5e>
   8a0e4:	f2a6 4213 	subw	r2, r6, #1043	; 0x413
   8a0e8:	f2a6 4633 	subw	r6, r6, #1075	; 0x433
   8a0ec:	4093      	lsls	r3, r2
   8a0ee:	40b5      	lsls	r5, r6
   8a0f0:	432b      	orrs	r3, r5
   8a0f2:	fb04 f003 	mul.w	r0, r4, r3
   8a0f6:	bd70      	pop	{r4, r5, r6, pc}
   8a0f8:	f002 f976 	bl	8c3e8 <__aeabi_d2iz>
   8a0fc:	bd70      	pop	{r4, r5, r6, pc}
   8a0fe:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
   8a102:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   8a106:	40f1      	lsrs	r1, r6
   8a108:	1809      	adds	r1, r1, r0
   8a10a:	f1c2 0234 	rsb	r2, r2, #52	; 0x34
   8a10e:	bf28      	it	cs
   8a110:	3301      	addcs	r3, #1
   8a112:	2a20      	cmp	r2, #32
   8a114:	fa03 f306 	lsl.w	r3, r3, r6
   8a118:	bf14      	ite	ne
   8a11a:	40d1      	lsrne	r1, r2
   8a11c:	2100      	moveq	r1, #0
   8a11e:	430b      	orrs	r3, r1
   8a120:	fb04 f003 	mul.w	r0, r4, r3
   8a124:	bd70      	pop	{r4, r5, r6, pc}
   8a126:	3201      	adds	r2, #1
   8a128:	bf0c      	ite	eq
   8a12a:	4620      	moveq	r0, r4
   8a12c:	2000      	movne	r0, #0
   8a12e:	bd70      	pop	{r4, r5, r6, pc}

0008a130 <round>:
   8a130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8a132:	f3c1 560a 	ubfx	r6, r1, #20, #11
   8a136:	f2a6 35ff 	subw	r5, r6, #1023	; 0x3ff
   8a13a:	2d13      	cmp	r5, #19
   8a13c:	460a      	mov	r2, r1
   8a13e:	460b      	mov	r3, r1
   8a140:	4604      	mov	r4, r0
   8a142:	4686      	mov	lr, r0
   8a144:	dc11      	bgt.n	8a16a <round+0x3a>
   8a146:	2d00      	cmp	r5, #0
   8a148:	db2d      	blt.n	8a1a6 <round+0x76>
   8a14a:	460f      	mov	r7, r1
   8a14c:	491f      	ldr	r1, [pc, #124]	; (8a1cc <round+0x9c>)
   8a14e:	4129      	asrs	r1, r5
   8a150:	4211      	tst	r1, r2
   8a152:	d024      	beq.n	8a19e <round+0x6e>
   8a154:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   8a158:	412b      	asrs	r3, r5
   8a15a:	443b      	add	r3, r7
   8a15c:	ea23 0301 	bic.w	r3, r3, r1
   8a160:	2200      	movs	r2, #0
   8a162:	4619      	mov	r1, r3
   8a164:	4614      	mov	r4, r2
   8a166:	4620      	mov	r0, r4
   8a168:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8a16a:	2d33      	cmp	r5, #51	; 0x33
   8a16c:	dd05      	ble.n	8a17a <round+0x4a>
   8a16e:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
   8a172:	d01e      	beq.n	8a1b2 <round+0x82>
   8a174:	4611      	mov	r1, r2
   8a176:	4620      	mov	r0, r4
   8a178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8a17a:	f2a6 4113 	subw	r1, r6, #1043	; 0x413
   8a17e:	f04f 30ff 	mov.w	r0, #4294967295
   8a182:	40c8      	lsrs	r0, r1
   8a184:	4220      	tst	r0, r4
   8a186:	d0f5      	beq.n	8a174 <round+0x44>
   8a188:	f5c6 6686 	rsb	r6, r6, #1072	; 0x430
   8a18c:	3602      	adds	r6, #2
   8a18e:	2101      	movs	r1, #1
   8a190:	40b1      	lsls	r1, r6
   8a192:	1909      	adds	r1, r1, r4
   8a194:	bf28      	it	cs
   8a196:	3301      	addcs	r3, #1
   8a198:	ea21 0200 	bic.w	r2, r1, r0
   8a19c:	e7e1      	b.n	8a162 <round+0x32>
   8a19e:	2800      	cmp	r0, #0
   8a1a0:	d1d8      	bne.n	8a154 <round+0x24>
   8a1a2:	4611      	mov	r1, r2
   8a1a4:	e7e7      	b.n	8a176 <round+0x46>
   8a1a6:	3501      	adds	r5, #1
   8a1a8:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   8a1ac:	d007      	beq.n	8a1be <round+0x8e>
   8a1ae:	2200      	movs	r2, #0
   8a1b0:	e7d7      	b.n	8a162 <round+0x32>
   8a1b2:	4602      	mov	r2, r0
   8a1b4:	460b      	mov	r3, r1
   8a1b6:	f001 fccb 	bl	8bb50 <__adddf3>
   8a1ba:	4604      	mov	r4, r0
   8a1bc:	e7d3      	b.n	8a166 <round+0x36>
   8a1be:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
   8a1c2:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
   8a1c6:	2200      	movs	r2, #0
   8a1c8:	e7cb      	b.n	8a162 <round+0x32>
   8a1ca:	bf00      	nop
   8a1cc:	000fffff 	.word	0x000fffff

0008a1d0 <sin>:
   8a1d0:	b530      	push	{r4, r5, lr}
   8a1d2:	4a22      	ldr	r2, [pc, #136]	; (8a25c <sin+0x8c>)
   8a1d4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   8a1d8:	4293      	cmp	r3, r2
   8a1da:	b087      	sub	sp, #28
   8a1dc:	dd1b      	ble.n	8a216 <sin+0x46>
   8a1de:	4a20      	ldr	r2, [pc, #128]	; (8a260 <sin+0x90>)
   8a1e0:	4293      	cmp	r3, r2
   8a1e2:	dd05      	ble.n	8a1f0 <sin+0x20>
   8a1e4:	4602      	mov	r2, r0
   8a1e6:	460b      	mov	r3, r1
   8a1e8:	f001 fcb0 	bl	8bb4c <__aeabi_dsub>
   8a1ec:	b007      	add	sp, #28
   8a1ee:	bd30      	pop	{r4, r5, pc}
   8a1f0:	aa02      	add	r2, sp, #8
   8a1f2:	f000 f9a5 	bl	8a540 <__ieee754_rem_pio2>
   8a1f6:	f000 0003 	and.w	r0, r0, #3
   8a1fa:	2801      	cmp	r0, #1
   8a1fc:	d01e      	beq.n	8a23c <sin+0x6c>
   8a1fe:	2802      	cmp	r0, #2
   8a200:	d011      	beq.n	8a226 <sin+0x56>
   8a202:	b310      	cbz	r0, 8a24a <sin+0x7a>
   8a204:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8a208:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   8a20c:	f000 fc70 	bl	8aaf0 <__kernel_cos>
   8a210:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8a214:	e7ea      	b.n	8a1ec <sin+0x1c>
   8a216:	2300      	movs	r3, #0
   8a218:	9300      	str	r3, [sp, #0]
   8a21a:	2200      	movs	r2, #0
   8a21c:	2300      	movs	r3, #0
   8a21e:	f001 f98f 	bl	8b540 <__kernel_sin>
   8a222:	b007      	add	sp, #28
   8a224:	bd30      	pop	{r4, r5, pc}
   8a226:	2301      	movs	r3, #1
   8a228:	9300      	str	r3, [sp, #0]
   8a22a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8a22e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   8a232:	f001 f985 	bl	8b540 <__kernel_sin>
   8a236:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8a23a:	e7d7      	b.n	8a1ec <sin+0x1c>
   8a23c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8a240:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   8a244:	f000 fc54 	bl	8aaf0 <__kernel_cos>
   8a248:	e7d0      	b.n	8a1ec <sin+0x1c>
   8a24a:	2401      	movs	r4, #1
   8a24c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8a250:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   8a254:	9400      	str	r4, [sp, #0]
   8a256:	f001 f973 	bl	8b540 <__kernel_sin>
   8a25a:	e7c7      	b.n	8a1ec <sin+0x1c>
   8a25c:	3fe921fb 	.word	0x3fe921fb
   8a260:	7fefffff 	.word	0x7fefffff

0008a264 <trunc>:
   8a264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8a266:	f3c1 560a 	ubfx	r6, r1, #20, #11
   8a26a:	f2a6 34ff 	subw	r4, r6, #1023	; 0x3ff
   8a26e:	2c13      	cmp	r4, #19
   8a270:	460b      	mov	r3, r1
   8a272:	dc10      	bgt.n	8a296 <trunc+0x32>
   8a274:	2c00      	cmp	r4, #0
   8a276:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   8a27a:	f04f 0000 	mov.w	r0, #0
   8a27e:	db22      	blt.n	8a2c6 <trunc+0x62>
   8a280:	4b14      	ldr	r3, [pc, #80]	; (8a2d4 <trunc+0x70>)
   8a282:	4123      	asrs	r3, r4
   8a284:	ea21 0503 	bic.w	r5, r1, r3
   8a288:	ea45 0102 	orr.w	r1, r5, r2
   8a28c:	460b      	mov	r3, r1
   8a28e:	4602      	mov	r2, r0
   8a290:	4610      	mov	r0, r2
   8a292:	4619      	mov	r1, r3
   8a294:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8a296:	2c33      	cmp	r4, #51	; 0x33
   8a298:	4602      	mov	r2, r0
   8a29a:	dd09      	ble.n	8a2b0 <trunc+0x4c>
   8a29c:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   8a2a0:	d1f6      	bne.n	8a290 <trunc+0x2c>
   8a2a2:	4602      	mov	r2, r0
   8a2a4:	460b      	mov	r3, r1
   8a2a6:	f001 fc53 	bl	8bb50 <__adddf3>
   8a2aa:	4602      	mov	r2, r0
   8a2ac:	460b      	mov	r3, r1
   8a2ae:	e7ef      	b.n	8a290 <trunc+0x2c>
   8a2b0:	460b      	mov	r3, r1
   8a2b2:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
   8a2b6:	f04f 31ff 	mov.w	r1, #4294967295
   8a2ba:	40f1      	lsrs	r1, r6
   8a2bc:	ea20 0201 	bic.w	r2, r0, r1
   8a2c0:	4610      	mov	r0, r2
   8a2c2:	4619      	mov	r1, r3
   8a2c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8a2c6:	4611      	mov	r1, r2
   8a2c8:	4602      	mov	r2, r0
   8a2ca:	460b      	mov	r3, r1
   8a2cc:	4610      	mov	r0, r2
   8a2ce:	4619      	mov	r1, r3
   8a2d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8a2d2:	bf00      	nop
   8a2d4:	000fffff 	.word	0x000fffff

0008a2d8 <atan2>:
   8a2d8:	f000 b856 	b.w	8a388 <__ieee754_atan2>

0008a2dc <sqrt>:
   8a2dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8a2e0:	b08a      	sub	sp, #40	; 0x28
   8a2e2:	4606      	mov	r6, r0
   8a2e4:	460f      	mov	r7, r1
   8a2e6:	f000 fb3d 	bl	8a964 <__ieee754_sqrt>
   8a2ea:	f8df a098 	ldr.w	sl, [pc, #152]	; 8a384 <sqrt+0xa8>
   8a2ee:	4604      	mov	r4, r0
   8a2f0:	f99a 3000 	ldrsb.w	r3, [sl]
   8a2f4:	460d      	mov	r5, r1
   8a2f6:	3301      	adds	r3, #1
   8a2f8:	d00f      	beq.n	8a31a <sqrt+0x3e>
   8a2fa:	4630      	mov	r0, r6
   8a2fc:	4639      	mov	r1, r7
   8a2fe:	f001 fb75 	bl	8b9ec <__fpclassifyd>
   8a302:	b150      	cbz	r0, 8a31a <sqrt+0x3e>
   8a304:	f04f 0800 	mov.w	r8, #0
   8a308:	f04f 0900 	mov.w	r9, #0
   8a30c:	4630      	mov	r0, r6
   8a30e:	4639      	mov	r1, r7
   8a310:	4642      	mov	r2, r8
   8a312:	464b      	mov	r3, r9
   8a314:	f002 f840 	bl	8c398 <__aeabi_dcmplt>
   8a318:	b920      	cbnz	r0, 8a324 <sqrt+0x48>
   8a31a:	4620      	mov	r0, r4
   8a31c:	4629      	mov	r1, r5
   8a31e:	b00a      	add	sp, #40	; 0x28
   8a320:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   8a324:	4916      	ldr	r1, [pc, #88]	; (8a380 <sqrt+0xa4>)
   8a326:	f89a 4000 	ldrb.w	r4, [sl]
   8a32a:	2201      	movs	r2, #1
   8a32c:	2300      	movs	r3, #0
   8a32e:	e9cd 6704 	strd	r6, r7, [sp, #16]
   8a332:	e9cd 6702 	strd	r6, r7, [sp, #8]
   8a336:	9101      	str	r1, [sp, #4]
   8a338:	9200      	str	r2, [sp, #0]
   8a33a:	9308      	str	r3, [sp, #32]
   8a33c:	b964      	cbnz	r4, 8a358 <sqrt+0x7c>
   8a33e:	e9cd 8906 	strd	r8, r9, [sp, #24]
   8a342:	4668      	mov	r0, sp
   8a344:	f001 fb7e 	bl	8ba44 <matherr>
   8a348:	b180      	cbz	r0, 8a36c <sqrt+0x90>
   8a34a:	9b08      	ldr	r3, [sp, #32]
   8a34c:	b99b      	cbnz	r3, 8a376 <sqrt+0x9a>
   8a34e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   8a352:	b00a      	add	sp, #40	; 0x28
   8a354:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   8a358:	4640      	mov	r0, r8
   8a35a:	4649      	mov	r1, r9
   8a35c:	4642      	mov	r2, r8
   8a35e:	464b      	mov	r3, r9
   8a360:	f001 fed2 	bl	8c108 <__aeabi_ddiv>
   8a364:	2c02      	cmp	r4, #2
   8a366:	e9cd 0106 	strd	r0, r1, [sp, #24]
   8a36a:	d1ea      	bne.n	8a342 <sqrt+0x66>
   8a36c:	f002 fbf2 	bl	8cb54 <__errno>
   8a370:	2321      	movs	r3, #33	; 0x21
   8a372:	6003      	str	r3, [r0, #0]
   8a374:	e7e9      	b.n	8a34a <sqrt+0x6e>
   8a376:	f002 fbed 	bl	8cb54 <__errno>
   8a37a:	9b08      	ldr	r3, [sp, #32]
   8a37c:	6003      	str	r3, [r0, #0]
   8a37e:	e7e6      	b.n	8a34e <sqrt+0x72>
   8a380:	00091f34 	.word	0x00091f34
   8a384:	2000004c 	.word	0x2000004c

0008a388 <__ieee754_atan2>:
   8a388:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8a38c:	4254      	negs	r4, r2
   8a38e:	4314      	orrs	r4, r2
   8a390:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   8a394:	f8df c178 	ldr.w	ip, [pc, #376]	; 8a510 <__ieee754_atan2+0x188>
   8a398:	ea49 74d4 	orr.w	r4, r9, r4, lsr #31
   8a39c:	4564      	cmp	r4, ip
   8a39e:	4617      	mov	r7, r2
   8a3a0:	469e      	mov	lr, r3
   8a3a2:	4606      	mov	r6, r0
   8a3a4:	460d      	mov	r5, r1
   8a3a6:	d841      	bhi.n	8a42c <__ieee754_atan2+0xa4>
   8a3a8:	4244      	negs	r4, r0
   8a3aa:	4304      	orrs	r4, r0
   8a3ac:	f021 4b00 	bic.w	fp, r1, #2147483648	; 0x80000000
   8a3b0:	ea4b 74d4 	orr.w	r4, fp, r4, lsr #31
   8a3b4:	4564      	cmp	r4, ip
   8a3b6:	468a      	mov	sl, r1
   8a3b8:	d838      	bhi.n	8a42c <__ieee754_atan2+0xa4>
   8a3ba:	f103 4440 	add.w	r4, r3, #3221225472	; 0xc0000000
   8a3be:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   8a3c2:	4314      	orrs	r4, r2
   8a3c4:	d049      	beq.n	8a45a <__ieee754_atan2+0xd2>
   8a3c6:	179c      	asrs	r4, r3, #30
   8a3c8:	f004 0402 	and.w	r4, r4, #2
   8a3cc:	ea44 74d1 	orr.w	r4, r4, r1, lsr #31
   8a3d0:	ea5b 0100 	orrs.w	r1, fp, r0
   8a3d4:	d032      	beq.n	8a43c <__ieee754_atan2+0xb4>
   8a3d6:	ea59 0107 	orrs.w	r1, r9, r7
   8a3da:	d038      	beq.n	8a44e <__ieee754_atan2+0xc6>
   8a3dc:	494c      	ldr	r1, [pc, #304]	; (8a510 <__ieee754_atan2+0x188>)
   8a3de:	4589      	cmp	r9, r1
   8a3e0:	d048      	beq.n	8a474 <__ieee754_atan2+0xec>
   8a3e2:	494b      	ldr	r1, [pc, #300]	; (8a510 <__ieee754_atan2+0x188>)
   8a3e4:	458b      	cmp	fp, r1
   8a3e6:	d032      	beq.n	8a44e <__ieee754_atan2+0xc6>
   8a3e8:	ebc9 090b 	rsb	r9, r9, fp
   8a3ec:	ea4f 5929 	mov.w	r9, r9, asr #20
   8a3f0:	f1b9 0f3c 	cmp.w	r9, #60	; 0x3c
   8a3f4:	dc3a      	bgt.n	8a46c <__ieee754_atan2+0xe4>
   8a3f6:	f1be 0f00 	cmp.w	lr, #0
   8a3fa:	db64      	blt.n	8a4c6 <__ieee754_atan2+0x13e>
   8a3fc:	4630      	mov	r0, r6
   8a3fe:	4629      	mov	r1, r5
   8a400:	f001 fe82 	bl	8c108 <__aeabi_ddiv>
   8a404:	f001 faee 	bl	8b9e4 <fabs>
   8a408:	f001 f952 	bl	8b6b0 <atan>
   8a40c:	2c01      	cmp	r4, #1
   8a40e:	d057      	beq.n	8a4c0 <__ieee754_atan2+0x138>
   8a410:	2c02      	cmp	r4, #2
   8a412:	d048      	beq.n	8a4a6 <__ieee754_atan2+0x11e>
   8a414:	b184      	cbz	r4, 8a438 <__ieee754_atan2+0xb0>
   8a416:	a338      	add	r3, pc, #224	; (adr r3, 8a4f8 <__ieee754_atan2+0x170>)
   8a418:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a41c:	f001 fb96 	bl	8bb4c <__aeabi_dsub>
   8a420:	a337      	add	r3, pc, #220	; (adr r3, 8a500 <__ieee754_atan2+0x178>)
   8a422:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a426:	f001 fb91 	bl	8bb4c <__aeabi_dsub>
   8a42a:	e005      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a42c:	4610      	mov	r0, r2
   8a42e:	4619      	mov	r1, r3
   8a430:	4632      	mov	r2, r6
   8a432:	462b      	mov	r3, r5
   8a434:	f001 fb8c 	bl	8bb50 <__adddf3>
   8a438:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8a43c:	2c03      	cmp	r4, #3
   8a43e:	d8ca      	bhi.n	8a3d6 <__ieee754_atan2+0x4e>
   8a440:	e8df f004 	tbb	[pc, r4]
   8a444:	0f021212 	.word	0x0f021212
   8a448:	4832      	ldr	r0, [pc, #200]	; (8a514 <__ieee754_atan2+0x18c>)
   8a44a:	4933      	ldr	r1, [pc, #204]	; (8a518 <__ieee754_atan2+0x190>)
   8a44c:	e7f4      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a44e:	f1ba 0f00 	cmp.w	sl, #0
   8a452:	4830      	ldr	r0, [pc, #192]	; (8a514 <__ieee754_atan2+0x18c>)
   8a454:	db25      	blt.n	8a4a2 <__ieee754_atan2+0x11a>
   8a456:	4931      	ldr	r1, [pc, #196]	; (8a51c <__ieee754_atan2+0x194>)
   8a458:	e7ee      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a45a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8a45e:	f001 b927 	b.w	8b6b0 <atan>
   8a462:	482c      	ldr	r0, [pc, #176]	; (8a514 <__ieee754_atan2+0x18c>)
   8a464:	492e      	ldr	r1, [pc, #184]	; (8a520 <__ieee754_atan2+0x198>)
   8a466:	e7e7      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a468:	4629      	mov	r1, r5
   8a46a:	e7e5      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a46c:	a126      	add	r1, pc, #152	; (adr r1, 8a508 <__ieee754_atan2+0x180>)
   8a46e:	e9d1 0100 	ldrd	r0, r1, [r1]
   8a472:	e7cb      	b.n	8a40c <__ieee754_atan2+0x84>
   8a474:	45cb      	cmp	fp, r9
   8a476:	d02c      	beq.n	8a4d2 <__ieee754_atan2+0x14a>
   8a478:	2c03      	cmp	r4, #3
   8a47a:	d8b2      	bhi.n	8a3e2 <__ieee754_atan2+0x5a>
   8a47c:	a101      	add	r1, pc, #4	; (adr r1, 8a484 <__ieee754_atan2+0xfc>)
   8a47e:	f851 f024 	ldr.w	pc, [r1, r4, lsl #2]
   8a482:	bf00      	nop
   8a484:	0008a495 	.word	0x0008a495
   8a488:	0008a49b 	.word	0x0008a49b
   8a48c:	0008a449 	.word	0x0008a449
   8a490:	0008a463 	.word	0x0008a463
   8a494:	2000      	movs	r0, #0
   8a496:	4601      	mov	r1, r0
   8a498:	e7ce      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a49a:	2000      	movs	r0, #0
   8a49c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   8a4a0:	e7ca      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4a2:	4920      	ldr	r1, [pc, #128]	; (8a524 <__ieee754_atan2+0x19c>)
   8a4a4:	e7c8      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4a6:	a314      	add	r3, pc, #80	; (adr r3, 8a4f8 <__ieee754_atan2+0x170>)
   8a4a8:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a4ac:	f001 fb4e 	bl	8bb4c <__aeabi_dsub>
   8a4b0:	4602      	mov	r2, r0
   8a4b2:	460b      	mov	r3, r1
   8a4b4:	a112      	add	r1, pc, #72	; (adr r1, 8a500 <__ieee754_atan2+0x178>)
   8a4b6:	e9d1 0100 	ldrd	r0, r1, [r1]
   8a4ba:	f001 fb47 	bl	8bb4c <__aeabi_dsub>
   8a4be:	e7bb      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4c0:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8a4c4:	e7b8      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4c6:	f119 0f3c 	cmn.w	r9, #60	; 0x3c
   8a4ca:	da97      	bge.n	8a3fc <__ieee754_atan2+0x74>
   8a4cc:	2000      	movs	r0, #0
   8a4ce:	2100      	movs	r1, #0
   8a4d0:	e79c      	b.n	8a40c <__ieee754_atan2+0x84>
   8a4d2:	2c03      	cmp	r4, #3
   8a4d4:	d8bb      	bhi.n	8a44e <__ieee754_atan2+0xc6>
   8a4d6:	e8df f004 	tbb	[pc, r4]
   8a4da:	0b02      	.short	0x0b02
   8a4dc:	0508      	.short	0x0508
   8a4de:	480d      	ldr	r0, [pc, #52]	; (8a514 <__ieee754_atan2+0x18c>)
   8a4e0:	4911      	ldr	r1, [pc, #68]	; (8a528 <__ieee754_atan2+0x1a0>)
   8a4e2:	e7a9      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4e4:	4811      	ldr	r0, [pc, #68]	; (8a52c <__ieee754_atan2+0x1a4>)
   8a4e6:	4912      	ldr	r1, [pc, #72]	; (8a530 <__ieee754_atan2+0x1a8>)
   8a4e8:	e7a6      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4ea:	4810      	ldr	r0, [pc, #64]	; (8a52c <__ieee754_atan2+0x1a4>)
   8a4ec:	4911      	ldr	r1, [pc, #68]	; (8a534 <__ieee754_atan2+0x1ac>)
   8a4ee:	e7a3      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4f0:	4808      	ldr	r0, [pc, #32]	; (8a514 <__ieee754_atan2+0x18c>)
   8a4f2:	4911      	ldr	r1, [pc, #68]	; (8a538 <__ieee754_atan2+0x1b0>)
   8a4f4:	e7a0      	b.n	8a438 <__ieee754_atan2+0xb0>
   8a4f6:	bf00      	nop
   8a4f8:	33145c07 	.word	0x33145c07
   8a4fc:	3ca1a626 	.word	0x3ca1a626
   8a500:	54442d18 	.word	0x54442d18
   8a504:	400921fb 	.word	0x400921fb
   8a508:	54442d18 	.word	0x54442d18
   8a50c:	3ff921fb 	.word	0x3ff921fb
   8a510:	7ff00000 	.word	0x7ff00000
   8a514:	54442d18 	.word	0x54442d18
   8a518:	400921fb 	.word	0x400921fb
   8a51c:	3ff921fb 	.word	0x3ff921fb
   8a520:	c00921fb 	.word	0xc00921fb
   8a524:	bff921fb 	.word	0xbff921fb
   8a528:	3fe921fb 	.word	0x3fe921fb
   8a52c:	7f3321d2 	.word	0x7f3321d2
   8a530:	c002d97c 	.word	0xc002d97c
   8a534:	4002d97c 	.word	0x4002d97c
   8a538:	bfe921fb 	.word	0xbfe921fb
   8a53c:	00000000 	.word	0x00000000

0008a540 <__ieee754_rem_pio2>:
   8a540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8a544:	4c92      	ldr	r4, [pc, #584]	; (8a790 <__ieee754_rem_pio2+0x250>)
   8a546:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
   8a54a:	42a7      	cmp	r7, r4
   8a54c:	b08f      	sub	sp, #60	; 0x3c
   8a54e:	460e      	mov	r6, r1
   8a550:	dd7f      	ble.n	8a652 <__ieee754_rem_pio2+0x112>
   8a552:	4614      	mov	r4, r2
   8a554:	4a8f      	ldr	r2, [pc, #572]	; (8a794 <__ieee754_rem_pio2+0x254>)
   8a556:	4297      	cmp	r7, r2
   8a558:	dc26      	bgt.n	8a5a8 <__ieee754_rem_pio2+0x68>
   8a55a:	a383      	add	r3, pc, #524	; (adr r3, 8a768 <__ieee754_rem_pio2+0x228>)
   8a55c:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a560:	2900      	cmp	r1, #0
   8a562:	f340 819d 	ble.w	8a8a0 <__ieee754_rem_pio2+0x360>
   8a566:	f001 faf1 	bl	8bb4c <__aeabi_dsub>
   8a56a:	4b8b      	ldr	r3, [pc, #556]	; (8a798 <__ieee754_rem_pio2+0x258>)
   8a56c:	4680      	mov	r8, r0
   8a56e:	429f      	cmp	r7, r3
   8a570:	4689      	mov	r9, r1
   8a572:	f000 8083 	beq.w	8a67c <__ieee754_rem_pio2+0x13c>
   8a576:	a37e      	add	r3, pc, #504	; (adr r3, 8a770 <__ieee754_rem_pio2+0x230>)
   8a578:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a57c:	f001 fae6 	bl	8bb4c <__aeabi_dsub>
   8a580:	4602      	mov	r2, r0
   8a582:	460b      	mov	r3, r1
   8a584:	4640      	mov	r0, r8
   8a586:	e9c4 2300 	strd	r2, r3, [r4]
   8a58a:	4649      	mov	r1, r9
   8a58c:	f001 fade 	bl	8bb4c <__aeabi_dsub>
   8a590:	a377      	add	r3, pc, #476	; (adr r3, 8a770 <__ieee754_rem_pio2+0x230>)
   8a592:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a596:	f001 fad9 	bl	8bb4c <__aeabi_dsub>
   8a59a:	2501      	movs	r5, #1
   8a59c:	e9c4 0102 	strd	r0, r1, [r4, #8]
   8a5a0:	4628      	mov	r0, r5
   8a5a2:	b00f      	add	sp, #60	; 0x3c
   8a5a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8a5a8:	4a7c      	ldr	r2, [pc, #496]	; (8a79c <__ieee754_rem_pio2+0x25c>)
   8a5aa:	4297      	cmp	r7, r2
   8a5ac:	f340 8083 	ble.w	8a6b6 <__ieee754_rem_pio2+0x176>
   8a5b0:	4a7b      	ldr	r2, [pc, #492]	; (8a7a0 <__ieee754_rem_pio2+0x260>)
   8a5b2:	4297      	cmp	r7, r2
   8a5b4:	dc58      	bgt.n	8a668 <__ieee754_rem_pio2+0x128>
   8a5b6:	153d      	asrs	r5, r7, #20
   8a5b8:	f2a5 4516 	subw	r5, r5, #1046	; 0x416
   8a5bc:	eba7 5105 	sub.w	r1, r7, r5, lsl #20
   8a5c0:	468b      	mov	fp, r1
   8a5c2:	4682      	mov	sl, r0
   8a5c4:	f001 ff10 	bl	8c3e8 <__aeabi_d2iz>
   8a5c8:	f001 fc0e 	bl	8bde8 <__aeabi_i2d>
   8a5cc:	4680      	mov	r8, r0
   8a5ce:	4689      	mov	r9, r1
   8a5d0:	4642      	mov	r2, r8
   8a5d2:	464b      	mov	r3, r9
   8a5d4:	4650      	mov	r0, sl
   8a5d6:	4659      	mov	r1, fp
   8a5d8:	e9cd 8908 	strd	r8, r9, [sp, #32]
   8a5dc:	f001 fab6 	bl	8bb4c <__aeabi_dsub>
   8a5e0:	2200      	movs	r2, #0
   8a5e2:	4b70      	ldr	r3, [pc, #448]	; (8a7a4 <__ieee754_rem_pio2+0x264>)
   8a5e4:	f001 fc66 	bl	8beb4 <__aeabi_dmul>
   8a5e8:	468b      	mov	fp, r1
   8a5ea:	4682      	mov	sl, r0
   8a5ec:	f001 fefc 	bl	8c3e8 <__aeabi_d2iz>
   8a5f0:	f001 fbfa 	bl	8bde8 <__aeabi_i2d>
   8a5f4:	4680      	mov	r8, r0
   8a5f6:	4689      	mov	r9, r1
   8a5f8:	4642      	mov	r2, r8
   8a5fa:	464b      	mov	r3, r9
   8a5fc:	4650      	mov	r0, sl
   8a5fe:	4659      	mov	r1, fp
   8a600:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
   8a604:	f001 faa2 	bl	8bb4c <__aeabi_dsub>
   8a608:	2200      	movs	r2, #0
   8a60a:	4b66      	ldr	r3, [pc, #408]	; (8a7a4 <__ieee754_rem_pio2+0x264>)
   8a60c:	f001 fc52 	bl	8beb4 <__aeabi_dmul>
   8a610:	2200      	movs	r2, #0
   8a612:	2300      	movs	r3, #0
   8a614:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   8a618:	f001 feb4 	bl	8c384 <__aeabi_dcmpeq>
   8a61c:	2800      	cmp	r0, #0
   8a61e:	f000 8167 	beq.w	8a8f0 <__ieee754_rem_pio2+0x3b0>
   8a622:	2300      	movs	r3, #0
   8a624:	4640      	mov	r0, r8
   8a626:	4649      	mov	r1, r9
   8a628:	2200      	movs	r2, #0
   8a62a:	f001 feab 	bl	8c384 <__aeabi_dcmpeq>
   8a62e:	2800      	cmp	r0, #0
   8a630:	bf14      	ite	ne
   8a632:	2301      	movne	r3, #1
   8a634:	2302      	moveq	r3, #2
   8a636:	485c      	ldr	r0, [pc, #368]	; (8a7a8 <__ieee754_rem_pio2+0x268>)
   8a638:	2102      	movs	r1, #2
   8a63a:	9001      	str	r0, [sp, #4]
   8a63c:	9100      	str	r1, [sp, #0]
   8a63e:	462a      	mov	r2, r5
   8a640:	a808      	add	r0, sp, #32
   8a642:	4621      	mov	r1, r4
   8a644:	f000 fb78 	bl	8ad38 <__kernel_rem_pio2>
   8a648:	2e00      	cmp	r6, #0
   8a64a:	f2c0 8147 	blt.w	8a8dc <__ieee754_rem_pio2+0x39c>
   8a64e:	4605      	mov	r5, r0
   8a650:	e006      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a652:	e9c2 0100 	strd	r0, r1, [r2]
   8a656:	2500      	movs	r5, #0
   8a658:	2400      	movs	r4, #0
   8a65a:	e9c2 4502 	strd	r4, r5, [r2, #8]
   8a65e:	2500      	movs	r5, #0
   8a660:	4628      	mov	r0, r5
   8a662:	b00f      	add	sp, #60	; 0x3c
   8a664:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8a668:	4602      	mov	r2, r0
   8a66a:	460b      	mov	r3, r1
   8a66c:	f001 fa6e 	bl	8bb4c <__aeabi_dsub>
   8a670:	2500      	movs	r5, #0
   8a672:	e9c4 0102 	strd	r0, r1, [r4, #8]
   8a676:	e9c4 0100 	strd	r0, r1, [r4]
   8a67a:	e7f1      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a67c:	a33e      	add	r3, pc, #248	; (adr r3, 8a778 <__ieee754_rem_pio2+0x238>)
   8a67e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a682:	f001 fa63 	bl	8bb4c <__aeabi_dsub>
   8a686:	a33e      	add	r3, pc, #248	; (adr r3, 8a780 <__ieee754_rem_pio2+0x240>)
   8a688:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a68c:	4606      	mov	r6, r0
   8a68e:	460f      	mov	r7, r1
   8a690:	f001 fa5c 	bl	8bb4c <__aeabi_dsub>
   8a694:	4602      	mov	r2, r0
   8a696:	460b      	mov	r3, r1
   8a698:	4630      	mov	r0, r6
   8a69a:	e9c4 2300 	strd	r2, r3, [r4]
   8a69e:	4639      	mov	r1, r7
   8a6a0:	f001 fa54 	bl	8bb4c <__aeabi_dsub>
   8a6a4:	a336      	add	r3, pc, #216	; (adr r3, 8a780 <__ieee754_rem_pio2+0x240>)
   8a6a6:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a6aa:	f001 fa4f 	bl	8bb4c <__aeabi_dsub>
   8a6ae:	2501      	movs	r5, #1
   8a6b0:	e9c4 0102 	strd	r0, r1, [r4, #8]
   8a6b4:	e7d4      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a6b6:	f001 f995 	bl	8b9e4 <fabs>
   8a6ba:	a333      	add	r3, pc, #204	; (adr r3, 8a788 <__ieee754_rem_pio2+0x248>)
   8a6bc:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a6c0:	4680      	mov	r8, r0
   8a6c2:	4689      	mov	r9, r1
   8a6c4:	f001 fbf6 	bl	8beb4 <__aeabi_dmul>
   8a6c8:	2200      	movs	r2, #0
   8a6ca:	4b38      	ldr	r3, [pc, #224]	; (8a7ac <__ieee754_rem_pio2+0x26c>)
   8a6cc:	f001 fa40 	bl	8bb50 <__adddf3>
   8a6d0:	f001 fe8a 	bl	8c3e8 <__aeabi_d2iz>
   8a6d4:	4605      	mov	r5, r0
   8a6d6:	f001 fb87 	bl	8bde8 <__aeabi_i2d>
   8a6da:	a323      	add	r3, pc, #140	; (adr r3, 8a768 <__ieee754_rem_pio2+0x228>)
   8a6dc:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a6e0:	e9cd 0104 	strd	r0, r1, [sp, #16]
   8a6e4:	f001 fbe6 	bl	8beb4 <__aeabi_dmul>
   8a6e8:	4602      	mov	r2, r0
   8a6ea:	460b      	mov	r3, r1
   8a6ec:	4640      	mov	r0, r8
   8a6ee:	4649      	mov	r1, r9
   8a6f0:	f001 fa2c 	bl	8bb4c <__aeabi_dsub>
   8a6f4:	a31e      	add	r3, pc, #120	; (adr r3, 8a770 <__ieee754_rem_pio2+0x230>)
   8a6f6:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a6fa:	4682      	mov	sl, r0
   8a6fc:	468b      	mov	fp, r1
   8a6fe:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8a702:	f001 fbd7 	bl	8beb4 <__aeabi_dmul>
   8a706:	2d1f      	cmp	r5, #31
   8a708:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8a70c:	4650      	mov	r0, sl
   8a70e:	4659      	mov	r1, fp
   8a710:	dc50      	bgt.n	8a7b4 <__ieee754_rem_pio2+0x274>
   8a712:	4b27      	ldr	r3, [pc, #156]	; (8a7b0 <__ieee754_rem_pio2+0x270>)
   8a714:	1e6a      	subs	r2, r5, #1
   8a716:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8a71a:	42bb      	cmp	r3, r7
   8a71c:	d04a      	beq.n	8a7b4 <__ieee754_rem_pio2+0x274>
   8a71e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8a722:	f001 fa13 	bl	8bb4c <__aeabi_dsub>
   8a726:	4602      	mov	r2, r0
   8a728:	460b      	mov	r3, r1
   8a72a:	4681      	mov	r9, r0
   8a72c:	4688      	mov	r8, r1
   8a72e:	e9c4 2300 	strd	r2, r3, [r4]
   8a732:	464a      	mov	r2, r9
   8a734:	4643      	mov	r3, r8
   8a736:	4650      	mov	r0, sl
   8a738:	4659      	mov	r1, fp
   8a73a:	f001 fa07 	bl	8bb4c <__aeabi_dsub>
   8a73e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8a742:	f001 fa03 	bl	8bb4c <__aeabi_dsub>
   8a746:	4602      	mov	r2, r0
   8a748:	460b      	mov	r3, r1
   8a74a:	2e00      	cmp	r6, #0
   8a74c:	e9c4 2302 	strd	r2, r3, [r4, #8]
   8a750:	da86      	bge.n	8a660 <__ieee754_rem_pio2+0x120>
   8a752:	464a      	mov	r2, r9
   8a754:	f108 4300 	add.w	r3, r8, #2147483648	; 0x80000000
   8a758:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8a75c:	e884 000c 	stmia.w	r4, {r2, r3}
   8a760:	60e1      	str	r1, [r4, #12]
   8a762:	60a0      	str	r0, [r4, #8]
   8a764:	426d      	negs	r5, r5
   8a766:	e77b      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a768:	54400000 	.word	0x54400000
   8a76c:	3ff921fb 	.word	0x3ff921fb
   8a770:	1a626331 	.word	0x1a626331
   8a774:	3dd0b461 	.word	0x3dd0b461
   8a778:	1a600000 	.word	0x1a600000
   8a77c:	3dd0b461 	.word	0x3dd0b461
   8a780:	2e037073 	.word	0x2e037073
   8a784:	3ba3198a 	.word	0x3ba3198a
   8a788:	6dc9c883 	.word	0x6dc9c883
   8a78c:	3fe45f30 	.word	0x3fe45f30
   8a790:	3fe921fb 	.word	0x3fe921fb
   8a794:	4002d97b 	.word	0x4002d97b
   8a798:	3ff921fb 	.word	0x3ff921fb
   8a79c:	413921fb 	.word	0x413921fb
   8a7a0:	7fefffff 	.word	0x7fefffff
   8a7a4:	41700000 	.word	0x41700000
   8a7a8:	00091fbc 	.word	0x00091fbc
   8a7ac:	3fe00000 	.word	0x3fe00000
   8a7b0:	00091f3c 	.word	0x00091f3c
   8a7b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8a7b8:	f001 f9c8 	bl	8bb4c <__aeabi_dsub>
   8a7bc:	4688      	mov	r8, r1
   8a7be:	153f      	asrs	r7, r7, #20
   8a7c0:	f3c8 530a 	ubfx	r3, r8, #20, #11
   8a7c4:	1afb      	subs	r3, r7, r3
   8a7c6:	2b10      	cmp	r3, #16
   8a7c8:	4681      	mov	r9, r0
   8a7ca:	e9c4 0100 	strd	r0, r1, [r4]
   8a7ce:	ddb0      	ble.n	8a732 <__ieee754_rem_pio2+0x1f2>
   8a7d0:	a359      	add	r3, pc, #356	; (adr r3, 8a938 <__ieee754_rem_pio2+0x3f8>)
   8a7d2:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a7d6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8a7da:	f001 fb6b 	bl	8beb4 <__aeabi_dmul>
   8a7de:	4680      	mov	r8, r0
   8a7e0:	4689      	mov	r9, r1
   8a7e2:	4642      	mov	r2, r8
   8a7e4:	464b      	mov	r3, r9
   8a7e6:	4650      	mov	r0, sl
   8a7e8:	4659      	mov	r1, fp
   8a7ea:	f001 f9af 	bl	8bb4c <__aeabi_dsub>
   8a7ee:	e9cd 0106 	strd	r0, r1, [sp, #24]
   8a7f2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   8a7f6:	4650      	mov	r0, sl
   8a7f8:	4659      	mov	r1, fp
   8a7fa:	f001 f9a7 	bl	8bb4c <__aeabi_dsub>
   8a7fe:	4642      	mov	r2, r8
   8a800:	464b      	mov	r3, r9
   8a802:	f001 f9a3 	bl	8bb4c <__aeabi_dsub>
   8a806:	a34e      	add	r3, pc, #312	; (adr r3, 8a940 <__ieee754_rem_pio2+0x400>)
   8a808:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a80c:	4680      	mov	r8, r0
   8a80e:	4689      	mov	r9, r1
   8a810:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8a814:	f001 fb4e 	bl	8beb4 <__aeabi_dmul>
   8a818:	4642      	mov	r2, r8
   8a81a:	464b      	mov	r3, r9
   8a81c:	f001 f996 	bl	8bb4c <__aeabi_dsub>
   8a820:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8a824:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8a828:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   8a82c:	f001 f98e 	bl	8bb4c <__aeabi_dsub>
   8a830:	460b      	mov	r3, r1
   8a832:	4602      	mov	r2, r0
   8a834:	4688      	mov	r8, r1
   8a836:	f3c1 510a 	ubfx	r1, r1, #20, #11
   8a83a:	1a7f      	subs	r7, r7, r1
   8a83c:	2f31      	cmp	r7, #49	; 0x31
   8a83e:	4681      	mov	r9, r0
   8a840:	e9c4 2300 	strd	r2, r3, [r4]
   8a844:	dd74      	ble.n	8a930 <__ieee754_rem_pio2+0x3f0>
   8a846:	a340      	add	r3, pc, #256	; (adr r3, 8a948 <__ieee754_rem_pio2+0x408>)
   8a848:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a84c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8a850:	f001 fb30 	bl	8beb4 <__aeabi_dmul>
   8a854:	4680      	mov	r8, r0
   8a856:	4689      	mov	r9, r1
   8a858:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   8a85c:	4642      	mov	r2, r8
   8a85e:	464b      	mov	r3, r9
   8a860:	f001 f974 	bl	8bb4c <__aeabi_dsub>
   8a864:	4682      	mov	sl, r0
   8a866:	468b      	mov	fp, r1
   8a868:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   8a86c:	4652      	mov	r2, sl
   8a86e:	465b      	mov	r3, fp
   8a870:	f001 f96c 	bl	8bb4c <__aeabi_dsub>
   8a874:	4642      	mov	r2, r8
   8a876:	464b      	mov	r3, r9
   8a878:	f001 f968 	bl	8bb4c <__aeabi_dsub>
   8a87c:	a334      	add	r3, pc, #208	; (adr r3, 8a950 <__ieee754_rem_pio2+0x410>)
   8a87e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a882:	4680      	mov	r8, r0
   8a884:	4689      	mov	r9, r1
   8a886:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8a88a:	f001 fb13 	bl	8beb4 <__aeabi_dmul>
   8a88e:	4642      	mov	r2, r8
   8a890:	464b      	mov	r3, r9
   8a892:	f001 f95b 	bl	8bb4c <__aeabi_dsub>
   8a896:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8a89a:	4650      	mov	r0, sl
   8a89c:	4659      	mov	r1, fp
   8a89e:	e73e      	b.n	8a71e <__ieee754_rem_pio2+0x1de>
   8a8a0:	f001 f956 	bl	8bb50 <__adddf3>
   8a8a4:	4b2e      	ldr	r3, [pc, #184]	; (8a960 <__ieee754_rem_pio2+0x420>)
   8a8a6:	4680      	mov	r8, r0
   8a8a8:	429f      	cmp	r7, r3
   8a8aa:	4689      	mov	r9, r1
   8a8ac:	d022      	beq.n	8a8f4 <__ieee754_rem_pio2+0x3b4>
   8a8ae:	a32a      	add	r3, pc, #168	; (adr r3, 8a958 <__ieee754_rem_pio2+0x418>)
   8a8b0:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a8b4:	f001 f94c 	bl	8bb50 <__adddf3>
   8a8b8:	4602      	mov	r2, r0
   8a8ba:	460b      	mov	r3, r1
   8a8bc:	4640      	mov	r0, r8
   8a8be:	e9c4 2300 	strd	r2, r3, [r4]
   8a8c2:	4649      	mov	r1, r9
   8a8c4:	f001 f942 	bl	8bb4c <__aeabi_dsub>
   8a8c8:	a323      	add	r3, pc, #140	; (adr r3, 8a958 <__ieee754_rem_pio2+0x418>)
   8a8ca:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a8ce:	f001 f93f 	bl	8bb50 <__adddf3>
   8a8d2:	f04f 35ff 	mov.w	r5, #4294967295
   8a8d6:	e9c4 0102 	strd	r0, r1, [r4, #8]
   8a8da:	e6c1      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a8dc:	6862      	ldr	r2, [r4, #4]
   8a8de:	68e3      	ldr	r3, [r4, #12]
   8a8e0:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   8a8e4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   8a8e8:	4245      	negs	r5, r0
   8a8ea:	6062      	str	r2, [r4, #4]
   8a8ec:	60e3      	str	r3, [r4, #12]
   8a8ee:	e6b7      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a8f0:	2303      	movs	r3, #3
   8a8f2:	e6a0      	b.n	8a636 <__ieee754_rem_pio2+0xf6>
   8a8f4:	a310      	add	r3, pc, #64	; (adr r3, 8a938 <__ieee754_rem_pio2+0x3f8>)
   8a8f6:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a8fa:	f001 f929 	bl	8bb50 <__adddf3>
   8a8fe:	a310      	add	r3, pc, #64	; (adr r3, 8a940 <__ieee754_rem_pio2+0x400>)
   8a900:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a904:	4606      	mov	r6, r0
   8a906:	460f      	mov	r7, r1
   8a908:	f001 f922 	bl	8bb50 <__adddf3>
   8a90c:	4602      	mov	r2, r0
   8a90e:	460b      	mov	r3, r1
   8a910:	4630      	mov	r0, r6
   8a912:	e9c4 2300 	strd	r2, r3, [r4]
   8a916:	4639      	mov	r1, r7
   8a918:	f001 f918 	bl	8bb4c <__aeabi_dsub>
   8a91c:	a308      	add	r3, pc, #32	; (adr r3, 8a940 <__ieee754_rem_pio2+0x400>)
   8a91e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8a922:	f001 f915 	bl	8bb50 <__adddf3>
   8a926:	f04f 35ff 	mov.w	r5, #4294967295
   8a92a:	e9c4 0102 	strd	r0, r1, [r4, #8]
   8a92e:	e697      	b.n	8a660 <__ieee754_rem_pio2+0x120>
   8a930:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
   8a934:	e6fd      	b.n	8a732 <__ieee754_rem_pio2+0x1f2>
   8a936:	bf00      	nop
   8a938:	1a600000 	.word	0x1a600000
   8a93c:	3dd0b461 	.word	0x3dd0b461
   8a940:	2e037073 	.word	0x2e037073
   8a944:	3ba3198a 	.word	0x3ba3198a
   8a948:	2e000000 	.word	0x2e000000
   8a94c:	3ba3198a 	.word	0x3ba3198a
   8a950:	252049c1 	.word	0x252049c1
   8a954:	397b839a 	.word	0x397b839a
   8a958:	1a626331 	.word	0x1a626331
   8a95c:	3dd0b461 	.word	0x3dd0b461
   8a960:	3ff921fb 	.word	0x3ff921fb

0008a964 <__ieee754_sqrt>:
   8a964:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8a968:	4e60      	ldr	r6, [pc, #384]	; (8aaec <__ieee754_sqrt+0x188>)
   8a96a:	460c      	mov	r4, r1
   8a96c:	46b6      	mov	lr, r6
   8a96e:	400e      	ands	r6, r1
   8a970:	4576      	cmp	r6, lr
   8a972:	4605      	mov	r5, r0
   8a974:	460b      	mov	r3, r1
   8a976:	f000 8098 	beq.w	8aaaa <__ieee754_sqrt+0x146>
   8a97a:	2900      	cmp	r1, #0
   8a97c:	4602      	mov	r2, r0
   8a97e:	dd76      	ble.n	8aa6e <__ieee754_sqrt+0x10a>
   8a980:	ea5f 5e21 	movs.w	lr, r1, asr #20
   8a984:	f000 8081 	beq.w	8aa8a <__ieee754_sqrt+0x126>
   8a988:	f2ae 3eff 	subw	lr, lr, #1023	; 0x3ff
   8a98c:	f3c3 0313 	ubfx	r3, r3, #0, #20
   8a990:	f01e 0f01 	tst.w	lr, #1
   8a994:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8a998:	d15e      	bne.n	8aa58 <__ieee754_sqrt+0xf4>
   8a99a:	2700      	movs	r7, #0
   8a99c:	463c      	mov	r4, r7
   8a99e:	0fd1      	lsrs	r1, r2, #31
   8a9a0:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   8a9a4:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   8a9a8:	0052      	lsls	r2, r2, #1
   8a9aa:	2016      	movs	r0, #22
   8a9ac:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   8a9b0:	1865      	adds	r5, r4, r1
   8a9b2:	429d      	cmp	r5, r3
   8a9b4:	ea4f 76d2 	mov.w	r6, r2, lsr #31
   8a9b8:	ea4f 0242 	mov.w	r2, r2, lsl #1
   8a9bc:	dc02      	bgt.n	8a9c4 <__ieee754_sqrt+0x60>
   8a9be:	1b5b      	subs	r3, r3, r5
   8a9c0:	186c      	adds	r4, r5, r1
   8a9c2:	440f      	add	r7, r1
   8a9c4:	3801      	subs	r0, #1
   8a9c6:	eb06 0343 	add.w	r3, r6, r3, lsl #1
   8a9ca:	ea4f 0151 	mov.w	r1, r1, lsr #1
   8a9ce:	d1ef      	bne.n	8a9b0 <__ieee754_sqrt+0x4c>
   8a9d0:	4684      	mov	ip, r0
   8a9d2:	2620      	movs	r6, #32
   8a9d4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   8a9d8:	e00a      	b.n	8a9f0 <__ieee754_sqrt+0x8c>
   8a9da:	42a3      	cmp	r3, r4
   8a9dc:	d020      	beq.n	8aa20 <__ieee754_sqrt+0xbc>
   8a9de:	0fd5      	lsrs	r5, r2, #31
   8a9e0:	3e01      	subs	r6, #1
   8a9e2:	ea4f 0151 	mov.w	r1, r1, lsr #1
   8a9e6:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   8a9ea:	ea4f 0242 	mov.w	r2, r2, lsl #1
   8a9ee:	d020      	beq.n	8aa32 <__ieee754_sqrt+0xce>
   8a9f0:	429c      	cmp	r4, r3
   8a9f2:	eb0c 0501 	add.w	r5, ip, r1
   8a9f6:	daf0      	bge.n	8a9da <__ieee754_sqrt+0x76>
   8a9f8:	2d00      	cmp	r5, #0
   8a9fa:	eb05 0c01 	add.w	ip, r5, r1
   8a9fe:	db09      	blt.n	8aa14 <__ieee754_sqrt+0xb0>
   8aa00:	46a0      	mov	r8, r4
   8aa02:	1b1b      	subs	r3, r3, r4
   8aa04:	4295      	cmp	r5, r2
   8aa06:	bf88      	it	hi
   8aa08:	f103 33ff 	addhi.w	r3, r3, #4294967295
   8aa0c:	4644      	mov	r4, r8
   8aa0e:	1b52      	subs	r2, r2, r5
   8aa10:	4408      	add	r0, r1
   8aa12:	e7e4      	b.n	8a9de <__ieee754_sqrt+0x7a>
   8aa14:	f1bc 0f00 	cmp.w	ip, #0
   8aa18:	dbf2      	blt.n	8aa00 <__ieee754_sqrt+0x9c>
   8aa1a:	f104 0801 	add.w	r8, r4, #1
   8aa1e:	e7f0      	b.n	8aa02 <__ieee754_sqrt+0x9e>
   8aa20:	4295      	cmp	r5, r2
   8aa22:	d817      	bhi.n	8aa54 <__ieee754_sqrt+0xf0>
   8aa24:	2d00      	cmp	r5, #0
   8aa26:	eb05 0c01 	add.w	ip, r5, r1
   8aa2a:	db48      	blt.n	8aabe <__ieee754_sqrt+0x15a>
   8aa2c:	4698      	mov	r8, r3
   8aa2e:	2300      	movs	r3, #0
   8aa30:	e7ec      	b.n	8aa0c <__ieee754_sqrt+0xa8>
   8aa32:	4313      	orrs	r3, r2
   8aa34:	d115      	bne.n	8aa62 <__ieee754_sqrt+0xfe>
   8aa36:	0840      	lsrs	r0, r0, #1
   8aa38:	107b      	asrs	r3, r7, #1
   8aa3a:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
   8aa3e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   8aa42:	07fa      	lsls	r2, r7, #31
   8aa44:	eb03 570e 	add.w	r7, r3, lr, lsl #20
   8aa48:	4639      	mov	r1, r7
   8aa4a:	bf48      	it	mi
   8aa4c:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
   8aa50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8aa54:	461c      	mov	r4, r3
   8aa56:	e7c2      	b.n	8a9de <__ieee754_sqrt+0x7a>
   8aa58:	0fd1      	lsrs	r1, r2, #31
   8aa5a:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   8aa5e:	0052      	lsls	r2, r2, #1
   8aa60:	e79b      	b.n	8a99a <__ieee754_sqrt+0x36>
   8aa62:	1c41      	adds	r1, r0, #1
   8aa64:	d031      	beq.n	8aaca <__ieee754_sqrt+0x166>
   8aa66:	f000 0301 	and.w	r3, r0, #1
   8aa6a:	4418      	add	r0, r3
   8aa6c:	e7e3      	b.n	8aa36 <__ieee754_sqrt+0xd2>
   8aa6e:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   8aa72:	4306      	orrs	r6, r0
   8aa74:	d0ec      	beq.n	8aa50 <__ieee754_sqrt+0xec>
   8aa76:	bb79      	cbnz	r1, 8aad8 <__ieee754_sqrt+0x174>
   8aa78:	468e      	mov	lr, r1
   8aa7a:	0ad3      	lsrs	r3, r2, #11
   8aa7c:	f1ae 0e15 	sub.w	lr, lr, #21
   8aa80:	0552      	lsls	r2, r2, #21
   8aa82:	2b00      	cmp	r3, #0
   8aa84:	d0f9      	beq.n	8aa7a <__ieee754_sqrt+0x116>
   8aa86:	02dc      	lsls	r4, r3, #11
   8aa88:	d422      	bmi.n	8aad0 <__ieee754_sqrt+0x16c>
   8aa8a:	2100      	movs	r1, #0
   8aa8c:	005b      	lsls	r3, r3, #1
   8aa8e:	02d8      	lsls	r0, r3, #11
   8aa90:	f101 0101 	add.w	r1, r1, #1
   8aa94:	d5fa      	bpl.n	8aa8c <__ieee754_sqrt+0x128>
   8aa96:	f1c1 0001 	rsb	r0, r1, #1
   8aa9a:	f1c1 0420 	rsb	r4, r1, #32
   8aa9e:	fa22 f404 	lsr.w	r4, r2, r4
   8aaa2:	4323      	orrs	r3, r4
   8aaa4:	4486      	add	lr, r0
   8aaa6:	408a      	lsls	r2, r1
   8aaa8:	e76e      	b.n	8a988 <__ieee754_sqrt+0x24>
   8aaaa:	4602      	mov	r2, r0
   8aaac:	460b      	mov	r3, r1
   8aaae:	f001 fa01 	bl	8beb4 <__aeabi_dmul>
   8aab2:	462a      	mov	r2, r5
   8aab4:	4623      	mov	r3, r4
   8aab6:	f001 f84b 	bl	8bb50 <__adddf3>
   8aaba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8aabe:	f1bc 0f00 	cmp.w	ip, #0
   8aac2:	daaa      	bge.n	8aa1a <__ieee754_sqrt+0xb6>
   8aac4:	46a0      	mov	r8, r4
   8aac6:	2300      	movs	r3, #0
   8aac8:	e7a0      	b.n	8aa0c <__ieee754_sqrt+0xa8>
   8aaca:	3701      	adds	r7, #1
   8aacc:	4630      	mov	r0, r6
   8aace:	e7b3      	b.n	8aa38 <__ieee754_sqrt+0xd4>
   8aad0:	2420      	movs	r4, #32
   8aad2:	2001      	movs	r0, #1
   8aad4:	2100      	movs	r1, #0
   8aad6:	e7e2      	b.n	8aa9e <__ieee754_sqrt+0x13a>
   8aad8:	4602      	mov	r2, r0
   8aada:	460b      	mov	r3, r1
   8aadc:	f001 f836 	bl	8bb4c <__aeabi_dsub>
   8aae0:	4602      	mov	r2, r0
   8aae2:	460b      	mov	r3, r1
   8aae4:	f001 fb10 	bl	8c108 <__aeabi_ddiv>
   8aae8:	e7b2      	b.n	8aa50 <__ieee754_sqrt+0xec>
   8aaea:	bf00      	nop
   8aaec:	7ff00000 	.word	0x7ff00000

0008aaf0 <__kernel_cos>:
   8aaf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8aaf4:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
   8aaf8:	f1b7 5f79 	cmp.w	r7, #1044381696	; 0x3e400000
   8aafc:	b085      	sub	sp, #20
   8aafe:	460c      	mov	r4, r1
   8ab00:	4692      	mov	sl, r2
   8ab02:	469b      	mov	fp, r3
   8ab04:	4605      	mov	r5, r0
   8ab06:	da6b      	bge.n	8abe0 <__kernel_cos+0xf0>
   8ab08:	f001 fc6e 	bl	8c3e8 <__aeabi_d2iz>
   8ab0c:	2800      	cmp	r0, #0
   8ab0e:	f000 80e7 	beq.w	8ace0 <__kernel_cos+0x1f0>
   8ab12:	462a      	mov	r2, r5
   8ab14:	4623      	mov	r3, r4
   8ab16:	4628      	mov	r0, r5
   8ab18:	4621      	mov	r1, r4
   8ab1a:	f001 f9cb 	bl	8beb4 <__aeabi_dmul>
   8ab1e:	a374      	add	r3, pc, #464	; (adr r3, 8acf0 <__kernel_cos+0x200>)
   8ab20:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab24:	4680      	mov	r8, r0
   8ab26:	4689      	mov	r9, r1
   8ab28:	f001 f9c4 	bl	8beb4 <__aeabi_dmul>
   8ab2c:	a372      	add	r3, pc, #456	; (adr r3, 8acf8 <__kernel_cos+0x208>)
   8ab2e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab32:	f001 f80d 	bl	8bb50 <__adddf3>
   8ab36:	4642      	mov	r2, r8
   8ab38:	464b      	mov	r3, r9
   8ab3a:	f001 f9bb 	bl	8beb4 <__aeabi_dmul>
   8ab3e:	a370      	add	r3, pc, #448	; (adr r3, 8ad00 <__kernel_cos+0x210>)
   8ab40:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab44:	f001 f802 	bl	8bb4c <__aeabi_dsub>
   8ab48:	4642      	mov	r2, r8
   8ab4a:	464b      	mov	r3, r9
   8ab4c:	f001 f9b2 	bl	8beb4 <__aeabi_dmul>
   8ab50:	a36d      	add	r3, pc, #436	; (adr r3, 8ad08 <__kernel_cos+0x218>)
   8ab52:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab56:	f000 fffb 	bl	8bb50 <__adddf3>
   8ab5a:	4642      	mov	r2, r8
   8ab5c:	464b      	mov	r3, r9
   8ab5e:	f001 f9a9 	bl	8beb4 <__aeabi_dmul>
   8ab62:	a36b      	add	r3, pc, #428	; (adr r3, 8ad10 <__kernel_cos+0x220>)
   8ab64:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab68:	f000 fff0 	bl	8bb4c <__aeabi_dsub>
   8ab6c:	4642      	mov	r2, r8
   8ab6e:	464b      	mov	r3, r9
   8ab70:	f001 f9a0 	bl	8beb4 <__aeabi_dmul>
   8ab74:	a368      	add	r3, pc, #416	; (adr r3, 8ad18 <__kernel_cos+0x228>)
   8ab76:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ab7a:	f000 ffe9 	bl	8bb50 <__adddf3>
   8ab7e:	4642      	mov	r2, r8
   8ab80:	464b      	mov	r3, r9
   8ab82:	f001 f997 	bl	8beb4 <__aeabi_dmul>
   8ab86:	e9cd 0100 	strd	r0, r1, [sp]
   8ab8a:	4640      	mov	r0, r8
   8ab8c:	4649      	mov	r1, r9
   8ab8e:	2200      	movs	r2, #0
   8ab90:	4b63      	ldr	r3, [pc, #396]	; (8ad20 <__kernel_cos+0x230>)
   8ab92:	f001 f98f 	bl	8beb4 <__aeabi_dmul>
   8ab96:	e9dd 2300 	ldrd	r2, r3, [sp]
   8ab9a:	4606      	mov	r6, r0
   8ab9c:	460f      	mov	r7, r1
   8ab9e:	4640      	mov	r0, r8
   8aba0:	4649      	mov	r1, r9
   8aba2:	f001 f987 	bl	8beb4 <__aeabi_dmul>
   8aba6:	4652      	mov	r2, sl
   8aba8:	4680      	mov	r8, r0
   8abaa:	4689      	mov	r9, r1
   8abac:	465b      	mov	r3, fp
   8abae:	4628      	mov	r0, r5
   8abb0:	4621      	mov	r1, r4
   8abb2:	f001 f97f 	bl	8beb4 <__aeabi_dmul>
   8abb6:	4602      	mov	r2, r0
   8abb8:	460b      	mov	r3, r1
   8abba:	4640      	mov	r0, r8
   8abbc:	4649      	mov	r1, r9
   8abbe:	f000 ffc5 	bl	8bb4c <__aeabi_dsub>
   8abc2:	4602      	mov	r2, r0
   8abc4:	460b      	mov	r3, r1
   8abc6:	4630      	mov	r0, r6
   8abc8:	4639      	mov	r1, r7
   8abca:	f000 ffbf 	bl	8bb4c <__aeabi_dsub>
   8abce:	4602      	mov	r2, r0
   8abd0:	460b      	mov	r3, r1
   8abd2:	2000      	movs	r0, #0
   8abd4:	4953      	ldr	r1, [pc, #332]	; (8ad24 <__kernel_cos+0x234>)
   8abd6:	f000 ffb9 	bl	8bb4c <__aeabi_dsub>
   8abda:	b005      	add	sp, #20
   8abdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8abe0:	4602      	mov	r2, r0
   8abe2:	460b      	mov	r3, r1
   8abe4:	f001 f966 	bl	8beb4 <__aeabi_dmul>
   8abe8:	a341      	add	r3, pc, #260	; (adr r3, 8acf0 <__kernel_cos+0x200>)
   8abea:	e9d3 2300 	ldrd	r2, r3, [r3]
   8abee:	4680      	mov	r8, r0
   8abf0:	4689      	mov	r9, r1
   8abf2:	f001 f95f 	bl	8beb4 <__aeabi_dmul>
   8abf6:	a340      	add	r3, pc, #256	; (adr r3, 8acf8 <__kernel_cos+0x208>)
   8abf8:	e9d3 2300 	ldrd	r2, r3, [r3]
   8abfc:	f000 ffa8 	bl	8bb50 <__adddf3>
   8ac00:	4642      	mov	r2, r8
   8ac02:	464b      	mov	r3, r9
   8ac04:	f001 f956 	bl	8beb4 <__aeabi_dmul>
   8ac08:	a33d      	add	r3, pc, #244	; (adr r3, 8ad00 <__kernel_cos+0x210>)
   8ac0a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ac0e:	f000 ff9d 	bl	8bb4c <__aeabi_dsub>
   8ac12:	4642      	mov	r2, r8
   8ac14:	464b      	mov	r3, r9
   8ac16:	f001 f94d 	bl	8beb4 <__aeabi_dmul>
   8ac1a:	a33b      	add	r3, pc, #236	; (adr r3, 8ad08 <__kernel_cos+0x218>)
   8ac1c:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ac20:	f000 ff96 	bl	8bb50 <__adddf3>
   8ac24:	4642      	mov	r2, r8
   8ac26:	464b      	mov	r3, r9
   8ac28:	f001 f944 	bl	8beb4 <__aeabi_dmul>
   8ac2c:	a338      	add	r3, pc, #224	; (adr r3, 8ad10 <__kernel_cos+0x220>)
   8ac2e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ac32:	f000 ff8b 	bl	8bb4c <__aeabi_dsub>
   8ac36:	4642      	mov	r2, r8
   8ac38:	464b      	mov	r3, r9
   8ac3a:	f001 f93b 	bl	8beb4 <__aeabi_dmul>
   8ac3e:	a336      	add	r3, pc, #216	; (adr r3, 8ad18 <__kernel_cos+0x228>)
   8ac40:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ac44:	f000 ff84 	bl	8bb50 <__adddf3>
   8ac48:	464b      	mov	r3, r9
   8ac4a:	4642      	mov	r2, r8
   8ac4c:	f001 f932 	bl	8beb4 <__aeabi_dmul>
   8ac50:	4b35      	ldr	r3, [pc, #212]	; (8ad28 <__kernel_cos+0x238>)
   8ac52:	e9cd 0100 	strd	r0, r1, [sp]
   8ac56:	429f      	cmp	r7, r3
   8ac58:	dd97      	ble.n	8ab8a <__kernel_cos+0x9a>
   8ac5a:	4b34      	ldr	r3, [pc, #208]	; (8ad2c <__kernel_cos+0x23c>)
   8ac5c:	2200      	movs	r2, #0
   8ac5e:	429f      	cmp	r7, r3
   8ac60:	dc38      	bgt.n	8acd4 <__kernel_cos+0x1e4>
   8ac62:	f5a7 1300 	sub.w	r3, r7, #2097152	; 0x200000
   8ac66:	2000      	movs	r0, #0
   8ac68:	492e      	ldr	r1, [pc, #184]	; (8ad24 <__kernel_cos+0x234>)
   8ac6a:	4616      	mov	r6, r2
   8ac6c:	461f      	mov	r7, r3
   8ac6e:	f000 ff6d 	bl	8bb4c <__aeabi_dsub>
   8ac72:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8ac76:	4640      	mov	r0, r8
   8ac78:	4649      	mov	r1, r9
   8ac7a:	2200      	movs	r2, #0
   8ac7c:	4b28      	ldr	r3, [pc, #160]	; (8ad20 <__kernel_cos+0x230>)
   8ac7e:	f001 f919 	bl	8beb4 <__aeabi_dmul>
   8ac82:	4632      	mov	r2, r6
   8ac84:	463b      	mov	r3, r7
   8ac86:	f000 ff61 	bl	8bb4c <__aeabi_dsub>
   8ac8a:	e9dd 2300 	ldrd	r2, r3, [sp]
   8ac8e:	4606      	mov	r6, r0
   8ac90:	460f      	mov	r7, r1
   8ac92:	4640      	mov	r0, r8
   8ac94:	4649      	mov	r1, r9
   8ac96:	f001 f90d 	bl	8beb4 <__aeabi_dmul>
   8ac9a:	4652      	mov	r2, sl
   8ac9c:	4680      	mov	r8, r0
   8ac9e:	4689      	mov	r9, r1
   8aca0:	465b      	mov	r3, fp
   8aca2:	4628      	mov	r0, r5
   8aca4:	4621      	mov	r1, r4
   8aca6:	f001 f905 	bl	8beb4 <__aeabi_dmul>
   8acaa:	4602      	mov	r2, r0
   8acac:	460b      	mov	r3, r1
   8acae:	4640      	mov	r0, r8
   8acb0:	4649      	mov	r1, r9
   8acb2:	f000 ff4b 	bl	8bb4c <__aeabi_dsub>
   8acb6:	4602      	mov	r2, r0
   8acb8:	460b      	mov	r3, r1
   8acba:	4630      	mov	r0, r6
   8acbc:	4639      	mov	r1, r7
   8acbe:	f000 ff45 	bl	8bb4c <__aeabi_dsub>
   8acc2:	4602      	mov	r2, r0
   8acc4:	460b      	mov	r3, r1
   8acc6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8acca:	f000 ff3f 	bl	8bb4c <__aeabi_dsub>
   8acce:	b005      	add	sp, #20
   8acd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8acd4:	4b16      	ldr	r3, [pc, #88]	; (8ad30 <__kernel_cos+0x240>)
   8acd6:	2600      	movs	r6, #0
   8acd8:	e9cd 2302 	strd	r2, r3, [sp, #8]
   8acdc:	4f15      	ldr	r7, [pc, #84]	; (8ad34 <__kernel_cos+0x244>)
   8acde:	e7ca      	b.n	8ac76 <__kernel_cos+0x186>
   8ace0:	4910      	ldr	r1, [pc, #64]	; (8ad24 <__kernel_cos+0x234>)
   8ace2:	2000      	movs	r0, #0
   8ace4:	b005      	add	sp, #20
   8ace6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8acea:	bf00      	nop
   8acec:	f3af 8000 	nop.w
   8acf0:	be8838d4 	.word	0xbe8838d4
   8acf4:	bda8fae9 	.word	0xbda8fae9
   8acf8:	bdb4b1c4 	.word	0xbdb4b1c4
   8acfc:	3e21ee9e 	.word	0x3e21ee9e
   8ad00:	809c52ad 	.word	0x809c52ad
   8ad04:	3e927e4f 	.word	0x3e927e4f
   8ad08:	19cb1590 	.word	0x19cb1590
   8ad0c:	3efa01a0 	.word	0x3efa01a0
   8ad10:	16c15177 	.word	0x16c15177
   8ad14:	3f56c16c 	.word	0x3f56c16c
   8ad18:	5555554c 	.word	0x5555554c
   8ad1c:	3fa55555 	.word	0x3fa55555
   8ad20:	3fe00000 	.word	0x3fe00000
   8ad24:	3ff00000 	.word	0x3ff00000
   8ad28:	3fd33332 	.word	0x3fd33332
   8ad2c:	3fe90000 	.word	0x3fe90000
   8ad30:	3fe70000 	.word	0x3fe70000
   8ad34:	3fd20000 	.word	0x3fd20000

0008ad38 <__kernel_rem_pio2>:
   8ad38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8ad3c:	469e      	mov	lr, r3
   8ad3e:	4d7e      	ldr	r5, [pc, #504]	; (8af38 <__kernel_rem_pio2+0x200>)
   8ad40:	1ed4      	subs	r4, r2, #3
   8ad42:	fb85 6504 	smull	r6, r5, r5, r4
   8ad46:	17e4      	asrs	r4, r4, #31
   8ad48:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
   8ad4c:	f5ad 7d1d 	sub.w	sp, sp, #628	; 0x274
   8ad50:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   8ad54:	4625      	mov	r5, r4
   8ad56:	9ea6      	ldr	r6, [sp, #664]	; 0x298
   8ad58:	940d      	str	r4, [sp, #52]	; 0x34
   8ad5a:	930c      	str	r3, [sp, #48]	; 0x30
   8ad5c:	43e3      	mvns	r3, r4
   8ad5e:	4c77      	ldr	r4, [pc, #476]	; (8af3c <__kernel_rem_pio2+0x204>)
   8ad60:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   8ad64:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
   8ad68:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   8ad6c:	4627      	mov	r7, r4
   8ad6e:	9409      	str	r4, [sp, #36]	; 0x24
   8ad70:	f10e 34ff 	add.w	r4, lr, #4294967295
   8ad74:	4626      	mov	r6, r4
   8ad76:	9403      	str	r4, [sp, #12]
   8ad78:	19f4      	adds	r4, r6, r7
   8ad7a:	9004      	str	r0, [sp, #16]
   8ad7c:	910a      	str	r1, [sp, #40]	; 0x28
   8ad7e:	9308      	str	r3, [sp, #32]
   8ad80:	eba5 0506 	sub.w	r5, r5, r6
   8ad84:	d416      	bmi.n	8adb4 <__kernel_rem_pio2+0x7c>
   8ad86:	442c      	add	r4, r5
   8ad88:	3401      	adds	r4, #1
   8ad8a:	ae22      	add	r6, sp, #136	; 0x88
   8ad8c:	9fa7      	ldr	r7, [sp, #668]	; 0x29c
   8ad8e:	e008      	b.n	8ada2 <__kernel_rem_pio2+0x6a>
   8ad90:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   8ad94:	f001 f828 	bl	8bde8 <__aeabi_i2d>
   8ad98:	3501      	adds	r5, #1
   8ad9a:	42a5      	cmp	r5, r4
   8ad9c:	e9e6 0102 	strd	r0, r1, [r6, #8]!
   8ada0:	d008      	beq.n	8adb4 <__kernel_rem_pio2+0x7c>
   8ada2:	2d00      	cmp	r5, #0
   8ada4:	daf4      	bge.n	8ad90 <__kernel_rem_pio2+0x58>
   8ada6:	3501      	adds	r5, #1
   8ada8:	2000      	movs	r0, #0
   8adaa:	2100      	movs	r1, #0
   8adac:	42a5      	cmp	r5, r4
   8adae:	e9e6 0102 	strd	r0, r1, [r6, #8]!
   8adb2:	d1f6      	bne.n	8ada2 <__kernel_rem_pio2+0x6a>
   8adb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8adb6:	2b00      	cmp	r3, #0
   8adb8:	db31      	blt.n	8ae1e <__kernel_rem_pio2+0xe6>
   8adba:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8adbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8adbe:	a974      	add	r1, sp, #464	; 0x1d0
   8adc0:	eb01 0bc2 	add.w	fp, r1, r2, lsl #3
   8adc4:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
   8adc8:	9a03      	ldr	r2, [sp, #12]
   8adca:	a924      	add	r1, sp, #144	; 0x90
   8adcc:	00db      	lsls	r3, r3, #3
   8adce:	eb01 08c2 	add.w	r8, r1, r2, lsl #3
   8add2:	9300      	str	r3, [sp, #0]
   8add4:	f50d 79e4 	add.w	r9, sp, #456	; 0x1c8
   8add8:	9b03      	ldr	r3, [sp, #12]
   8adda:	2b00      	cmp	r3, #0
   8addc:	f2c0 8197 	blt.w	8b10e <__kernel_rem_pio2+0x3d6>
   8ade0:	4644      	mov	r4, r8
   8ade2:	9b04      	ldr	r3, [sp, #16]
   8ade4:	2600      	movs	r6, #0
   8ade6:	f1a3 0a08 	sub.w	sl, r3, #8
   8adea:	9b00      	ldr	r3, [sp, #0]
   8adec:	2700      	movs	r7, #0
   8adee:	eb08 0503 	add.w	r5, r8, r3
   8adf2:	e9fa 2302 	ldrd	r2, r3, [sl, #8]!
   8adf6:	e874 0102 	ldrd	r0, r1, [r4], #-8
   8adfa:	f001 f85b 	bl	8beb4 <__aeabi_dmul>
   8adfe:	4602      	mov	r2, r0
   8ae00:	460b      	mov	r3, r1
   8ae02:	4630      	mov	r0, r6
   8ae04:	4639      	mov	r1, r7
   8ae06:	f000 fea3 	bl	8bb50 <__adddf3>
   8ae0a:	42ac      	cmp	r4, r5
   8ae0c:	4606      	mov	r6, r0
   8ae0e:	460f      	mov	r7, r1
   8ae10:	d1ef      	bne.n	8adf2 <__kernel_rem_pio2+0xba>
   8ae12:	e9e9 6702 	strd	r6, r7, [r9, #8]!
   8ae16:	45d9      	cmp	r9, fp
   8ae18:	f108 0808 	add.w	r8, r8, #8
   8ae1c:	d1dc      	bne.n	8add8 <__kernel_rem_pio2+0xa0>
   8ae1e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8ae20:	a910      	add	r1, sp, #64	; 0x40
   8ae22:	469b      	mov	fp, r3
   8ae24:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   8ae28:	3b01      	subs	r3, #1
   8ae2a:	009b      	lsls	r3, r3, #2
   8ae2c:	1d1a      	adds	r2, r3, #4
   8ae2e:	440a      	add	r2, r1
   8ae30:	440b      	add	r3, r1
   8ae32:	920f      	str	r2, [sp, #60]	; 0x3c
   8ae34:	930e      	str	r3, [sp, #56]	; 0x38
   8ae36:	ea4f 03cb 	mov.w	r3, fp, lsl #3
   8ae3a:	a99c      	add	r1, sp, #624	; 0x270
   8ae3c:	461a      	mov	r2, r3
   8ae3e:	9306      	str	r3, [sp, #24]
   8ae40:	f1bb 0f00 	cmp.w	fp, #0
   8ae44:	440b      	add	r3, r1
   8ae46:	e953 4528 	ldrd	r4, r5, [r3, #-160]	; 0xa0
   8ae4a:	dd28      	ble.n	8ae9e <__kernel_rem_pio2+0x166>
   8ae4c:	f50d 7ae8 	add.w	sl, sp, #464	; 0x1d0
   8ae50:	eb0a 0602 	add.w	r6, sl, r2
   8ae54:	af0f      	add	r7, sp, #60	; 0x3c
   8ae56:	2200      	movs	r2, #0
   8ae58:	4b39      	ldr	r3, [pc, #228]	; (8af40 <__kernel_rem_pio2+0x208>)
   8ae5a:	4620      	mov	r0, r4
   8ae5c:	4629      	mov	r1, r5
   8ae5e:	f001 f829 	bl	8beb4 <__aeabi_dmul>
   8ae62:	f001 fac1 	bl	8c3e8 <__aeabi_d2iz>
   8ae66:	f000 ffbf 	bl	8bde8 <__aeabi_i2d>
   8ae6a:	2200      	movs	r2, #0
   8ae6c:	4b35      	ldr	r3, [pc, #212]	; (8af44 <__kernel_rem_pio2+0x20c>)
   8ae6e:	4680      	mov	r8, r0
   8ae70:	4689      	mov	r9, r1
   8ae72:	f001 f81f 	bl	8beb4 <__aeabi_dmul>
   8ae76:	4602      	mov	r2, r0
   8ae78:	460b      	mov	r3, r1
   8ae7a:	4620      	mov	r0, r4
   8ae7c:	4629      	mov	r1, r5
   8ae7e:	f000 fe65 	bl	8bb4c <__aeabi_dsub>
   8ae82:	f001 fab1 	bl	8c3e8 <__aeabi_d2iz>
   8ae86:	e976 2302 	ldrd	r2, r3, [r6, #-8]!
   8ae8a:	f847 0f04 	str.w	r0, [r7, #4]!
   8ae8e:	4649      	mov	r1, r9
   8ae90:	4640      	mov	r0, r8
   8ae92:	f000 fe5d 	bl	8bb50 <__adddf3>
   8ae96:	4556      	cmp	r6, sl
   8ae98:	4604      	mov	r4, r0
   8ae9a:	460d      	mov	r5, r1
   8ae9c:	d1db      	bne.n	8ae56 <__kernel_rem_pio2+0x11e>
   8ae9e:	f8dd 9020 	ldr.w	r9, [sp, #32]
   8aea2:	4620      	mov	r0, r4
   8aea4:	4629      	mov	r1, r5
   8aea6:	464a      	mov	r2, r9
   8aea8:	f000 fdce 	bl	8ba48 <scalbn>
   8aeac:	2200      	movs	r2, #0
   8aeae:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   8aeb2:	4604      	mov	r4, r0
   8aeb4:	460d      	mov	r5, r1
   8aeb6:	f000 fffd 	bl	8beb4 <__aeabi_dmul>
   8aeba:	f7ff f865 	bl	89f88 <floor>
   8aebe:	2200      	movs	r2, #0
   8aec0:	4b21      	ldr	r3, [pc, #132]	; (8af48 <__kernel_rem_pio2+0x210>)
   8aec2:	f000 fff7 	bl	8beb4 <__aeabi_dmul>
   8aec6:	4602      	mov	r2, r0
   8aec8:	460b      	mov	r3, r1
   8aeca:	4620      	mov	r0, r4
   8aecc:	4629      	mov	r1, r5
   8aece:	f000 fe3d 	bl	8bb4c <__aeabi_dsub>
   8aed2:	4604      	mov	r4, r0
   8aed4:	460d      	mov	r5, r1
   8aed6:	f001 fa87 	bl	8c3e8 <__aeabi_d2iz>
   8aeda:	4680      	mov	r8, r0
   8aedc:	f000 ff84 	bl	8bde8 <__aeabi_i2d>
   8aee0:	4602      	mov	r2, r0
   8aee2:	460b      	mov	r3, r1
   8aee4:	4620      	mov	r0, r4
   8aee6:	4629      	mov	r1, r5
   8aee8:	464c      	mov	r4, r9
   8aeea:	f000 fe2f 	bl	8bb4c <__aeabi_dsub>
   8aeee:	2c00      	cmp	r4, #0
   8aef0:	4606      	mov	r6, r0
   8aef2:	460f      	mov	r7, r1
   8aef4:	f340 80f1 	ble.w	8b0da <__kernel_rem_pio2+0x3a2>
   8aef8:	f10b 31ff 	add.w	r1, fp, #4294967295
   8aefc:	ab10      	add	r3, sp, #64	; 0x40
   8aefe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   8af02:	f1c9 0018 	rsb	r0, r9, #24
   8af06:	fa43 f200 	asr.w	r2, r3, r0
   8af0a:	fa02 f500 	lsl.w	r5, r2, r0
   8af0e:	1b5d      	subs	r5, r3, r5
   8af10:	a810      	add	r0, sp, #64	; 0x40
   8af12:	f1c9 0317 	rsb	r3, r9, #23
   8af16:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
   8af1a:	4490      	add	r8, r2
   8af1c:	411d      	asrs	r5, r3
   8af1e:	2d00      	cmp	r5, #0
   8af20:	dd3f      	ble.n	8afa2 <__kernel_rem_pio2+0x26a>
   8af22:	f1bb 0f00 	cmp.w	fp, #0
   8af26:	f108 0801 	add.w	r8, r8, #1
   8af2a:	f340 8284 	ble.w	8b436 <__kernel_rem_pio2+0x6fe>
   8af2e:	2200      	movs	r2, #0
   8af30:	4614      	mov	r4, r2
   8af32:	a90f      	add	r1, sp, #60	; 0x3c
   8af34:	e012      	b.n	8af5c <__kernel_rem_pio2+0x224>
   8af36:	bf00      	nop
   8af38:	2aaaaaab 	.word	0x2aaaaaab
   8af3c:	000920c4 	.word	0x000920c4
   8af40:	3e700000 	.word	0x3e700000
   8af44:	41700000 	.word	0x41700000
   8af48:	40200000 	.word	0x40200000
   8af4c:	f1c3 7080 	rsb	r0, r3, #16777216	; 0x1000000
   8af50:	b10b      	cbz	r3, 8af56 <__kernel_rem_pio2+0x21e>
   8af52:	6008      	str	r0, [r1, #0]
   8af54:	2401      	movs	r4, #1
   8af56:	3201      	adds	r2, #1
   8af58:	4593      	cmp	fp, r2
   8af5a:	dd0d      	ble.n	8af78 <__kernel_rem_pio2+0x240>
   8af5c:	f851 3f04 	ldr.w	r3, [r1, #4]!
   8af60:	2c00      	cmp	r4, #0
   8af62:	d0f3      	beq.n	8af4c <__kernel_rem_pio2+0x214>
   8af64:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
   8af68:	3201      	adds	r2, #1
   8af6a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
   8af6e:	4593      	cmp	fp, r2
   8af70:	600b      	str	r3, [r1, #0]
   8af72:	f04f 0401 	mov.w	r4, #1
   8af76:	dcf1      	bgt.n	8af5c <__kernel_rem_pio2+0x224>
   8af78:	9b08      	ldr	r3, [sp, #32]
   8af7a:	2b00      	cmp	r3, #0
   8af7c:	dd0e      	ble.n	8af9c <__kernel_rem_pio2+0x264>
   8af7e:	2b01      	cmp	r3, #1
   8af80:	f000 80b3 	beq.w	8b0ea <__kernel_rem_pio2+0x3b2>
   8af84:	2b02      	cmp	r3, #2
   8af86:	d109      	bne.n	8af9c <__kernel_rem_pio2+0x264>
   8af88:	f10b 32ff 	add.w	r2, fp, #4294967295
   8af8c:	ab10      	add	r3, sp, #64	; 0x40
   8af8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8af92:	a910      	add	r1, sp, #64	; 0x40
   8af94:	f3c3 0315 	ubfx	r3, r3, #0, #22
   8af98:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   8af9c:	2d02      	cmp	r5, #2
   8af9e:	f000 8083 	beq.w	8b0a8 <__kernel_rem_pio2+0x370>
   8afa2:	4630      	mov	r0, r6
   8afa4:	4639      	mov	r1, r7
   8afa6:	2200      	movs	r2, #0
   8afa8:	2300      	movs	r3, #0
   8afaa:	f001 f9eb 	bl	8c384 <__aeabi_dcmpeq>
   8afae:	2800      	cmp	r0, #0
   8afb0:	f000 80c9 	beq.w	8b146 <__kernel_rem_pio2+0x40e>
   8afb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8afb6:	f10b 3aff 	add.w	sl, fp, #4294967295
   8afba:	4553      	cmp	r3, sl
   8afbc:	dc0d      	bgt.n	8afda <__kernel_rem_pio2+0x2a2>
   8afbe:	ab10      	add	r3, sp, #64	; 0x40
   8afc0:	980f      	ldr	r0, [sp, #60]	; 0x3c
   8afc2:	eb03 038b 	add.w	r3, r3, fp, lsl #2
   8afc6:	2200      	movs	r2, #0
   8afc8:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   8afcc:	4283      	cmp	r3, r0
   8afce:	ea42 0201 	orr.w	r2, r2, r1
   8afd2:	d1f9      	bne.n	8afc8 <__kernel_rem_pio2+0x290>
   8afd4:	2a00      	cmp	r2, #0
   8afd6:	f040 8214 	bne.w	8b402 <__kernel_rem_pio2+0x6ca>
   8afda:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8afdc:	aa10      	add	r2, sp, #64	; 0x40
   8afde:	3b01      	subs	r3, #1
   8afe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   8afe4:	2b00      	cmp	r3, #0
   8afe6:	f040 8224 	bne.w	8b432 <__kernel_rem_pio2+0x6fa>
   8afea:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8afec:	2301      	movs	r3, #1
   8afee:	f852 1d04 	ldr.w	r1, [r2, #-4]!
   8aff2:	3301      	adds	r3, #1
   8aff4:	2900      	cmp	r1, #0
   8aff6:	d0fa      	beq.n	8afee <__kernel_rem_pio2+0x2b6>
   8aff8:	445b      	add	r3, fp
   8affa:	461a      	mov	r2, r3
   8affc:	930b      	str	r3, [sp, #44]	; 0x2c
   8affe:	f10b 0301 	add.w	r3, fp, #1
   8b002:	4293      	cmp	r3, r2
   8b004:	dc4d      	bgt.n	8b0a2 <__kernel_rem_pio2+0x36a>
   8b006:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   8b008:	f04f 0800 	mov.w	r8, #0
   8b00c:	eb03 0902 	add.w	r9, r3, r2
   8b010:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   8b012:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8b014:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   8b018:	445b      	add	r3, fp
   8b01a:	ebcb 0b02 	rsb	fp, fp, r2
   8b01e:	9aa7      	ldr	r2, [sp, #668]	; 0x29c
   8b020:	f109 39ff 	add.w	r9, r9, #4294967295
   8b024:	eb02 0289 	add.w	r2, r2, r9, lsl #2
   8b028:	9200      	str	r2, [sp, #0]
   8b02a:	ea4f 02cb 	mov.w	r2, fp, lsl #3
   8b02e:	00db      	lsls	r3, r3, #3
   8b030:	9205      	str	r2, [sp, #20]
   8b032:	aa24      	add	r2, sp, #144	; 0x90
   8b034:	eb02 0b03 	add.w	fp, r2, r3
   8b038:	9307      	str	r3, [sp, #28]
   8b03a:	9b06      	ldr	r3, [sp, #24]
   8b03c:	aa74      	add	r2, sp, #464	; 0x1d0
   8b03e:	eb02 0a03 	add.w	sl, r2, r3
   8b042:	9b00      	ldr	r3, [sp, #0]
   8b044:	2600      	movs	r6, #0
   8b046:	f853 0f04 	ldr.w	r0, [r3, #4]!
   8b04a:	2700      	movs	r7, #0
   8b04c:	9300      	str	r3, [sp, #0]
   8b04e:	f000 fecb 	bl	8bde8 <__aeabi_i2d>
   8b052:	9b03      	ldr	r3, [sp, #12]
   8b054:	e8eb 0102 	strd	r0, r1, [fp], #8
   8b058:	2b00      	cmp	r3, #0
   8b05a:	db1b      	blt.n	8b094 <__kernel_rem_pio2+0x35c>
   8b05c:	9b07      	ldr	r3, [sp, #28]
   8b05e:	eb03 0408 	add.w	r4, r3, r8
   8b062:	9b06      	ldr	r3, [sp, #24]
   8b064:	eb08 0503 	add.w	r5, r8, r3
   8b068:	ab24      	add	r3, sp, #144	; 0x90
   8b06a:	441c      	add	r4, r3
   8b06c:	441d      	add	r5, r3
   8b06e:	9b04      	ldr	r3, [sp, #16]
   8b070:	f1a3 0908 	sub.w	r9, r3, #8
   8b074:	e9f9 2302 	ldrd	r2, r3, [r9, #8]!
   8b078:	e874 0102 	ldrd	r0, r1, [r4], #-8
   8b07c:	f000 ff1a 	bl	8beb4 <__aeabi_dmul>
   8b080:	4602      	mov	r2, r0
   8b082:	460b      	mov	r3, r1
   8b084:	4630      	mov	r0, r6
   8b086:	4639      	mov	r1, r7
   8b088:	f000 fd62 	bl	8bb50 <__adddf3>
   8b08c:	42ac      	cmp	r4, r5
   8b08e:	4606      	mov	r6, r0
   8b090:	460f      	mov	r7, r1
   8b092:	d1ef      	bne.n	8b074 <__kernel_rem_pio2+0x33c>
   8b094:	9b05      	ldr	r3, [sp, #20]
   8b096:	f108 0808 	add.w	r8, r8, #8
   8b09a:	4598      	cmp	r8, r3
   8b09c:	e9ea 6702 	strd	r6, r7, [sl, #8]!
   8b0a0:	d1cf      	bne.n	8b042 <__kernel_rem_pio2+0x30a>
   8b0a2:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   8b0a6:	e6c6      	b.n	8ae36 <__kernel_rem_pio2+0xfe>
   8b0a8:	4632      	mov	r2, r6
   8b0aa:	463b      	mov	r3, r7
   8b0ac:	2000      	movs	r0, #0
   8b0ae:	49bf      	ldr	r1, [pc, #764]	; (8b3ac <__kernel_rem_pio2+0x674>)
   8b0b0:	f000 fd4c 	bl	8bb4c <__aeabi_dsub>
   8b0b4:	4606      	mov	r6, r0
   8b0b6:	460f      	mov	r7, r1
   8b0b8:	2c00      	cmp	r4, #0
   8b0ba:	f43f af72 	beq.w	8afa2 <__kernel_rem_pio2+0x26a>
   8b0be:	9a08      	ldr	r2, [sp, #32]
   8b0c0:	2000      	movs	r0, #0
   8b0c2:	49ba      	ldr	r1, [pc, #744]	; (8b3ac <__kernel_rem_pio2+0x674>)
   8b0c4:	f000 fcc0 	bl	8ba48 <scalbn>
   8b0c8:	4602      	mov	r2, r0
   8b0ca:	460b      	mov	r3, r1
   8b0cc:	4630      	mov	r0, r6
   8b0ce:	4639      	mov	r1, r7
   8b0d0:	f000 fd3c 	bl	8bb4c <__aeabi_dsub>
   8b0d4:	4606      	mov	r6, r0
   8b0d6:	460f      	mov	r7, r1
   8b0d8:	e763      	b.n	8afa2 <__kernel_rem_pio2+0x26a>
   8b0da:	d111      	bne.n	8b100 <__kernel_rem_pio2+0x3c8>
   8b0dc:	f10b 33ff 	add.w	r3, fp, #4294967295
   8b0e0:	aa10      	add	r2, sp, #64	; 0x40
   8b0e2:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   8b0e6:	15ed      	asrs	r5, r5, #23
   8b0e8:	e719      	b.n	8af1e <__kernel_rem_pio2+0x1e6>
   8b0ea:	f10b 32ff 	add.w	r2, fp, #4294967295
   8b0ee:	ab10      	add	r3, sp, #64	; 0x40
   8b0f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8b0f4:	a910      	add	r1, sp, #64	; 0x40
   8b0f6:	f3c3 0316 	ubfx	r3, r3, #0, #23
   8b0fa:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   8b0fe:	e74d      	b.n	8af9c <__kernel_rem_pio2+0x264>
   8b100:	2200      	movs	r2, #0
   8b102:	4bab      	ldr	r3, [pc, #684]	; (8b3b0 <__kernel_rem_pio2+0x678>)
   8b104:	f001 f95c 	bl	8c3c0 <__aeabi_dcmpge>
   8b108:	b958      	cbnz	r0, 8b122 <__kernel_rem_pio2+0x3ea>
   8b10a:	4605      	mov	r5, r0
   8b10c:	e749      	b.n	8afa2 <__kernel_rem_pio2+0x26a>
   8b10e:	2600      	movs	r6, #0
   8b110:	2700      	movs	r7, #0
   8b112:	e9e9 6702 	strd	r6, r7, [r9, #8]!
   8b116:	45d9      	cmp	r9, fp
   8b118:	f108 0808 	add.w	r8, r8, #8
   8b11c:	f47f ae5c 	bne.w	8add8 <__kernel_rem_pio2+0xa0>
   8b120:	e67d      	b.n	8ae1e <__kernel_rem_pio2+0xe6>
   8b122:	f1bb 0f00 	cmp.w	fp, #0
   8b126:	f108 0801 	add.w	r8, r8, #1
   8b12a:	bfc8      	it	gt
   8b12c:	2502      	movgt	r5, #2
   8b12e:	f73f aefe 	bgt.w	8af2e <__kernel_rem_pio2+0x1f6>
   8b132:	4632      	mov	r2, r6
   8b134:	463b      	mov	r3, r7
   8b136:	2000      	movs	r0, #0
   8b138:	499c      	ldr	r1, [pc, #624]	; (8b3ac <__kernel_rem_pio2+0x674>)
   8b13a:	f000 fd07 	bl	8bb4c <__aeabi_dsub>
   8b13e:	2502      	movs	r5, #2
   8b140:	4606      	mov	r6, r0
   8b142:	460f      	mov	r7, r1
   8b144:	e72d      	b.n	8afa2 <__kernel_rem_pio2+0x26a>
   8b146:	9b08      	ldr	r3, [sp, #32]
   8b148:	4630      	mov	r0, r6
   8b14a:	425a      	negs	r2, r3
   8b14c:	4639      	mov	r1, r7
   8b14e:	9503      	str	r5, [sp, #12]
   8b150:	f8cd 8014 	str.w	r8, [sp, #20]
   8b154:	f000 fc78 	bl	8ba48 <scalbn>
   8b158:	2200      	movs	r2, #0
   8b15a:	4b96      	ldr	r3, [pc, #600]	; (8b3b4 <__kernel_rem_pio2+0x67c>)
   8b15c:	4604      	mov	r4, r0
   8b15e:	460d      	mov	r5, r1
   8b160:	f001 f92e 	bl	8c3c0 <__aeabi_dcmpge>
   8b164:	2800      	cmp	r0, #0
   8b166:	f000 81e1 	beq.w	8b52c <__kernel_rem_pio2+0x7f4>
   8b16a:	2200      	movs	r2, #0
   8b16c:	4b92      	ldr	r3, [pc, #584]	; (8b3b8 <__kernel_rem_pio2+0x680>)
   8b16e:	4620      	mov	r0, r4
   8b170:	4629      	mov	r1, r5
   8b172:	f000 fe9f 	bl	8beb4 <__aeabi_dmul>
   8b176:	f001 f937 	bl	8c3e8 <__aeabi_d2iz>
   8b17a:	4606      	mov	r6, r0
   8b17c:	f000 fe34 	bl	8bde8 <__aeabi_i2d>
   8b180:	2200      	movs	r2, #0
   8b182:	4b8c      	ldr	r3, [pc, #560]	; (8b3b4 <__kernel_rem_pio2+0x67c>)
   8b184:	f000 fe96 	bl	8beb4 <__aeabi_dmul>
   8b188:	460b      	mov	r3, r1
   8b18a:	4602      	mov	r2, r0
   8b18c:	4629      	mov	r1, r5
   8b18e:	4620      	mov	r0, r4
   8b190:	f000 fcdc 	bl	8bb4c <__aeabi_dsub>
   8b194:	f001 f928 	bl	8c3e8 <__aeabi_d2iz>
   8b198:	9b08      	ldr	r3, [sp, #32]
   8b19a:	f10b 0a01 	add.w	sl, fp, #1
   8b19e:	3318      	adds	r3, #24
   8b1a0:	9308      	str	r3, [sp, #32]
   8b1a2:	ab10      	add	r3, sp, #64	; 0x40
   8b1a4:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
   8b1a8:	f843 602a 	str.w	r6, [r3, sl, lsl #2]
   8b1ac:	9a08      	ldr	r2, [sp, #32]
   8b1ae:	2000      	movs	r0, #0
   8b1b0:	497e      	ldr	r1, [pc, #504]	; (8b3ac <__kernel_rem_pio2+0x674>)
   8b1b2:	f000 fc49 	bl	8ba48 <scalbn>
   8b1b6:	f1ba 0f00 	cmp.w	sl, #0
   8b1ba:	4604      	mov	r4, r0
   8b1bc:	460d      	mov	r5, r1
   8b1be:	f2c0 80ca 	blt.w	8b356 <__kernel_rem_pio2+0x61e>
   8b1c2:	f10a 0301 	add.w	r3, sl, #1
   8b1c6:	ea4f 08c3 	mov.w	r8, r3, lsl #3
   8b1ca:	af74      	add	r7, sp, #464	; 0x1d0
   8b1cc:	aa10      	add	r2, sp, #64	; 0x40
   8b1ce:	9300      	str	r3, [sp, #0]
   8b1d0:	eb02 0983 	add.w	r9, r2, r3, lsl #2
   8b1d4:	eb07 0608 	add.w	r6, r7, r8
   8b1d8:	f859 0d04 	ldr.w	r0, [r9, #-4]!
   8b1dc:	f000 fe04 	bl	8bde8 <__aeabi_i2d>
   8b1e0:	4622      	mov	r2, r4
   8b1e2:	462b      	mov	r3, r5
   8b1e4:	f000 fe66 	bl	8beb4 <__aeabi_dmul>
   8b1e8:	2200      	movs	r2, #0
   8b1ea:	e966 0102 	strd	r0, r1, [r6, #-8]!
   8b1ee:	4b72      	ldr	r3, [pc, #456]	; (8b3b8 <__kernel_rem_pio2+0x680>)
   8b1f0:	4620      	mov	r0, r4
   8b1f2:	4629      	mov	r1, r5
   8b1f4:	f000 fe5e 	bl	8beb4 <__aeabi_dmul>
   8b1f8:	42be      	cmp	r6, r7
   8b1fa:	4604      	mov	r4, r0
   8b1fc:	460d      	mov	r5, r1
   8b1fe:	d1eb      	bne.n	8b1d8 <__kernel_rem_pio2+0x4a0>
   8b200:	f1a8 0808 	sub.w	r8, r8, #8
   8b204:	eb06 0308 	add.w	r3, r6, r8
   8b208:	469b      	mov	fp, r3
   8b20a:	f50d 7998 	add.w	r9, sp, #304	; 0x130
   8b20e:	f8cd a018 	str.w	sl, [sp, #24]
   8b212:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
   8b216:	f04f 0800 	mov.w	r8, #0
   8b21a:	f8cd 9010 	str.w	r9, [sp, #16]
   8b21e:	f1ba 0f00 	cmp.w	sl, #0
   8b222:	f2c0 8095 	blt.w	8b350 <__kernel_rem_pio2+0x618>
   8b226:	f1b8 0f00 	cmp.w	r8, #0
   8b22a:	f2c0 8091 	blt.w	8b350 <__kernel_rem_pio2+0x618>
   8b22e:	f8df 918c 	ldr.w	r9, [pc, #396]	; 8b3bc <__kernel_rem_pio2+0x684>
   8b232:	465d      	mov	r5, fp
   8b234:	2600      	movs	r6, #0
   8b236:	2700      	movs	r7, #0
   8b238:	2400      	movs	r4, #0
   8b23a:	e001      	b.n	8b240 <__kernel_rem_pio2+0x508>
   8b23c:	4544      	cmp	r4, r8
   8b23e:	dc10      	bgt.n	8b262 <__kernel_rem_pio2+0x52a>
   8b240:	e9f9 2302 	ldrd	r2, r3, [r9, #8]!
   8b244:	e8f5 0102 	ldrd	r0, r1, [r5], #8
   8b248:	f000 fe34 	bl	8beb4 <__aeabi_dmul>
   8b24c:	4602      	mov	r2, r0
   8b24e:	460b      	mov	r3, r1
   8b250:	4630      	mov	r0, r6
   8b252:	4639      	mov	r1, r7
   8b254:	f000 fc7c 	bl	8bb50 <__adddf3>
   8b258:	3401      	adds	r4, #1
   8b25a:	45a2      	cmp	sl, r4
   8b25c:	4606      	mov	r6, r0
   8b25e:	460f      	mov	r7, r1
   8b260:	daec      	bge.n	8b23c <__kernel_rem_pio2+0x504>
   8b262:	9b04      	ldr	r3, [sp, #16]
   8b264:	f1ab 0b08 	sub.w	fp, fp, #8
   8b268:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
   8b26c:	e9c3 6700 	strd	r6, r7, [r3]
   8b270:	9b00      	ldr	r3, [sp, #0]
   8b272:	f108 0801 	add.w	r8, r8, #1
   8b276:	4598      	cmp	r8, r3
   8b278:	d1d1      	bne.n	8b21e <__kernel_rem_pio2+0x4e6>
   8b27a:	9ba6      	ldr	r3, [sp, #664]	; 0x298
   8b27c:	f8dd a018 	ldr.w	sl, [sp, #24]
   8b280:	f8dd 9010 	ldr.w	r9, [sp, #16]
   8b284:	2b03      	cmp	r3, #3
   8b286:	d83b      	bhi.n	8b300 <__kernel_rem_pio2+0x5c8>
   8b288:	e8df f013 	tbh	[pc, r3, lsl #1]
   8b28c:	00040041 	.word	0x00040041
   8b290:	00d70004 	.word	0x00d70004
   8b294:	2700      	movs	r7, #0
   8b296:	463e      	mov	r6, r7
   8b298:	9b00      	ldr	r3, [sp, #0]
   8b29a:	eb09 04c3 	add.w	r4, r9, r3, lsl #3
   8b29e:	4638      	mov	r0, r7
   8b2a0:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
   8b2a4:	4631      	mov	r1, r6
   8b2a6:	f000 fc53 	bl	8bb50 <__adddf3>
   8b2aa:	454c      	cmp	r4, r9
   8b2ac:	4607      	mov	r7, r0
   8b2ae:	460e      	mov	r6, r1
   8b2b0:	d1f5      	bne.n	8b29e <__kernel_rem_pio2+0x566>
   8b2b2:	9b03      	ldr	r3, [sp, #12]
   8b2b4:	2b00      	cmp	r3, #0
   8b2b6:	f000 808b 	beq.w	8b3d0 <__kernel_rem_pio2+0x698>
   8b2ba:	e9d9 0100 	ldrd	r0, r1, [r9]
   8b2be:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   8b2c0:	4633      	mov	r3, r6
   8b2c2:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   8b2c6:	463a      	mov	r2, r7
   8b2c8:	606e      	str	r6, [r5, #4]
   8b2ca:	602f      	str	r7, [r5, #0]
   8b2cc:	f000 fc3e 	bl	8bb4c <__aeabi_dsub>
   8b2d0:	f1ba 0f00 	cmp.w	sl, #0
   8b2d4:	4603      	mov	r3, r0
   8b2d6:	dd0c      	ble.n	8b2f2 <__kernel_rem_pio2+0x5ba>
   8b2d8:	2601      	movs	r6, #1
   8b2da:	461c      	mov	r4, r3
   8b2dc:	e9f9 2302 	ldrd	r2, r3, [r9, #8]!
   8b2e0:	4620      	mov	r0, r4
   8b2e2:	f000 fc35 	bl	8bb50 <__adddf3>
   8b2e6:	3601      	adds	r6, #1
   8b2e8:	45b2      	cmp	sl, r6
   8b2ea:	4603      	mov	r3, r0
   8b2ec:	daf5      	bge.n	8b2da <__kernel_rem_pio2+0x5a2>
   8b2ee:	9a03      	ldr	r2, [sp, #12]
   8b2f0:	b10a      	cbz	r2, 8b2f6 <__kernel_rem_pio2+0x5be>
   8b2f2:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8b2f6:	461c      	mov	r4, r3
   8b2f8:	460d      	mov	r5, r1
   8b2fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8b2fc:	e9c3 4502 	strd	r4, r5, [r3, #8]
   8b300:	9b05      	ldr	r3, [sp, #20]
   8b302:	f003 0007 	and.w	r0, r3, #7
   8b306:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   8b30a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b30e:	2300      	movs	r3, #0
   8b310:	4619      	mov	r1, r3
   8b312:	9a00      	ldr	r2, [sp, #0]
   8b314:	eb09 09c2 	add.w	r9, r9, r2, lsl #3
   8b318:	461c      	mov	r4, r3
   8b31a:	e979 2302 	ldrd	r2, r3, [r9, #-8]!
   8b31e:	4620      	mov	r0, r4
   8b320:	f000 fc16 	bl	8bb50 <__adddf3>
   8b324:	f10a 3aff 	add.w	sl, sl, #4294967295
   8b328:	f1ba 3fff 	cmp.w	sl, #4294967295
   8b32c:	4603      	mov	r3, r0
   8b32e:	d1f3      	bne.n	8b318 <__kernel_rem_pio2+0x5e0>
   8b330:	9a03      	ldr	r2, [sp, #12]
   8b332:	b10a      	cbz	r2, 8b338 <__kernel_rem_pio2+0x600>
   8b334:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8b338:	461c      	mov	r4, r3
   8b33a:	460d      	mov	r5, r1
   8b33c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8b33e:	e9c3 4500 	strd	r4, r5, [r3]
   8b342:	9b05      	ldr	r3, [sp, #20]
   8b344:	f003 0007 	and.w	r0, r3, #7
   8b348:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   8b34c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b350:	2600      	movs	r6, #0
   8b352:	2700      	movs	r7, #0
   8b354:	e785      	b.n	8b262 <__kernel_rem_pio2+0x52a>
   8b356:	9ba6      	ldr	r3, [sp, #664]	; 0x298
   8b358:	2b03      	cmp	r3, #3
   8b35a:	d8d1      	bhi.n	8b300 <__kernel_rem_pio2+0x5c8>
   8b35c:	e8df f003 	tbb	[pc, r3]
   8b360:	0230304e 	.word	0x0230304e
   8b364:	f50d 7998 	add.w	r9, sp, #304	; 0x130
   8b368:	9a03      	ldr	r2, [sp, #12]
   8b36a:	2300      	movs	r3, #0
   8b36c:	461e      	mov	r6, r3
   8b36e:	2a00      	cmp	r2, #0
   8b370:	f000 80c8 	beq.w	8b504 <__kernel_rem_pio2+0x7cc>
   8b374:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   8b376:	f8d9 0008 	ldr.w	r0, [r9, #8]
   8b37a:	f8d9 4004 	ldr.w	r4, [r9, #4]
   8b37e:	f8d9 200c 	ldr.w	r2, [r9, #12]
   8b382:	613b      	str	r3, [r7, #16]
   8b384:	9b05      	ldr	r3, [sp, #20]
   8b386:	f8d9 1000 	ldr.w	r1, [r9]
   8b38a:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   8b38e:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   8b392:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   8b396:	60b8      	str	r0, [r7, #8]
   8b398:	f003 0007 	and.w	r0, r3, #7
   8b39c:	617e      	str	r6, [r7, #20]
   8b39e:	607c      	str	r4, [r7, #4]
   8b3a0:	60fa      	str	r2, [r7, #12]
   8b3a2:	6039      	str	r1, [r7, #0]
   8b3a4:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   8b3a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b3ac:	3ff00000 	.word	0x3ff00000
   8b3b0:	3fe00000 	.word	0x3fe00000
   8b3b4:	41700000 	.word	0x41700000
   8b3b8:	3e700000 	.word	0x3e700000
   8b3bc:	000920d0 	.word	0x000920d0
   8b3c0:	9b03      	ldr	r3, [sp, #12]
   8b3c2:	2700      	movs	r7, #0
   8b3c4:	463e      	mov	r6, r7
   8b3c6:	f50d 7998 	add.w	r9, sp, #304	; 0x130
   8b3ca:	2b00      	cmp	r3, #0
   8b3cc:	f47f af75 	bne.w	8b2ba <__kernel_rem_pio2+0x582>
   8b3d0:	e9d9 0100 	ldrd	r0, r1, [r9]
   8b3d4:	4635      	mov	r5, r6
   8b3d6:	463c      	mov	r4, r7
   8b3d8:	4633      	mov	r3, r6
   8b3da:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   8b3dc:	463a      	mov	r2, r7
   8b3de:	e9c6 4500 	strd	r4, r5, [r6]
   8b3e2:	f000 fbb3 	bl	8bb4c <__aeabi_dsub>
   8b3e6:	f1ba 0f00 	cmp.w	sl, #0
   8b3ea:	4603      	mov	r3, r0
   8b3ec:	f73f af74 	bgt.w	8b2d8 <__kernel_rem_pio2+0x5a0>
   8b3f0:	461c      	mov	r4, r3
   8b3f2:	460d      	mov	r5, r1
   8b3f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8b3f6:	e9c3 4502 	strd	r4, r5, [r3, #8]
   8b3fa:	e781      	b.n	8b300 <__kernel_rem_pio2+0x5c8>
   8b3fc:	2300      	movs	r3, #0
   8b3fe:	4619      	mov	r1, r3
   8b400:	e796      	b.n	8b330 <__kernel_rem_pio2+0x5f8>
   8b402:	9a08      	ldr	r2, [sp, #32]
   8b404:	ab10      	add	r3, sp, #64	; 0x40
   8b406:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   8b40a:	3a18      	subs	r2, #24
   8b40c:	9503      	str	r5, [sp, #12]
   8b40e:	f8cd 8014 	str.w	r8, [sp, #20]
   8b412:	9208      	str	r2, [sp, #32]
   8b414:	2b00      	cmp	r3, #0
   8b416:	f47f aec9 	bne.w	8b1ac <__kernel_rem_pio2+0x474>
   8b41a:	ab10      	add	r3, sp, #64	; 0x40
   8b41c:	eb03 038a 	add.w	r3, r3, sl, lsl #2
   8b420:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   8b424:	f10a 3aff 	add.w	sl, sl, #4294967295
   8b428:	3a18      	subs	r2, #24
   8b42a:	2900      	cmp	r1, #0
   8b42c:	d0f8      	beq.n	8b420 <__kernel_rem_pio2+0x6e8>
   8b42e:	9208      	str	r2, [sp, #32]
   8b430:	e6bc      	b.n	8b1ac <__kernel_rem_pio2+0x474>
   8b432:	2301      	movs	r3, #1
   8b434:	e5e0      	b.n	8aff8 <__kernel_rem_pio2+0x2c0>
   8b436:	2400      	movs	r4, #0
   8b438:	e59e      	b.n	8af78 <__kernel_rem_pio2+0x240>
   8b43a:	f1ba 0f00 	cmp.w	sl, #0
   8b43e:	dd93      	ble.n	8b368 <__kernel_rem_pio2+0x630>
   8b440:	ea4f 08ca 	mov.w	r8, sl, lsl #3
   8b444:	eb09 0308 	add.w	r3, r9, r8
   8b448:	469b      	mov	fp, r3
   8b44a:	e9d3 6700 	ldrd	r6, r7, [r3]
   8b44e:	e97b 2302 	ldrd	r2, r3, [fp, #-8]!
   8b452:	4630      	mov	r0, r6
   8b454:	4639      	mov	r1, r7
   8b456:	e9cd 2300 	strd	r2, r3, [sp]
   8b45a:	f000 fb79 	bl	8bb50 <__adddf3>
   8b45e:	4604      	mov	r4, r0
   8b460:	460d      	mov	r5, r1
   8b462:	e9dd 0100 	ldrd	r0, r1, [sp]
   8b466:	4622      	mov	r2, r4
   8b468:	462b      	mov	r3, r5
   8b46a:	f000 fb6f 	bl	8bb4c <__aeabi_dsub>
   8b46e:	4602      	mov	r2, r0
   8b470:	460b      	mov	r3, r1
   8b472:	4630      	mov	r0, r6
   8b474:	4639      	mov	r1, r7
   8b476:	f000 fb6b 	bl	8bb50 <__adddf3>
   8b47a:	45cb      	cmp	fp, r9
   8b47c:	4626      	mov	r6, r4
   8b47e:	462f      	mov	r7, r5
   8b480:	e9cb 0102 	strd	r0, r1, [fp, #8]
   8b484:	e9cb 4500 	strd	r4, r5, [fp]
   8b488:	d1e1      	bne.n	8b44e <__kernel_rem_pio2+0x716>
   8b48a:	f1ba 0f01 	cmp.w	sl, #1
   8b48e:	f77f af6b 	ble.w	8b368 <__kernel_rem_pio2+0x630>
   8b492:	eb09 0308 	add.w	r3, r9, r8
   8b496:	469a      	mov	sl, r3
   8b498:	e9d3 6700 	ldrd	r6, r7, [r3]
   8b49c:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
   8b4a0:	e97a 2302 	ldrd	r2, r3, [sl, #-8]!
   8b4a4:	4610      	mov	r0, r2
   8b4a6:	4619      	mov	r1, r3
   8b4a8:	4632      	mov	r2, r6
   8b4aa:	463b      	mov	r3, r7
   8b4ac:	e9cd 0100 	strd	r0, r1, [sp]
   8b4b0:	f000 fb4e 	bl	8bb50 <__adddf3>
   8b4b4:	4604      	mov	r4, r0
   8b4b6:	460d      	mov	r5, r1
   8b4b8:	e9dd 0100 	ldrd	r0, r1, [sp]
   8b4bc:	4622      	mov	r2, r4
   8b4be:	462b      	mov	r3, r5
   8b4c0:	f000 fb44 	bl	8bb4c <__aeabi_dsub>
   8b4c4:	4632      	mov	r2, r6
   8b4c6:	463b      	mov	r3, r7
   8b4c8:	f000 fb42 	bl	8bb50 <__adddf3>
   8b4cc:	45da      	cmp	sl, fp
   8b4ce:	4626      	mov	r6, r4
   8b4d0:	462f      	mov	r7, r5
   8b4d2:	e9ca 0102 	strd	r0, r1, [sl, #8]
   8b4d6:	e9ca 4500 	strd	r4, r5, [sl]
   8b4da:	d1e1      	bne.n	8b4a0 <__kernel_rem_pio2+0x768>
   8b4dc:	2300      	movs	r3, #0
   8b4de:	461e      	mov	r6, r3
   8b4e0:	f108 0408 	add.w	r4, r8, #8
   8b4e4:	444c      	add	r4, r9
   8b4e6:	ad50      	add	r5, sp, #320	; 0x140
   8b4e8:	4618      	mov	r0, r3
   8b4ea:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
   8b4ee:	4631      	mov	r1, r6
   8b4f0:	f000 fb2e 	bl	8bb50 <__adddf3>
   8b4f4:	42ac      	cmp	r4, r5
   8b4f6:	4603      	mov	r3, r0
   8b4f8:	460e      	mov	r6, r1
   8b4fa:	d1f5      	bne.n	8b4e8 <__kernel_rem_pio2+0x7b0>
   8b4fc:	9a03      	ldr	r2, [sp, #12]
   8b4fe:	2a00      	cmp	r2, #0
   8b500:	f47f af38 	bne.w	8b374 <__kernel_rem_pio2+0x63c>
   8b504:	e9d9 4500 	ldrd	r4, r5, [r9]
   8b508:	e9d9 8902 	ldrd	r8, r9, [r9, #8]
   8b50c:	4618      	mov	r0, r3
   8b50e:	4631      	mov	r1, r6
   8b510:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   8b512:	9b05      	ldr	r3, [sp, #20]
   8b514:	e9c2 0104 	strd	r0, r1, [r2, #16]
   8b518:	f003 0007 	and.w	r0, r3, #7
   8b51c:	e9c2 4500 	strd	r4, r5, [r2]
   8b520:	e9c2 8902 	strd	r8, r9, [r2, #8]
   8b524:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   8b528:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b52c:	4620      	mov	r0, r4
   8b52e:	4629      	mov	r1, r5
   8b530:	f000 ff5a 	bl	8c3e8 <__aeabi_d2iz>
   8b534:	ab10      	add	r3, sp, #64	; 0x40
   8b536:	46da      	mov	sl, fp
   8b538:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
   8b53c:	e636      	b.n	8b1ac <__kernel_rem_pio2+0x474>
   8b53e:	bf00      	nop

0008b540 <__kernel_sin>:
   8b540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8b544:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   8b548:	f1b6 5f79 	cmp.w	r6, #1044381696	; 0x3e400000
   8b54c:	b085      	sub	sp, #20
   8b54e:	460c      	mov	r4, r1
   8b550:	4690      	mov	r8, r2
   8b552:	4699      	mov	r9, r3
   8b554:	4605      	mov	r5, r0
   8b556:	da04      	bge.n	8b562 <__kernel_sin+0x22>
   8b558:	f000 ff46 	bl	8c3e8 <__aeabi_d2iz>
   8b55c:	2800      	cmp	r0, #0
   8b55e:	f000 8083 	beq.w	8b668 <__kernel_sin+0x128>
   8b562:	462a      	mov	r2, r5
   8b564:	4623      	mov	r3, r4
   8b566:	4628      	mov	r0, r5
   8b568:	4621      	mov	r1, r4
   8b56a:	f000 fca3 	bl	8beb4 <__aeabi_dmul>
   8b56e:	462a      	mov	r2, r5
   8b570:	4623      	mov	r3, r4
   8b572:	4606      	mov	r6, r0
   8b574:	460f      	mov	r7, r1
   8b576:	f000 fc9d 	bl	8beb4 <__aeabi_dmul>
   8b57a:	a33f      	add	r3, pc, #252	; (adr r3, 8b678 <__kernel_sin+0x138>)
   8b57c:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b580:	4682      	mov	sl, r0
   8b582:	468b      	mov	fp, r1
   8b584:	4630      	mov	r0, r6
   8b586:	4639      	mov	r1, r7
   8b588:	f000 fc94 	bl	8beb4 <__aeabi_dmul>
   8b58c:	a33c      	add	r3, pc, #240	; (adr r3, 8b680 <__kernel_sin+0x140>)
   8b58e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b592:	f000 fadb 	bl	8bb4c <__aeabi_dsub>
   8b596:	4632      	mov	r2, r6
   8b598:	463b      	mov	r3, r7
   8b59a:	f000 fc8b 	bl	8beb4 <__aeabi_dmul>
   8b59e:	a33a      	add	r3, pc, #232	; (adr r3, 8b688 <__kernel_sin+0x148>)
   8b5a0:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b5a4:	f000 fad4 	bl	8bb50 <__adddf3>
   8b5a8:	4632      	mov	r2, r6
   8b5aa:	463b      	mov	r3, r7
   8b5ac:	f000 fc82 	bl	8beb4 <__aeabi_dmul>
   8b5b0:	a337      	add	r3, pc, #220	; (adr r3, 8b690 <__kernel_sin+0x150>)
   8b5b2:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b5b6:	f000 fac9 	bl	8bb4c <__aeabi_dsub>
   8b5ba:	4632      	mov	r2, r6
   8b5bc:	463b      	mov	r3, r7
   8b5be:	f000 fc79 	bl	8beb4 <__aeabi_dmul>
   8b5c2:	a335      	add	r3, pc, #212	; (adr r3, 8b698 <__kernel_sin+0x158>)
   8b5c4:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b5c8:	f000 fac2 	bl	8bb50 <__adddf3>
   8b5cc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8b5ce:	e9cd 0100 	strd	r0, r1, [sp]
   8b5d2:	b39b      	cbz	r3, 8b63c <__kernel_sin+0xfc>
   8b5d4:	4640      	mov	r0, r8
   8b5d6:	4649      	mov	r1, r9
   8b5d8:	2200      	movs	r2, #0
   8b5da:	4b33      	ldr	r3, [pc, #204]	; (8b6a8 <__kernel_sin+0x168>)
   8b5dc:	f000 fc6a 	bl	8beb4 <__aeabi_dmul>
   8b5e0:	e9dd 2300 	ldrd	r2, r3, [sp]
   8b5e4:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8b5e8:	4650      	mov	r0, sl
   8b5ea:	4659      	mov	r1, fp
   8b5ec:	f000 fc62 	bl	8beb4 <__aeabi_dmul>
   8b5f0:	4602      	mov	r2, r0
   8b5f2:	460b      	mov	r3, r1
   8b5f4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8b5f8:	f000 faa8 	bl	8bb4c <__aeabi_dsub>
   8b5fc:	4632      	mov	r2, r6
   8b5fe:	463b      	mov	r3, r7
   8b600:	f000 fc58 	bl	8beb4 <__aeabi_dmul>
   8b604:	4642      	mov	r2, r8
   8b606:	464b      	mov	r3, r9
   8b608:	f000 faa0 	bl	8bb4c <__aeabi_dsub>
   8b60c:	a324      	add	r3, pc, #144	; (adr r3, 8b6a0 <__kernel_sin+0x160>)
   8b60e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b612:	4606      	mov	r6, r0
   8b614:	460f      	mov	r7, r1
   8b616:	4650      	mov	r0, sl
   8b618:	4659      	mov	r1, fp
   8b61a:	f000 fc4b 	bl	8beb4 <__aeabi_dmul>
   8b61e:	4602      	mov	r2, r0
   8b620:	460b      	mov	r3, r1
   8b622:	4630      	mov	r0, r6
   8b624:	4639      	mov	r1, r7
   8b626:	f000 fa93 	bl	8bb50 <__adddf3>
   8b62a:	4602      	mov	r2, r0
   8b62c:	460b      	mov	r3, r1
   8b62e:	4628      	mov	r0, r5
   8b630:	4621      	mov	r1, r4
   8b632:	f000 fa8b 	bl	8bb4c <__aeabi_dsub>
   8b636:	b005      	add	sp, #20
   8b638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b63c:	e9dd 2300 	ldrd	r2, r3, [sp]
   8b640:	4630      	mov	r0, r6
   8b642:	4639      	mov	r1, r7
   8b644:	f000 fc36 	bl	8beb4 <__aeabi_dmul>
   8b648:	a315      	add	r3, pc, #84	; (adr r3, 8b6a0 <__kernel_sin+0x160>)
   8b64a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b64e:	f000 fa7d 	bl	8bb4c <__aeabi_dsub>
   8b652:	4652      	mov	r2, sl
   8b654:	465b      	mov	r3, fp
   8b656:	f000 fc2d 	bl	8beb4 <__aeabi_dmul>
   8b65a:	462a      	mov	r2, r5
   8b65c:	4623      	mov	r3, r4
   8b65e:	f000 fa77 	bl	8bb50 <__adddf3>
   8b662:	b005      	add	sp, #20
   8b664:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b668:	4628      	mov	r0, r5
   8b66a:	4621      	mov	r1, r4
   8b66c:	b005      	add	sp, #20
   8b66e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b672:	bf00      	nop
   8b674:	f3af 8000 	nop.w
   8b678:	5acfd57c 	.word	0x5acfd57c
   8b67c:	3de5d93a 	.word	0x3de5d93a
   8b680:	8a2b9ceb 	.word	0x8a2b9ceb
   8b684:	3e5ae5e6 	.word	0x3e5ae5e6
   8b688:	57b1fe7d 	.word	0x57b1fe7d
   8b68c:	3ec71de3 	.word	0x3ec71de3
   8b690:	19c161d5 	.word	0x19c161d5
   8b694:	3f2a01a0 	.word	0x3f2a01a0
   8b698:	1110f8a6 	.word	0x1110f8a6
   8b69c:	3f811111 	.word	0x3f811111
   8b6a0:	55555549 	.word	0x55555549
   8b6a4:	3fc55555 	.word	0x3fc55555
   8b6a8:	3fe00000 	.word	0x3fe00000
   8b6ac:	00000000 	.word	0x00000000

0008b6b0 <atan>:
   8b6b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8b6b4:	4bbe      	ldr	r3, [pc, #760]	; (8b9b0 <atan+0x300>)
   8b6b6:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   8b6ba:	429e      	cmp	r6, r3
   8b6bc:	460d      	mov	r5, r1
   8b6be:	468a      	mov	sl, r1
   8b6c0:	4604      	mov	r4, r0
   8b6c2:	dd0f      	ble.n	8b6e4 <atan+0x34>
   8b6c4:	4bbb      	ldr	r3, [pc, #748]	; (8b9b4 <atan+0x304>)
   8b6c6:	429e      	cmp	r6, r3
   8b6c8:	f300 80b0 	bgt.w	8b82c <atan+0x17c>
   8b6cc:	f000 80ab 	beq.w	8b826 <atan+0x176>
   8b6d0:	4bb9      	ldr	r3, [pc, #740]	; (8b9b8 <atan+0x308>)
   8b6d2:	49ba      	ldr	r1, [pc, #744]	; (8b9bc <atan+0x30c>)
   8b6d4:	4cba      	ldr	r4, [pc, #744]	; (8b9c0 <atan+0x310>)
   8b6d6:	f1ba 0f00 	cmp.w	sl, #0
   8b6da:	bfc8      	it	gt
   8b6dc:	4619      	movgt	r1, r3
   8b6de:	4620      	mov	r0, r4
   8b6e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b6e4:	4bb7      	ldr	r3, [pc, #732]	; (8b9c4 <atan+0x314>)
   8b6e6:	429e      	cmp	r6, r3
   8b6e8:	f300 80ba 	bgt.w	8b860 <atan+0x1b0>
   8b6ec:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
   8b6f0:	429e      	cmp	r6, r3
   8b6f2:	f340 80a5 	ble.w	8b840 <atan+0x190>
   8b6f6:	f04f 3bff 	mov.w	fp, #4294967295
   8b6fa:	4622      	mov	r2, r4
   8b6fc:	462b      	mov	r3, r5
   8b6fe:	4620      	mov	r0, r4
   8b700:	4629      	mov	r1, r5
   8b702:	f000 fbd7 	bl	8beb4 <__aeabi_dmul>
   8b706:	4602      	mov	r2, r0
   8b708:	460b      	mov	r3, r1
   8b70a:	4680      	mov	r8, r0
   8b70c:	4689      	mov	r9, r1
   8b70e:	f000 fbd1 	bl	8beb4 <__aeabi_dmul>
   8b712:	a38f      	add	r3, pc, #572	; (adr r3, 8b950 <atan+0x2a0>)
   8b714:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b718:	4606      	mov	r6, r0
   8b71a:	460f      	mov	r7, r1
   8b71c:	f000 fbca 	bl	8beb4 <__aeabi_dmul>
   8b720:	a38d      	add	r3, pc, #564	; (adr r3, 8b958 <atan+0x2a8>)
   8b722:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b726:	f000 fa13 	bl	8bb50 <__adddf3>
   8b72a:	4632      	mov	r2, r6
   8b72c:	463b      	mov	r3, r7
   8b72e:	f000 fbc1 	bl	8beb4 <__aeabi_dmul>
   8b732:	a38b      	add	r3, pc, #556	; (adr r3, 8b960 <atan+0x2b0>)
   8b734:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b738:	f000 fa0a 	bl	8bb50 <__adddf3>
   8b73c:	4632      	mov	r2, r6
   8b73e:	463b      	mov	r3, r7
   8b740:	f000 fbb8 	bl	8beb4 <__aeabi_dmul>
   8b744:	a388      	add	r3, pc, #544	; (adr r3, 8b968 <atan+0x2b8>)
   8b746:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b74a:	f000 fa01 	bl	8bb50 <__adddf3>
   8b74e:	4632      	mov	r2, r6
   8b750:	463b      	mov	r3, r7
   8b752:	f000 fbaf 	bl	8beb4 <__aeabi_dmul>
   8b756:	a386      	add	r3, pc, #536	; (adr r3, 8b970 <atan+0x2c0>)
   8b758:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b75c:	f000 f9f8 	bl	8bb50 <__adddf3>
   8b760:	4632      	mov	r2, r6
   8b762:	463b      	mov	r3, r7
   8b764:	f000 fba6 	bl	8beb4 <__aeabi_dmul>
   8b768:	a383      	add	r3, pc, #524	; (adr r3, 8b978 <atan+0x2c8>)
   8b76a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b76e:	f000 f9ef 	bl	8bb50 <__adddf3>
   8b772:	4642      	mov	r2, r8
   8b774:	464b      	mov	r3, r9
   8b776:	f000 fb9d 	bl	8beb4 <__aeabi_dmul>
   8b77a:	a381      	add	r3, pc, #516	; (adr r3, 8b980 <atan+0x2d0>)
   8b77c:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b780:	4680      	mov	r8, r0
   8b782:	4689      	mov	r9, r1
   8b784:	4630      	mov	r0, r6
   8b786:	4639      	mov	r1, r7
   8b788:	f000 fb94 	bl	8beb4 <__aeabi_dmul>
   8b78c:	a37e      	add	r3, pc, #504	; (adr r3, 8b988 <atan+0x2d8>)
   8b78e:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b792:	f000 f9db 	bl	8bb4c <__aeabi_dsub>
   8b796:	4632      	mov	r2, r6
   8b798:	463b      	mov	r3, r7
   8b79a:	f000 fb8b 	bl	8beb4 <__aeabi_dmul>
   8b79e:	a37c      	add	r3, pc, #496	; (adr r3, 8b990 <atan+0x2e0>)
   8b7a0:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b7a4:	f000 f9d2 	bl	8bb4c <__aeabi_dsub>
   8b7a8:	4632      	mov	r2, r6
   8b7aa:	463b      	mov	r3, r7
   8b7ac:	f000 fb82 	bl	8beb4 <__aeabi_dmul>
   8b7b0:	a379      	add	r3, pc, #484	; (adr r3, 8b998 <atan+0x2e8>)
   8b7b2:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b7b6:	f000 f9c9 	bl	8bb4c <__aeabi_dsub>
   8b7ba:	4632      	mov	r2, r6
   8b7bc:	463b      	mov	r3, r7
   8b7be:	f000 fb79 	bl	8beb4 <__aeabi_dmul>
   8b7c2:	a377      	add	r3, pc, #476	; (adr r3, 8b9a0 <atan+0x2f0>)
   8b7c4:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b7c8:	f000 f9c0 	bl	8bb4c <__aeabi_dsub>
   8b7cc:	4632      	mov	r2, r6
   8b7ce:	463b      	mov	r3, r7
   8b7d0:	f000 fb70 	bl	8beb4 <__aeabi_dmul>
   8b7d4:	f1bb 3fff 	cmp.w	fp, #4294967295
   8b7d8:	4602      	mov	r2, r0
   8b7da:	460b      	mov	r3, r1
   8b7dc:	d067      	beq.n	8b8ae <atan+0x1fe>
   8b7de:	4640      	mov	r0, r8
   8b7e0:	4649      	mov	r1, r9
   8b7e2:	f000 f9b5 	bl	8bb50 <__adddf3>
   8b7e6:	4622      	mov	r2, r4
   8b7e8:	462b      	mov	r3, r5
   8b7ea:	f000 fb63 	bl	8beb4 <__aeabi_dmul>
   8b7ee:	4e76      	ldr	r6, [pc, #472]	; (8b9c8 <atan+0x318>)
   8b7f0:	4b76      	ldr	r3, [pc, #472]	; (8b9cc <atan+0x31c>)
   8b7f2:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
   8b7f6:	445e      	add	r6, fp
   8b7f8:	449b      	add	fp, r3
   8b7fa:	e9db 2300 	ldrd	r2, r3, [fp]
   8b7fe:	f000 f9a5 	bl	8bb4c <__aeabi_dsub>
   8b802:	4622      	mov	r2, r4
   8b804:	462b      	mov	r3, r5
   8b806:	f000 f9a1 	bl	8bb4c <__aeabi_dsub>
   8b80a:	4602      	mov	r2, r0
   8b80c:	460b      	mov	r3, r1
   8b80e:	e9d6 0100 	ldrd	r0, r1, [r6]
   8b812:	f000 f99b 	bl	8bb4c <__aeabi_dsub>
   8b816:	f1ba 0f00 	cmp.w	sl, #0
   8b81a:	4604      	mov	r4, r0
   8b81c:	f6bf af5f 	bge.w	8b6de <atan+0x2e>
   8b820:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   8b824:	e75b      	b.n	8b6de <atan+0x2e>
   8b826:	2800      	cmp	r0, #0
   8b828:	f43f af52 	beq.w	8b6d0 <atan+0x20>
   8b82c:	4622      	mov	r2, r4
   8b82e:	4620      	mov	r0, r4
   8b830:	4629      	mov	r1, r5
   8b832:	462b      	mov	r3, r5
   8b834:	f000 f98c 	bl	8bb50 <__adddf3>
   8b838:	4604      	mov	r4, r0
   8b83a:	4620      	mov	r0, r4
   8b83c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b840:	a359      	add	r3, pc, #356	; (adr r3, 8b9a8 <atan+0x2f8>)
   8b842:	e9d3 2300 	ldrd	r2, r3, [r3]
   8b846:	f000 f983 	bl	8bb50 <__adddf3>
   8b84a:	2200      	movs	r2, #0
   8b84c:	4b60      	ldr	r3, [pc, #384]	; (8b9d0 <atan+0x320>)
   8b84e:	f000 fdc1 	bl	8c3d4 <__aeabi_dcmpgt>
   8b852:	2800      	cmp	r0, #0
   8b854:	f43f af4f 	beq.w	8b6f6 <atan+0x46>
   8b858:	4629      	mov	r1, r5
   8b85a:	4620      	mov	r0, r4
   8b85c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8b860:	f000 f8c0 	bl	8b9e4 <fabs>
   8b864:	4b5b      	ldr	r3, [pc, #364]	; (8b9d4 <atan+0x324>)
   8b866:	4604      	mov	r4, r0
   8b868:	429e      	cmp	r6, r3
   8b86a:	460d      	mov	r5, r1
   8b86c:	dc2f      	bgt.n	8b8ce <atan+0x21e>
   8b86e:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
   8b872:	429e      	cmp	r6, r3
   8b874:	dc54      	bgt.n	8b920 <atan+0x270>
   8b876:	4602      	mov	r2, r0
   8b878:	460b      	mov	r3, r1
   8b87a:	f000 f969 	bl	8bb50 <__adddf3>
   8b87e:	2200      	movs	r2, #0
   8b880:	4b53      	ldr	r3, [pc, #332]	; (8b9d0 <atan+0x320>)
   8b882:	f000 f963 	bl	8bb4c <__aeabi_dsub>
   8b886:	2200      	movs	r2, #0
   8b888:	4606      	mov	r6, r0
   8b88a:	460f      	mov	r7, r1
   8b88c:	4620      	mov	r0, r4
   8b88e:	4629      	mov	r1, r5
   8b890:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   8b894:	f000 f95c 	bl	8bb50 <__adddf3>
   8b898:	4602      	mov	r2, r0
   8b89a:	460b      	mov	r3, r1
   8b89c:	4630      	mov	r0, r6
   8b89e:	4639      	mov	r1, r7
   8b8a0:	f000 fc32 	bl	8c108 <__aeabi_ddiv>
   8b8a4:	f04f 0b00 	mov.w	fp, #0
   8b8a8:	4604      	mov	r4, r0
   8b8aa:	460d      	mov	r5, r1
   8b8ac:	e725      	b.n	8b6fa <atan+0x4a>
   8b8ae:	4640      	mov	r0, r8
   8b8b0:	4649      	mov	r1, r9
   8b8b2:	f000 f94d 	bl	8bb50 <__adddf3>
   8b8b6:	4622      	mov	r2, r4
   8b8b8:	462b      	mov	r3, r5
   8b8ba:	f000 fafb 	bl	8beb4 <__aeabi_dmul>
   8b8be:	4602      	mov	r2, r0
   8b8c0:	460b      	mov	r3, r1
   8b8c2:	4620      	mov	r0, r4
   8b8c4:	4629      	mov	r1, r5
   8b8c6:	f000 f941 	bl	8bb4c <__aeabi_dsub>
   8b8ca:	4604      	mov	r4, r0
   8b8cc:	e707      	b.n	8b6de <atan+0x2e>
   8b8ce:	4b42      	ldr	r3, [pc, #264]	; (8b9d8 <atan+0x328>)
   8b8d0:	429e      	cmp	r6, r3
   8b8d2:	dc1a      	bgt.n	8b90a <atan+0x25a>
   8b8d4:	2200      	movs	r2, #0
   8b8d6:	4b41      	ldr	r3, [pc, #260]	; (8b9dc <atan+0x32c>)
   8b8d8:	f000 f938 	bl	8bb4c <__aeabi_dsub>
   8b8dc:	2200      	movs	r2, #0
   8b8de:	4606      	mov	r6, r0
   8b8e0:	460f      	mov	r7, r1
   8b8e2:	4620      	mov	r0, r4
   8b8e4:	4629      	mov	r1, r5
   8b8e6:	4b3d      	ldr	r3, [pc, #244]	; (8b9dc <atan+0x32c>)
   8b8e8:	f000 fae4 	bl	8beb4 <__aeabi_dmul>
   8b8ec:	2200      	movs	r2, #0
   8b8ee:	4b38      	ldr	r3, [pc, #224]	; (8b9d0 <atan+0x320>)
   8b8f0:	f000 f92e 	bl	8bb50 <__adddf3>
   8b8f4:	4602      	mov	r2, r0
   8b8f6:	460b      	mov	r3, r1
   8b8f8:	4630      	mov	r0, r6
   8b8fa:	4639      	mov	r1, r7
   8b8fc:	f000 fc04 	bl	8c108 <__aeabi_ddiv>
   8b900:	f04f 0b02 	mov.w	fp, #2
   8b904:	4604      	mov	r4, r0
   8b906:	460d      	mov	r5, r1
   8b908:	e6f7      	b.n	8b6fa <atan+0x4a>
   8b90a:	4602      	mov	r2, r0
   8b90c:	460b      	mov	r3, r1
   8b90e:	2000      	movs	r0, #0
   8b910:	4933      	ldr	r1, [pc, #204]	; (8b9e0 <atan+0x330>)
   8b912:	f000 fbf9 	bl	8c108 <__aeabi_ddiv>
   8b916:	f04f 0b03 	mov.w	fp, #3
   8b91a:	4604      	mov	r4, r0
   8b91c:	460d      	mov	r5, r1
   8b91e:	e6ec      	b.n	8b6fa <atan+0x4a>
   8b920:	2200      	movs	r2, #0
   8b922:	4b2b      	ldr	r3, [pc, #172]	; (8b9d0 <atan+0x320>)
   8b924:	f000 f912 	bl	8bb4c <__aeabi_dsub>
   8b928:	2200      	movs	r2, #0
   8b92a:	4606      	mov	r6, r0
   8b92c:	460f      	mov	r7, r1
   8b92e:	4620      	mov	r0, r4
   8b930:	4629      	mov	r1, r5
   8b932:	4b27      	ldr	r3, [pc, #156]	; (8b9d0 <atan+0x320>)
   8b934:	f000 f90c 	bl	8bb50 <__adddf3>
   8b938:	4602      	mov	r2, r0
   8b93a:	460b      	mov	r3, r1
   8b93c:	4630      	mov	r0, r6
   8b93e:	4639      	mov	r1, r7
   8b940:	f000 fbe2 	bl	8c108 <__aeabi_ddiv>
   8b944:	f04f 0b01 	mov.w	fp, #1
   8b948:	4604      	mov	r4, r0
   8b94a:	460d      	mov	r5, r1
   8b94c:	e6d5      	b.n	8b6fa <atan+0x4a>
   8b94e:	bf00      	nop
   8b950:	e322da11 	.word	0xe322da11
   8b954:	3f90ad3a 	.word	0x3f90ad3a
   8b958:	24760deb 	.word	0x24760deb
   8b95c:	3fa97b4b 	.word	0x3fa97b4b
   8b960:	a0d03d51 	.word	0xa0d03d51
   8b964:	3fb10d66 	.word	0x3fb10d66
   8b968:	c54c206e 	.word	0xc54c206e
   8b96c:	3fb745cd 	.word	0x3fb745cd
   8b970:	920083ff 	.word	0x920083ff
   8b974:	3fc24924 	.word	0x3fc24924
   8b978:	5555550d 	.word	0x5555550d
   8b97c:	3fd55555 	.word	0x3fd55555
   8b980:	2c6a6c2f 	.word	0x2c6a6c2f
   8b984:	bfa2b444 	.word	0xbfa2b444
   8b988:	52defd9a 	.word	0x52defd9a
   8b98c:	3fadde2d 	.word	0x3fadde2d
   8b990:	af749a6d 	.word	0xaf749a6d
   8b994:	3fb3b0f2 	.word	0x3fb3b0f2
   8b998:	fe231671 	.word	0xfe231671
   8b99c:	3fbc71c6 	.word	0x3fbc71c6
   8b9a0:	9998ebc4 	.word	0x9998ebc4
   8b9a4:	3fc99999 	.word	0x3fc99999
   8b9a8:	8800759c 	.word	0x8800759c
   8b9ac:	7e37e43c 	.word	0x7e37e43c
   8b9b0:	440fffff 	.word	0x440fffff
   8b9b4:	7ff00000 	.word	0x7ff00000
   8b9b8:	3ff921fb 	.word	0x3ff921fb
   8b9bc:	bff921fb 	.word	0xbff921fb
   8b9c0:	54442d18 	.word	0x54442d18
   8b9c4:	3fdbffff 	.word	0x3fdbffff
   8b9c8:	00092138 	.word	0x00092138
   8b9cc:	00092118 	.word	0x00092118
   8b9d0:	3ff00000 	.word	0x3ff00000
   8b9d4:	3ff2ffff 	.word	0x3ff2ffff
   8b9d8:	40037fff 	.word	0x40037fff
   8b9dc:	3ff80000 	.word	0x3ff80000
   8b9e0:	bff00000 	.word	0xbff00000

0008b9e4 <fabs>:
   8b9e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   8b9e8:	4770      	bx	lr
   8b9ea:	bf00      	nop

0008b9ec <__fpclassifyd>:
   8b9ec:	b410      	push	{r4}
   8b9ee:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
   8b9f2:	d008      	beq.n	8ba06 <__fpclassifyd+0x1a>
   8b9f4:	4b11      	ldr	r3, [pc, #68]	; (8ba3c <__fpclassifyd+0x50>)
   8b9f6:	f5a1 1280 	sub.w	r2, r1, #1048576	; 0x100000
   8b9fa:	429a      	cmp	r2, r3
   8b9fc:	d808      	bhi.n	8ba10 <__fpclassifyd+0x24>
   8b9fe:	2004      	movs	r0, #4
   8ba00:	f85d 4b04 	ldr.w	r4, [sp], #4
   8ba04:	4770      	bx	lr
   8ba06:	b918      	cbnz	r0, 8ba10 <__fpclassifyd+0x24>
   8ba08:	2002      	movs	r0, #2
   8ba0a:	f85d 4b04 	ldr.w	r4, [sp], #4
   8ba0e:	4770      	bx	lr
   8ba10:	f101 41ff 	add.w	r1, r1, #2139095040	; 0x7f800000
   8ba14:	4b09      	ldr	r3, [pc, #36]	; (8ba3c <__fpclassifyd+0x50>)
   8ba16:	f501 01e0 	add.w	r1, r1, #7340032	; 0x700000
   8ba1a:	4299      	cmp	r1, r3
   8ba1c:	d9ef      	bls.n	8b9fe <__fpclassifyd+0x12>
   8ba1e:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
   8ba22:	d201      	bcs.n	8ba28 <__fpclassifyd+0x3c>
   8ba24:	2003      	movs	r0, #3
   8ba26:	e7eb      	b.n	8ba00 <__fpclassifyd+0x14>
   8ba28:	4b05      	ldr	r3, [pc, #20]	; (8ba40 <__fpclassifyd+0x54>)
   8ba2a:	429c      	cmp	r4, r3
   8ba2c:	d001      	beq.n	8ba32 <__fpclassifyd+0x46>
   8ba2e:	2000      	movs	r0, #0
   8ba30:	e7e6      	b.n	8ba00 <__fpclassifyd+0x14>
   8ba32:	fab0 f080 	clz	r0, r0
   8ba36:	0940      	lsrs	r0, r0, #5
   8ba38:	e7e2      	b.n	8ba00 <__fpclassifyd+0x14>
   8ba3a:	bf00      	nop
   8ba3c:	7fdfffff 	.word	0x7fdfffff
   8ba40:	7ff00000 	.word	0x7ff00000

0008ba44 <matherr>:
   8ba44:	2000      	movs	r0, #0
   8ba46:	4770      	bx	lr

0008ba48 <scalbn>:
   8ba48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8ba4a:	f3c1 560a 	ubfx	r6, r1, #20, #11
   8ba4e:	4604      	mov	r4, r0
   8ba50:	460d      	mov	r5, r1
   8ba52:	460b      	mov	r3, r1
   8ba54:	4617      	mov	r7, r2
   8ba56:	bb16      	cbnz	r6, 8ba9e <scalbn+0x56>
   8ba58:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   8ba5c:	4303      	orrs	r3, r0
   8ba5e:	d032      	beq.n	8bac6 <scalbn+0x7e>
   8ba60:	2200      	movs	r2, #0
   8ba62:	4b31      	ldr	r3, [pc, #196]	; (8bb28 <scalbn+0xe0>)
   8ba64:	f000 fa26 	bl	8beb4 <__aeabi_dmul>
   8ba68:	4a30      	ldr	r2, [pc, #192]	; (8bb2c <scalbn+0xe4>)
   8ba6a:	4604      	mov	r4, r0
   8ba6c:	4297      	cmp	r7, r2
   8ba6e:	460d      	mov	r5, r1
   8ba70:	460b      	mov	r3, r1
   8ba72:	db37      	blt.n	8bae4 <scalbn+0x9c>
   8ba74:	f240 72fe 	movw	r2, #2046	; 0x7fe
   8ba78:	f3c1 560a 	ubfx	r6, r1, #20, #11
   8ba7c:	3e36      	subs	r6, #54	; 0x36
   8ba7e:	443e      	add	r6, r7
   8ba80:	4296      	cmp	r6, r2
   8ba82:	dd15      	ble.n	8bab0 <scalbn+0x68>
   8ba84:	a124      	add	r1, pc, #144	; (adr r1, 8bb18 <scalbn+0xd0>)
   8ba86:	e9d1 0100 	ldrd	r0, r1, [r1]
   8ba8a:	4622      	mov	r2, r4
   8ba8c:	462b      	mov	r3, r5
   8ba8e:	f000 f851 	bl	8bb34 <copysign>
   8ba92:	a321      	add	r3, pc, #132	; (adr r3, 8bb18 <scalbn+0xd0>)
   8ba94:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ba98:	f000 fa0c 	bl	8beb4 <__aeabi_dmul>
   8ba9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8ba9e:	f240 72ff 	movw	r2, #2047	; 0x7ff
   8baa2:	4296      	cmp	r6, r2
   8baa4:	d024      	beq.n	8baf0 <scalbn+0xa8>
   8baa6:	f240 72fe 	movw	r2, #2046	; 0x7fe
   8baaa:	443e      	add	r6, r7
   8baac:	4296      	cmp	r6, r2
   8baae:	dce9      	bgt.n	8ba84 <scalbn+0x3c>
   8bab0:	2e00      	cmp	r6, #0
   8bab2:	dd09      	ble.n	8bac8 <scalbn+0x80>
   8bab4:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   8bab8:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   8babc:	ea43 5506 	orr.w	r5, r3, r6, lsl #20
   8bac0:	4620      	mov	r0, r4
   8bac2:	4629      	mov	r1, r5
   8bac4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8bac6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8bac8:	f116 0f35 	cmn.w	r6, #53	; 0x35
   8bacc:	da15      	bge.n	8bafa <scalbn+0xb2>
   8bace:	f24c 3350 	movw	r3, #50000	; 0xc350
   8bad2:	429f      	cmp	r7, r3
   8bad4:	dcd6      	bgt.n	8ba84 <scalbn+0x3c>
   8bad6:	a112      	add	r1, pc, #72	; (adr r1, 8bb20 <scalbn+0xd8>)
   8bad8:	e9d1 0100 	ldrd	r0, r1, [r1]
   8badc:	4622      	mov	r2, r4
   8bade:	462b      	mov	r3, r5
   8bae0:	f000 f828 	bl	8bb34 <copysign>
   8bae4:	a30e      	add	r3, pc, #56	; (adr r3, 8bb20 <scalbn+0xd8>)
   8bae6:	e9d3 2300 	ldrd	r2, r3, [r3]
   8baea:	f000 f9e3 	bl	8beb4 <__aeabi_dmul>
   8baee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8baf0:	4602      	mov	r2, r0
   8baf2:	460b      	mov	r3, r1
   8baf4:	f000 f82c 	bl	8bb50 <__adddf3>
   8baf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8bafa:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   8bafe:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   8bb02:	3636      	adds	r6, #54	; 0x36
   8bb04:	ea43 5506 	orr.w	r5, r3, r6, lsl #20
   8bb08:	4620      	mov	r0, r4
   8bb0a:	4629      	mov	r1, r5
   8bb0c:	2200      	movs	r2, #0
   8bb0e:	4b08      	ldr	r3, [pc, #32]	; (8bb30 <scalbn+0xe8>)
   8bb10:	f000 f9d0 	bl	8beb4 <__aeabi_dmul>
   8bb14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8bb16:	bf00      	nop
   8bb18:	8800759c 	.word	0x8800759c
   8bb1c:	7e37e43c 	.word	0x7e37e43c
   8bb20:	c2f8f359 	.word	0xc2f8f359
   8bb24:	01a56e1f 	.word	0x01a56e1f
   8bb28:	43500000 	.word	0x43500000
   8bb2c:	ffff3cb0 	.word	0xffff3cb0
   8bb30:	3c900000 	.word	0x3c900000

0008bb34 <copysign>:
   8bb34:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
   8bb38:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   8bb3c:	ea43 0102 	orr.w	r1, r3, r2
   8bb40:	4770      	bx	lr
   8bb42:	bf00      	nop

0008bb44 <__aeabi_drsub>:
   8bb44:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   8bb48:	e002      	b.n	8bb50 <__adddf3>
   8bb4a:	bf00      	nop

0008bb4c <__aeabi_dsub>:
   8bb4c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0008bb50 <__adddf3>:
   8bb50:	b530      	push	{r4, r5, lr}
   8bb52:	ea4f 0441 	mov.w	r4, r1, lsl #1
   8bb56:	ea4f 0543 	mov.w	r5, r3, lsl #1
   8bb5a:	ea94 0f05 	teq	r4, r5
   8bb5e:	bf08      	it	eq
   8bb60:	ea90 0f02 	teqeq	r0, r2
   8bb64:	bf1f      	itttt	ne
   8bb66:	ea54 0c00 	orrsne.w	ip, r4, r0
   8bb6a:	ea55 0c02 	orrsne.w	ip, r5, r2
   8bb6e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   8bb72:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   8bb76:	f000 80e2 	beq.w	8bd3e <__adddf3+0x1ee>
   8bb7a:	ea4f 5454 	mov.w	r4, r4, lsr #21
   8bb7e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   8bb82:	bfb8      	it	lt
   8bb84:	426d      	neglt	r5, r5
   8bb86:	dd0c      	ble.n	8bba2 <__adddf3+0x52>
   8bb88:	442c      	add	r4, r5
   8bb8a:	ea80 0202 	eor.w	r2, r0, r2
   8bb8e:	ea81 0303 	eor.w	r3, r1, r3
   8bb92:	ea82 0000 	eor.w	r0, r2, r0
   8bb96:	ea83 0101 	eor.w	r1, r3, r1
   8bb9a:	ea80 0202 	eor.w	r2, r0, r2
   8bb9e:	ea81 0303 	eor.w	r3, r1, r3
   8bba2:	2d36      	cmp	r5, #54	; 0x36
   8bba4:	bf88      	it	hi
   8bba6:	bd30      	pophi	{r4, r5, pc}
   8bba8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8bbac:	ea4f 3101 	mov.w	r1, r1, lsl #12
   8bbb0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   8bbb4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   8bbb8:	d002      	beq.n	8bbc0 <__adddf3+0x70>
   8bbba:	4240      	negs	r0, r0
   8bbbc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8bbc0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   8bbc4:	ea4f 3303 	mov.w	r3, r3, lsl #12
   8bbc8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   8bbcc:	d002      	beq.n	8bbd4 <__adddf3+0x84>
   8bbce:	4252      	negs	r2, r2
   8bbd0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   8bbd4:	ea94 0f05 	teq	r4, r5
   8bbd8:	f000 80a7 	beq.w	8bd2a <__adddf3+0x1da>
   8bbdc:	f1a4 0401 	sub.w	r4, r4, #1
   8bbe0:	f1d5 0e20 	rsbs	lr, r5, #32
   8bbe4:	db0d      	blt.n	8bc02 <__adddf3+0xb2>
   8bbe6:	fa02 fc0e 	lsl.w	ip, r2, lr
   8bbea:	fa22 f205 	lsr.w	r2, r2, r5
   8bbee:	1880      	adds	r0, r0, r2
   8bbf0:	f141 0100 	adc.w	r1, r1, #0
   8bbf4:	fa03 f20e 	lsl.w	r2, r3, lr
   8bbf8:	1880      	adds	r0, r0, r2
   8bbfa:	fa43 f305 	asr.w	r3, r3, r5
   8bbfe:	4159      	adcs	r1, r3
   8bc00:	e00e      	b.n	8bc20 <__adddf3+0xd0>
   8bc02:	f1a5 0520 	sub.w	r5, r5, #32
   8bc06:	f10e 0e20 	add.w	lr, lr, #32
   8bc0a:	2a01      	cmp	r2, #1
   8bc0c:	fa03 fc0e 	lsl.w	ip, r3, lr
   8bc10:	bf28      	it	cs
   8bc12:	f04c 0c02 	orrcs.w	ip, ip, #2
   8bc16:	fa43 f305 	asr.w	r3, r3, r5
   8bc1a:	18c0      	adds	r0, r0, r3
   8bc1c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   8bc20:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8bc24:	d507      	bpl.n	8bc36 <__adddf3+0xe6>
   8bc26:	f04f 0e00 	mov.w	lr, #0
   8bc2a:	f1dc 0c00 	rsbs	ip, ip, #0
   8bc2e:	eb7e 0000 	sbcs.w	r0, lr, r0
   8bc32:	eb6e 0101 	sbc.w	r1, lr, r1
   8bc36:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   8bc3a:	d31b      	bcc.n	8bc74 <__adddf3+0x124>
   8bc3c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   8bc40:	d30c      	bcc.n	8bc5c <__adddf3+0x10c>
   8bc42:	0849      	lsrs	r1, r1, #1
   8bc44:	ea5f 0030 	movs.w	r0, r0, rrx
   8bc48:	ea4f 0c3c 	mov.w	ip, ip, rrx
   8bc4c:	f104 0401 	add.w	r4, r4, #1
   8bc50:	ea4f 5244 	mov.w	r2, r4, lsl #21
   8bc54:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   8bc58:	f080 809a 	bcs.w	8bd90 <__adddf3+0x240>
   8bc5c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   8bc60:	bf08      	it	eq
   8bc62:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   8bc66:	f150 0000 	adcs.w	r0, r0, #0
   8bc6a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8bc6e:	ea41 0105 	orr.w	r1, r1, r5
   8bc72:	bd30      	pop	{r4, r5, pc}
   8bc74:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   8bc78:	4140      	adcs	r0, r0
   8bc7a:	eb41 0101 	adc.w	r1, r1, r1
   8bc7e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8bc82:	f1a4 0401 	sub.w	r4, r4, #1
   8bc86:	d1e9      	bne.n	8bc5c <__adddf3+0x10c>
   8bc88:	f091 0f00 	teq	r1, #0
   8bc8c:	bf04      	itt	eq
   8bc8e:	4601      	moveq	r1, r0
   8bc90:	2000      	moveq	r0, #0
   8bc92:	fab1 f381 	clz	r3, r1
   8bc96:	bf08      	it	eq
   8bc98:	3320      	addeq	r3, #32
   8bc9a:	f1a3 030b 	sub.w	r3, r3, #11
   8bc9e:	f1b3 0220 	subs.w	r2, r3, #32
   8bca2:	da0c      	bge.n	8bcbe <__adddf3+0x16e>
   8bca4:	320c      	adds	r2, #12
   8bca6:	dd08      	ble.n	8bcba <__adddf3+0x16a>
   8bca8:	f102 0c14 	add.w	ip, r2, #20
   8bcac:	f1c2 020c 	rsb	r2, r2, #12
   8bcb0:	fa01 f00c 	lsl.w	r0, r1, ip
   8bcb4:	fa21 f102 	lsr.w	r1, r1, r2
   8bcb8:	e00c      	b.n	8bcd4 <__adddf3+0x184>
   8bcba:	f102 0214 	add.w	r2, r2, #20
   8bcbe:	bfd8      	it	le
   8bcc0:	f1c2 0c20 	rsble	ip, r2, #32
   8bcc4:	fa01 f102 	lsl.w	r1, r1, r2
   8bcc8:	fa20 fc0c 	lsr.w	ip, r0, ip
   8bccc:	bfdc      	itt	le
   8bcce:	ea41 010c 	orrle.w	r1, r1, ip
   8bcd2:	4090      	lslle	r0, r2
   8bcd4:	1ae4      	subs	r4, r4, r3
   8bcd6:	bfa2      	ittt	ge
   8bcd8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   8bcdc:	4329      	orrge	r1, r5
   8bcde:	bd30      	popge	{r4, r5, pc}
   8bce0:	ea6f 0404 	mvn.w	r4, r4
   8bce4:	3c1f      	subs	r4, #31
   8bce6:	da1c      	bge.n	8bd22 <__adddf3+0x1d2>
   8bce8:	340c      	adds	r4, #12
   8bcea:	dc0e      	bgt.n	8bd0a <__adddf3+0x1ba>
   8bcec:	f104 0414 	add.w	r4, r4, #20
   8bcf0:	f1c4 0220 	rsb	r2, r4, #32
   8bcf4:	fa20 f004 	lsr.w	r0, r0, r4
   8bcf8:	fa01 f302 	lsl.w	r3, r1, r2
   8bcfc:	ea40 0003 	orr.w	r0, r0, r3
   8bd00:	fa21 f304 	lsr.w	r3, r1, r4
   8bd04:	ea45 0103 	orr.w	r1, r5, r3
   8bd08:	bd30      	pop	{r4, r5, pc}
   8bd0a:	f1c4 040c 	rsb	r4, r4, #12
   8bd0e:	f1c4 0220 	rsb	r2, r4, #32
   8bd12:	fa20 f002 	lsr.w	r0, r0, r2
   8bd16:	fa01 f304 	lsl.w	r3, r1, r4
   8bd1a:	ea40 0003 	orr.w	r0, r0, r3
   8bd1e:	4629      	mov	r1, r5
   8bd20:	bd30      	pop	{r4, r5, pc}
   8bd22:	fa21 f004 	lsr.w	r0, r1, r4
   8bd26:	4629      	mov	r1, r5
   8bd28:	bd30      	pop	{r4, r5, pc}
   8bd2a:	f094 0f00 	teq	r4, #0
   8bd2e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   8bd32:	bf06      	itte	eq
   8bd34:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   8bd38:	3401      	addeq	r4, #1
   8bd3a:	3d01      	subne	r5, #1
   8bd3c:	e74e      	b.n	8bbdc <__adddf3+0x8c>
   8bd3e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   8bd42:	bf18      	it	ne
   8bd44:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   8bd48:	d029      	beq.n	8bd9e <__adddf3+0x24e>
   8bd4a:	ea94 0f05 	teq	r4, r5
   8bd4e:	bf08      	it	eq
   8bd50:	ea90 0f02 	teqeq	r0, r2
   8bd54:	d005      	beq.n	8bd62 <__adddf3+0x212>
   8bd56:	ea54 0c00 	orrs.w	ip, r4, r0
   8bd5a:	bf04      	itt	eq
   8bd5c:	4619      	moveq	r1, r3
   8bd5e:	4610      	moveq	r0, r2
   8bd60:	bd30      	pop	{r4, r5, pc}
   8bd62:	ea91 0f03 	teq	r1, r3
   8bd66:	bf1e      	ittt	ne
   8bd68:	2100      	movne	r1, #0
   8bd6a:	2000      	movne	r0, #0
   8bd6c:	bd30      	popne	{r4, r5, pc}
   8bd6e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   8bd72:	d105      	bne.n	8bd80 <__adddf3+0x230>
   8bd74:	0040      	lsls	r0, r0, #1
   8bd76:	4149      	adcs	r1, r1
   8bd78:	bf28      	it	cs
   8bd7a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   8bd7e:	bd30      	pop	{r4, r5, pc}
   8bd80:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   8bd84:	bf3c      	itt	cc
   8bd86:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   8bd8a:	bd30      	popcc	{r4, r5, pc}
   8bd8c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8bd90:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   8bd94:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   8bd98:	f04f 0000 	mov.w	r0, #0
   8bd9c:	bd30      	pop	{r4, r5, pc}
   8bd9e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   8bda2:	bf1a      	itte	ne
   8bda4:	4619      	movne	r1, r3
   8bda6:	4610      	movne	r0, r2
   8bda8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   8bdac:	bf1c      	itt	ne
   8bdae:	460b      	movne	r3, r1
   8bdb0:	4602      	movne	r2, r0
   8bdb2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   8bdb6:	bf06      	itte	eq
   8bdb8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   8bdbc:	ea91 0f03 	teqeq	r1, r3
   8bdc0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   8bdc4:	bd30      	pop	{r4, r5, pc}
   8bdc6:	bf00      	nop

0008bdc8 <__aeabi_ui2d>:
   8bdc8:	f090 0f00 	teq	r0, #0
   8bdcc:	bf04      	itt	eq
   8bdce:	2100      	moveq	r1, #0
   8bdd0:	4770      	bxeq	lr
   8bdd2:	b530      	push	{r4, r5, lr}
   8bdd4:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8bdd8:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8bddc:	f04f 0500 	mov.w	r5, #0
   8bde0:	f04f 0100 	mov.w	r1, #0
   8bde4:	e750      	b.n	8bc88 <__adddf3+0x138>
   8bde6:	bf00      	nop

0008bde8 <__aeabi_i2d>:
   8bde8:	f090 0f00 	teq	r0, #0
   8bdec:	bf04      	itt	eq
   8bdee:	2100      	moveq	r1, #0
   8bdf0:	4770      	bxeq	lr
   8bdf2:	b530      	push	{r4, r5, lr}
   8bdf4:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8bdf8:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8bdfc:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   8be00:	bf48      	it	mi
   8be02:	4240      	negmi	r0, r0
   8be04:	f04f 0100 	mov.w	r1, #0
   8be08:	e73e      	b.n	8bc88 <__adddf3+0x138>
   8be0a:	bf00      	nop

0008be0c <__aeabi_f2d>:
   8be0c:	0042      	lsls	r2, r0, #1
   8be0e:	ea4f 01e2 	mov.w	r1, r2, asr #3
   8be12:	ea4f 0131 	mov.w	r1, r1, rrx
   8be16:	ea4f 7002 	mov.w	r0, r2, lsl #28
   8be1a:	bf1f      	itttt	ne
   8be1c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   8be20:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   8be24:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   8be28:	4770      	bxne	lr
   8be2a:	f092 0f00 	teq	r2, #0
   8be2e:	bf14      	ite	ne
   8be30:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   8be34:	4770      	bxeq	lr
   8be36:	b530      	push	{r4, r5, lr}
   8be38:	f44f 7460 	mov.w	r4, #896	; 0x380
   8be3c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8be40:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   8be44:	e720      	b.n	8bc88 <__adddf3+0x138>
   8be46:	bf00      	nop

0008be48 <__aeabi_ul2d>:
   8be48:	ea50 0201 	orrs.w	r2, r0, r1
   8be4c:	bf08      	it	eq
   8be4e:	4770      	bxeq	lr
   8be50:	b530      	push	{r4, r5, lr}
   8be52:	f04f 0500 	mov.w	r5, #0
   8be56:	e00a      	b.n	8be6e <__aeabi_l2d+0x16>

0008be58 <__aeabi_l2d>:
   8be58:	ea50 0201 	orrs.w	r2, r0, r1
   8be5c:	bf08      	it	eq
   8be5e:	4770      	bxeq	lr
   8be60:	b530      	push	{r4, r5, lr}
   8be62:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   8be66:	d502      	bpl.n	8be6e <__aeabi_l2d+0x16>
   8be68:	4240      	negs	r0, r0
   8be6a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8be6e:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8be72:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8be76:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   8be7a:	f43f aedc 	beq.w	8bc36 <__adddf3+0xe6>
   8be7e:	f04f 0203 	mov.w	r2, #3
   8be82:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   8be86:	bf18      	it	ne
   8be88:	3203      	addne	r2, #3
   8be8a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   8be8e:	bf18      	it	ne
   8be90:	3203      	addne	r2, #3
   8be92:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   8be96:	f1c2 0320 	rsb	r3, r2, #32
   8be9a:	fa00 fc03 	lsl.w	ip, r0, r3
   8be9e:	fa20 f002 	lsr.w	r0, r0, r2
   8bea2:	fa01 fe03 	lsl.w	lr, r1, r3
   8bea6:	ea40 000e 	orr.w	r0, r0, lr
   8beaa:	fa21 f102 	lsr.w	r1, r1, r2
   8beae:	4414      	add	r4, r2
   8beb0:	e6c1      	b.n	8bc36 <__adddf3+0xe6>
   8beb2:	bf00      	nop

0008beb4 <__aeabi_dmul>:
   8beb4:	b570      	push	{r4, r5, r6, lr}
   8beb6:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8beba:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   8bebe:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   8bec2:	bf1d      	ittte	ne
   8bec4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   8bec8:	ea94 0f0c 	teqne	r4, ip
   8becc:	ea95 0f0c 	teqne	r5, ip
   8bed0:	f000 f8de 	bleq	8c090 <__aeabi_dmul+0x1dc>
   8bed4:	442c      	add	r4, r5
   8bed6:	ea81 0603 	eor.w	r6, r1, r3
   8beda:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   8bede:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   8bee2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   8bee6:	bf18      	it	ne
   8bee8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   8beec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8bef0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8bef4:	d038      	beq.n	8bf68 <__aeabi_dmul+0xb4>
   8bef6:	fba0 ce02 	umull	ip, lr, r0, r2
   8befa:	f04f 0500 	mov.w	r5, #0
   8befe:	fbe1 e502 	umlal	lr, r5, r1, r2
   8bf02:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   8bf06:	fbe0 e503 	umlal	lr, r5, r0, r3
   8bf0a:	f04f 0600 	mov.w	r6, #0
   8bf0e:	fbe1 5603 	umlal	r5, r6, r1, r3
   8bf12:	f09c 0f00 	teq	ip, #0
   8bf16:	bf18      	it	ne
   8bf18:	f04e 0e01 	orrne.w	lr, lr, #1
   8bf1c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   8bf20:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   8bf24:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   8bf28:	d204      	bcs.n	8bf34 <__aeabi_dmul+0x80>
   8bf2a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   8bf2e:	416d      	adcs	r5, r5
   8bf30:	eb46 0606 	adc.w	r6, r6, r6
   8bf34:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   8bf38:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   8bf3c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   8bf40:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   8bf44:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   8bf48:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   8bf4c:	bf88      	it	hi
   8bf4e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   8bf52:	d81e      	bhi.n	8bf92 <__aeabi_dmul+0xde>
   8bf54:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   8bf58:	bf08      	it	eq
   8bf5a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   8bf5e:	f150 0000 	adcs.w	r0, r0, #0
   8bf62:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8bf66:	bd70      	pop	{r4, r5, r6, pc}
   8bf68:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   8bf6c:	ea46 0101 	orr.w	r1, r6, r1
   8bf70:	ea40 0002 	orr.w	r0, r0, r2
   8bf74:	ea81 0103 	eor.w	r1, r1, r3
   8bf78:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   8bf7c:	bfc2      	ittt	gt
   8bf7e:	ebd4 050c 	rsbsgt	r5, r4, ip
   8bf82:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   8bf86:	bd70      	popgt	{r4, r5, r6, pc}
   8bf88:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8bf8c:	f04f 0e00 	mov.w	lr, #0
   8bf90:	3c01      	subs	r4, #1
   8bf92:	f300 80ab 	bgt.w	8c0ec <__aeabi_dmul+0x238>
   8bf96:	f114 0f36 	cmn.w	r4, #54	; 0x36
   8bf9a:	bfde      	ittt	le
   8bf9c:	2000      	movle	r0, #0
   8bf9e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   8bfa2:	bd70      	pople	{r4, r5, r6, pc}
   8bfa4:	f1c4 0400 	rsb	r4, r4, #0
   8bfa8:	3c20      	subs	r4, #32
   8bfaa:	da35      	bge.n	8c018 <__aeabi_dmul+0x164>
   8bfac:	340c      	adds	r4, #12
   8bfae:	dc1b      	bgt.n	8bfe8 <__aeabi_dmul+0x134>
   8bfb0:	f104 0414 	add.w	r4, r4, #20
   8bfb4:	f1c4 0520 	rsb	r5, r4, #32
   8bfb8:	fa00 f305 	lsl.w	r3, r0, r5
   8bfbc:	fa20 f004 	lsr.w	r0, r0, r4
   8bfc0:	fa01 f205 	lsl.w	r2, r1, r5
   8bfc4:	ea40 0002 	orr.w	r0, r0, r2
   8bfc8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   8bfcc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   8bfd0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   8bfd4:	fa21 f604 	lsr.w	r6, r1, r4
   8bfd8:	eb42 0106 	adc.w	r1, r2, r6
   8bfdc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8bfe0:	bf08      	it	eq
   8bfe2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8bfe6:	bd70      	pop	{r4, r5, r6, pc}
   8bfe8:	f1c4 040c 	rsb	r4, r4, #12
   8bfec:	f1c4 0520 	rsb	r5, r4, #32
   8bff0:	fa00 f304 	lsl.w	r3, r0, r4
   8bff4:	fa20 f005 	lsr.w	r0, r0, r5
   8bff8:	fa01 f204 	lsl.w	r2, r1, r4
   8bffc:	ea40 0002 	orr.w	r0, r0, r2
   8c000:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8c004:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   8c008:	f141 0100 	adc.w	r1, r1, #0
   8c00c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8c010:	bf08      	it	eq
   8c012:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8c016:	bd70      	pop	{r4, r5, r6, pc}
   8c018:	f1c4 0520 	rsb	r5, r4, #32
   8c01c:	fa00 f205 	lsl.w	r2, r0, r5
   8c020:	ea4e 0e02 	orr.w	lr, lr, r2
   8c024:	fa20 f304 	lsr.w	r3, r0, r4
   8c028:	fa01 f205 	lsl.w	r2, r1, r5
   8c02c:	ea43 0302 	orr.w	r3, r3, r2
   8c030:	fa21 f004 	lsr.w	r0, r1, r4
   8c034:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8c038:	fa21 f204 	lsr.w	r2, r1, r4
   8c03c:	ea20 0002 	bic.w	r0, r0, r2
   8c040:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   8c044:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8c048:	bf08      	it	eq
   8c04a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8c04e:	bd70      	pop	{r4, r5, r6, pc}
   8c050:	f094 0f00 	teq	r4, #0
   8c054:	d10f      	bne.n	8c076 <__aeabi_dmul+0x1c2>
   8c056:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   8c05a:	0040      	lsls	r0, r0, #1
   8c05c:	eb41 0101 	adc.w	r1, r1, r1
   8c060:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8c064:	bf08      	it	eq
   8c066:	3c01      	subeq	r4, #1
   8c068:	d0f7      	beq.n	8c05a <__aeabi_dmul+0x1a6>
   8c06a:	ea41 0106 	orr.w	r1, r1, r6
   8c06e:	f095 0f00 	teq	r5, #0
   8c072:	bf18      	it	ne
   8c074:	4770      	bxne	lr
   8c076:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   8c07a:	0052      	lsls	r2, r2, #1
   8c07c:	eb43 0303 	adc.w	r3, r3, r3
   8c080:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   8c084:	bf08      	it	eq
   8c086:	3d01      	subeq	r5, #1
   8c088:	d0f7      	beq.n	8c07a <__aeabi_dmul+0x1c6>
   8c08a:	ea43 0306 	orr.w	r3, r3, r6
   8c08e:	4770      	bx	lr
   8c090:	ea94 0f0c 	teq	r4, ip
   8c094:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   8c098:	bf18      	it	ne
   8c09a:	ea95 0f0c 	teqne	r5, ip
   8c09e:	d00c      	beq.n	8c0ba <__aeabi_dmul+0x206>
   8c0a0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8c0a4:	bf18      	it	ne
   8c0a6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8c0aa:	d1d1      	bne.n	8c050 <__aeabi_dmul+0x19c>
   8c0ac:	ea81 0103 	eor.w	r1, r1, r3
   8c0b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8c0b4:	f04f 0000 	mov.w	r0, #0
   8c0b8:	bd70      	pop	{r4, r5, r6, pc}
   8c0ba:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8c0be:	bf06      	itte	eq
   8c0c0:	4610      	moveq	r0, r2
   8c0c2:	4619      	moveq	r1, r3
   8c0c4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8c0c8:	d019      	beq.n	8c0fe <__aeabi_dmul+0x24a>
   8c0ca:	ea94 0f0c 	teq	r4, ip
   8c0ce:	d102      	bne.n	8c0d6 <__aeabi_dmul+0x222>
   8c0d0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   8c0d4:	d113      	bne.n	8c0fe <__aeabi_dmul+0x24a>
   8c0d6:	ea95 0f0c 	teq	r5, ip
   8c0da:	d105      	bne.n	8c0e8 <__aeabi_dmul+0x234>
   8c0dc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   8c0e0:	bf1c      	itt	ne
   8c0e2:	4610      	movne	r0, r2
   8c0e4:	4619      	movne	r1, r3
   8c0e6:	d10a      	bne.n	8c0fe <__aeabi_dmul+0x24a>
   8c0e8:	ea81 0103 	eor.w	r1, r1, r3
   8c0ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8c0f0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   8c0f4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   8c0f8:	f04f 0000 	mov.w	r0, #0
   8c0fc:	bd70      	pop	{r4, r5, r6, pc}
   8c0fe:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   8c102:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   8c106:	bd70      	pop	{r4, r5, r6, pc}

0008c108 <__aeabi_ddiv>:
   8c108:	b570      	push	{r4, r5, r6, lr}
   8c10a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8c10e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   8c112:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   8c116:	bf1d      	ittte	ne
   8c118:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   8c11c:	ea94 0f0c 	teqne	r4, ip
   8c120:	ea95 0f0c 	teqne	r5, ip
   8c124:	f000 f8a7 	bleq	8c276 <__aeabi_ddiv+0x16e>
   8c128:	eba4 0405 	sub.w	r4, r4, r5
   8c12c:	ea81 0e03 	eor.w	lr, r1, r3
   8c130:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   8c134:	ea4f 3101 	mov.w	r1, r1, lsl #12
   8c138:	f000 8088 	beq.w	8c24c <__aeabi_ddiv+0x144>
   8c13c:	ea4f 3303 	mov.w	r3, r3, lsl #12
   8c140:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   8c144:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   8c148:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   8c14c:	ea4f 2202 	mov.w	r2, r2, lsl #8
   8c150:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   8c154:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   8c158:	ea4f 2600 	mov.w	r6, r0, lsl #8
   8c15c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   8c160:	429d      	cmp	r5, r3
   8c162:	bf08      	it	eq
   8c164:	4296      	cmpeq	r6, r2
   8c166:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   8c16a:	f504 7440 	add.w	r4, r4, #768	; 0x300
   8c16e:	d202      	bcs.n	8c176 <__aeabi_ddiv+0x6e>
   8c170:	085b      	lsrs	r3, r3, #1
   8c172:	ea4f 0232 	mov.w	r2, r2, rrx
   8c176:	1ab6      	subs	r6, r6, r2
   8c178:	eb65 0503 	sbc.w	r5, r5, r3
   8c17c:	085b      	lsrs	r3, r3, #1
   8c17e:	ea4f 0232 	mov.w	r2, r2, rrx
   8c182:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   8c186:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   8c18a:	ebb6 0e02 	subs.w	lr, r6, r2
   8c18e:	eb75 0e03 	sbcs.w	lr, r5, r3
   8c192:	bf22      	ittt	cs
   8c194:	1ab6      	subcs	r6, r6, r2
   8c196:	4675      	movcs	r5, lr
   8c198:	ea40 000c 	orrcs.w	r0, r0, ip
   8c19c:	085b      	lsrs	r3, r3, #1
   8c19e:	ea4f 0232 	mov.w	r2, r2, rrx
   8c1a2:	ebb6 0e02 	subs.w	lr, r6, r2
   8c1a6:	eb75 0e03 	sbcs.w	lr, r5, r3
   8c1aa:	bf22      	ittt	cs
   8c1ac:	1ab6      	subcs	r6, r6, r2
   8c1ae:	4675      	movcs	r5, lr
   8c1b0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   8c1b4:	085b      	lsrs	r3, r3, #1
   8c1b6:	ea4f 0232 	mov.w	r2, r2, rrx
   8c1ba:	ebb6 0e02 	subs.w	lr, r6, r2
   8c1be:	eb75 0e03 	sbcs.w	lr, r5, r3
   8c1c2:	bf22      	ittt	cs
   8c1c4:	1ab6      	subcs	r6, r6, r2
   8c1c6:	4675      	movcs	r5, lr
   8c1c8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   8c1cc:	085b      	lsrs	r3, r3, #1
   8c1ce:	ea4f 0232 	mov.w	r2, r2, rrx
   8c1d2:	ebb6 0e02 	subs.w	lr, r6, r2
   8c1d6:	eb75 0e03 	sbcs.w	lr, r5, r3
   8c1da:	bf22      	ittt	cs
   8c1dc:	1ab6      	subcs	r6, r6, r2
   8c1de:	4675      	movcs	r5, lr
   8c1e0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   8c1e4:	ea55 0e06 	orrs.w	lr, r5, r6
   8c1e8:	d018      	beq.n	8c21c <__aeabi_ddiv+0x114>
   8c1ea:	ea4f 1505 	mov.w	r5, r5, lsl #4
   8c1ee:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   8c1f2:	ea4f 1606 	mov.w	r6, r6, lsl #4
   8c1f6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   8c1fa:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   8c1fe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   8c202:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   8c206:	d1c0      	bne.n	8c18a <__aeabi_ddiv+0x82>
   8c208:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8c20c:	d10b      	bne.n	8c226 <__aeabi_ddiv+0x11e>
   8c20e:	ea41 0100 	orr.w	r1, r1, r0
   8c212:	f04f 0000 	mov.w	r0, #0
   8c216:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   8c21a:	e7b6      	b.n	8c18a <__aeabi_ddiv+0x82>
   8c21c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8c220:	bf04      	itt	eq
   8c222:	4301      	orreq	r1, r0
   8c224:	2000      	moveq	r0, #0
   8c226:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   8c22a:	bf88      	it	hi
   8c22c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   8c230:	f63f aeaf 	bhi.w	8bf92 <__aeabi_dmul+0xde>
   8c234:	ebb5 0c03 	subs.w	ip, r5, r3
   8c238:	bf04      	itt	eq
   8c23a:	ebb6 0c02 	subseq.w	ip, r6, r2
   8c23e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   8c242:	f150 0000 	adcs.w	r0, r0, #0
   8c246:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8c24a:	bd70      	pop	{r4, r5, r6, pc}
   8c24c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   8c250:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   8c254:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   8c258:	bfc2      	ittt	gt
   8c25a:	ebd4 050c 	rsbsgt	r5, r4, ip
   8c25e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   8c262:	bd70      	popgt	{r4, r5, r6, pc}
   8c264:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8c268:	f04f 0e00 	mov.w	lr, #0
   8c26c:	3c01      	subs	r4, #1
   8c26e:	e690      	b.n	8bf92 <__aeabi_dmul+0xde>
   8c270:	ea45 0e06 	orr.w	lr, r5, r6
   8c274:	e68d      	b.n	8bf92 <__aeabi_dmul+0xde>
   8c276:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   8c27a:	ea94 0f0c 	teq	r4, ip
   8c27e:	bf08      	it	eq
   8c280:	ea95 0f0c 	teqeq	r5, ip
   8c284:	f43f af3b 	beq.w	8c0fe <__aeabi_dmul+0x24a>
   8c288:	ea94 0f0c 	teq	r4, ip
   8c28c:	d10a      	bne.n	8c2a4 <__aeabi_ddiv+0x19c>
   8c28e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   8c292:	f47f af34 	bne.w	8c0fe <__aeabi_dmul+0x24a>
   8c296:	ea95 0f0c 	teq	r5, ip
   8c29a:	f47f af25 	bne.w	8c0e8 <__aeabi_dmul+0x234>
   8c29e:	4610      	mov	r0, r2
   8c2a0:	4619      	mov	r1, r3
   8c2a2:	e72c      	b.n	8c0fe <__aeabi_dmul+0x24a>
   8c2a4:	ea95 0f0c 	teq	r5, ip
   8c2a8:	d106      	bne.n	8c2b8 <__aeabi_ddiv+0x1b0>
   8c2aa:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   8c2ae:	f43f aefd 	beq.w	8c0ac <__aeabi_dmul+0x1f8>
   8c2b2:	4610      	mov	r0, r2
   8c2b4:	4619      	mov	r1, r3
   8c2b6:	e722      	b.n	8c0fe <__aeabi_dmul+0x24a>
   8c2b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8c2bc:	bf18      	it	ne
   8c2be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8c2c2:	f47f aec5 	bne.w	8c050 <__aeabi_dmul+0x19c>
   8c2c6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   8c2ca:	f47f af0d 	bne.w	8c0e8 <__aeabi_dmul+0x234>
   8c2ce:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   8c2d2:	f47f aeeb 	bne.w	8c0ac <__aeabi_dmul+0x1f8>
   8c2d6:	e712      	b.n	8c0fe <__aeabi_dmul+0x24a>

0008c2d8 <__gedf2>:
   8c2d8:	f04f 3cff 	mov.w	ip, #4294967295
   8c2dc:	e006      	b.n	8c2ec <__cmpdf2+0x4>
   8c2de:	bf00      	nop

0008c2e0 <__ledf2>:
   8c2e0:	f04f 0c01 	mov.w	ip, #1
   8c2e4:	e002      	b.n	8c2ec <__cmpdf2+0x4>
   8c2e6:	bf00      	nop

0008c2e8 <__cmpdf2>:
   8c2e8:	f04f 0c01 	mov.w	ip, #1
   8c2ec:	f84d cd04 	str.w	ip, [sp, #-4]!
   8c2f0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   8c2f4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8c2f8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   8c2fc:	bf18      	it	ne
   8c2fe:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   8c302:	d01b      	beq.n	8c33c <__cmpdf2+0x54>
   8c304:	b001      	add	sp, #4
   8c306:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   8c30a:	bf0c      	ite	eq
   8c30c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   8c310:	ea91 0f03 	teqne	r1, r3
   8c314:	bf02      	ittt	eq
   8c316:	ea90 0f02 	teqeq	r0, r2
   8c31a:	2000      	moveq	r0, #0
   8c31c:	4770      	bxeq	lr
   8c31e:	f110 0f00 	cmn.w	r0, #0
   8c322:	ea91 0f03 	teq	r1, r3
   8c326:	bf58      	it	pl
   8c328:	4299      	cmppl	r1, r3
   8c32a:	bf08      	it	eq
   8c32c:	4290      	cmpeq	r0, r2
   8c32e:	bf2c      	ite	cs
   8c330:	17d8      	asrcs	r0, r3, #31
   8c332:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   8c336:	f040 0001 	orr.w	r0, r0, #1
   8c33a:	4770      	bx	lr
   8c33c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   8c340:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8c344:	d102      	bne.n	8c34c <__cmpdf2+0x64>
   8c346:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   8c34a:	d107      	bne.n	8c35c <__cmpdf2+0x74>
   8c34c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   8c350:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8c354:	d1d6      	bne.n	8c304 <__cmpdf2+0x1c>
   8c356:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   8c35a:	d0d3      	beq.n	8c304 <__cmpdf2+0x1c>
   8c35c:	f85d 0b04 	ldr.w	r0, [sp], #4
   8c360:	4770      	bx	lr
   8c362:	bf00      	nop

0008c364 <__aeabi_cdrcmple>:
   8c364:	4684      	mov	ip, r0
   8c366:	4610      	mov	r0, r2
   8c368:	4662      	mov	r2, ip
   8c36a:	468c      	mov	ip, r1
   8c36c:	4619      	mov	r1, r3
   8c36e:	4663      	mov	r3, ip
   8c370:	e000      	b.n	8c374 <__aeabi_cdcmpeq>
   8c372:	bf00      	nop

0008c374 <__aeabi_cdcmpeq>:
   8c374:	b501      	push	{r0, lr}
   8c376:	f7ff ffb7 	bl	8c2e8 <__cmpdf2>
   8c37a:	2800      	cmp	r0, #0
   8c37c:	bf48      	it	mi
   8c37e:	f110 0f00 	cmnmi.w	r0, #0
   8c382:	bd01      	pop	{r0, pc}

0008c384 <__aeabi_dcmpeq>:
   8c384:	f84d ed08 	str.w	lr, [sp, #-8]!
   8c388:	f7ff fff4 	bl	8c374 <__aeabi_cdcmpeq>
   8c38c:	bf0c      	ite	eq
   8c38e:	2001      	moveq	r0, #1
   8c390:	2000      	movne	r0, #0
   8c392:	f85d fb08 	ldr.w	pc, [sp], #8
   8c396:	bf00      	nop

0008c398 <__aeabi_dcmplt>:
   8c398:	f84d ed08 	str.w	lr, [sp, #-8]!
   8c39c:	f7ff ffea 	bl	8c374 <__aeabi_cdcmpeq>
   8c3a0:	bf34      	ite	cc
   8c3a2:	2001      	movcc	r0, #1
   8c3a4:	2000      	movcs	r0, #0
   8c3a6:	f85d fb08 	ldr.w	pc, [sp], #8
   8c3aa:	bf00      	nop

0008c3ac <__aeabi_dcmple>:
   8c3ac:	f84d ed08 	str.w	lr, [sp, #-8]!
   8c3b0:	f7ff ffe0 	bl	8c374 <__aeabi_cdcmpeq>
   8c3b4:	bf94      	ite	ls
   8c3b6:	2001      	movls	r0, #1
   8c3b8:	2000      	movhi	r0, #0
   8c3ba:	f85d fb08 	ldr.w	pc, [sp], #8
   8c3be:	bf00      	nop

0008c3c0 <__aeabi_dcmpge>:
   8c3c0:	f84d ed08 	str.w	lr, [sp, #-8]!
   8c3c4:	f7ff ffce 	bl	8c364 <__aeabi_cdrcmple>
   8c3c8:	bf94      	ite	ls
   8c3ca:	2001      	movls	r0, #1
   8c3cc:	2000      	movhi	r0, #0
   8c3ce:	f85d fb08 	ldr.w	pc, [sp], #8
   8c3d2:	bf00      	nop

0008c3d4 <__aeabi_dcmpgt>:
   8c3d4:	f84d ed08 	str.w	lr, [sp, #-8]!
   8c3d8:	f7ff ffc4 	bl	8c364 <__aeabi_cdrcmple>
   8c3dc:	bf34      	ite	cc
   8c3de:	2001      	movcc	r0, #1
   8c3e0:	2000      	movcs	r0, #0
   8c3e2:	f85d fb08 	ldr.w	pc, [sp], #8
   8c3e6:	bf00      	nop

0008c3e8 <__aeabi_d2iz>:
   8c3e8:	ea4f 0241 	mov.w	r2, r1, lsl #1
   8c3ec:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   8c3f0:	d215      	bcs.n	8c41e <__aeabi_d2iz+0x36>
   8c3f2:	d511      	bpl.n	8c418 <__aeabi_d2iz+0x30>
   8c3f4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   8c3f8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   8c3fc:	d912      	bls.n	8c424 <__aeabi_d2iz+0x3c>
   8c3fe:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   8c402:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8c406:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   8c40a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8c40e:	fa23 f002 	lsr.w	r0, r3, r2
   8c412:	bf18      	it	ne
   8c414:	4240      	negne	r0, r0
   8c416:	4770      	bx	lr
   8c418:	f04f 0000 	mov.w	r0, #0
   8c41c:	4770      	bx	lr
   8c41e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   8c422:	d105      	bne.n	8c430 <__aeabi_d2iz+0x48>
   8c424:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   8c428:	bf08      	it	eq
   8c42a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   8c42e:	4770      	bx	lr
   8c430:	f04f 0000 	mov.w	r0, #0
   8c434:	4770      	bx	lr
   8c436:	bf00      	nop

0008c438 <__aeabi_d2uiz>:
   8c438:	004a      	lsls	r2, r1, #1
   8c43a:	d211      	bcs.n	8c460 <__aeabi_d2uiz+0x28>
   8c43c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   8c440:	d211      	bcs.n	8c466 <__aeabi_d2uiz+0x2e>
   8c442:	d50d      	bpl.n	8c460 <__aeabi_d2uiz+0x28>
   8c444:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   8c448:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   8c44c:	d40e      	bmi.n	8c46c <__aeabi_d2uiz+0x34>
   8c44e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   8c452:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8c456:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   8c45a:	fa23 f002 	lsr.w	r0, r3, r2
   8c45e:	4770      	bx	lr
   8c460:	f04f 0000 	mov.w	r0, #0
   8c464:	4770      	bx	lr
   8c466:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   8c46a:	d102      	bne.n	8c472 <__aeabi_d2uiz+0x3a>
   8c46c:	f04f 30ff 	mov.w	r0, #4294967295
   8c470:	4770      	bx	lr
   8c472:	f04f 0000 	mov.w	r0, #0
   8c476:	4770      	bx	lr

0008c478 <__aeabi_d2f>:
   8c478:	ea4f 0241 	mov.w	r2, r1, lsl #1
   8c47c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   8c480:	bf24      	itt	cs
   8c482:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   8c486:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   8c48a:	d90d      	bls.n	8c4a8 <__aeabi_d2f+0x30>
   8c48c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   8c490:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   8c494:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   8c498:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   8c49c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   8c4a0:	bf08      	it	eq
   8c4a2:	f020 0001 	biceq.w	r0, r0, #1
   8c4a6:	4770      	bx	lr
   8c4a8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   8c4ac:	d121      	bne.n	8c4f2 <__aeabi_d2f+0x7a>
   8c4ae:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   8c4b2:	bfbc      	itt	lt
   8c4b4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   8c4b8:	4770      	bxlt	lr
   8c4ba:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8c4be:	ea4f 5252 	mov.w	r2, r2, lsr #21
   8c4c2:	f1c2 0218 	rsb	r2, r2, #24
   8c4c6:	f1c2 0c20 	rsb	ip, r2, #32
   8c4ca:	fa10 f30c 	lsls.w	r3, r0, ip
   8c4ce:	fa20 f002 	lsr.w	r0, r0, r2
   8c4d2:	bf18      	it	ne
   8c4d4:	f040 0001 	orrne.w	r0, r0, #1
   8c4d8:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   8c4dc:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   8c4e0:	fa03 fc0c 	lsl.w	ip, r3, ip
   8c4e4:	ea40 000c 	orr.w	r0, r0, ip
   8c4e8:	fa23 f302 	lsr.w	r3, r3, r2
   8c4ec:	ea4f 0343 	mov.w	r3, r3, lsl #1
   8c4f0:	e7cc      	b.n	8c48c <__aeabi_d2f+0x14>
   8c4f2:	ea7f 5362 	mvns.w	r3, r2, asr #21
   8c4f6:	d107      	bne.n	8c508 <__aeabi_d2f+0x90>
   8c4f8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   8c4fc:	bf1e      	ittt	ne
   8c4fe:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   8c502:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   8c506:	4770      	bxne	lr
   8c508:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   8c50c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   8c510:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c514:	4770      	bx	lr
   8c516:	bf00      	nop

0008c518 <__aeabi_frsub>:
   8c518:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   8c51c:	e002      	b.n	8c524 <__addsf3>
   8c51e:	bf00      	nop

0008c520 <__aeabi_fsub>:
   8c520:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0008c524 <__addsf3>:
   8c524:	0042      	lsls	r2, r0, #1
   8c526:	bf1f      	itttt	ne
   8c528:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   8c52c:	ea92 0f03 	teqne	r2, r3
   8c530:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   8c534:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8c538:	d06a      	beq.n	8c610 <__addsf3+0xec>
   8c53a:	ea4f 6212 	mov.w	r2, r2, lsr #24
   8c53e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   8c542:	bfc1      	itttt	gt
   8c544:	18d2      	addgt	r2, r2, r3
   8c546:	4041      	eorgt	r1, r0
   8c548:	4048      	eorgt	r0, r1
   8c54a:	4041      	eorgt	r1, r0
   8c54c:	bfb8      	it	lt
   8c54e:	425b      	neglt	r3, r3
   8c550:	2b19      	cmp	r3, #25
   8c552:	bf88      	it	hi
   8c554:	4770      	bxhi	lr
   8c556:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   8c55a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c55e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   8c562:	bf18      	it	ne
   8c564:	4240      	negne	r0, r0
   8c566:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8c56a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   8c56e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   8c572:	bf18      	it	ne
   8c574:	4249      	negne	r1, r1
   8c576:	ea92 0f03 	teq	r2, r3
   8c57a:	d03f      	beq.n	8c5fc <__addsf3+0xd8>
   8c57c:	f1a2 0201 	sub.w	r2, r2, #1
   8c580:	fa41 fc03 	asr.w	ip, r1, r3
   8c584:	eb10 000c 	adds.w	r0, r0, ip
   8c588:	f1c3 0320 	rsb	r3, r3, #32
   8c58c:	fa01 f103 	lsl.w	r1, r1, r3
   8c590:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   8c594:	d502      	bpl.n	8c59c <__addsf3+0x78>
   8c596:	4249      	negs	r1, r1
   8c598:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   8c59c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   8c5a0:	d313      	bcc.n	8c5ca <__addsf3+0xa6>
   8c5a2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   8c5a6:	d306      	bcc.n	8c5b6 <__addsf3+0x92>
   8c5a8:	0840      	lsrs	r0, r0, #1
   8c5aa:	ea4f 0131 	mov.w	r1, r1, rrx
   8c5ae:	f102 0201 	add.w	r2, r2, #1
   8c5b2:	2afe      	cmp	r2, #254	; 0xfe
   8c5b4:	d251      	bcs.n	8c65a <__addsf3+0x136>
   8c5b6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   8c5ba:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8c5be:	bf08      	it	eq
   8c5c0:	f020 0001 	biceq.w	r0, r0, #1
   8c5c4:	ea40 0003 	orr.w	r0, r0, r3
   8c5c8:	4770      	bx	lr
   8c5ca:	0049      	lsls	r1, r1, #1
   8c5cc:	eb40 0000 	adc.w	r0, r0, r0
   8c5d0:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   8c5d4:	f1a2 0201 	sub.w	r2, r2, #1
   8c5d8:	d1ed      	bne.n	8c5b6 <__addsf3+0x92>
   8c5da:	fab0 fc80 	clz	ip, r0
   8c5de:	f1ac 0c08 	sub.w	ip, ip, #8
   8c5e2:	ebb2 020c 	subs.w	r2, r2, ip
   8c5e6:	fa00 f00c 	lsl.w	r0, r0, ip
   8c5ea:	bfaa      	itet	ge
   8c5ec:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   8c5f0:	4252      	neglt	r2, r2
   8c5f2:	4318      	orrge	r0, r3
   8c5f4:	bfbc      	itt	lt
   8c5f6:	40d0      	lsrlt	r0, r2
   8c5f8:	4318      	orrlt	r0, r3
   8c5fa:	4770      	bx	lr
   8c5fc:	f092 0f00 	teq	r2, #0
   8c600:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   8c604:	bf06      	itte	eq
   8c606:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   8c60a:	3201      	addeq	r2, #1
   8c60c:	3b01      	subne	r3, #1
   8c60e:	e7b5      	b.n	8c57c <__addsf3+0x58>
   8c610:	ea4f 0341 	mov.w	r3, r1, lsl #1
   8c614:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8c618:	bf18      	it	ne
   8c61a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8c61e:	d021      	beq.n	8c664 <__addsf3+0x140>
   8c620:	ea92 0f03 	teq	r2, r3
   8c624:	d004      	beq.n	8c630 <__addsf3+0x10c>
   8c626:	f092 0f00 	teq	r2, #0
   8c62a:	bf08      	it	eq
   8c62c:	4608      	moveq	r0, r1
   8c62e:	4770      	bx	lr
   8c630:	ea90 0f01 	teq	r0, r1
   8c634:	bf1c      	itt	ne
   8c636:	2000      	movne	r0, #0
   8c638:	4770      	bxne	lr
   8c63a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   8c63e:	d104      	bne.n	8c64a <__addsf3+0x126>
   8c640:	0040      	lsls	r0, r0, #1
   8c642:	bf28      	it	cs
   8c644:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   8c648:	4770      	bx	lr
   8c64a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   8c64e:	bf3c      	itt	cc
   8c650:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   8c654:	4770      	bxcc	lr
   8c656:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   8c65a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   8c65e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c662:	4770      	bx	lr
   8c664:	ea7f 6222 	mvns.w	r2, r2, asr #24
   8c668:	bf16      	itet	ne
   8c66a:	4608      	movne	r0, r1
   8c66c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   8c670:	4601      	movne	r1, r0
   8c672:	0242      	lsls	r2, r0, #9
   8c674:	bf06      	itte	eq
   8c676:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   8c67a:	ea90 0f01 	teqeq	r0, r1
   8c67e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   8c682:	4770      	bx	lr

0008c684 <__aeabi_ui2f>:
   8c684:	f04f 0300 	mov.w	r3, #0
   8c688:	e004      	b.n	8c694 <__aeabi_i2f+0x8>
   8c68a:	bf00      	nop

0008c68c <__aeabi_i2f>:
   8c68c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   8c690:	bf48      	it	mi
   8c692:	4240      	negmi	r0, r0
   8c694:	ea5f 0c00 	movs.w	ip, r0
   8c698:	bf08      	it	eq
   8c69a:	4770      	bxeq	lr
   8c69c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   8c6a0:	4601      	mov	r1, r0
   8c6a2:	f04f 0000 	mov.w	r0, #0
   8c6a6:	e01c      	b.n	8c6e2 <__aeabi_l2f+0x2a>

0008c6a8 <__aeabi_ul2f>:
   8c6a8:	ea50 0201 	orrs.w	r2, r0, r1
   8c6ac:	bf08      	it	eq
   8c6ae:	4770      	bxeq	lr
   8c6b0:	f04f 0300 	mov.w	r3, #0
   8c6b4:	e00a      	b.n	8c6cc <__aeabi_l2f+0x14>
   8c6b6:	bf00      	nop

0008c6b8 <__aeabi_l2f>:
   8c6b8:	ea50 0201 	orrs.w	r2, r0, r1
   8c6bc:	bf08      	it	eq
   8c6be:	4770      	bxeq	lr
   8c6c0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   8c6c4:	d502      	bpl.n	8c6cc <__aeabi_l2f+0x14>
   8c6c6:	4240      	negs	r0, r0
   8c6c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8c6cc:	ea5f 0c01 	movs.w	ip, r1
   8c6d0:	bf02      	ittt	eq
   8c6d2:	4684      	moveq	ip, r0
   8c6d4:	4601      	moveq	r1, r0
   8c6d6:	2000      	moveq	r0, #0
   8c6d8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   8c6dc:	bf08      	it	eq
   8c6de:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   8c6e2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   8c6e6:	fabc f28c 	clz	r2, ip
   8c6ea:	3a08      	subs	r2, #8
   8c6ec:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   8c6f0:	db10      	blt.n	8c714 <__aeabi_l2f+0x5c>
   8c6f2:	fa01 fc02 	lsl.w	ip, r1, r2
   8c6f6:	4463      	add	r3, ip
   8c6f8:	fa00 fc02 	lsl.w	ip, r0, r2
   8c6fc:	f1c2 0220 	rsb	r2, r2, #32
   8c700:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   8c704:	fa20 f202 	lsr.w	r2, r0, r2
   8c708:	eb43 0002 	adc.w	r0, r3, r2
   8c70c:	bf08      	it	eq
   8c70e:	f020 0001 	biceq.w	r0, r0, #1
   8c712:	4770      	bx	lr
   8c714:	f102 0220 	add.w	r2, r2, #32
   8c718:	fa01 fc02 	lsl.w	ip, r1, r2
   8c71c:	f1c2 0220 	rsb	r2, r2, #32
   8c720:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   8c724:	fa21 f202 	lsr.w	r2, r1, r2
   8c728:	eb43 0002 	adc.w	r0, r3, r2
   8c72c:	bf08      	it	eq
   8c72e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   8c732:	4770      	bx	lr

0008c734 <__aeabi_fmul>:
   8c734:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8c738:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   8c73c:	bf1e      	ittt	ne
   8c73e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   8c742:	ea92 0f0c 	teqne	r2, ip
   8c746:	ea93 0f0c 	teqne	r3, ip
   8c74a:	d06f      	beq.n	8c82c <__aeabi_fmul+0xf8>
   8c74c:	441a      	add	r2, r3
   8c74e:	ea80 0c01 	eor.w	ip, r0, r1
   8c752:	0240      	lsls	r0, r0, #9
   8c754:	bf18      	it	ne
   8c756:	ea5f 2141 	movsne.w	r1, r1, lsl #9
   8c75a:	d01e      	beq.n	8c79a <__aeabi_fmul+0x66>
   8c75c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   8c760:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
   8c764:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
   8c768:	fba0 3101 	umull	r3, r1, r0, r1
   8c76c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   8c770:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   8c774:	bf3e      	ittt	cc
   8c776:	0049      	lslcc	r1, r1, #1
   8c778:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
   8c77c:	005b      	lslcc	r3, r3, #1
   8c77e:	ea40 0001 	orr.w	r0, r0, r1
   8c782:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
   8c786:	2afd      	cmp	r2, #253	; 0xfd
   8c788:	d81d      	bhi.n	8c7c6 <__aeabi_fmul+0x92>
   8c78a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   8c78e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8c792:	bf08      	it	eq
   8c794:	f020 0001 	biceq.w	r0, r0, #1
   8c798:	4770      	bx	lr
   8c79a:	f090 0f00 	teq	r0, #0
   8c79e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   8c7a2:	bf08      	it	eq
   8c7a4:	0249      	lsleq	r1, r1, #9
   8c7a6:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   8c7aa:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
   8c7ae:	3a7f      	subs	r2, #127	; 0x7f
   8c7b0:	bfc2      	ittt	gt
   8c7b2:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   8c7b6:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   8c7ba:	4770      	bxgt	lr
   8c7bc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c7c0:	f04f 0300 	mov.w	r3, #0
   8c7c4:	3a01      	subs	r2, #1
   8c7c6:	dc5d      	bgt.n	8c884 <__aeabi_fmul+0x150>
   8c7c8:	f112 0f19 	cmn.w	r2, #25
   8c7cc:	bfdc      	itt	le
   8c7ce:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
   8c7d2:	4770      	bxle	lr
   8c7d4:	f1c2 0200 	rsb	r2, r2, #0
   8c7d8:	0041      	lsls	r1, r0, #1
   8c7da:	fa21 f102 	lsr.w	r1, r1, r2
   8c7de:	f1c2 0220 	rsb	r2, r2, #32
   8c7e2:	fa00 fc02 	lsl.w	ip, r0, r2
   8c7e6:	ea5f 0031 	movs.w	r0, r1, rrx
   8c7ea:	f140 0000 	adc.w	r0, r0, #0
   8c7ee:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
   8c7f2:	bf08      	it	eq
   8c7f4:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   8c7f8:	4770      	bx	lr
   8c7fa:	f092 0f00 	teq	r2, #0
   8c7fe:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   8c802:	bf02      	ittt	eq
   8c804:	0040      	lsleq	r0, r0, #1
   8c806:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   8c80a:	3a01      	subeq	r2, #1
   8c80c:	d0f9      	beq.n	8c802 <__aeabi_fmul+0xce>
   8c80e:	ea40 000c 	orr.w	r0, r0, ip
   8c812:	f093 0f00 	teq	r3, #0
   8c816:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   8c81a:	bf02      	ittt	eq
   8c81c:	0049      	lsleq	r1, r1, #1
   8c81e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   8c822:	3b01      	subeq	r3, #1
   8c824:	d0f9      	beq.n	8c81a <__aeabi_fmul+0xe6>
   8c826:	ea41 010c 	orr.w	r1, r1, ip
   8c82a:	e78f      	b.n	8c74c <__aeabi_fmul+0x18>
   8c82c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   8c830:	ea92 0f0c 	teq	r2, ip
   8c834:	bf18      	it	ne
   8c836:	ea93 0f0c 	teqne	r3, ip
   8c83a:	d00a      	beq.n	8c852 <__aeabi_fmul+0x11e>
   8c83c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   8c840:	bf18      	it	ne
   8c842:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   8c846:	d1d8      	bne.n	8c7fa <__aeabi_fmul+0xc6>
   8c848:	ea80 0001 	eor.w	r0, r0, r1
   8c84c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   8c850:	4770      	bx	lr
   8c852:	f090 0f00 	teq	r0, #0
   8c856:	bf17      	itett	ne
   8c858:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
   8c85c:	4608      	moveq	r0, r1
   8c85e:	f091 0f00 	teqne	r1, #0
   8c862:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
   8c866:	d014      	beq.n	8c892 <__aeabi_fmul+0x15e>
   8c868:	ea92 0f0c 	teq	r2, ip
   8c86c:	d101      	bne.n	8c872 <__aeabi_fmul+0x13e>
   8c86e:	0242      	lsls	r2, r0, #9
   8c870:	d10f      	bne.n	8c892 <__aeabi_fmul+0x15e>
   8c872:	ea93 0f0c 	teq	r3, ip
   8c876:	d103      	bne.n	8c880 <__aeabi_fmul+0x14c>
   8c878:	024b      	lsls	r3, r1, #9
   8c87a:	bf18      	it	ne
   8c87c:	4608      	movne	r0, r1
   8c87e:	d108      	bne.n	8c892 <__aeabi_fmul+0x15e>
   8c880:	ea80 0001 	eor.w	r0, r0, r1
   8c884:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   8c888:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   8c88c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c890:	4770      	bx	lr
   8c892:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   8c896:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
   8c89a:	4770      	bx	lr

0008c89c <__aeabi_fdiv>:
   8c89c:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8c8a0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   8c8a4:	bf1e      	ittt	ne
   8c8a6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   8c8aa:	ea92 0f0c 	teqne	r2, ip
   8c8ae:	ea93 0f0c 	teqne	r3, ip
   8c8b2:	d069      	beq.n	8c988 <__aeabi_fdiv+0xec>
   8c8b4:	eba2 0203 	sub.w	r2, r2, r3
   8c8b8:	ea80 0c01 	eor.w	ip, r0, r1
   8c8bc:	0249      	lsls	r1, r1, #9
   8c8be:	ea4f 2040 	mov.w	r0, r0, lsl #9
   8c8c2:	d037      	beq.n	8c934 <__aeabi_fdiv+0x98>
   8c8c4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   8c8c8:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
   8c8cc:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
   8c8d0:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   8c8d4:	428b      	cmp	r3, r1
   8c8d6:	bf38      	it	cc
   8c8d8:	005b      	lslcc	r3, r3, #1
   8c8da:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
   8c8de:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
   8c8e2:	428b      	cmp	r3, r1
   8c8e4:	bf24      	itt	cs
   8c8e6:	1a5b      	subcs	r3, r3, r1
   8c8e8:	ea40 000c 	orrcs.w	r0, r0, ip
   8c8ec:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
   8c8f0:	bf24      	itt	cs
   8c8f2:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
   8c8f6:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   8c8fa:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
   8c8fe:	bf24      	itt	cs
   8c900:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
   8c904:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   8c908:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   8c90c:	bf24      	itt	cs
   8c90e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
   8c912:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   8c916:	011b      	lsls	r3, r3, #4
   8c918:	bf18      	it	ne
   8c91a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
   8c91e:	d1e0      	bne.n	8c8e2 <__aeabi_fdiv+0x46>
   8c920:	2afd      	cmp	r2, #253	; 0xfd
   8c922:	f63f af50 	bhi.w	8c7c6 <__aeabi_fmul+0x92>
   8c926:	428b      	cmp	r3, r1
   8c928:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8c92c:	bf08      	it	eq
   8c92e:	f020 0001 	biceq.w	r0, r0, #1
   8c932:	4770      	bx	lr
   8c934:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   8c938:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   8c93c:	327f      	adds	r2, #127	; 0x7f
   8c93e:	bfc2      	ittt	gt
   8c940:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   8c944:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   8c948:	4770      	bxgt	lr
   8c94a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8c94e:	f04f 0300 	mov.w	r3, #0
   8c952:	3a01      	subs	r2, #1
   8c954:	e737      	b.n	8c7c6 <__aeabi_fmul+0x92>
   8c956:	f092 0f00 	teq	r2, #0
   8c95a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   8c95e:	bf02      	ittt	eq
   8c960:	0040      	lsleq	r0, r0, #1
   8c962:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   8c966:	3a01      	subeq	r2, #1
   8c968:	d0f9      	beq.n	8c95e <__aeabi_fdiv+0xc2>
   8c96a:	ea40 000c 	orr.w	r0, r0, ip
   8c96e:	f093 0f00 	teq	r3, #0
   8c972:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   8c976:	bf02      	ittt	eq
   8c978:	0049      	lsleq	r1, r1, #1
   8c97a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   8c97e:	3b01      	subeq	r3, #1
   8c980:	d0f9      	beq.n	8c976 <__aeabi_fdiv+0xda>
   8c982:	ea41 010c 	orr.w	r1, r1, ip
   8c986:	e795      	b.n	8c8b4 <__aeabi_fdiv+0x18>
   8c988:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   8c98c:	ea92 0f0c 	teq	r2, ip
   8c990:	d108      	bne.n	8c9a4 <__aeabi_fdiv+0x108>
   8c992:	0242      	lsls	r2, r0, #9
   8c994:	f47f af7d 	bne.w	8c892 <__aeabi_fmul+0x15e>
   8c998:	ea93 0f0c 	teq	r3, ip
   8c99c:	f47f af70 	bne.w	8c880 <__aeabi_fmul+0x14c>
   8c9a0:	4608      	mov	r0, r1
   8c9a2:	e776      	b.n	8c892 <__aeabi_fmul+0x15e>
   8c9a4:	ea93 0f0c 	teq	r3, ip
   8c9a8:	d104      	bne.n	8c9b4 <__aeabi_fdiv+0x118>
   8c9aa:	024b      	lsls	r3, r1, #9
   8c9ac:	f43f af4c 	beq.w	8c848 <__aeabi_fmul+0x114>
   8c9b0:	4608      	mov	r0, r1
   8c9b2:	e76e      	b.n	8c892 <__aeabi_fmul+0x15e>
   8c9b4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   8c9b8:	bf18      	it	ne
   8c9ba:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   8c9be:	d1ca      	bne.n	8c956 <__aeabi_fdiv+0xba>
   8c9c0:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   8c9c4:	f47f af5c 	bne.w	8c880 <__aeabi_fmul+0x14c>
   8c9c8:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   8c9cc:	f47f af3c 	bne.w	8c848 <__aeabi_fmul+0x114>
   8c9d0:	e75f      	b.n	8c892 <__aeabi_fmul+0x15e>
   8c9d2:	bf00      	nop

0008c9d4 <__gesf2>:
   8c9d4:	f04f 3cff 	mov.w	ip, #4294967295
   8c9d8:	e006      	b.n	8c9e8 <__cmpsf2+0x4>
   8c9da:	bf00      	nop

0008c9dc <__lesf2>:
   8c9dc:	f04f 0c01 	mov.w	ip, #1
   8c9e0:	e002      	b.n	8c9e8 <__cmpsf2+0x4>
   8c9e2:	bf00      	nop

0008c9e4 <__cmpsf2>:
   8c9e4:	f04f 0c01 	mov.w	ip, #1
   8c9e8:	f84d cd04 	str.w	ip, [sp, #-4]!
   8c9ec:	ea4f 0240 	mov.w	r2, r0, lsl #1
   8c9f0:	ea4f 0341 	mov.w	r3, r1, lsl #1
   8c9f4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8c9f8:	bf18      	it	ne
   8c9fa:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8c9fe:	d011      	beq.n	8ca24 <__cmpsf2+0x40>
   8ca00:	b001      	add	sp, #4
   8ca02:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
   8ca06:	bf18      	it	ne
   8ca08:	ea90 0f01 	teqne	r0, r1
   8ca0c:	bf58      	it	pl
   8ca0e:	ebb2 0003 	subspl.w	r0, r2, r3
   8ca12:	bf88      	it	hi
   8ca14:	17c8      	asrhi	r0, r1, #31
   8ca16:	bf38      	it	cc
   8ca18:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
   8ca1c:	bf18      	it	ne
   8ca1e:	f040 0001 	orrne.w	r0, r0, #1
   8ca22:	4770      	bx	lr
   8ca24:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8ca28:	d102      	bne.n	8ca30 <__cmpsf2+0x4c>
   8ca2a:	ea5f 2c40 	movs.w	ip, r0, lsl #9
   8ca2e:	d105      	bne.n	8ca3c <__cmpsf2+0x58>
   8ca30:	ea7f 6c23 	mvns.w	ip, r3, asr #24
   8ca34:	d1e4      	bne.n	8ca00 <__cmpsf2+0x1c>
   8ca36:	ea5f 2c41 	movs.w	ip, r1, lsl #9
   8ca3a:	d0e1      	beq.n	8ca00 <__cmpsf2+0x1c>
   8ca3c:	f85d 0b04 	ldr.w	r0, [sp], #4
   8ca40:	4770      	bx	lr
   8ca42:	bf00      	nop

0008ca44 <__aeabi_cfrcmple>:
   8ca44:	4684      	mov	ip, r0
   8ca46:	4608      	mov	r0, r1
   8ca48:	4661      	mov	r1, ip
   8ca4a:	e7ff      	b.n	8ca4c <__aeabi_cfcmpeq>

0008ca4c <__aeabi_cfcmpeq>:
   8ca4c:	b50f      	push	{r0, r1, r2, r3, lr}
   8ca4e:	f7ff ffc9 	bl	8c9e4 <__cmpsf2>
   8ca52:	2800      	cmp	r0, #0
   8ca54:	bf48      	it	mi
   8ca56:	f110 0f00 	cmnmi.w	r0, #0
   8ca5a:	bd0f      	pop	{r0, r1, r2, r3, pc}

0008ca5c <__aeabi_fcmpeq>:
   8ca5c:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ca60:	f7ff fff4 	bl	8ca4c <__aeabi_cfcmpeq>
   8ca64:	bf0c      	ite	eq
   8ca66:	2001      	moveq	r0, #1
   8ca68:	2000      	movne	r0, #0
   8ca6a:	f85d fb08 	ldr.w	pc, [sp], #8
   8ca6e:	bf00      	nop

0008ca70 <__aeabi_fcmplt>:
   8ca70:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ca74:	f7ff ffea 	bl	8ca4c <__aeabi_cfcmpeq>
   8ca78:	bf34      	ite	cc
   8ca7a:	2001      	movcc	r0, #1
   8ca7c:	2000      	movcs	r0, #0
   8ca7e:	f85d fb08 	ldr.w	pc, [sp], #8
   8ca82:	bf00      	nop

0008ca84 <__aeabi_fcmple>:
   8ca84:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ca88:	f7ff ffe0 	bl	8ca4c <__aeabi_cfcmpeq>
   8ca8c:	bf94      	ite	ls
   8ca8e:	2001      	movls	r0, #1
   8ca90:	2000      	movhi	r0, #0
   8ca92:	f85d fb08 	ldr.w	pc, [sp], #8
   8ca96:	bf00      	nop

0008ca98 <__aeabi_fcmpge>:
   8ca98:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ca9c:	f7ff ffd2 	bl	8ca44 <__aeabi_cfrcmple>
   8caa0:	bf94      	ite	ls
   8caa2:	2001      	movls	r0, #1
   8caa4:	2000      	movhi	r0, #0
   8caa6:	f85d fb08 	ldr.w	pc, [sp], #8
   8caaa:	bf00      	nop

0008caac <__aeabi_fcmpgt>:
   8caac:	f84d ed08 	str.w	lr, [sp, #-8]!
   8cab0:	f7ff ffc8 	bl	8ca44 <__aeabi_cfrcmple>
   8cab4:	bf34      	ite	cc
   8cab6:	2001      	movcc	r0, #1
   8cab8:	2000      	movcs	r0, #0
   8caba:	f85d fb08 	ldr.w	pc, [sp], #8
   8cabe:	bf00      	nop

0008cac0 <__aeabi_f2iz>:
   8cac0:	ea4f 0240 	mov.w	r2, r0, lsl #1
   8cac4:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   8cac8:	d30f      	bcc.n	8caea <__aeabi_f2iz+0x2a>
   8caca:	f04f 039e 	mov.w	r3, #158	; 0x9e
   8cace:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   8cad2:	d90d      	bls.n	8caf0 <__aeabi_f2iz+0x30>
   8cad4:	ea4f 2300 	mov.w	r3, r0, lsl #8
   8cad8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8cadc:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   8cae0:	fa23 f002 	lsr.w	r0, r3, r2
   8cae4:	bf18      	it	ne
   8cae6:	4240      	negne	r0, r0
   8cae8:	4770      	bx	lr
   8caea:	f04f 0000 	mov.w	r0, #0
   8caee:	4770      	bx	lr
   8caf0:	f112 0f61 	cmn.w	r2, #97	; 0x61
   8caf4:	d101      	bne.n	8cafa <__aeabi_f2iz+0x3a>
   8caf6:	0242      	lsls	r2, r0, #9
   8caf8:	d105      	bne.n	8cb06 <__aeabi_f2iz+0x46>
   8cafa:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
   8cafe:	bf08      	it	eq
   8cb00:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   8cb04:	4770      	bx	lr
   8cb06:	f04f 0000 	mov.w	r0, #0
   8cb0a:	4770      	bx	lr

0008cb0c <__aeabi_f2uiz>:
   8cb0c:	0042      	lsls	r2, r0, #1
   8cb0e:	d20e      	bcs.n	8cb2e <__aeabi_f2uiz+0x22>
   8cb10:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   8cb14:	d30b      	bcc.n	8cb2e <__aeabi_f2uiz+0x22>
   8cb16:	f04f 039e 	mov.w	r3, #158	; 0x9e
   8cb1a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   8cb1e:	d409      	bmi.n	8cb34 <__aeabi_f2uiz+0x28>
   8cb20:	ea4f 2300 	mov.w	r3, r0, lsl #8
   8cb24:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8cb28:	fa23 f002 	lsr.w	r0, r3, r2
   8cb2c:	4770      	bx	lr
   8cb2e:	f04f 0000 	mov.w	r0, #0
   8cb32:	4770      	bx	lr
   8cb34:	f112 0f61 	cmn.w	r2, #97	; 0x61
   8cb38:	d101      	bne.n	8cb3e <__aeabi_f2uiz+0x32>
   8cb3a:	0242      	lsls	r2, r0, #9
   8cb3c:	d102      	bne.n	8cb44 <__aeabi_f2uiz+0x38>
   8cb3e:	f04f 30ff 	mov.w	r0, #4294967295
   8cb42:	4770      	bx	lr
   8cb44:	f04f 0000 	mov.w	r0, #0
   8cb48:	4770      	bx	lr
   8cb4a:	bf00      	nop

0008cb4c <atol>:
   8cb4c:	2100      	movs	r1, #0
   8cb4e:	220a      	movs	r2, #10
   8cb50:	f000 bd28 	b.w	8d5a4 <strtol>

0008cb54 <__errno>:
   8cb54:	4b01      	ldr	r3, [pc, #4]	; (8cb5c <__errno+0x8>)
   8cb56:	6818      	ldr	r0, [r3, #0]
   8cb58:	4770      	bx	lr
   8cb5a:	bf00      	nop
   8cb5c:	20000478 	.word	0x20000478

0008cb60 <__libc_init_array>:
   8cb60:	b570      	push	{r4, r5, r6, lr}
   8cb62:	4e0f      	ldr	r6, [pc, #60]	; (8cba0 <__libc_init_array+0x40>)
   8cb64:	4d0f      	ldr	r5, [pc, #60]	; (8cba4 <__libc_init_array+0x44>)
   8cb66:	1b76      	subs	r6, r6, r5
   8cb68:	10b6      	asrs	r6, r6, #2
   8cb6a:	bf18      	it	ne
   8cb6c:	2400      	movne	r4, #0
   8cb6e:	d005      	beq.n	8cb7c <__libc_init_array+0x1c>
   8cb70:	3401      	adds	r4, #1
   8cb72:	f855 3b04 	ldr.w	r3, [r5], #4
   8cb76:	4798      	blx	r3
   8cb78:	42a6      	cmp	r6, r4
   8cb7a:	d1f9      	bne.n	8cb70 <__libc_init_array+0x10>
   8cb7c:	4e0a      	ldr	r6, [pc, #40]	; (8cba8 <__libc_init_array+0x48>)
   8cb7e:	4d0b      	ldr	r5, [pc, #44]	; (8cbac <__libc_init_array+0x4c>)
   8cb80:	f005 fc2e 	bl	923e0 <_init>
   8cb84:	1b76      	subs	r6, r6, r5
   8cb86:	10b6      	asrs	r6, r6, #2
   8cb88:	bf18      	it	ne
   8cb8a:	2400      	movne	r4, #0
   8cb8c:	d006      	beq.n	8cb9c <__libc_init_array+0x3c>
   8cb8e:	3401      	adds	r4, #1
   8cb90:	f855 3b04 	ldr.w	r3, [r5], #4
   8cb94:	4798      	blx	r3
   8cb96:	42a6      	cmp	r6, r4
   8cb98:	d1f9      	bne.n	8cb8e <__libc_init_array+0x2e>
   8cb9a:	bd70      	pop	{r4, r5, r6, pc}
   8cb9c:	bd70      	pop	{r4, r5, r6, pc}
   8cb9e:	bf00      	nop
   8cba0:	000923ec 	.word	0x000923ec
   8cba4:	000923ec 	.word	0x000923ec
   8cba8:	000923f4 	.word	0x000923f4
   8cbac:	000923ec 	.word	0x000923ec

0008cbb0 <malloc>:
   8cbb0:	4b02      	ldr	r3, [pc, #8]	; (8cbbc <malloc+0xc>)
   8cbb2:	4601      	mov	r1, r0
   8cbb4:	6818      	ldr	r0, [r3, #0]
   8cbb6:	f000 b80b 	b.w	8cbd0 <_malloc_r>
   8cbba:	bf00      	nop
   8cbbc:	20000478 	.word	0x20000478

0008cbc0 <free>:
   8cbc0:	4b02      	ldr	r3, [pc, #8]	; (8cbcc <free+0xc>)
   8cbc2:	4601      	mov	r1, r0
   8cbc4:	6818      	ldr	r0, [r3, #0]
   8cbc6:	f002 bfd1 	b.w	8fb6c <_free_r>
   8cbca:	bf00      	nop
   8cbcc:	20000478 	.word	0x20000478

0008cbd0 <_malloc_r>:
   8cbd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8cbd4:	f101 050b 	add.w	r5, r1, #11
   8cbd8:	2d16      	cmp	r5, #22
   8cbda:	b083      	sub	sp, #12
   8cbdc:	4606      	mov	r6, r0
   8cbde:	d927      	bls.n	8cc30 <_malloc_r+0x60>
   8cbe0:	f035 0507 	bics.w	r5, r5, #7
   8cbe4:	f100 80b6 	bmi.w	8cd54 <_malloc_r+0x184>
   8cbe8:	42a9      	cmp	r1, r5
   8cbea:	f200 80b3 	bhi.w	8cd54 <_malloc_r+0x184>
   8cbee:	f000 fb39 	bl	8d264 <__malloc_lock>
   8cbf2:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
   8cbf6:	d222      	bcs.n	8cc3e <_malloc_r+0x6e>
   8cbf8:	4fbc      	ldr	r7, [pc, #752]	; (8ceec <_malloc_r+0x31c>)
   8cbfa:	08e8      	lsrs	r0, r5, #3
   8cbfc:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
   8cc00:	68dc      	ldr	r4, [r3, #12]
   8cc02:	429c      	cmp	r4, r3
   8cc04:	f000 81bc 	beq.w	8cf80 <_malloc_r+0x3b0>
   8cc08:	6863      	ldr	r3, [r4, #4]
   8cc0a:	68e1      	ldr	r1, [r4, #12]
   8cc0c:	f023 0303 	bic.w	r3, r3, #3
   8cc10:	4423      	add	r3, r4
   8cc12:	685a      	ldr	r2, [r3, #4]
   8cc14:	68a5      	ldr	r5, [r4, #8]
   8cc16:	f042 0201 	orr.w	r2, r2, #1
   8cc1a:	60e9      	str	r1, [r5, #12]
   8cc1c:	4630      	mov	r0, r6
   8cc1e:	608d      	str	r5, [r1, #8]
   8cc20:	605a      	str	r2, [r3, #4]
   8cc22:	f000 fb21 	bl	8d268 <__malloc_unlock>
   8cc26:	3408      	adds	r4, #8
   8cc28:	4620      	mov	r0, r4
   8cc2a:	b003      	add	sp, #12
   8cc2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8cc30:	2910      	cmp	r1, #16
   8cc32:	f200 808f 	bhi.w	8cd54 <_malloc_r+0x184>
   8cc36:	f000 fb15 	bl	8d264 <__malloc_lock>
   8cc3a:	2510      	movs	r5, #16
   8cc3c:	e7dc      	b.n	8cbf8 <_malloc_r+0x28>
   8cc3e:	0a68      	lsrs	r0, r5, #9
   8cc40:	f000 808f 	beq.w	8cd62 <_malloc_r+0x192>
   8cc44:	2804      	cmp	r0, #4
   8cc46:	f200 8147 	bhi.w	8ced8 <_malloc_r+0x308>
   8cc4a:	09a8      	lsrs	r0, r5, #6
   8cc4c:	3038      	adds	r0, #56	; 0x38
   8cc4e:	0041      	lsls	r1, r0, #1
   8cc50:	4fa6      	ldr	r7, [pc, #664]	; (8ceec <_malloc_r+0x31c>)
   8cc52:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   8cc56:	68cc      	ldr	r4, [r1, #12]
   8cc58:	42a1      	cmp	r1, r4
   8cc5a:	d106      	bne.n	8cc6a <_malloc_r+0x9a>
   8cc5c:	e00c      	b.n	8cc78 <_malloc_r+0xa8>
   8cc5e:	2a00      	cmp	r2, #0
   8cc60:	f280 8082 	bge.w	8cd68 <_malloc_r+0x198>
   8cc64:	68e4      	ldr	r4, [r4, #12]
   8cc66:	42a1      	cmp	r1, r4
   8cc68:	d006      	beq.n	8cc78 <_malloc_r+0xa8>
   8cc6a:	6863      	ldr	r3, [r4, #4]
   8cc6c:	f023 0303 	bic.w	r3, r3, #3
   8cc70:	1b5a      	subs	r2, r3, r5
   8cc72:	2a0f      	cmp	r2, #15
   8cc74:	ddf3      	ble.n	8cc5e <_malloc_r+0x8e>
   8cc76:	3801      	subs	r0, #1
   8cc78:	3001      	adds	r0, #1
   8cc7a:	499c      	ldr	r1, [pc, #624]	; (8ceec <_malloc_r+0x31c>)
   8cc7c:	693c      	ldr	r4, [r7, #16]
   8cc7e:	f101 0e08 	add.w	lr, r1, #8
   8cc82:	4574      	cmp	r4, lr
   8cc84:	f000 8171 	beq.w	8cf6a <_malloc_r+0x39a>
   8cc88:	6863      	ldr	r3, [r4, #4]
   8cc8a:	f023 0303 	bic.w	r3, r3, #3
   8cc8e:	1b5a      	subs	r2, r3, r5
   8cc90:	2a0f      	cmp	r2, #15
   8cc92:	f300 8157 	bgt.w	8cf44 <_malloc_r+0x374>
   8cc96:	2a00      	cmp	r2, #0
   8cc98:	f8c1 e014 	str.w	lr, [r1, #20]
   8cc9c:	f8c1 e010 	str.w	lr, [r1, #16]
   8cca0:	da66      	bge.n	8cd70 <_malloc_r+0x1a0>
   8cca2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8cca6:	f080 812d 	bcs.w	8cf04 <_malloc_r+0x334>
   8ccaa:	08db      	lsrs	r3, r3, #3
   8ccac:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
   8ccb0:	ea4f 0ca3 	mov.w	ip, r3, asr #2
   8ccb4:	684a      	ldr	r2, [r1, #4]
   8ccb6:	2301      	movs	r3, #1
   8ccb8:	fa03 f30c 	lsl.w	r3, r3, ip
   8ccbc:	f8d8 c008 	ldr.w	ip, [r8, #8]
   8ccc0:	4313      	orrs	r3, r2
   8ccc2:	f8c4 c008 	str.w	ip, [r4, #8]
   8ccc6:	f8c4 800c 	str.w	r8, [r4, #12]
   8ccca:	604b      	str	r3, [r1, #4]
   8cccc:	f8c8 4008 	str.w	r4, [r8, #8]
   8ccd0:	f8cc 400c 	str.w	r4, [ip, #12]
   8ccd4:	1082      	asrs	r2, r0, #2
   8ccd6:	2401      	movs	r4, #1
   8ccd8:	4094      	lsls	r4, r2
   8ccda:	429c      	cmp	r4, r3
   8ccdc:	d855      	bhi.n	8cd8a <_malloc_r+0x1ba>
   8ccde:	4223      	tst	r3, r4
   8cce0:	d106      	bne.n	8ccf0 <_malloc_r+0x120>
   8cce2:	f020 0003 	bic.w	r0, r0, #3
   8cce6:	0064      	lsls	r4, r4, #1
   8cce8:	4223      	tst	r3, r4
   8ccea:	f100 0004 	add.w	r0, r0, #4
   8ccee:	d0fa      	beq.n	8cce6 <_malloc_r+0x116>
   8ccf0:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
   8ccf4:	46c4      	mov	ip, r8
   8ccf6:	4681      	mov	r9, r0
   8ccf8:	f8dc 300c 	ldr.w	r3, [ip, #12]
   8ccfc:	459c      	cmp	ip, r3
   8ccfe:	d107      	bne.n	8cd10 <_malloc_r+0x140>
   8cd00:	e135      	b.n	8cf6e <_malloc_r+0x39e>
   8cd02:	2900      	cmp	r1, #0
   8cd04:	f280 8145 	bge.w	8cf92 <_malloc_r+0x3c2>
   8cd08:	68db      	ldr	r3, [r3, #12]
   8cd0a:	459c      	cmp	ip, r3
   8cd0c:	f000 812f 	beq.w	8cf6e <_malloc_r+0x39e>
   8cd10:	685a      	ldr	r2, [r3, #4]
   8cd12:	f022 0203 	bic.w	r2, r2, #3
   8cd16:	1b51      	subs	r1, r2, r5
   8cd18:	290f      	cmp	r1, #15
   8cd1a:	ddf2      	ble.n	8cd02 <_malloc_r+0x132>
   8cd1c:	461c      	mov	r4, r3
   8cd1e:	68da      	ldr	r2, [r3, #12]
   8cd20:	f854 cf08 	ldr.w	ip, [r4, #8]!
   8cd24:	f045 0901 	orr.w	r9, r5, #1
   8cd28:	f041 0801 	orr.w	r8, r1, #1
   8cd2c:	441d      	add	r5, r3
   8cd2e:	f8c3 9004 	str.w	r9, [r3, #4]
   8cd32:	4630      	mov	r0, r6
   8cd34:	f8cc 200c 	str.w	r2, [ip, #12]
   8cd38:	f8c2 c008 	str.w	ip, [r2, #8]
   8cd3c:	617d      	str	r5, [r7, #20]
   8cd3e:	613d      	str	r5, [r7, #16]
   8cd40:	f8c5 e00c 	str.w	lr, [r5, #12]
   8cd44:	f8c5 e008 	str.w	lr, [r5, #8]
   8cd48:	f8c5 8004 	str.w	r8, [r5, #4]
   8cd4c:	5069      	str	r1, [r5, r1]
   8cd4e:	f000 fa8b 	bl	8d268 <__malloc_unlock>
   8cd52:	e769      	b.n	8cc28 <_malloc_r+0x58>
   8cd54:	2400      	movs	r4, #0
   8cd56:	4620      	mov	r0, r4
   8cd58:	230c      	movs	r3, #12
   8cd5a:	6033      	str	r3, [r6, #0]
   8cd5c:	b003      	add	sp, #12
   8cd5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8cd62:	217e      	movs	r1, #126	; 0x7e
   8cd64:	203f      	movs	r0, #63	; 0x3f
   8cd66:	e773      	b.n	8cc50 <_malloc_r+0x80>
   8cd68:	4423      	add	r3, r4
   8cd6a:	685a      	ldr	r2, [r3, #4]
   8cd6c:	68e1      	ldr	r1, [r4, #12]
   8cd6e:	e751      	b.n	8cc14 <_malloc_r+0x44>
   8cd70:	4423      	add	r3, r4
   8cd72:	685a      	ldr	r2, [r3, #4]
   8cd74:	4630      	mov	r0, r6
   8cd76:	f042 0201 	orr.w	r2, r2, #1
   8cd7a:	605a      	str	r2, [r3, #4]
   8cd7c:	3408      	adds	r4, #8
   8cd7e:	f000 fa73 	bl	8d268 <__malloc_unlock>
   8cd82:	4620      	mov	r0, r4
   8cd84:	b003      	add	sp, #12
   8cd86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8cd8a:	68bc      	ldr	r4, [r7, #8]
   8cd8c:	6863      	ldr	r3, [r4, #4]
   8cd8e:	f023 0803 	bic.w	r8, r3, #3
   8cd92:	4545      	cmp	r5, r8
   8cd94:	d804      	bhi.n	8cda0 <_malloc_r+0x1d0>
   8cd96:	ebc5 0308 	rsb	r3, r5, r8
   8cd9a:	2b0f      	cmp	r3, #15
   8cd9c:	f300 808c 	bgt.w	8ceb8 <_malloc_r+0x2e8>
   8cda0:	4b53      	ldr	r3, [pc, #332]	; (8cef0 <_malloc_r+0x320>)
   8cda2:	f8df a15c 	ldr.w	sl, [pc, #348]	; 8cf00 <_malloc_r+0x330>
   8cda6:	681a      	ldr	r2, [r3, #0]
   8cda8:	f8da 3000 	ldr.w	r3, [sl]
   8cdac:	442a      	add	r2, r5
   8cdae:	3301      	adds	r3, #1
   8cdb0:	eb04 0b08 	add.w	fp, r4, r8
   8cdb4:	f000 8151 	beq.w	8d05a <_malloc_r+0x48a>
   8cdb8:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   8cdbc:	320f      	adds	r2, #15
   8cdbe:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
   8cdc2:	f022 020f 	bic.w	r2, r2, #15
   8cdc6:	4611      	mov	r1, r2
   8cdc8:	4630      	mov	r0, r6
   8cdca:	9201      	str	r2, [sp, #4]
   8cdcc:	f000 fa4e 	bl	8d26c <_sbrk_r>
   8cdd0:	f1b0 3fff 	cmp.w	r0, #4294967295
   8cdd4:	4681      	mov	r9, r0
   8cdd6:	9a01      	ldr	r2, [sp, #4]
   8cdd8:	f000 8148 	beq.w	8d06c <_malloc_r+0x49c>
   8cddc:	4583      	cmp	fp, r0
   8cdde:	f200 80ef 	bhi.w	8cfc0 <_malloc_r+0x3f0>
   8cde2:	4b44      	ldr	r3, [pc, #272]	; (8cef4 <_malloc_r+0x324>)
   8cde4:	45cb      	cmp	fp, r9
   8cde6:	6819      	ldr	r1, [r3, #0]
   8cde8:	4411      	add	r1, r2
   8cdea:	6019      	str	r1, [r3, #0]
   8cdec:	f000 8143 	beq.w	8d076 <_malloc_r+0x4a6>
   8cdf0:	f8da 0000 	ldr.w	r0, [sl]
   8cdf4:	f8df e108 	ldr.w	lr, [pc, #264]	; 8cf00 <_malloc_r+0x330>
   8cdf8:	3001      	adds	r0, #1
   8cdfa:	bf1b      	ittet	ne
   8cdfc:	ebcb 0b09 	rsbne	fp, fp, r9
   8ce00:	4459      	addne	r1, fp
   8ce02:	f8ce 9000 	streq.w	r9, [lr]
   8ce06:	6019      	strne	r1, [r3, #0]
   8ce08:	f019 0107 	ands.w	r1, r9, #7
   8ce0c:	f000 8108 	beq.w	8d020 <_malloc_r+0x450>
   8ce10:	f1c1 0008 	rsb	r0, r1, #8
   8ce14:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
   8ce18:	4481      	add	r9, r0
   8ce1a:	3108      	adds	r1, #8
   8ce1c:	444a      	add	r2, r9
   8ce1e:	f3c2 020b 	ubfx	r2, r2, #0, #12
   8ce22:	ebc2 0a01 	rsb	sl, r2, r1
   8ce26:	4651      	mov	r1, sl
   8ce28:	4630      	mov	r0, r6
   8ce2a:	9301      	str	r3, [sp, #4]
   8ce2c:	f000 fa1e 	bl	8d26c <_sbrk_r>
   8ce30:	1c43      	adds	r3, r0, #1
   8ce32:	9b01      	ldr	r3, [sp, #4]
   8ce34:	f000 812d 	beq.w	8d092 <_malloc_r+0x4c2>
   8ce38:	ebc9 0200 	rsb	r2, r9, r0
   8ce3c:	4452      	add	r2, sl
   8ce3e:	f042 0201 	orr.w	r2, r2, #1
   8ce42:	6819      	ldr	r1, [r3, #0]
   8ce44:	42bc      	cmp	r4, r7
   8ce46:	4451      	add	r1, sl
   8ce48:	f8c7 9008 	str.w	r9, [r7, #8]
   8ce4c:	6019      	str	r1, [r3, #0]
   8ce4e:	f8c9 2004 	str.w	r2, [r9, #4]
   8ce52:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 8cef4 <_malloc_r+0x324>
   8ce56:	d016      	beq.n	8ce86 <_malloc_r+0x2b6>
   8ce58:	f1b8 0f0f 	cmp.w	r8, #15
   8ce5c:	f240 80ef 	bls.w	8d03e <_malloc_r+0x46e>
   8ce60:	6862      	ldr	r2, [r4, #4]
   8ce62:	f1a8 030c 	sub.w	r3, r8, #12
   8ce66:	f023 0307 	bic.w	r3, r3, #7
   8ce6a:	f002 0201 	and.w	r2, r2, #1
   8ce6e:	18e0      	adds	r0, r4, r3
   8ce70:	f04f 0e05 	mov.w	lr, #5
   8ce74:	431a      	orrs	r2, r3
   8ce76:	2b0f      	cmp	r3, #15
   8ce78:	6062      	str	r2, [r4, #4]
   8ce7a:	f8c0 e004 	str.w	lr, [r0, #4]
   8ce7e:	f8c0 e008 	str.w	lr, [r0, #8]
   8ce82:	f200 810a 	bhi.w	8d09a <_malloc_r+0x4ca>
   8ce86:	4b1c      	ldr	r3, [pc, #112]	; (8cef8 <_malloc_r+0x328>)
   8ce88:	68bc      	ldr	r4, [r7, #8]
   8ce8a:	681a      	ldr	r2, [r3, #0]
   8ce8c:	4291      	cmp	r1, r2
   8ce8e:	bf88      	it	hi
   8ce90:	6019      	strhi	r1, [r3, #0]
   8ce92:	4b1a      	ldr	r3, [pc, #104]	; (8cefc <_malloc_r+0x32c>)
   8ce94:	681a      	ldr	r2, [r3, #0]
   8ce96:	4291      	cmp	r1, r2
   8ce98:	6862      	ldr	r2, [r4, #4]
   8ce9a:	bf88      	it	hi
   8ce9c:	6019      	strhi	r1, [r3, #0]
   8ce9e:	f022 0203 	bic.w	r2, r2, #3
   8cea2:	4295      	cmp	r5, r2
   8cea4:	eba2 0305 	sub.w	r3, r2, r5
   8cea8:	d801      	bhi.n	8ceae <_malloc_r+0x2de>
   8ceaa:	2b0f      	cmp	r3, #15
   8ceac:	dc04      	bgt.n	8ceb8 <_malloc_r+0x2e8>
   8ceae:	4630      	mov	r0, r6
   8ceb0:	f000 f9da 	bl	8d268 <__malloc_unlock>
   8ceb4:	2400      	movs	r4, #0
   8ceb6:	e6b7      	b.n	8cc28 <_malloc_r+0x58>
   8ceb8:	f045 0201 	orr.w	r2, r5, #1
   8cebc:	f043 0301 	orr.w	r3, r3, #1
   8cec0:	4425      	add	r5, r4
   8cec2:	6062      	str	r2, [r4, #4]
   8cec4:	4630      	mov	r0, r6
   8cec6:	60bd      	str	r5, [r7, #8]
   8cec8:	3408      	adds	r4, #8
   8ceca:	606b      	str	r3, [r5, #4]
   8cecc:	f000 f9cc 	bl	8d268 <__malloc_unlock>
   8ced0:	4620      	mov	r0, r4
   8ced2:	b003      	add	sp, #12
   8ced4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8ced8:	2814      	cmp	r0, #20
   8ceda:	d969      	bls.n	8cfb0 <_malloc_r+0x3e0>
   8cedc:	2854      	cmp	r0, #84	; 0x54
   8cede:	f200 8098 	bhi.w	8d012 <_malloc_r+0x442>
   8cee2:	0b28      	lsrs	r0, r5, #12
   8cee4:	306e      	adds	r0, #110	; 0x6e
   8cee6:	0041      	lsls	r1, r0, #1
   8cee8:	e6b2      	b.n	8cc50 <_malloc_r+0x80>
   8ceea:	bf00      	nop
   8ceec:	2000047c 	.word	0x2000047c
   8cef0:	20001188 	.word	0x20001188
   8cef4:	2000118c 	.word	0x2000118c
   8cef8:	20001184 	.word	0x20001184
   8cefc:	20001180 	.word	0x20001180
   8cf00:	20000888 	.word	0x20000888
   8cf04:	0a5a      	lsrs	r2, r3, #9
   8cf06:	2a04      	cmp	r2, #4
   8cf08:	d955      	bls.n	8cfb6 <_malloc_r+0x3e6>
   8cf0a:	2a14      	cmp	r2, #20
   8cf0c:	f200 80a7 	bhi.w	8d05e <_malloc_r+0x48e>
   8cf10:	325b      	adds	r2, #91	; 0x5b
   8cf12:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   8cf16:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
   8cf1a:	f8dc 1008 	ldr.w	r1, [ip, #8]
   8cf1e:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 8d0d8 <_malloc_r+0x508>
   8cf22:	4561      	cmp	r1, ip
   8cf24:	d07f      	beq.n	8d026 <_malloc_r+0x456>
   8cf26:	684a      	ldr	r2, [r1, #4]
   8cf28:	f022 0203 	bic.w	r2, r2, #3
   8cf2c:	4293      	cmp	r3, r2
   8cf2e:	d202      	bcs.n	8cf36 <_malloc_r+0x366>
   8cf30:	6889      	ldr	r1, [r1, #8]
   8cf32:	458c      	cmp	ip, r1
   8cf34:	d1f7      	bne.n	8cf26 <_malloc_r+0x356>
   8cf36:	68ca      	ldr	r2, [r1, #12]
   8cf38:	687b      	ldr	r3, [r7, #4]
   8cf3a:	60e2      	str	r2, [r4, #12]
   8cf3c:	60a1      	str	r1, [r4, #8]
   8cf3e:	6094      	str	r4, [r2, #8]
   8cf40:	60cc      	str	r4, [r1, #12]
   8cf42:	e6c7      	b.n	8ccd4 <_malloc_r+0x104>
   8cf44:	f045 0701 	orr.w	r7, r5, #1
   8cf48:	f042 0301 	orr.w	r3, r2, #1
   8cf4c:	4425      	add	r5, r4
   8cf4e:	6067      	str	r7, [r4, #4]
   8cf50:	4630      	mov	r0, r6
   8cf52:	614d      	str	r5, [r1, #20]
   8cf54:	610d      	str	r5, [r1, #16]
   8cf56:	f8c5 e00c 	str.w	lr, [r5, #12]
   8cf5a:	f8c5 e008 	str.w	lr, [r5, #8]
   8cf5e:	606b      	str	r3, [r5, #4]
   8cf60:	50aa      	str	r2, [r5, r2]
   8cf62:	3408      	adds	r4, #8
   8cf64:	f000 f980 	bl	8d268 <__malloc_unlock>
   8cf68:	e65e      	b.n	8cc28 <_malloc_r+0x58>
   8cf6a:	684b      	ldr	r3, [r1, #4]
   8cf6c:	e6b2      	b.n	8ccd4 <_malloc_r+0x104>
   8cf6e:	f109 0901 	add.w	r9, r9, #1
   8cf72:	f019 0f03 	tst.w	r9, #3
   8cf76:	f10c 0c08 	add.w	ip, ip, #8
   8cf7a:	f47f aebd 	bne.w	8ccf8 <_malloc_r+0x128>
   8cf7e:	e02c      	b.n	8cfda <_malloc_r+0x40a>
   8cf80:	f104 0308 	add.w	r3, r4, #8
   8cf84:	6964      	ldr	r4, [r4, #20]
   8cf86:	42a3      	cmp	r3, r4
   8cf88:	bf08      	it	eq
   8cf8a:	3002      	addeq	r0, #2
   8cf8c:	f43f ae75 	beq.w	8cc7a <_malloc_r+0xaa>
   8cf90:	e63a      	b.n	8cc08 <_malloc_r+0x38>
   8cf92:	461c      	mov	r4, r3
   8cf94:	441a      	add	r2, r3
   8cf96:	6851      	ldr	r1, [r2, #4]
   8cf98:	68db      	ldr	r3, [r3, #12]
   8cf9a:	f854 5f08 	ldr.w	r5, [r4, #8]!
   8cf9e:	f041 0101 	orr.w	r1, r1, #1
   8cfa2:	6051      	str	r1, [r2, #4]
   8cfa4:	4630      	mov	r0, r6
   8cfa6:	60eb      	str	r3, [r5, #12]
   8cfa8:	609d      	str	r5, [r3, #8]
   8cfaa:	f000 f95d 	bl	8d268 <__malloc_unlock>
   8cfae:	e63b      	b.n	8cc28 <_malloc_r+0x58>
   8cfb0:	305b      	adds	r0, #91	; 0x5b
   8cfb2:	0041      	lsls	r1, r0, #1
   8cfb4:	e64c      	b.n	8cc50 <_malloc_r+0x80>
   8cfb6:	099a      	lsrs	r2, r3, #6
   8cfb8:	3238      	adds	r2, #56	; 0x38
   8cfba:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   8cfbe:	e7aa      	b.n	8cf16 <_malloc_r+0x346>
   8cfc0:	42bc      	cmp	r4, r7
   8cfc2:	4b45      	ldr	r3, [pc, #276]	; (8d0d8 <_malloc_r+0x508>)
   8cfc4:	f43f af0d 	beq.w	8cde2 <_malloc_r+0x212>
   8cfc8:	689c      	ldr	r4, [r3, #8]
   8cfca:	6862      	ldr	r2, [r4, #4]
   8cfcc:	f022 0203 	bic.w	r2, r2, #3
   8cfd0:	e767      	b.n	8cea2 <_malloc_r+0x2d2>
   8cfd2:	f8d8 8000 	ldr.w	r8, [r8]
   8cfd6:	4598      	cmp	r8, r3
   8cfd8:	d17c      	bne.n	8d0d4 <_malloc_r+0x504>
   8cfda:	f010 0f03 	tst.w	r0, #3
   8cfde:	f1a8 0308 	sub.w	r3, r8, #8
   8cfe2:	f100 30ff 	add.w	r0, r0, #4294967295
   8cfe6:	d1f4      	bne.n	8cfd2 <_malloc_r+0x402>
   8cfe8:	687b      	ldr	r3, [r7, #4]
   8cfea:	ea23 0304 	bic.w	r3, r3, r4
   8cfee:	607b      	str	r3, [r7, #4]
   8cff0:	0064      	lsls	r4, r4, #1
   8cff2:	429c      	cmp	r4, r3
   8cff4:	f63f aec9 	bhi.w	8cd8a <_malloc_r+0x1ba>
   8cff8:	2c00      	cmp	r4, #0
   8cffa:	f43f aec6 	beq.w	8cd8a <_malloc_r+0x1ba>
   8cffe:	4223      	tst	r3, r4
   8d000:	4648      	mov	r0, r9
   8d002:	f47f ae75 	bne.w	8ccf0 <_malloc_r+0x120>
   8d006:	0064      	lsls	r4, r4, #1
   8d008:	4223      	tst	r3, r4
   8d00a:	f100 0004 	add.w	r0, r0, #4
   8d00e:	d0fa      	beq.n	8d006 <_malloc_r+0x436>
   8d010:	e66e      	b.n	8ccf0 <_malloc_r+0x120>
   8d012:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
   8d016:	d818      	bhi.n	8d04a <_malloc_r+0x47a>
   8d018:	0be8      	lsrs	r0, r5, #15
   8d01a:	3077      	adds	r0, #119	; 0x77
   8d01c:	0041      	lsls	r1, r0, #1
   8d01e:	e617      	b.n	8cc50 <_malloc_r+0x80>
   8d020:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   8d024:	e6fa      	b.n	8ce1c <_malloc_r+0x24c>
   8d026:	f8d8 3004 	ldr.w	r3, [r8, #4]
   8d02a:	1092      	asrs	r2, r2, #2
   8d02c:	f04f 0c01 	mov.w	ip, #1
   8d030:	fa0c f202 	lsl.w	r2, ip, r2
   8d034:	4313      	orrs	r3, r2
   8d036:	f8c8 3004 	str.w	r3, [r8, #4]
   8d03a:	460a      	mov	r2, r1
   8d03c:	e77d      	b.n	8cf3a <_malloc_r+0x36a>
   8d03e:	2301      	movs	r3, #1
   8d040:	f8c9 3004 	str.w	r3, [r9, #4]
   8d044:	464c      	mov	r4, r9
   8d046:	2200      	movs	r2, #0
   8d048:	e72b      	b.n	8cea2 <_malloc_r+0x2d2>
   8d04a:	f240 5354 	movw	r3, #1364	; 0x554
   8d04e:	4298      	cmp	r0, r3
   8d050:	d81c      	bhi.n	8d08c <_malloc_r+0x4bc>
   8d052:	0ca8      	lsrs	r0, r5, #18
   8d054:	307c      	adds	r0, #124	; 0x7c
   8d056:	0041      	lsls	r1, r0, #1
   8d058:	e5fa      	b.n	8cc50 <_malloc_r+0x80>
   8d05a:	3210      	adds	r2, #16
   8d05c:	e6b3      	b.n	8cdc6 <_malloc_r+0x1f6>
   8d05e:	2a54      	cmp	r2, #84	; 0x54
   8d060:	d823      	bhi.n	8d0aa <_malloc_r+0x4da>
   8d062:	0b1a      	lsrs	r2, r3, #12
   8d064:	326e      	adds	r2, #110	; 0x6e
   8d066:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   8d06a:	e754      	b.n	8cf16 <_malloc_r+0x346>
   8d06c:	68bc      	ldr	r4, [r7, #8]
   8d06e:	6862      	ldr	r2, [r4, #4]
   8d070:	f022 0203 	bic.w	r2, r2, #3
   8d074:	e715      	b.n	8cea2 <_malloc_r+0x2d2>
   8d076:	f3cb 000b 	ubfx	r0, fp, #0, #12
   8d07a:	2800      	cmp	r0, #0
   8d07c:	f47f aeb8 	bne.w	8cdf0 <_malloc_r+0x220>
   8d080:	4442      	add	r2, r8
   8d082:	68bb      	ldr	r3, [r7, #8]
   8d084:	f042 0201 	orr.w	r2, r2, #1
   8d088:	605a      	str	r2, [r3, #4]
   8d08a:	e6fc      	b.n	8ce86 <_malloc_r+0x2b6>
   8d08c:	21fc      	movs	r1, #252	; 0xfc
   8d08e:	207e      	movs	r0, #126	; 0x7e
   8d090:	e5de      	b.n	8cc50 <_malloc_r+0x80>
   8d092:	2201      	movs	r2, #1
   8d094:	f04f 0a00 	mov.w	sl, #0
   8d098:	e6d3      	b.n	8ce42 <_malloc_r+0x272>
   8d09a:	f104 0108 	add.w	r1, r4, #8
   8d09e:	4630      	mov	r0, r6
   8d0a0:	f002 fd64 	bl	8fb6c <_free_r>
   8d0a4:	f8da 1000 	ldr.w	r1, [sl]
   8d0a8:	e6ed      	b.n	8ce86 <_malloc_r+0x2b6>
   8d0aa:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   8d0ae:	d804      	bhi.n	8d0ba <_malloc_r+0x4ea>
   8d0b0:	0bda      	lsrs	r2, r3, #15
   8d0b2:	3277      	adds	r2, #119	; 0x77
   8d0b4:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   8d0b8:	e72d      	b.n	8cf16 <_malloc_r+0x346>
   8d0ba:	f240 5154 	movw	r1, #1364	; 0x554
   8d0be:	428a      	cmp	r2, r1
   8d0c0:	d804      	bhi.n	8d0cc <_malloc_r+0x4fc>
   8d0c2:	0c9a      	lsrs	r2, r3, #18
   8d0c4:	327c      	adds	r2, #124	; 0x7c
   8d0c6:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   8d0ca:	e724      	b.n	8cf16 <_malloc_r+0x346>
   8d0cc:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
   8d0d0:	227e      	movs	r2, #126	; 0x7e
   8d0d2:	e720      	b.n	8cf16 <_malloc_r+0x346>
   8d0d4:	687b      	ldr	r3, [r7, #4]
   8d0d6:	e78b      	b.n	8cff0 <_malloc_r+0x420>
   8d0d8:	2000047c 	.word	0x2000047c

0008d0dc <memcpy>:
   8d0dc:	4684      	mov	ip, r0
   8d0de:	ea41 0300 	orr.w	r3, r1, r0
   8d0e2:	f013 0303 	ands.w	r3, r3, #3
   8d0e6:	d149      	bne.n	8d17c <memcpy+0xa0>
   8d0e8:	3a40      	subs	r2, #64	; 0x40
   8d0ea:	d323      	bcc.n	8d134 <memcpy+0x58>
   8d0ec:	680b      	ldr	r3, [r1, #0]
   8d0ee:	6003      	str	r3, [r0, #0]
   8d0f0:	684b      	ldr	r3, [r1, #4]
   8d0f2:	6043      	str	r3, [r0, #4]
   8d0f4:	688b      	ldr	r3, [r1, #8]
   8d0f6:	6083      	str	r3, [r0, #8]
   8d0f8:	68cb      	ldr	r3, [r1, #12]
   8d0fa:	60c3      	str	r3, [r0, #12]
   8d0fc:	690b      	ldr	r3, [r1, #16]
   8d0fe:	6103      	str	r3, [r0, #16]
   8d100:	694b      	ldr	r3, [r1, #20]
   8d102:	6143      	str	r3, [r0, #20]
   8d104:	698b      	ldr	r3, [r1, #24]
   8d106:	6183      	str	r3, [r0, #24]
   8d108:	69cb      	ldr	r3, [r1, #28]
   8d10a:	61c3      	str	r3, [r0, #28]
   8d10c:	6a0b      	ldr	r3, [r1, #32]
   8d10e:	6203      	str	r3, [r0, #32]
   8d110:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   8d112:	6243      	str	r3, [r0, #36]	; 0x24
   8d114:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   8d116:	6283      	str	r3, [r0, #40]	; 0x28
   8d118:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   8d11a:	62c3      	str	r3, [r0, #44]	; 0x2c
   8d11c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   8d11e:	6303      	str	r3, [r0, #48]	; 0x30
   8d120:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   8d122:	6343      	str	r3, [r0, #52]	; 0x34
   8d124:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   8d126:	6383      	str	r3, [r0, #56]	; 0x38
   8d128:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   8d12a:	63c3      	str	r3, [r0, #60]	; 0x3c
   8d12c:	3040      	adds	r0, #64	; 0x40
   8d12e:	3140      	adds	r1, #64	; 0x40
   8d130:	3a40      	subs	r2, #64	; 0x40
   8d132:	d2db      	bcs.n	8d0ec <memcpy+0x10>
   8d134:	3230      	adds	r2, #48	; 0x30
   8d136:	d30b      	bcc.n	8d150 <memcpy+0x74>
   8d138:	680b      	ldr	r3, [r1, #0]
   8d13a:	6003      	str	r3, [r0, #0]
   8d13c:	684b      	ldr	r3, [r1, #4]
   8d13e:	6043      	str	r3, [r0, #4]
   8d140:	688b      	ldr	r3, [r1, #8]
   8d142:	6083      	str	r3, [r0, #8]
   8d144:	68cb      	ldr	r3, [r1, #12]
   8d146:	60c3      	str	r3, [r0, #12]
   8d148:	3010      	adds	r0, #16
   8d14a:	3110      	adds	r1, #16
   8d14c:	3a10      	subs	r2, #16
   8d14e:	d2f3      	bcs.n	8d138 <memcpy+0x5c>
   8d150:	320c      	adds	r2, #12
   8d152:	d305      	bcc.n	8d160 <memcpy+0x84>
   8d154:	f851 3b04 	ldr.w	r3, [r1], #4
   8d158:	f840 3b04 	str.w	r3, [r0], #4
   8d15c:	3a04      	subs	r2, #4
   8d15e:	d2f9      	bcs.n	8d154 <memcpy+0x78>
   8d160:	3204      	adds	r2, #4
   8d162:	d008      	beq.n	8d176 <memcpy+0x9a>
   8d164:	07d2      	lsls	r2, r2, #31
   8d166:	bf1c      	itt	ne
   8d168:	f811 3b01 	ldrbne.w	r3, [r1], #1
   8d16c:	f800 3b01 	strbne.w	r3, [r0], #1
   8d170:	d301      	bcc.n	8d176 <memcpy+0x9a>
   8d172:	880b      	ldrh	r3, [r1, #0]
   8d174:	8003      	strh	r3, [r0, #0]
   8d176:	4660      	mov	r0, ip
   8d178:	4770      	bx	lr
   8d17a:	bf00      	nop
   8d17c:	2a08      	cmp	r2, #8
   8d17e:	d313      	bcc.n	8d1a8 <memcpy+0xcc>
   8d180:	078b      	lsls	r3, r1, #30
   8d182:	d0b1      	beq.n	8d0e8 <memcpy+0xc>
   8d184:	f010 0303 	ands.w	r3, r0, #3
   8d188:	d0ae      	beq.n	8d0e8 <memcpy+0xc>
   8d18a:	f1c3 0304 	rsb	r3, r3, #4
   8d18e:	1ad2      	subs	r2, r2, r3
   8d190:	07db      	lsls	r3, r3, #31
   8d192:	bf1c      	itt	ne
   8d194:	f811 3b01 	ldrbne.w	r3, [r1], #1
   8d198:	f800 3b01 	strbne.w	r3, [r0], #1
   8d19c:	d3a4      	bcc.n	8d0e8 <memcpy+0xc>
   8d19e:	f831 3b02 	ldrh.w	r3, [r1], #2
   8d1a2:	f820 3b02 	strh.w	r3, [r0], #2
   8d1a6:	e79f      	b.n	8d0e8 <memcpy+0xc>
   8d1a8:	3a04      	subs	r2, #4
   8d1aa:	d3d9      	bcc.n	8d160 <memcpy+0x84>
   8d1ac:	3a01      	subs	r2, #1
   8d1ae:	f811 3b01 	ldrb.w	r3, [r1], #1
   8d1b2:	f800 3b01 	strb.w	r3, [r0], #1
   8d1b6:	d2f9      	bcs.n	8d1ac <memcpy+0xd0>
   8d1b8:	780b      	ldrb	r3, [r1, #0]
   8d1ba:	7003      	strb	r3, [r0, #0]
   8d1bc:	784b      	ldrb	r3, [r1, #1]
   8d1be:	7043      	strb	r3, [r0, #1]
   8d1c0:	788b      	ldrb	r3, [r1, #2]
   8d1c2:	7083      	strb	r3, [r0, #2]
   8d1c4:	4660      	mov	r0, ip
   8d1c6:	4770      	bx	lr

0008d1c8 <memset>:
   8d1c8:	b470      	push	{r4, r5, r6}
   8d1ca:	0784      	lsls	r4, r0, #30
   8d1cc:	d046      	beq.n	8d25c <memset+0x94>
   8d1ce:	1e54      	subs	r4, r2, #1
   8d1d0:	2a00      	cmp	r2, #0
   8d1d2:	d041      	beq.n	8d258 <memset+0x90>
   8d1d4:	b2cd      	uxtb	r5, r1
   8d1d6:	4603      	mov	r3, r0
   8d1d8:	e002      	b.n	8d1e0 <memset+0x18>
   8d1da:	1e62      	subs	r2, r4, #1
   8d1dc:	b3e4      	cbz	r4, 8d258 <memset+0x90>
   8d1de:	4614      	mov	r4, r2
   8d1e0:	f803 5b01 	strb.w	r5, [r3], #1
   8d1e4:	079a      	lsls	r2, r3, #30
   8d1e6:	d1f8      	bne.n	8d1da <memset+0x12>
   8d1e8:	2c03      	cmp	r4, #3
   8d1ea:	d92e      	bls.n	8d24a <memset+0x82>
   8d1ec:	b2cd      	uxtb	r5, r1
   8d1ee:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   8d1f2:	2c0f      	cmp	r4, #15
   8d1f4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   8d1f8:	d919      	bls.n	8d22e <memset+0x66>
   8d1fa:	4626      	mov	r6, r4
   8d1fc:	f103 0210 	add.w	r2, r3, #16
   8d200:	3e10      	subs	r6, #16
   8d202:	2e0f      	cmp	r6, #15
   8d204:	f842 5c10 	str.w	r5, [r2, #-16]
   8d208:	f842 5c0c 	str.w	r5, [r2, #-12]
   8d20c:	f842 5c08 	str.w	r5, [r2, #-8]
   8d210:	f842 5c04 	str.w	r5, [r2, #-4]
   8d214:	f102 0210 	add.w	r2, r2, #16
   8d218:	d8f2      	bhi.n	8d200 <memset+0x38>
   8d21a:	f1a4 0210 	sub.w	r2, r4, #16
   8d21e:	f022 020f 	bic.w	r2, r2, #15
   8d222:	f004 040f 	and.w	r4, r4, #15
   8d226:	3210      	adds	r2, #16
   8d228:	2c03      	cmp	r4, #3
   8d22a:	4413      	add	r3, r2
   8d22c:	d90d      	bls.n	8d24a <memset+0x82>
   8d22e:	461e      	mov	r6, r3
   8d230:	4622      	mov	r2, r4
   8d232:	3a04      	subs	r2, #4
   8d234:	2a03      	cmp	r2, #3
   8d236:	f846 5b04 	str.w	r5, [r6], #4
   8d23a:	d8fa      	bhi.n	8d232 <memset+0x6a>
   8d23c:	1f22      	subs	r2, r4, #4
   8d23e:	f022 0203 	bic.w	r2, r2, #3
   8d242:	3204      	adds	r2, #4
   8d244:	4413      	add	r3, r2
   8d246:	f004 0403 	and.w	r4, r4, #3
   8d24a:	b12c      	cbz	r4, 8d258 <memset+0x90>
   8d24c:	b2c9      	uxtb	r1, r1
   8d24e:	441c      	add	r4, r3
   8d250:	f803 1b01 	strb.w	r1, [r3], #1
   8d254:	42a3      	cmp	r3, r4
   8d256:	d1fb      	bne.n	8d250 <memset+0x88>
   8d258:	bc70      	pop	{r4, r5, r6}
   8d25a:	4770      	bx	lr
   8d25c:	4614      	mov	r4, r2
   8d25e:	4603      	mov	r3, r0
   8d260:	e7c2      	b.n	8d1e8 <memset+0x20>
   8d262:	bf00      	nop

0008d264 <__malloc_lock>:
   8d264:	4770      	bx	lr
   8d266:	bf00      	nop

0008d268 <__malloc_unlock>:
   8d268:	4770      	bx	lr
   8d26a:	bf00      	nop

0008d26c <_sbrk_r>:
   8d26c:	b538      	push	{r3, r4, r5, lr}
   8d26e:	4c07      	ldr	r4, [pc, #28]	; (8d28c <_sbrk_r+0x20>)
   8d270:	2300      	movs	r3, #0
   8d272:	4605      	mov	r5, r0
   8d274:	4608      	mov	r0, r1
   8d276:	6023      	str	r3, [r4, #0]
   8d278:	f7fb ffb2 	bl	891e0 <_sbrk>
   8d27c:	1c43      	adds	r3, r0, #1
   8d27e:	d000      	beq.n	8d282 <_sbrk_r+0x16>
   8d280:	bd38      	pop	{r3, r4, r5, pc}
   8d282:	6823      	ldr	r3, [r4, #0]
   8d284:	2b00      	cmp	r3, #0
   8d286:	d0fb      	beq.n	8d280 <_sbrk_r+0x14>
   8d288:	602b      	str	r3, [r5, #0]
   8d28a:	bd38      	pop	{r3, r4, r5, pc}
   8d28c:	200016e4 	.word	0x200016e4

0008d290 <sprintf>:
   8d290:	b40e      	push	{r1, r2, r3}
   8d292:	b5f0      	push	{r4, r5, r6, r7, lr}
   8d294:	4606      	mov	r6, r0
   8d296:	f64f 7eff 	movw	lr, #65535	; 0xffff
   8d29a:	b09c      	sub	sp, #112	; 0x70
   8d29c:	ac21      	add	r4, sp, #132	; 0x84
   8d29e:	f854 2b04 	ldr.w	r2, [r4], #4
   8d2a2:	490d      	ldr	r1, [pc, #52]	; (8d2d8 <sprintf+0x48>)
   8d2a4:	4623      	mov	r3, r4
   8d2a6:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   8d2aa:	6808      	ldr	r0, [r1, #0]
   8d2ac:	f44f 7702 	mov.w	r7, #520	; 0x208
   8d2b0:	a902      	add	r1, sp, #8
   8d2b2:	9602      	str	r6, [sp, #8]
   8d2b4:	9606      	str	r6, [sp, #24]
   8d2b6:	9401      	str	r4, [sp, #4]
   8d2b8:	f8ad e016 	strh.w	lr, [sp, #22]
   8d2bc:	f8ad 7014 	strh.w	r7, [sp, #20]
   8d2c0:	9504      	str	r5, [sp, #16]
   8d2c2:	9507      	str	r5, [sp, #28]
   8d2c4:	f000 f97a 	bl	8d5bc <_svfprintf_r>
   8d2c8:	9b02      	ldr	r3, [sp, #8]
   8d2ca:	2200      	movs	r2, #0
   8d2cc:	701a      	strb	r2, [r3, #0]
   8d2ce:	b01c      	add	sp, #112	; 0x70
   8d2d0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   8d2d4:	b003      	add	sp, #12
   8d2d6:	4770      	bx	lr
   8d2d8:	20000478 	.word	0x20000478

0008d2dc <strcpy>:
   8d2dc:	ea80 0201 	eor.w	r2, r0, r1
   8d2e0:	4684      	mov	ip, r0
   8d2e2:	f012 0f03 	tst.w	r2, #3
   8d2e6:	d14f      	bne.n	8d388 <strcpy+0xac>
   8d2e8:	f011 0f03 	tst.w	r1, #3
   8d2ec:	d132      	bne.n	8d354 <strcpy+0x78>
   8d2ee:	f84d 4d04 	str.w	r4, [sp, #-4]!
   8d2f2:	f011 0f04 	tst.w	r1, #4
   8d2f6:	f851 3b04 	ldr.w	r3, [r1], #4
   8d2fa:	d00b      	beq.n	8d314 <strcpy+0x38>
   8d2fc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   8d300:	439a      	bics	r2, r3
   8d302:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   8d306:	bf04      	itt	eq
   8d308:	f84c 3b04 	streq.w	r3, [ip], #4
   8d30c:	f851 3b04 	ldreq.w	r3, [r1], #4
   8d310:	d116      	bne.n	8d340 <strcpy+0x64>
   8d312:	bf00      	nop
   8d314:	f851 4b04 	ldr.w	r4, [r1], #4
   8d318:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   8d31c:	439a      	bics	r2, r3
   8d31e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   8d322:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   8d326:	d10b      	bne.n	8d340 <strcpy+0x64>
   8d328:	f84c 3b04 	str.w	r3, [ip], #4
   8d32c:	43a2      	bics	r2, r4
   8d32e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   8d332:	bf04      	itt	eq
   8d334:	f851 3b04 	ldreq.w	r3, [r1], #4
   8d338:	f84c 4b04 	streq.w	r4, [ip], #4
   8d33c:	d0ea      	beq.n	8d314 <strcpy+0x38>
   8d33e:	4623      	mov	r3, r4
   8d340:	f80c 3b01 	strb.w	r3, [ip], #1
   8d344:	f013 0fff 	tst.w	r3, #255	; 0xff
   8d348:	ea4f 2333 	mov.w	r3, r3, ror #8
   8d34c:	d1f8      	bne.n	8d340 <strcpy+0x64>
   8d34e:	f85d 4b04 	ldr.w	r4, [sp], #4
   8d352:	4770      	bx	lr
   8d354:	f011 0f01 	tst.w	r1, #1
   8d358:	d006      	beq.n	8d368 <strcpy+0x8c>
   8d35a:	f811 2b01 	ldrb.w	r2, [r1], #1
   8d35e:	f80c 2b01 	strb.w	r2, [ip], #1
   8d362:	2a00      	cmp	r2, #0
   8d364:	bf08      	it	eq
   8d366:	4770      	bxeq	lr
   8d368:	f011 0f02 	tst.w	r1, #2
   8d36c:	d0bf      	beq.n	8d2ee <strcpy+0x12>
   8d36e:	f831 2b02 	ldrh.w	r2, [r1], #2
   8d372:	f012 0fff 	tst.w	r2, #255	; 0xff
   8d376:	bf16      	itet	ne
   8d378:	f82c 2b02 	strhne.w	r2, [ip], #2
   8d37c:	f88c 2000 	strbeq.w	r2, [ip]
   8d380:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   8d384:	d1b3      	bne.n	8d2ee <strcpy+0x12>
   8d386:	4770      	bx	lr
   8d388:	f811 2b01 	ldrb.w	r2, [r1], #1
   8d38c:	f80c 2b01 	strb.w	r2, [ip], #1
   8d390:	2a00      	cmp	r2, #0
   8d392:	d1f9      	bne.n	8d388 <strcpy+0xac>
   8d394:	4770      	bx	lr
   8d396:	bf00      	nop

0008d398 <strlen>:
   8d398:	f020 0103 	bic.w	r1, r0, #3
   8d39c:	f010 0003 	ands.w	r0, r0, #3
   8d3a0:	f1c0 0000 	rsb	r0, r0, #0
   8d3a4:	f851 3b04 	ldr.w	r3, [r1], #4
   8d3a8:	f100 0c04 	add.w	ip, r0, #4
   8d3ac:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   8d3b0:	f06f 0200 	mvn.w	r2, #0
   8d3b4:	bf1c      	itt	ne
   8d3b6:	fa22 f20c 	lsrne.w	r2, r2, ip
   8d3ba:	4313      	orrne	r3, r2
   8d3bc:	f04f 0c01 	mov.w	ip, #1
   8d3c0:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   8d3c4:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   8d3c8:	eba3 020c 	sub.w	r2, r3, ip
   8d3cc:	ea22 0203 	bic.w	r2, r2, r3
   8d3d0:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   8d3d4:	bf04      	itt	eq
   8d3d6:	f851 3b04 	ldreq.w	r3, [r1], #4
   8d3da:	3004      	addeq	r0, #4
   8d3dc:	d0f4      	beq.n	8d3c8 <strlen+0x30>
   8d3de:	f1c2 0100 	rsb	r1, r2, #0
   8d3e2:	ea02 0201 	and.w	r2, r2, r1
   8d3e6:	fab2 f282 	clz	r2, r2
   8d3ea:	f1c2 021f 	rsb	r2, r2, #31
   8d3ee:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   8d3f2:	4770      	bx	lr

0008d3f4 <strncmp>:
   8d3f4:	2a00      	cmp	r2, #0
   8d3f6:	d03c      	beq.n	8d472 <strncmp+0x7e>
   8d3f8:	ea40 0301 	orr.w	r3, r0, r1
   8d3fc:	f013 0303 	ands.w	r3, r3, #3
   8d400:	b4f0      	push	{r4, r5, r6, r7}
   8d402:	d125      	bne.n	8d450 <strncmp+0x5c>
   8d404:	2a03      	cmp	r2, #3
   8d406:	d923      	bls.n	8d450 <strncmp+0x5c>
   8d408:	6804      	ldr	r4, [r0, #0]
   8d40a:	680d      	ldr	r5, [r1, #0]
   8d40c:	42ac      	cmp	r4, r5
   8d40e:	d11f      	bne.n	8d450 <strncmp+0x5c>
   8d410:	3a04      	subs	r2, #4
   8d412:	d030      	beq.n	8d476 <strncmp+0x82>
   8d414:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
   8d418:	ea25 0404 	bic.w	r4, r5, r4
   8d41c:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   8d420:	d12c      	bne.n	8d47c <strncmp+0x88>
   8d422:	1d07      	adds	r7, r0, #4
   8d424:	1d0d      	adds	r5, r1, #4
   8d426:	e00d      	b.n	8d444 <strncmp+0x50>
   8d428:	f857 3b04 	ldr.w	r3, [r7], #4
   8d42c:	680e      	ldr	r6, [r1, #0]
   8d42e:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
   8d432:	42b3      	cmp	r3, r6
   8d434:	ea24 0403 	bic.w	r4, r4, r3
   8d438:	d10a      	bne.n	8d450 <strncmp+0x5c>
   8d43a:	3a04      	subs	r2, #4
   8d43c:	d01b      	beq.n	8d476 <strncmp+0x82>
   8d43e:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   8d442:	d11e      	bne.n	8d482 <strncmp+0x8e>
   8d444:	2a03      	cmp	r2, #3
   8d446:	4629      	mov	r1, r5
   8d448:	4638      	mov	r0, r7
   8d44a:	f105 0504 	add.w	r5, r5, #4
   8d44e:	d8eb      	bhi.n	8d428 <strncmp+0x34>
   8d450:	7803      	ldrb	r3, [r0, #0]
   8d452:	780c      	ldrb	r4, [r1, #0]
   8d454:	3a01      	subs	r2, #1
   8d456:	42a3      	cmp	r3, r4
   8d458:	d108      	bne.n	8d46c <strncmp+0x78>
   8d45a:	b162      	cbz	r2, 8d476 <strncmp+0x82>
   8d45c:	b173      	cbz	r3, 8d47c <strncmp+0x88>
   8d45e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   8d462:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   8d466:	3a01      	subs	r2, #1
   8d468:	42a3      	cmp	r3, r4
   8d46a:	d0f6      	beq.n	8d45a <strncmp+0x66>
   8d46c:	1b18      	subs	r0, r3, r4
   8d46e:	bcf0      	pop	{r4, r5, r6, r7}
   8d470:	4770      	bx	lr
   8d472:	4610      	mov	r0, r2
   8d474:	4770      	bx	lr
   8d476:	4610      	mov	r0, r2
   8d478:	bcf0      	pop	{r4, r5, r6, r7}
   8d47a:	4770      	bx	lr
   8d47c:	4618      	mov	r0, r3
   8d47e:	bcf0      	pop	{r4, r5, r6, r7}
   8d480:	4770      	bx	lr
   8d482:	2000      	movs	r0, #0
   8d484:	e7f3      	b.n	8d46e <strncmp+0x7a>
   8d486:	bf00      	nop

0008d488 <_strtol_r>:
   8d488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8d48c:	4c44      	ldr	r4, [pc, #272]	; (8d5a0 <_strtol_r+0x118>)
   8d48e:	4683      	mov	fp, r0
   8d490:	460e      	mov	r6, r1
   8d492:	f8d4 e000 	ldr.w	lr, [r4]
   8d496:	e000      	b.n	8d49a <_strtol_r+0x12>
   8d498:	4626      	mov	r6, r4
   8d49a:	4634      	mov	r4, r6
   8d49c:	f814 5b01 	ldrb.w	r5, [r4], #1
   8d4a0:	eb0e 0005 	add.w	r0, lr, r5
   8d4a4:	7840      	ldrb	r0, [r0, #1]
   8d4a6:	f000 0008 	and.w	r0, r0, #8
   8d4aa:	f000 08ff 	and.w	r8, r0, #255	; 0xff
   8d4ae:	2800      	cmp	r0, #0
   8d4b0:	d1f2      	bne.n	8d498 <_strtol_r+0x10>
   8d4b2:	2d2d      	cmp	r5, #45	; 0x2d
   8d4b4:	d04b      	beq.n	8d54e <_strtol_r+0xc6>
   8d4b6:	2d2b      	cmp	r5, #43	; 0x2b
   8d4b8:	bf04      	itt	eq
   8d4ba:	7875      	ldrbeq	r5, [r6, #1]
   8d4bc:	1cb4      	addeq	r4, r6, #2
   8d4be:	b11b      	cbz	r3, 8d4c8 <_strtol_r+0x40>
   8d4c0:	2b10      	cmp	r3, #16
   8d4c2:	d060      	beq.n	8d586 <_strtol_r+0xfe>
   8d4c4:	469a      	mov	sl, r3
   8d4c6:	e003      	b.n	8d4d0 <_strtol_r+0x48>
   8d4c8:	2d30      	cmp	r5, #48	; 0x30
   8d4ca:	d054      	beq.n	8d576 <_strtol_r+0xee>
   8d4cc:	230a      	movs	r3, #10
   8d4ce:	469a      	mov	sl, r3
   8d4d0:	f1b8 0f00 	cmp.w	r8, #0
   8d4d4:	bf14      	ite	ne
   8d4d6:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
   8d4da:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   8d4de:	fbb0 f9fa 	udiv	r9, r0, sl
   8d4e2:	2700      	movs	r7, #0
   8d4e4:	46bc      	mov	ip, r7
   8d4e6:	fb0a 0019 	mls	r0, sl, r9, r0
   8d4ea:	e00c      	b.n	8d506 <_strtol_r+0x7e>
   8d4ec:	3d30      	subs	r5, #48	; 0x30
   8d4ee:	42ab      	cmp	r3, r5
   8d4f0:	dd19      	ble.n	8d526 <_strtol_r+0x9e>
   8d4f2:	1c7e      	adds	r6, r7, #1
   8d4f4:	d005      	beq.n	8d502 <_strtol_r+0x7a>
   8d4f6:	45cc      	cmp	ip, r9
   8d4f8:	d824      	bhi.n	8d544 <_strtol_r+0xbc>
   8d4fa:	d021      	beq.n	8d540 <_strtol_r+0xb8>
   8d4fc:	fb0a 5c0c 	mla	ip, sl, ip, r5
   8d500:	2701      	movs	r7, #1
   8d502:	f814 5b01 	ldrb.w	r5, [r4], #1
   8d506:	eb0e 0605 	add.w	r6, lr, r5
   8d50a:	7876      	ldrb	r6, [r6, #1]
   8d50c:	f016 0f04 	tst.w	r6, #4
   8d510:	d1ec      	bne.n	8d4ec <_strtol_r+0x64>
   8d512:	f016 0603 	ands.w	r6, r6, #3
   8d516:	d006      	beq.n	8d526 <_strtol_r+0x9e>
   8d518:	2e01      	cmp	r6, #1
   8d51a:	bf0c      	ite	eq
   8d51c:	2637      	moveq	r6, #55	; 0x37
   8d51e:	2657      	movne	r6, #87	; 0x57
   8d520:	1bad      	subs	r5, r5, r6
   8d522:	42ab      	cmp	r3, r5
   8d524:	dce5      	bgt.n	8d4f2 <_strtol_r+0x6a>
   8d526:	1c7b      	adds	r3, r7, #1
   8d528:	d016      	beq.n	8d558 <_strtol_r+0xd0>
   8d52a:	f1c8 0000 	rsb	r0, r8, #0
   8d52e:	ea8c 0000 	eor.w	r0, ip, r0
   8d532:	4440      	add	r0, r8
   8d534:	b14a      	cbz	r2, 8d54a <_strtol_r+0xc2>
   8d536:	b107      	cbz	r7, 8d53a <_strtol_r+0xb2>
   8d538:	1e61      	subs	r1, r4, #1
   8d53a:	6011      	str	r1, [r2, #0]
   8d53c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8d540:	4285      	cmp	r5, r0
   8d542:	dddb      	ble.n	8d4fc <_strtol_r+0x74>
   8d544:	f04f 37ff 	mov.w	r7, #4294967295
   8d548:	e7db      	b.n	8d502 <_strtol_r+0x7a>
   8d54a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8d54e:	1cb4      	adds	r4, r6, #2
   8d550:	7875      	ldrb	r5, [r6, #1]
   8d552:	f04f 0801 	mov.w	r8, #1
   8d556:	e7b2      	b.n	8d4be <_strtol_r+0x36>
   8d558:	f1b8 0f00 	cmp.w	r8, #0
   8d55c:	f04f 0322 	mov.w	r3, #34	; 0x22
   8d560:	bf14      	ite	ne
   8d562:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
   8d566:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   8d56a:	f8cb 3000 	str.w	r3, [fp]
   8d56e:	2a00      	cmp	r2, #0
   8d570:	d1e2      	bne.n	8d538 <_strtol_r+0xb0>
   8d572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8d576:	7823      	ldrb	r3, [r4, #0]
   8d578:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   8d57c:	2b58      	cmp	r3, #88	; 0x58
   8d57e:	d009      	beq.n	8d594 <_strtol_r+0x10c>
   8d580:	2308      	movs	r3, #8
   8d582:	469a      	mov	sl, r3
   8d584:	e7a4      	b.n	8d4d0 <_strtol_r+0x48>
   8d586:	2d30      	cmp	r5, #48	; 0x30
   8d588:	d19c      	bne.n	8d4c4 <_strtol_r+0x3c>
   8d58a:	7820      	ldrb	r0, [r4, #0]
   8d58c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   8d590:	2858      	cmp	r0, #88	; 0x58
   8d592:	d197      	bne.n	8d4c4 <_strtol_r+0x3c>
   8d594:	f04f 0a10 	mov.w	sl, #16
   8d598:	7865      	ldrb	r5, [r4, #1]
   8d59a:	4653      	mov	r3, sl
   8d59c:	3402      	adds	r4, #2
   8d59e:	e797      	b.n	8d4d0 <_strtol_r+0x48>
   8d5a0:	2000088c 	.word	0x2000088c

0008d5a4 <strtol>:
   8d5a4:	b430      	push	{r4, r5}
   8d5a6:	460d      	mov	r5, r1
   8d5a8:	4c03      	ldr	r4, [pc, #12]	; (8d5b8 <strtol+0x14>)
   8d5aa:	4613      	mov	r3, r2
   8d5ac:	4601      	mov	r1, r0
   8d5ae:	462a      	mov	r2, r5
   8d5b0:	6820      	ldr	r0, [r4, #0]
   8d5b2:	bc30      	pop	{r4, r5}
   8d5b4:	f7ff bf68 	b.w	8d488 <_strtol_r>
   8d5b8:	20000478 	.word	0x20000478

0008d5bc <_svfprintf_r>:
   8d5bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8d5c0:	b0c1      	sub	sp, #260	; 0x104
   8d5c2:	4689      	mov	r9, r1
   8d5c4:	920a      	str	r2, [sp, #40]	; 0x28
   8d5c6:	930e      	str	r3, [sp, #56]	; 0x38
   8d5c8:	9008      	str	r0, [sp, #32]
   8d5ca:	f002 fba7 	bl	8fd1c <_localeconv_r>
   8d5ce:	6803      	ldr	r3, [r0, #0]
   8d5d0:	4618      	mov	r0, r3
   8d5d2:	9317      	str	r3, [sp, #92]	; 0x5c
   8d5d4:	f7ff fee0 	bl	8d398 <strlen>
   8d5d8:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   8d5dc:	9018      	str	r0, [sp, #96]	; 0x60
   8d5de:	061c      	lsls	r4, r3, #24
   8d5e0:	d504      	bpl.n	8d5ec <_svfprintf_r+0x30>
   8d5e2:	f8d9 3010 	ldr.w	r3, [r9, #16]
   8d5e6:	2b00      	cmp	r3, #0
   8d5e8:	f001 80c2 	beq.w	8e770 <_svfprintf_r+0x11b4>
   8d5ec:	af30      	add	r7, sp, #192	; 0xc0
   8d5ee:	463c      	mov	r4, r7
   8d5f0:	464e      	mov	r6, r9
   8d5f2:	2300      	movs	r3, #0
   8d5f4:	9313      	str	r3, [sp, #76]	; 0x4c
   8d5f6:	9316      	str	r3, [sp, #88]	; 0x58
   8d5f8:	9319      	str	r3, [sp, #100]	; 0x64
   8d5fa:	930b      	str	r3, [sp, #44]	; 0x2c
   8d5fc:	9325      	str	r3, [sp, #148]	; 0x94
   8d5fe:	9324      	str	r3, [sp, #144]	; 0x90
   8d600:	9723      	str	r7, [sp, #140]	; 0x8c
   8d602:	9314      	str	r3, [sp, #80]	; 0x50
   8d604:	9315      	str	r3, [sp, #84]	; 0x54
   8d606:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   8d608:	782b      	ldrb	r3, [r5, #0]
   8d60a:	2b00      	cmp	r3, #0
   8d60c:	f000 80a9 	beq.w	8d762 <_svfprintf_r+0x1a6>
   8d610:	2b25      	cmp	r3, #37	; 0x25
   8d612:	d102      	bne.n	8d61a <_svfprintf_r+0x5e>
   8d614:	e0a5      	b.n	8d762 <_svfprintf_r+0x1a6>
   8d616:	2b25      	cmp	r3, #37	; 0x25
   8d618:	d003      	beq.n	8d622 <_svfprintf_r+0x66>
   8d61a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   8d61e:	2b00      	cmp	r3, #0
   8d620:	d1f9      	bne.n	8d616 <_svfprintf_r+0x5a>
   8d622:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8d624:	1aeb      	subs	r3, r5, r3
   8d626:	b173      	cbz	r3, 8d646 <_svfprintf_r+0x8a>
   8d628:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8d62a:	9925      	ldr	r1, [sp, #148]	; 0x94
   8d62c:	3201      	adds	r2, #1
   8d62e:	980a      	ldr	r0, [sp, #40]	; 0x28
   8d630:	4419      	add	r1, r3
   8d632:	2a07      	cmp	r2, #7
   8d634:	e884 0009 	stmia.w	r4, {r0, r3}
   8d638:	9125      	str	r1, [sp, #148]	; 0x94
   8d63a:	9224      	str	r2, [sp, #144]	; 0x90
   8d63c:	dc72      	bgt.n	8d724 <_svfprintf_r+0x168>
   8d63e:	3408      	adds	r4, #8
   8d640:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   8d642:	441a      	add	r2, r3
   8d644:	920b      	str	r2, [sp, #44]	; 0x2c
   8d646:	782b      	ldrb	r3, [r5, #0]
   8d648:	2b00      	cmp	r3, #0
   8d64a:	f000 87e2 	beq.w	8e612 <_svfprintf_r+0x1056>
   8d64e:	2300      	movs	r3, #0
   8d650:	461a      	mov	r2, r3
   8d652:	1c69      	adds	r1, r5, #1
   8d654:	786d      	ldrb	r5, [r5, #1]
   8d656:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   8d65a:	930c      	str	r3, [sp, #48]	; 0x30
   8d65c:	9307      	str	r3, [sp, #28]
   8d65e:	f04f 3aff 	mov.w	sl, #4294967295
   8d662:	1c4b      	adds	r3, r1, #1
   8d664:	f1a5 0120 	sub.w	r1, r5, #32
   8d668:	2958      	cmp	r1, #88	; 0x58
   8d66a:	f200 83ea 	bhi.w	8de42 <_svfprintf_r+0x886>
   8d66e:	e8df f011 	tbh	[pc, r1, lsl #1]
   8d672:	026d      	.short	0x026d
   8d674:	03e803e8 	.word	0x03e803e8
   8d678:	03e802d1 	.word	0x03e802d1
   8d67c:	03e803e8 	.word	0x03e803e8
   8d680:	03e803e8 	.word	0x03e803e8
   8d684:	02bc03e8 	.word	0x02bc03e8
   8d688:	03e8020d 	.word	0x03e8020d
   8d68c:	021101f4 	.word	0x021101f4
   8d690:	02d803e8 	.word	0x02d803e8
   8d694:	027b027b 	.word	0x027b027b
   8d698:	027b027b 	.word	0x027b027b
   8d69c:	027b027b 	.word	0x027b027b
   8d6a0:	027b027b 	.word	0x027b027b
   8d6a4:	03e8027b 	.word	0x03e8027b
   8d6a8:	03e803e8 	.word	0x03e803e8
   8d6ac:	03e803e8 	.word	0x03e803e8
   8d6b0:	03e803e8 	.word	0x03e803e8
   8d6b4:	03e803e8 	.word	0x03e803e8
   8d6b8:	028a03e8 	.word	0x028a03e8
   8d6bc:	03e802df 	.word	0x03e802df
   8d6c0:	03e802df 	.word	0x03e802df
   8d6c4:	03e803e8 	.word	0x03e803e8
   8d6c8:	03cb03e8 	.word	0x03cb03e8
   8d6cc:	03e803e8 	.word	0x03e803e8
   8d6d0:	03e8032f 	.word	0x03e8032f
   8d6d4:	03e803e8 	.word	0x03e803e8
   8d6d8:	03e803e8 	.word	0x03e803e8
   8d6dc:	03e8034d 	.word	0x03e8034d
   8d6e0:	036703e8 	.word	0x036703e8
   8d6e4:	03e803e8 	.word	0x03e803e8
   8d6e8:	03e803e8 	.word	0x03e803e8
   8d6ec:	03e803e8 	.word	0x03e803e8
   8d6f0:	03e803e8 	.word	0x03e803e8
   8d6f4:	03e803e8 	.word	0x03e803e8
   8d6f8:	022b0382 	.word	0x022b0382
   8d6fc:	02df02df 	.word	0x02df02df
   8d700:	02ca02df 	.word	0x02ca02df
   8d704:	03e8022b 	.word	0x03e8022b
   8d708:	02b203e8 	.word	0x02b203e8
   8d70c:	03d203e8 	.word	0x03d203e8
   8d710:	031901fb 	.word	0x031901fb
   8d714:	03e80274 	.word	0x03e80274
   8d718:	03e803a3 	.word	0x03e803a3
   8d71c:	03e8007a 	.word	0x03e8007a
   8d720:	024703e8 	.word	0x024703e8
   8d724:	9808      	ldr	r0, [sp, #32]
   8d726:	4631      	mov	r1, r6
   8d728:	aa23      	add	r2, sp, #140	; 0x8c
   8d72a:	9307      	str	r3, [sp, #28]
   8d72c:	f002 fe42 	bl	903b4 <__ssprint_r>
   8d730:	b950      	cbnz	r0, 8d748 <_svfprintf_r+0x18c>
   8d732:	463c      	mov	r4, r7
   8d734:	9b07      	ldr	r3, [sp, #28]
   8d736:	e783      	b.n	8d640 <_svfprintf_r+0x84>
   8d738:	9808      	ldr	r0, [sp, #32]
   8d73a:	4631      	mov	r1, r6
   8d73c:	aa23      	add	r2, sp, #140	; 0x8c
   8d73e:	f002 fe39 	bl	903b4 <__ssprint_r>
   8d742:	2800      	cmp	r0, #0
   8d744:	f000 8185 	beq.w	8da52 <_svfprintf_r+0x496>
   8d748:	46b1      	mov	r9, r6
   8d74a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   8d74e:	f013 0f40 	tst.w	r3, #64	; 0x40
   8d752:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   8d754:	bf18      	it	ne
   8d756:	f04f 33ff 	movne.w	r3, #4294967295
   8d75a:	4618      	mov	r0, r3
   8d75c:	b041      	add	sp, #260	; 0x104
   8d75e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8d762:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   8d764:	e76f      	b.n	8d646 <_svfprintf_r+0x8a>
   8d766:	930a      	str	r3, [sp, #40]	; 0x28
   8d768:	9b07      	ldr	r3, [sp, #28]
   8d76a:	0698      	lsls	r0, r3, #26
   8d76c:	f140 82d7 	bpl.w	8dd1e <_svfprintf_r+0x762>
   8d770:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8d772:	f103 0907 	add.w	r9, r3, #7
   8d776:	f029 0307 	bic.w	r3, r9, #7
   8d77a:	f103 0208 	add.w	r2, r3, #8
   8d77e:	e9d3 8900 	ldrd	r8, r9, [r3]
   8d782:	920e      	str	r2, [sp, #56]	; 0x38
   8d784:	2301      	movs	r3, #1
   8d786:	2200      	movs	r2, #0
   8d788:	4694      	mov	ip, r2
   8d78a:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
   8d78e:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8d792:	f1ba 0f00 	cmp.w	sl, #0
   8d796:	db03      	blt.n	8d7a0 <_svfprintf_r+0x1e4>
   8d798:	9a07      	ldr	r2, [sp, #28]
   8d79a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   8d79e:	9207      	str	r2, [sp, #28]
   8d7a0:	ea58 0209 	orrs.w	r2, r8, r9
   8d7a4:	f040 836f 	bne.w	8de86 <_svfprintf_r+0x8ca>
   8d7a8:	f1ba 0f00 	cmp.w	sl, #0
   8d7ac:	f000 8474 	beq.w	8e098 <_svfprintf_r+0xadc>
   8d7b0:	2b01      	cmp	r3, #1
   8d7b2:	f000 8372 	beq.w	8de9a <_svfprintf_r+0x8de>
   8d7b6:	2b02      	cmp	r3, #2
   8d7b8:	f000 84c2 	beq.w	8e140 <_svfprintf_r+0xb84>
   8d7bc:	4639      	mov	r1, r7
   8d7be:	ea4f 02d8 	mov.w	r2, r8, lsr #3
   8d7c2:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
   8d7c6:	ea4f 00d9 	mov.w	r0, r9, lsr #3
   8d7ca:	f008 0307 	and.w	r3, r8, #7
   8d7ce:	4681      	mov	r9, r0
   8d7d0:	4690      	mov	r8, r2
   8d7d2:	3330      	adds	r3, #48	; 0x30
   8d7d4:	ea58 0209 	orrs.w	r2, r8, r9
   8d7d8:	f801 3d01 	strb.w	r3, [r1, #-1]!
   8d7dc:	d1ef      	bne.n	8d7be <_svfprintf_r+0x202>
   8d7de:	9a07      	ldr	r2, [sp, #28]
   8d7e0:	9110      	str	r1, [sp, #64]	; 0x40
   8d7e2:	07d2      	lsls	r2, r2, #31
   8d7e4:	f100 857f 	bmi.w	8e2e6 <_svfprintf_r+0xd2a>
   8d7e8:	1a7b      	subs	r3, r7, r1
   8d7ea:	930d      	str	r3, [sp, #52]	; 0x34
   8d7ec:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   8d7ee:	4653      	mov	r3, sl
   8d7f0:	4592      	cmp	sl, r2
   8d7f2:	bfb8      	it	lt
   8d7f4:	4613      	movlt	r3, r2
   8d7f6:	9309      	str	r3, [sp, #36]	; 0x24
   8d7f8:	2300      	movs	r3, #0
   8d7fa:	9312      	str	r3, [sp, #72]	; 0x48
   8d7fc:	f1bc 0f00 	cmp.w	ip, #0
   8d800:	d002      	beq.n	8d808 <_svfprintf_r+0x24c>
   8d802:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8d804:	3301      	adds	r3, #1
   8d806:	9309      	str	r3, [sp, #36]	; 0x24
   8d808:	9b07      	ldr	r3, [sp, #28]
   8d80a:	f013 0302 	ands.w	r3, r3, #2
   8d80e:	930f      	str	r3, [sp, #60]	; 0x3c
   8d810:	d002      	beq.n	8d818 <_svfprintf_r+0x25c>
   8d812:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8d814:	3302      	adds	r3, #2
   8d816:	9309      	str	r3, [sp, #36]	; 0x24
   8d818:	9b07      	ldr	r3, [sp, #28]
   8d81a:	f013 0984 	ands.w	r9, r3, #132	; 0x84
   8d81e:	f040 832f 	bne.w	8de80 <_svfprintf_r+0x8c4>
   8d822:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8d824:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8d826:	ebc2 0803 	rsb	r8, r2, r3
   8d82a:	f1b8 0f00 	cmp.w	r8, #0
   8d82e:	f340 8327 	ble.w	8de80 <_svfprintf_r+0x8c4>
   8d832:	f1b8 0f10 	cmp.w	r8, #16
   8d836:	9925      	ldr	r1, [sp, #148]	; 0x94
   8d838:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8d83a:	f8df a570 	ldr.w	sl, [pc, #1392]	; 8ddac <_svfprintf_r+0x7f0>
   8d83e:	dd29      	ble.n	8d894 <_svfprintf_r+0x2d8>
   8d840:	4653      	mov	r3, sl
   8d842:	f04f 0b10 	mov.w	fp, #16
   8d846:	46c2      	mov	sl, r8
   8d848:	46a8      	mov	r8, r5
   8d84a:	461d      	mov	r5, r3
   8d84c:	e006      	b.n	8d85c <_svfprintf_r+0x2a0>
   8d84e:	f1aa 0a10 	sub.w	sl, sl, #16
   8d852:	f1ba 0f10 	cmp.w	sl, #16
   8d856:	f104 0408 	add.w	r4, r4, #8
   8d85a:	dd17      	ble.n	8d88c <_svfprintf_r+0x2d0>
   8d85c:	3201      	adds	r2, #1
   8d85e:	3110      	adds	r1, #16
   8d860:	2a07      	cmp	r2, #7
   8d862:	9125      	str	r1, [sp, #148]	; 0x94
   8d864:	9224      	str	r2, [sp, #144]	; 0x90
   8d866:	e884 0820 	stmia.w	r4, {r5, fp}
   8d86a:	ddf0      	ble.n	8d84e <_svfprintf_r+0x292>
   8d86c:	9808      	ldr	r0, [sp, #32]
   8d86e:	4631      	mov	r1, r6
   8d870:	aa23      	add	r2, sp, #140	; 0x8c
   8d872:	f002 fd9f 	bl	903b4 <__ssprint_r>
   8d876:	2800      	cmp	r0, #0
   8d878:	f47f af66 	bne.w	8d748 <_svfprintf_r+0x18c>
   8d87c:	f1aa 0a10 	sub.w	sl, sl, #16
   8d880:	f1ba 0f10 	cmp.w	sl, #16
   8d884:	463c      	mov	r4, r7
   8d886:	9925      	ldr	r1, [sp, #148]	; 0x94
   8d888:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8d88a:	dce7      	bgt.n	8d85c <_svfprintf_r+0x2a0>
   8d88c:	462b      	mov	r3, r5
   8d88e:	4645      	mov	r5, r8
   8d890:	46d0      	mov	r8, sl
   8d892:	469a      	mov	sl, r3
   8d894:	3201      	adds	r2, #1
   8d896:	eb08 0b01 	add.w	fp, r8, r1
   8d89a:	2a07      	cmp	r2, #7
   8d89c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8d8a0:	9224      	str	r2, [sp, #144]	; 0x90
   8d8a2:	f8c4 a000 	str.w	sl, [r4]
   8d8a6:	f8c4 8004 	str.w	r8, [r4, #4]
   8d8aa:	f300 82de 	bgt.w	8de6a <_svfprintf_r+0x8ae>
   8d8ae:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8d8b2:	3408      	adds	r4, #8
   8d8b4:	f1bc 0f00 	cmp.w	ip, #0
   8d8b8:	d00f      	beq.n	8d8da <_svfprintf_r+0x31e>
   8d8ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8d8bc:	f10b 0b01 	add.w	fp, fp, #1
   8d8c0:	3301      	adds	r3, #1
   8d8c2:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
   8d8c6:	2201      	movs	r2, #1
   8d8c8:	2b07      	cmp	r3, #7
   8d8ca:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8d8ce:	9324      	str	r3, [sp, #144]	; 0x90
   8d8d0:	e884 0006 	stmia.w	r4, {r1, r2}
   8d8d4:	f300 83fd 	bgt.w	8e0d2 <_svfprintf_r+0xb16>
   8d8d8:	3408      	adds	r4, #8
   8d8da:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   8d8dc:	b173      	cbz	r3, 8d8fc <_svfprintf_r+0x340>
   8d8de:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8d8e0:	f10b 0b02 	add.w	fp, fp, #2
   8d8e4:	3301      	adds	r3, #1
   8d8e6:	a91c      	add	r1, sp, #112	; 0x70
   8d8e8:	2202      	movs	r2, #2
   8d8ea:	2b07      	cmp	r3, #7
   8d8ec:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8d8f0:	9324      	str	r3, [sp, #144]	; 0x90
   8d8f2:	e884 0006 	stmia.w	r4, {r1, r2}
   8d8f6:	f300 83f9 	bgt.w	8e0ec <_svfprintf_r+0xb30>
   8d8fa:	3408      	adds	r4, #8
   8d8fc:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
   8d900:	f000 8334 	beq.w	8df6c <_svfprintf_r+0x9b0>
   8d904:	9b11      	ldr	r3, [sp, #68]	; 0x44
   8d906:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   8d908:	ebc2 0a03 	rsb	sl, r2, r3
   8d90c:	f1ba 0f00 	cmp.w	sl, #0
   8d910:	dd3c      	ble.n	8d98c <_svfprintf_r+0x3d0>
   8d912:	f1ba 0f10 	cmp.w	sl, #16
   8d916:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8d918:	f8df 9494 	ldr.w	r9, [pc, #1172]	; 8ddb0 <_svfprintf_r+0x7f4>
   8d91c:	dd2b      	ble.n	8d976 <_svfprintf_r+0x3ba>
   8d91e:	4649      	mov	r1, r9
   8d920:	465b      	mov	r3, fp
   8d922:	46a9      	mov	r9, r5
   8d924:	f04f 0810 	mov.w	r8, #16
   8d928:	f8dd b020 	ldr.w	fp, [sp, #32]
   8d92c:	460d      	mov	r5, r1
   8d92e:	e006      	b.n	8d93e <_svfprintf_r+0x382>
   8d930:	f1aa 0a10 	sub.w	sl, sl, #16
   8d934:	f1ba 0f10 	cmp.w	sl, #16
   8d938:	f104 0408 	add.w	r4, r4, #8
   8d93c:	dd17      	ble.n	8d96e <_svfprintf_r+0x3b2>
   8d93e:	3201      	adds	r2, #1
   8d940:	3310      	adds	r3, #16
   8d942:	2a07      	cmp	r2, #7
   8d944:	9325      	str	r3, [sp, #148]	; 0x94
   8d946:	9224      	str	r2, [sp, #144]	; 0x90
   8d948:	e884 0120 	stmia.w	r4, {r5, r8}
   8d94c:	ddf0      	ble.n	8d930 <_svfprintf_r+0x374>
   8d94e:	4658      	mov	r0, fp
   8d950:	4631      	mov	r1, r6
   8d952:	aa23      	add	r2, sp, #140	; 0x8c
   8d954:	f002 fd2e 	bl	903b4 <__ssprint_r>
   8d958:	2800      	cmp	r0, #0
   8d95a:	f47f aef5 	bne.w	8d748 <_svfprintf_r+0x18c>
   8d95e:	f1aa 0a10 	sub.w	sl, sl, #16
   8d962:	f1ba 0f10 	cmp.w	sl, #16
   8d966:	463c      	mov	r4, r7
   8d968:	9b25      	ldr	r3, [sp, #148]	; 0x94
   8d96a:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8d96c:	dce7      	bgt.n	8d93e <_svfprintf_r+0x382>
   8d96e:	469b      	mov	fp, r3
   8d970:	462b      	mov	r3, r5
   8d972:	464d      	mov	r5, r9
   8d974:	4699      	mov	r9, r3
   8d976:	3201      	adds	r2, #1
   8d978:	44d3      	add	fp, sl
   8d97a:	2a07      	cmp	r2, #7
   8d97c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8d980:	9224      	str	r2, [sp, #144]	; 0x90
   8d982:	e884 0600 	stmia.w	r4, {r9, sl}
   8d986:	f300 8398 	bgt.w	8e0ba <_svfprintf_r+0xafe>
   8d98a:	3408      	adds	r4, #8
   8d98c:	9b07      	ldr	r3, [sp, #28]
   8d98e:	05d9      	lsls	r1, r3, #23
   8d990:	f100 828f 	bmi.w	8deb2 <_svfprintf_r+0x8f6>
   8d994:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8d996:	990d      	ldr	r1, [sp, #52]	; 0x34
   8d998:	3301      	adds	r3, #1
   8d99a:	9a10      	ldr	r2, [sp, #64]	; 0x40
   8d99c:	448b      	add	fp, r1
   8d99e:	2b07      	cmp	r3, #7
   8d9a0:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8d9a4:	6022      	str	r2, [r4, #0]
   8d9a6:	6061      	str	r1, [r4, #4]
   8d9a8:	9324      	str	r3, [sp, #144]	; 0x90
   8d9aa:	f300 83b8 	bgt.w	8e11e <_svfprintf_r+0xb62>
   8d9ae:	3408      	adds	r4, #8
   8d9b0:	9b07      	ldr	r3, [sp, #28]
   8d9b2:	075a      	lsls	r2, r3, #29
   8d9b4:	d541      	bpl.n	8da3a <_svfprintf_r+0x47e>
   8d9b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8d9b8:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8d9ba:	1a9d      	subs	r5, r3, r2
   8d9bc:	2d00      	cmp	r5, #0
   8d9be:	dd3c      	ble.n	8da3a <_svfprintf_r+0x47e>
   8d9c0:	2d10      	cmp	r5, #16
   8d9c2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8d9c4:	f8df a3e4 	ldr.w	sl, [pc, #996]	; 8ddac <_svfprintf_r+0x7f0>
   8d9c8:	dd23      	ble.n	8da12 <_svfprintf_r+0x456>
   8d9ca:	f04f 0810 	mov.w	r8, #16
   8d9ce:	465a      	mov	r2, fp
   8d9d0:	f8dd 9020 	ldr.w	r9, [sp, #32]
   8d9d4:	e004      	b.n	8d9e0 <_svfprintf_r+0x424>
   8d9d6:	3d10      	subs	r5, #16
   8d9d8:	2d10      	cmp	r5, #16
   8d9da:	f104 0408 	add.w	r4, r4, #8
   8d9de:	dd17      	ble.n	8da10 <_svfprintf_r+0x454>
   8d9e0:	3301      	adds	r3, #1
   8d9e2:	3210      	adds	r2, #16
   8d9e4:	2b07      	cmp	r3, #7
   8d9e6:	9225      	str	r2, [sp, #148]	; 0x94
   8d9e8:	9324      	str	r3, [sp, #144]	; 0x90
   8d9ea:	f8c4 a000 	str.w	sl, [r4]
   8d9ee:	f8c4 8004 	str.w	r8, [r4, #4]
   8d9f2:	ddf0      	ble.n	8d9d6 <_svfprintf_r+0x41a>
   8d9f4:	4648      	mov	r0, r9
   8d9f6:	4631      	mov	r1, r6
   8d9f8:	aa23      	add	r2, sp, #140	; 0x8c
   8d9fa:	f002 fcdb 	bl	903b4 <__ssprint_r>
   8d9fe:	2800      	cmp	r0, #0
   8da00:	f47f aea2 	bne.w	8d748 <_svfprintf_r+0x18c>
   8da04:	3d10      	subs	r5, #16
   8da06:	2d10      	cmp	r5, #16
   8da08:	463c      	mov	r4, r7
   8da0a:	9a25      	ldr	r2, [sp, #148]	; 0x94
   8da0c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8da0e:	dce7      	bgt.n	8d9e0 <_svfprintf_r+0x424>
   8da10:	4693      	mov	fp, r2
   8da12:	3301      	adds	r3, #1
   8da14:	44ab      	add	fp, r5
   8da16:	2b07      	cmp	r3, #7
   8da18:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8da1c:	9324      	str	r3, [sp, #144]	; 0x90
   8da1e:	f8c4 a000 	str.w	sl, [r4]
   8da22:	6065      	str	r5, [r4, #4]
   8da24:	dd09      	ble.n	8da3a <_svfprintf_r+0x47e>
   8da26:	9808      	ldr	r0, [sp, #32]
   8da28:	4631      	mov	r1, r6
   8da2a:	aa23      	add	r2, sp, #140	; 0x8c
   8da2c:	f002 fcc2 	bl	903b4 <__ssprint_r>
   8da30:	2800      	cmp	r0, #0
   8da32:	f47f ae89 	bne.w	8d748 <_svfprintf_r+0x18c>
   8da36:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8da3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   8da3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8da3e:	990c      	ldr	r1, [sp, #48]	; 0x30
   8da40:	428a      	cmp	r2, r1
   8da42:	bfac      	ite	ge
   8da44:	189b      	addge	r3, r3, r2
   8da46:	185b      	addlt	r3, r3, r1
   8da48:	930b      	str	r3, [sp, #44]	; 0x2c
   8da4a:	f1bb 0f00 	cmp.w	fp, #0
   8da4e:	f47f ae73 	bne.w	8d738 <_svfprintf_r+0x17c>
   8da52:	2300      	movs	r3, #0
   8da54:	9324      	str	r3, [sp, #144]	; 0x90
   8da56:	463c      	mov	r4, r7
   8da58:	e5d5      	b.n	8d606 <_svfprintf_r+0x4a>
   8da5a:	4619      	mov	r1, r3
   8da5c:	9807      	ldr	r0, [sp, #28]
   8da5e:	f040 0004 	orr.w	r0, r0, #4
   8da62:	9007      	str	r0, [sp, #28]
   8da64:	781d      	ldrb	r5, [r3, #0]
   8da66:	e5fc      	b.n	8d662 <_svfprintf_r+0xa6>
   8da68:	930a      	str	r3, [sp, #40]	; 0x28
   8da6a:	9b07      	ldr	r3, [sp, #28]
   8da6c:	f013 0320 	ands.w	r3, r3, #32
   8da70:	f000 8138 	beq.w	8dce4 <_svfprintf_r+0x728>
   8da74:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8da76:	f103 0907 	add.w	r9, r3, #7
   8da7a:	f029 0307 	bic.w	r3, r9, #7
   8da7e:	f103 0208 	add.w	r2, r3, #8
   8da82:	e9d3 8900 	ldrd	r8, r9, [r3]
   8da86:	920e      	str	r2, [sp, #56]	; 0x38
   8da88:	2300      	movs	r3, #0
   8da8a:	e67c      	b.n	8d786 <_svfprintf_r+0x1ca>
   8da8c:	781d      	ldrb	r5, [r3, #0]
   8da8e:	4619      	mov	r1, r3
   8da90:	222b      	movs	r2, #43	; 0x2b
   8da92:	e5e6      	b.n	8d662 <_svfprintf_r+0xa6>
   8da94:	781d      	ldrb	r5, [r3, #0]
   8da96:	1c59      	adds	r1, r3, #1
   8da98:	2d2a      	cmp	r5, #42	; 0x2a
   8da9a:	f000 87e5 	beq.w	8ea68 <_svfprintf_r+0x14ac>
   8da9e:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
   8daa2:	2809      	cmp	r0, #9
   8daa4:	460b      	mov	r3, r1
   8daa6:	f04f 0a00 	mov.w	sl, #0
   8daaa:	f63f addb 	bhi.w	8d664 <_svfprintf_r+0xa8>
   8daae:	f813 5b01 	ldrb.w	r5, [r3], #1
   8dab2:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
   8dab6:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
   8daba:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
   8dabe:	2809      	cmp	r0, #9
   8dac0:	d9f5      	bls.n	8daae <_svfprintf_r+0x4f2>
   8dac2:	ea4a 7aea 	orr.w	sl, sl, sl, asr #31
   8dac6:	e5cd      	b.n	8d664 <_svfprintf_r+0xa8>
   8dac8:	930a      	str	r3, [sp, #40]	; 0x28
   8daca:	9b07      	ldr	r3, [sp, #28]
   8dacc:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8dad0:	0698      	lsls	r0, r3, #26
   8dad2:	d562      	bpl.n	8db9a <_svfprintf_r+0x5de>
   8dad4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8dad6:	f103 0907 	add.w	r9, r3, #7
   8dada:	f029 0907 	bic.w	r9, r9, #7
   8dade:	e9d9 2300 	ldrd	r2, r3, [r9]
   8dae2:	f109 0108 	add.w	r1, r9, #8
   8dae6:	4690      	mov	r8, r2
   8dae8:	4699      	mov	r9, r3
   8daea:	910e      	str	r1, [sp, #56]	; 0x38
   8daec:	2a00      	cmp	r2, #0
   8daee:	f173 0300 	sbcs.w	r3, r3, #0
   8daf2:	db64      	blt.n	8dbbe <_svfprintf_r+0x602>
   8daf4:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8daf8:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
   8dafc:	2301      	movs	r3, #1
   8dafe:	e648      	b.n	8d792 <_svfprintf_r+0x1d6>
   8db00:	930a      	str	r3, [sp, #40]	; 0x28
   8db02:	4ba7      	ldr	r3, [pc, #668]	; (8dda0 <_svfprintf_r+0x7e4>)
   8db04:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8db08:	9316      	str	r3, [sp, #88]	; 0x58
   8db0a:	9b07      	ldr	r3, [sp, #28]
   8db0c:	069b      	lsls	r3, r3, #26
   8db0e:	f140 8120 	bpl.w	8dd52 <_svfprintf_r+0x796>
   8db12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8db14:	f103 0907 	add.w	r9, r3, #7
   8db18:	f029 0307 	bic.w	r3, r9, #7
   8db1c:	f103 0208 	add.w	r2, r3, #8
   8db20:	920e      	str	r2, [sp, #56]	; 0x38
   8db22:	e9d3 8900 	ldrd	r8, r9, [r3]
   8db26:	9b07      	ldr	r3, [sp, #28]
   8db28:	07d9      	lsls	r1, r3, #31
   8db2a:	f140 8122 	bpl.w	8dd72 <_svfprintf_r+0x7b6>
   8db2e:	ea58 0309 	orrs.w	r3, r8, r9
   8db32:	f000 811e 	beq.w	8dd72 <_svfprintf_r+0x7b6>
   8db36:	9a07      	ldr	r2, [sp, #28]
   8db38:	2330      	movs	r3, #48	; 0x30
   8db3a:	f042 0202 	orr.w	r2, r2, #2
   8db3e:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
   8db42:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
   8db46:	9207      	str	r2, [sp, #28]
   8db48:	2302      	movs	r3, #2
   8db4a:	e61c      	b.n	8d786 <_svfprintf_r+0x1ca>
   8db4c:	2a00      	cmp	r2, #0
   8db4e:	f040 84e5 	bne.w	8e51c <_svfprintf_r+0xf60>
   8db52:	781d      	ldrb	r5, [r3, #0]
   8db54:	4619      	mov	r1, r3
   8db56:	2220      	movs	r2, #32
   8db58:	e583      	b.n	8d662 <_svfprintf_r+0xa6>
   8db5a:	9907      	ldr	r1, [sp, #28]
   8db5c:	f041 0120 	orr.w	r1, r1, #32
   8db60:	9107      	str	r1, [sp, #28]
   8db62:	781d      	ldrb	r5, [r3, #0]
   8db64:	4619      	mov	r1, r3
   8db66:	e57c      	b.n	8d662 <_svfprintf_r+0xa6>
   8db68:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
   8db6c:	2100      	movs	r1, #0
   8db6e:	f813 5b01 	ldrb.w	r5, [r3], #1
   8db72:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   8db76:	eb00 0141 	add.w	r1, r0, r1, lsl #1
   8db7a:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
   8db7e:	2809      	cmp	r0, #9
   8db80:	d9f5      	bls.n	8db6e <_svfprintf_r+0x5b2>
   8db82:	910c      	str	r1, [sp, #48]	; 0x30
   8db84:	e56e      	b.n	8d664 <_svfprintf_r+0xa8>
   8db86:	930a      	str	r3, [sp, #40]	; 0x28
   8db88:	9b07      	ldr	r3, [sp, #28]
   8db8a:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8db8e:	f043 0310 	orr.w	r3, r3, #16
   8db92:	9307      	str	r3, [sp, #28]
   8db94:	9b07      	ldr	r3, [sp, #28]
   8db96:	0698      	lsls	r0, r3, #26
   8db98:	d49c      	bmi.n	8dad4 <_svfprintf_r+0x518>
   8db9a:	9b07      	ldr	r3, [sp, #28]
   8db9c:	06d9      	lsls	r1, r3, #27
   8db9e:	f140 84c1 	bpl.w	8e524 <_svfprintf_r+0xf68>
   8dba2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8dba4:	4613      	mov	r3, r2
   8dba6:	681b      	ldr	r3, [r3, #0]
   8dba8:	3204      	adds	r2, #4
   8dbaa:	920e      	str	r2, [sp, #56]	; 0x38
   8dbac:	ea4f 79e3 	mov.w	r9, r3, asr #31
   8dbb0:	461a      	mov	r2, r3
   8dbb2:	4698      	mov	r8, r3
   8dbb4:	464b      	mov	r3, r9
   8dbb6:	2a00      	cmp	r2, #0
   8dbb8:	f173 0300 	sbcs.w	r3, r3, #0
   8dbbc:	da9a      	bge.n	8daf4 <_svfprintf_r+0x538>
   8dbbe:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
   8dbc2:	f1d8 0800 	rsbs	r8, r8, #0
   8dbc6:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
   8dbca:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
   8dbce:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
   8dbd2:	2301      	movs	r3, #1
   8dbd4:	e5dd      	b.n	8d792 <_svfprintf_r+0x1d6>
   8dbd6:	781d      	ldrb	r5, [r3, #0]
   8dbd8:	9907      	ldr	r1, [sp, #28]
   8dbda:	2d6c      	cmp	r5, #108	; 0x6c
   8dbdc:	f000 8525 	beq.w	8e62a <_svfprintf_r+0x106e>
   8dbe0:	f041 0110 	orr.w	r1, r1, #16
   8dbe4:	9107      	str	r1, [sp, #28]
   8dbe6:	4619      	mov	r1, r3
   8dbe8:	e53b      	b.n	8d662 <_svfprintf_r+0xa6>
   8dbea:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   8dbec:	6829      	ldr	r1, [r5, #0]
   8dbee:	4608      	mov	r0, r1
   8dbf0:	910c      	str	r1, [sp, #48]	; 0x30
   8dbf2:	4629      	mov	r1, r5
   8dbf4:	2800      	cmp	r0, #0
   8dbf6:	f101 0104 	add.w	r1, r1, #4
   8dbfa:	f2c0 851d 	blt.w	8e638 <_svfprintf_r+0x107c>
   8dbfe:	910e      	str	r1, [sp, #56]	; 0x38
   8dc00:	781d      	ldrb	r5, [r3, #0]
   8dc02:	4619      	mov	r1, r3
   8dc04:	e52d      	b.n	8d662 <_svfprintf_r+0xa6>
   8dc06:	9907      	ldr	r1, [sp, #28]
   8dc08:	f041 0140 	orr.w	r1, r1, #64	; 0x40
   8dc0c:	9107      	str	r1, [sp, #28]
   8dc0e:	781d      	ldrb	r5, [r3, #0]
   8dc10:	4619      	mov	r1, r3
   8dc12:	e526      	b.n	8d662 <_svfprintf_r+0xa6>
   8dc14:	9907      	ldr	r1, [sp, #28]
   8dc16:	f041 0101 	orr.w	r1, r1, #1
   8dc1a:	9107      	str	r1, [sp, #28]
   8dc1c:	781d      	ldrb	r5, [r3, #0]
   8dc1e:	4619      	mov	r1, r3
   8dc20:	e51f      	b.n	8d662 <_svfprintf_r+0xa6>
   8dc22:	9907      	ldr	r1, [sp, #28]
   8dc24:	f041 0180 	orr.w	r1, r1, #128	; 0x80
   8dc28:	9107      	str	r1, [sp, #28]
   8dc2a:	781d      	ldrb	r5, [r3, #0]
   8dc2c:	4619      	mov	r1, r3
   8dc2e:	e518      	b.n	8d662 <_svfprintf_r+0xa6>
   8dc30:	930a      	str	r3, [sp, #40]	; 0x28
   8dc32:	9b07      	ldr	r3, [sp, #28]
   8dc34:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8dc38:	f013 0f08 	tst.w	r3, #8
   8dc3c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   8dc3e:	46d3      	mov	fp, sl
   8dc40:	f103 0907 	add.w	r9, r3, #7
   8dc44:	f000 8437 	beq.w	8e4b6 <_svfprintf_r+0xefa>
   8dc48:	f029 0307 	bic.w	r3, r9, #7
   8dc4c:	f103 0208 	add.w	r2, r3, #8
   8dc50:	920e      	str	r2, [sp, #56]	; 0x38
   8dc52:	681a      	ldr	r2, [r3, #0]
   8dc54:	685b      	ldr	r3, [r3, #4]
   8dc56:	9214      	str	r2, [sp, #80]	; 0x50
   8dc58:	9315      	str	r3, [sp, #84]	; 0x54
   8dc5a:	9915      	ldr	r1, [sp, #84]	; 0x54
   8dc5c:	9814      	ldr	r0, [sp, #80]	; 0x50
   8dc5e:	f7fd fec5 	bl	8b9ec <__fpclassifyd>
   8dc62:	2801      	cmp	r0, #1
   8dc64:	9915      	ldr	r1, [sp, #84]	; 0x54
   8dc66:	9814      	ldr	r0, [sp, #80]	; 0x50
   8dc68:	f040 840b 	bne.w	8e482 <_svfprintf_r+0xec6>
   8dc6c:	2200      	movs	r2, #0
   8dc6e:	2300      	movs	r3, #0
   8dc70:	f7fe fb92 	bl	8c398 <__aeabi_dcmplt>
   8dc74:	2800      	cmp	r0, #0
   8dc76:	f040 8639 	bne.w	8e8ec <_svfprintf_r+0x1330>
   8dc7a:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8dc7e:	9b07      	ldr	r3, [sp, #28]
   8dc80:	4a48      	ldr	r2, [pc, #288]	; (8dda4 <_svfprintf_r+0x7e8>)
   8dc82:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   8dc86:	9307      	str	r3, [sp, #28]
   8dc88:	4613      	mov	r3, r2
   8dc8a:	f8df e128 	ldr.w	lr, [pc, #296]	; 8ddb4 <_svfprintf_r+0x7f8>
   8dc8e:	2103      	movs	r1, #3
   8dc90:	2d47      	cmp	r5, #71	; 0x47
   8dc92:	bfd8      	it	le
   8dc94:	4673      	movle	r3, lr
   8dc96:	2000      	movs	r0, #0
   8dc98:	9109      	str	r1, [sp, #36]	; 0x24
   8dc9a:	9011      	str	r0, [sp, #68]	; 0x44
   8dc9c:	9310      	str	r3, [sp, #64]	; 0x40
   8dc9e:	910d      	str	r1, [sp, #52]	; 0x34
   8dca0:	9012      	str	r0, [sp, #72]	; 0x48
   8dca2:	e5ab      	b.n	8d7fc <_svfprintf_r+0x240>
   8dca4:	990e      	ldr	r1, [sp, #56]	; 0x38
   8dca6:	9807      	ldr	r0, [sp, #28]
   8dca8:	930a      	str	r3, [sp, #40]	; 0x28
   8dcaa:	2330      	movs	r3, #48	; 0x30
   8dcac:	680a      	ldr	r2, [r1, #0]
   8dcae:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
   8dcb2:	4b3b      	ldr	r3, [pc, #236]	; (8dda0 <_svfprintf_r+0x7e4>)
   8dcb4:	2578      	movs	r5, #120	; 0x78
   8dcb6:	f040 0002 	orr.w	r0, r0, #2
   8dcba:	3104      	adds	r1, #4
   8dcbc:	9316      	str	r3, [sp, #88]	; 0x58
   8dcbe:	9007      	str	r0, [sp, #28]
   8dcc0:	910e      	str	r1, [sp, #56]	; 0x38
   8dcc2:	4690      	mov	r8, r2
   8dcc4:	f04f 0900 	mov.w	r9, #0
   8dcc8:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
   8dccc:	2302      	movs	r3, #2
   8dcce:	e55a      	b.n	8d786 <_svfprintf_r+0x1ca>
   8dcd0:	930a      	str	r3, [sp, #40]	; 0x28
   8dcd2:	9b07      	ldr	r3, [sp, #28]
   8dcd4:	f043 0310 	orr.w	r3, r3, #16
   8dcd8:	9307      	str	r3, [sp, #28]
   8dcda:	9b07      	ldr	r3, [sp, #28]
   8dcdc:	f013 0320 	ands.w	r3, r3, #32
   8dce0:	f47f aec8 	bne.w	8da74 <_svfprintf_r+0x4b8>
   8dce4:	9a07      	ldr	r2, [sp, #28]
   8dce6:	f012 0210 	ands.w	r2, r2, #16
   8dcea:	f040 830a 	bne.w	8e302 <_svfprintf_r+0xd46>
   8dcee:	9b07      	ldr	r3, [sp, #28]
   8dcf0:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   8dcf4:	f000 8305 	beq.w	8e302 <_svfprintf_r+0xd46>
   8dcf8:	990e      	ldr	r1, [sp, #56]	; 0x38
   8dcfa:	4613      	mov	r3, r2
   8dcfc:	460a      	mov	r2, r1
   8dcfe:	3204      	adds	r2, #4
   8dd00:	f8b1 8000 	ldrh.w	r8, [r1]
   8dd04:	f04f 0900 	mov.w	r9, #0
   8dd08:	920e      	str	r2, [sp, #56]	; 0x38
   8dd0a:	e53c      	b.n	8d786 <_svfprintf_r+0x1ca>
   8dd0c:	930a      	str	r3, [sp, #40]	; 0x28
   8dd0e:	9b07      	ldr	r3, [sp, #28]
   8dd10:	f043 0310 	orr.w	r3, r3, #16
   8dd14:	9307      	str	r3, [sp, #28]
   8dd16:	9b07      	ldr	r3, [sp, #28]
   8dd18:	0698      	lsls	r0, r3, #26
   8dd1a:	f53f ad29 	bmi.w	8d770 <_svfprintf_r+0x1b4>
   8dd1e:	9b07      	ldr	r3, [sp, #28]
   8dd20:	06d9      	lsls	r1, r3, #27
   8dd22:	f100 82f7 	bmi.w	8e314 <_svfprintf_r+0xd58>
   8dd26:	9b07      	ldr	r3, [sp, #28]
   8dd28:	065a      	lsls	r2, r3, #25
   8dd2a:	f140 82f3 	bpl.w	8e314 <_svfprintf_r+0xd58>
   8dd2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8dd30:	f04f 0900 	mov.w	r9, #0
   8dd34:	f8b2 8000 	ldrh.w	r8, [r2]
   8dd38:	3204      	adds	r2, #4
   8dd3a:	2301      	movs	r3, #1
   8dd3c:	920e      	str	r2, [sp, #56]	; 0x38
   8dd3e:	e522      	b.n	8d786 <_svfprintf_r+0x1ca>
   8dd40:	930a      	str	r3, [sp, #40]	; 0x28
   8dd42:	4b19      	ldr	r3, [pc, #100]	; (8dda8 <_svfprintf_r+0x7ec>)
   8dd44:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8dd48:	9316      	str	r3, [sp, #88]	; 0x58
   8dd4a:	9b07      	ldr	r3, [sp, #28]
   8dd4c:	069b      	lsls	r3, r3, #26
   8dd4e:	f53f aee0 	bmi.w	8db12 <_svfprintf_r+0x556>
   8dd52:	9b07      	ldr	r3, [sp, #28]
   8dd54:	06d8      	lsls	r0, r3, #27
   8dd56:	f140 83bb 	bpl.w	8e4d0 <_svfprintf_r+0xf14>
   8dd5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8dd5c:	4613      	mov	r3, r2
   8dd5e:	681b      	ldr	r3, [r3, #0]
   8dd60:	3204      	adds	r2, #4
   8dd62:	4698      	mov	r8, r3
   8dd64:	9b07      	ldr	r3, [sp, #28]
   8dd66:	920e      	str	r2, [sp, #56]	; 0x38
   8dd68:	07d9      	lsls	r1, r3, #31
   8dd6a:	f04f 0900 	mov.w	r9, #0
   8dd6e:	f53f aede 	bmi.w	8db2e <_svfprintf_r+0x572>
   8dd72:	2302      	movs	r3, #2
   8dd74:	e507      	b.n	8d786 <_svfprintf_r+0x1ca>
   8dd76:	980e      	ldr	r0, [sp, #56]	; 0x38
   8dd78:	930a      	str	r3, [sp, #40]	; 0x28
   8dd7a:	6802      	ldr	r2, [r0, #0]
   8dd7c:	2300      	movs	r3, #0
   8dd7e:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
   8dd82:	4602      	mov	r2, r0
   8dd84:	2101      	movs	r1, #1
   8dd86:	469c      	mov	ip, r3
   8dd88:	3204      	adds	r2, #4
   8dd8a:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   8dd8e:	9311      	str	r3, [sp, #68]	; 0x44
   8dd90:	9312      	str	r3, [sp, #72]	; 0x48
   8dd92:	ab26      	add	r3, sp, #152	; 0x98
   8dd94:	9109      	str	r1, [sp, #36]	; 0x24
   8dd96:	920e      	str	r2, [sp, #56]	; 0x38
   8dd98:	910d      	str	r1, [sp, #52]	; 0x34
   8dd9a:	9310      	str	r3, [sp, #64]	; 0x40
   8dd9c:	e534      	b.n	8d808 <_svfprintf_r+0x24c>
   8dd9e:	bf00      	nop
   8dda0:	000921a4 	.word	0x000921a4
   8dda4:	00092184 	.word	0x00092184
   8dda8:	00092190 	.word	0x00092190
   8ddac:	00092170 	.word	0x00092170
   8ddb0:	00092160 	.word	0x00092160
   8ddb4:	00092180 	.word	0x00092180
   8ddb8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8ddba:	930a      	str	r3, [sp, #40]	; 0x28
   8ddbc:	6813      	ldr	r3, [r2, #0]
   8ddbe:	f04f 0b00 	mov.w	fp, #0
   8ddc2:	9310      	str	r3, [sp, #64]	; 0x40
   8ddc4:	f88d b06f 	strb.w	fp, [sp, #111]	; 0x6f
   8ddc8:	f102 0904 	add.w	r9, r2, #4
   8ddcc:	2b00      	cmp	r3, #0
   8ddce:	f000 8558 	beq.w	8e882 <_svfprintf_r+0x12c6>
   8ddd2:	f1ba 0f00 	cmp.w	sl, #0
   8ddd6:	9810      	ldr	r0, [sp, #64]	; 0x40
   8ddd8:	f2c0 84ea 	blt.w	8e7b0 <_svfprintf_r+0x11f4>
   8dddc:	4659      	mov	r1, fp
   8ddde:	4652      	mov	r2, sl
   8dde0:	f001 ffa0 	bl	8fd24 <memchr>
   8dde4:	2800      	cmp	r0, #0
   8dde6:	f000 8589 	beq.w	8e8fc <_svfprintf_r+0x1340>
   8ddea:	9b10      	ldr	r3, [sp, #64]	; 0x40
   8ddec:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
   8ddf0:	1ac3      	subs	r3, r0, r3
   8ddf2:	930d      	str	r3, [sp, #52]	; 0x34
   8ddf4:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
   8ddf8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8ddfc:	9309      	str	r3, [sp, #36]	; 0x24
   8ddfe:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
   8de02:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8de06:	e4f9      	b.n	8d7fc <_svfprintf_r+0x240>
   8de08:	9907      	ldr	r1, [sp, #28]
   8de0a:	f041 0108 	orr.w	r1, r1, #8
   8de0e:	9107      	str	r1, [sp, #28]
   8de10:	781d      	ldrb	r5, [r3, #0]
   8de12:	4619      	mov	r1, r3
   8de14:	e425      	b.n	8d662 <_svfprintf_r+0xa6>
   8de16:	930a      	str	r3, [sp, #40]	; 0x28
   8de18:	9b07      	ldr	r3, [sp, #28]
   8de1a:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8de1e:	069a      	lsls	r2, r3, #26
   8de20:	f140 8365 	bpl.w	8e4ee <_svfprintf_r+0xf32>
   8de24:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8de26:	4613      	mov	r3, r2
   8de28:	3304      	adds	r3, #4
   8de2a:	930e      	str	r3, [sp, #56]	; 0x38
   8de2c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   8de2e:	6811      	ldr	r1, [r2, #0]
   8de30:	ea4f 79e3 	mov.w	r9, r3, asr #31
   8de34:	461a      	mov	r2, r3
   8de36:	4698      	mov	r8, r3
   8de38:	464b      	mov	r3, r9
   8de3a:	e9c1 2300 	strd	r2, r3, [r1]
   8de3e:	f7ff bbe2 	b.w	8d606 <_svfprintf_r+0x4a>
   8de42:	930a      	str	r3, [sp, #40]	; 0x28
   8de44:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   8de48:	2d00      	cmp	r5, #0
   8de4a:	f000 83e2 	beq.w	8e612 <_svfprintf_r+0x1056>
   8de4e:	2300      	movs	r3, #0
   8de50:	2201      	movs	r2, #1
   8de52:	469c      	mov	ip, r3
   8de54:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   8de58:	9311      	str	r3, [sp, #68]	; 0x44
   8de5a:	9312      	str	r3, [sp, #72]	; 0x48
   8de5c:	ab26      	add	r3, sp, #152	; 0x98
   8de5e:	9209      	str	r2, [sp, #36]	; 0x24
   8de60:	f88d 5098 	strb.w	r5, [sp, #152]	; 0x98
   8de64:	920d      	str	r2, [sp, #52]	; 0x34
   8de66:	9310      	str	r3, [sp, #64]	; 0x40
   8de68:	e4ce      	b.n	8d808 <_svfprintf_r+0x24c>
   8de6a:	9808      	ldr	r0, [sp, #32]
   8de6c:	4631      	mov	r1, r6
   8de6e:	aa23      	add	r2, sp, #140	; 0x8c
   8de70:	f002 faa0 	bl	903b4 <__ssprint_r>
   8de74:	2800      	cmp	r0, #0
   8de76:	f47f ac67 	bne.w	8d748 <_svfprintf_r+0x18c>
   8de7a:	463c      	mov	r4, r7
   8de7c:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8de80:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8de84:	e516      	b.n	8d8b4 <_svfprintf_r+0x2f8>
   8de86:	2b01      	cmp	r3, #1
   8de88:	f47f ac95 	bne.w	8d7b6 <_svfprintf_r+0x1fa>
   8de8c:	f1b9 0f00 	cmp.w	r9, #0
   8de90:	bf08      	it	eq
   8de92:	f1b8 0f0a 	cmpeq.w	r8, #10
   8de96:	f080 8206 	bcs.w	8e2a6 <_svfprintf_r+0xcea>
   8de9a:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
   8de9e:	f108 0830 	add.w	r8, r8, #48	; 0x30
   8dea2:	f80b 8d41 	strb.w	r8, [fp, #-65]!
   8dea6:	ebcb 0307 	rsb	r3, fp, r7
   8deaa:	930d      	str	r3, [sp, #52]	; 0x34
   8deac:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
   8deb0:	e49c      	b.n	8d7ec <_svfprintf_r+0x230>
   8deb2:	2d65      	cmp	r5, #101	; 0x65
   8deb4:	f340 80a0 	ble.w	8dff8 <_svfprintf_r+0xa3c>
   8deb8:	9814      	ldr	r0, [sp, #80]	; 0x50
   8deba:	9915      	ldr	r1, [sp, #84]	; 0x54
   8debc:	2200      	movs	r2, #0
   8debe:	2300      	movs	r3, #0
   8dec0:	f7fe fa60 	bl	8c384 <__aeabi_dcmpeq>
   8dec4:	2800      	cmp	r0, #0
   8dec6:	f000 8154 	beq.w	8e172 <_svfprintf_r+0xbb6>
   8deca:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8decc:	49c1      	ldr	r1, [pc, #772]	; (8e1d4 <_svfprintf_r+0xc18>)
   8dece:	3301      	adds	r3, #1
   8ded0:	f10b 0b01 	add.w	fp, fp, #1
   8ded4:	2201      	movs	r2, #1
   8ded6:	2b07      	cmp	r3, #7
   8ded8:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8dedc:	9324      	str	r3, [sp, #144]	; 0x90
   8dede:	e884 0006 	stmia.w	r4, {r1, r2}
   8dee2:	f300 833e 	bgt.w	8e562 <_svfprintf_r+0xfa6>
   8dee6:	3408      	adds	r4, #8
   8dee8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8deea:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8deec:	4293      	cmp	r3, r2
   8deee:	db03      	blt.n	8def8 <_svfprintf_r+0x93c>
   8def0:	9b07      	ldr	r3, [sp, #28]
   8def2:	07da      	lsls	r2, r3, #31
   8def4:	f57f ad5c 	bpl.w	8d9b0 <_svfprintf_r+0x3f4>
   8def8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8defa:	9918      	ldr	r1, [sp, #96]	; 0x60
   8defc:	3301      	adds	r3, #1
   8defe:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   8df00:	448b      	add	fp, r1
   8df02:	2b07      	cmp	r3, #7
   8df04:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8df08:	6022      	str	r2, [r4, #0]
   8df0a:	6061      	str	r1, [r4, #4]
   8df0c:	9324      	str	r3, [sp, #144]	; 0x90
   8df0e:	f300 841a 	bgt.w	8e746 <_svfprintf_r+0x118a>
   8df12:	3408      	adds	r4, #8
   8df14:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8df16:	1e5d      	subs	r5, r3, #1
   8df18:	2d00      	cmp	r5, #0
   8df1a:	f77f ad49 	ble.w	8d9b0 <_svfprintf_r+0x3f4>
   8df1e:	2d10      	cmp	r5, #16
   8df20:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8df22:	f8df 92b4 	ldr.w	r9, [pc, #692]	; 8e1d8 <_svfprintf_r+0xc1c>
   8df26:	f340 80ef 	ble.w	8e108 <_svfprintf_r+0xb4c>
   8df2a:	f04f 0810 	mov.w	r8, #16
   8df2e:	465a      	mov	r2, fp
   8df30:	f8dd a020 	ldr.w	sl, [sp, #32]
   8df34:	e004      	b.n	8df40 <_svfprintf_r+0x984>
   8df36:	3408      	adds	r4, #8
   8df38:	3d10      	subs	r5, #16
   8df3a:	2d10      	cmp	r5, #16
   8df3c:	f340 80e3 	ble.w	8e106 <_svfprintf_r+0xb4a>
   8df40:	3301      	adds	r3, #1
   8df42:	3210      	adds	r2, #16
   8df44:	2b07      	cmp	r3, #7
   8df46:	9225      	str	r2, [sp, #148]	; 0x94
   8df48:	9324      	str	r3, [sp, #144]	; 0x90
   8df4a:	f8c4 9000 	str.w	r9, [r4]
   8df4e:	f8c4 8004 	str.w	r8, [r4, #4]
   8df52:	ddf0      	ble.n	8df36 <_svfprintf_r+0x97a>
   8df54:	4650      	mov	r0, sl
   8df56:	4631      	mov	r1, r6
   8df58:	aa23      	add	r2, sp, #140	; 0x8c
   8df5a:	f002 fa2b 	bl	903b4 <__ssprint_r>
   8df5e:	2800      	cmp	r0, #0
   8df60:	f47f abf2 	bne.w	8d748 <_svfprintf_r+0x18c>
   8df64:	463c      	mov	r4, r7
   8df66:	9a25      	ldr	r2, [sp, #148]	; 0x94
   8df68:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8df6a:	e7e5      	b.n	8df38 <_svfprintf_r+0x97c>
   8df6c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8df6e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8df70:	ebc2 0a03 	rsb	sl, r2, r3
   8df74:	f1ba 0f00 	cmp.w	sl, #0
   8df78:	f77f acc4 	ble.w	8d904 <_svfprintf_r+0x348>
   8df7c:	f1ba 0f10 	cmp.w	sl, #16
   8df80:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8df82:	f8df 9254 	ldr.w	r9, [pc, #596]	; 8e1d8 <_svfprintf_r+0xc1c>
   8df86:	dd2b      	ble.n	8dfe0 <_svfprintf_r+0xa24>
   8df88:	4649      	mov	r1, r9
   8df8a:	465b      	mov	r3, fp
   8df8c:	46a9      	mov	r9, r5
   8df8e:	f04f 0810 	mov.w	r8, #16
   8df92:	f8dd b020 	ldr.w	fp, [sp, #32]
   8df96:	460d      	mov	r5, r1
   8df98:	e006      	b.n	8dfa8 <_svfprintf_r+0x9ec>
   8df9a:	f1aa 0a10 	sub.w	sl, sl, #16
   8df9e:	f1ba 0f10 	cmp.w	sl, #16
   8dfa2:	f104 0408 	add.w	r4, r4, #8
   8dfa6:	dd17      	ble.n	8dfd8 <_svfprintf_r+0xa1c>
   8dfa8:	3201      	adds	r2, #1
   8dfaa:	3310      	adds	r3, #16
   8dfac:	2a07      	cmp	r2, #7
   8dfae:	9325      	str	r3, [sp, #148]	; 0x94
   8dfb0:	9224      	str	r2, [sp, #144]	; 0x90
   8dfb2:	e884 0120 	stmia.w	r4, {r5, r8}
   8dfb6:	ddf0      	ble.n	8df9a <_svfprintf_r+0x9de>
   8dfb8:	4658      	mov	r0, fp
   8dfba:	4631      	mov	r1, r6
   8dfbc:	aa23      	add	r2, sp, #140	; 0x8c
   8dfbe:	f002 f9f9 	bl	903b4 <__ssprint_r>
   8dfc2:	2800      	cmp	r0, #0
   8dfc4:	f47f abc0 	bne.w	8d748 <_svfprintf_r+0x18c>
   8dfc8:	f1aa 0a10 	sub.w	sl, sl, #16
   8dfcc:	f1ba 0f10 	cmp.w	sl, #16
   8dfd0:	463c      	mov	r4, r7
   8dfd2:	9b25      	ldr	r3, [sp, #148]	; 0x94
   8dfd4:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8dfd6:	dce7      	bgt.n	8dfa8 <_svfprintf_r+0x9ec>
   8dfd8:	469b      	mov	fp, r3
   8dfda:	462b      	mov	r3, r5
   8dfdc:	464d      	mov	r5, r9
   8dfde:	4699      	mov	r9, r3
   8dfe0:	3201      	adds	r2, #1
   8dfe2:	44d3      	add	fp, sl
   8dfe4:	2a07      	cmp	r2, #7
   8dfe6:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8dfea:	9224      	str	r2, [sp, #144]	; 0x90
   8dfec:	e884 0600 	stmia.w	r4, {r9, sl}
   8dff0:	f300 823a 	bgt.w	8e468 <_svfprintf_r+0xeac>
   8dff4:	3408      	adds	r4, #8
   8dff6:	e485      	b.n	8d904 <_svfprintf_r+0x348>
   8dff8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8dffa:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8dffc:	2b01      	cmp	r3, #1
   8dffe:	f340 81fc 	ble.w	8e3fa <_svfprintf_r+0xe3e>
   8e002:	3501      	adds	r5, #1
   8e004:	9910      	ldr	r1, [sp, #64]	; 0x40
   8e006:	f10b 0301 	add.w	r3, fp, #1
   8e00a:	2201      	movs	r2, #1
   8e00c:	2d07      	cmp	r5, #7
   8e00e:	9325      	str	r3, [sp, #148]	; 0x94
   8e010:	6021      	str	r1, [r4, #0]
   8e012:	9524      	str	r5, [sp, #144]	; 0x90
   8e014:	6062      	str	r2, [r4, #4]
   8e016:	f300 820e 	bgt.w	8e436 <_svfprintf_r+0xe7a>
   8e01a:	3408      	adds	r4, #8
   8e01c:	9918      	ldr	r1, [sp, #96]	; 0x60
   8e01e:	3501      	adds	r5, #1
   8e020:	eb03 0b01 	add.w	fp, r3, r1
   8e024:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   8e026:	2d07      	cmp	r5, #7
   8e028:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e02c:	9524      	str	r5, [sp, #144]	; 0x90
   8e02e:	6023      	str	r3, [r4, #0]
   8e030:	6061      	str	r1, [r4, #4]
   8e032:	f300 820c 	bgt.w	8e44e <_svfprintf_r+0xe92>
   8e036:	3408      	adds	r4, #8
   8e038:	2300      	movs	r3, #0
   8e03a:	9814      	ldr	r0, [sp, #80]	; 0x50
   8e03c:	9915      	ldr	r1, [sp, #84]	; 0x54
   8e03e:	2200      	movs	r2, #0
   8e040:	f7fe f9a0 	bl	8c384 <__aeabi_dcmpeq>
   8e044:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8e046:	2800      	cmp	r0, #0
   8e048:	f040 80e3 	bne.w	8e212 <_svfprintf_r+0xc56>
   8e04c:	9a10      	ldr	r2, [sp, #64]	; 0x40
   8e04e:	3b01      	subs	r3, #1
   8e050:	3501      	adds	r5, #1
   8e052:	3201      	adds	r2, #1
   8e054:	449b      	add	fp, r3
   8e056:	2d07      	cmp	r5, #7
   8e058:	6022      	str	r2, [r4, #0]
   8e05a:	9524      	str	r5, [sp, #144]	; 0x90
   8e05c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e060:	6063      	str	r3, [r4, #4]
   8e062:	f300 8113 	bgt.w	8e28c <_svfprintf_r+0xcd0>
   8e066:	3408      	adds	r4, #8
   8e068:	9a19      	ldr	r2, [sp, #100]	; 0x64
   8e06a:	3501      	adds	r5, #1
   8e06c:	4493      	add	fp, r2
   8e06e:	ab1f      	add	r3, sp, #124	; 0x7c
   8e070:	2d07      	cmp	r5, #7
   8e072:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e076:	9524      	str	r5, [sp, #144]	; 0x90
   8e078:	6062      	str	r2, [r4, #4]
   8e07a:	6023      	str	r3, [r4, #0]
   8e07c:	f77f ac97 	ble.w	8d9ae <_svfprintf_r+0x3f2>
   8e080:	9808      	ldr	r0, [sp, #32]
   8e082:	4631      	mov	r1, r6
   8e084:	aa23      	add	r2, sp, #140	; 0x8c
   8e086:	f002 f995 	bl	903b4 <__ssprint_r>
   8e08a:	2800      	cmp	r0, #0
   8e08c:	f47f ab5c 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e090:	463c      	mov	r4, r7
   8e092:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e096:	e48b      	b.n	8d9b0 <_svfprintf_r+0x3f4>
   8e098:	2b00      	cmp	r3, #0
   8e09a:	d14c      	bne.n	8e136 <_svfprintf_r+0xb7a>
   8e09c:	9b07      	ldr	r3, [sp, #28]
   8e09e:	07d8      	lsls	r0, r3, #31
   8e0a0:	d549      	bpl.n	8e136 <_svfprintf_r+0xb7a>
   8e0a2:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
   8e0a6:	2330      	movs	r3, #48	; 0x30
   8e0a8:	f80b 3d41 	strb.w	r3, [fp, #-65]!
   8e0ac:	ebcb 0307 	rsb	r3, fp, r7
   8e0b0:	930d      	str	r3, [sp, #52]	; 0x34
   8e0b2:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
   8e0b6:	f7ff bb99 	b.w	8d7ec <_svfprintf_r+0x230>
   8e0ba:	9808      	ldr	r0, [sp, #32]
   8e0bc:	4631      	mov	r1, r6
   8e0be:	aa23      	add	r2, sp, #140	; 0x8c
   8e0c0:	f002 f978 	bl	903b4 <__ssprint_r>
   8e0c4:	2800      	cmp	r0, #0
   8e0c6:	f47f ab3f 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e0ca:	463c      	mov	r4, r7
   8e0cc:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e0d0:	e45c      	b.n	8d98c <_svfprintf_r+0x3d0>
   8e0d2:	9808      	ldr	r0, [sp, #32]
   8e0d4:	4631      	mov	r1, r6
   8e0d6:	aa23      	add	r2, sp, #140	; 0x8c
   8e0d8:	f002 f96c 	bl	903b4 <__ssprint_r>
   8e0dc:	2800      	cmp	r0, #0
   8e0de:	f47f ab33 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e0e2:	463c      	mov	r4, r7
   8e0e4:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e0e8:	f7ff bbf7 	b.w	8d8da <_svfprintf_r+0x31e>
   8e0ec:	9808      	ldr	r0, [sp, #32]
   8e0ee:	4631      	mov	r1, r6
   8e0f0:	aa23      	add	r2, sp, #140	; 0x8c
   8e0f2:	f002 f95f 	bl	903b4 <__ssprint_r>
   8e0f6:	2800      	cmp	r0, #0
   8e0f8:	f47f ab26 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e0fc:	463c      	mov	r4, r7
   8e0fe:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e102:	f7ff bbfb 	b.w	8d8fc <_svfprintf_r+0x340>
   8e106:	4693      	mov	fp, r2
   8e108:	3301      	adds	r3, #1
   8e10a:	44ab      	add	fp, r5
   8e10c:	2b07      	cmp	r3, #7
   8e10e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e112:	9324      	str	r3, [sp, #144]	; 0x90
   8e114:	f8c4 9000 	str.w	r9, [r4]
   8e118:	6065      	str	r5, [r4, #4]
   8e11a:	f77f ac48 	ble.w	8d9ae <_svfprintf_r+0x3f2>
   8e11e:	9808      	ldr	r0, [sp, #32]
   8e120:	4631      	mov	r1, r6
   8e122:	aa23      	add	r2, sp, #140	; 0x8c
   8e124:	f002 f946 	bl	903b4 <__ssprint_r>
   8e128:	2800      	cmp	r0, #0
   8e12a:	f47f ab0d 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e12e:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e132:	463c      	mov	r4, r7
   8e134:	e43c      	b.n	8d9b0 <_svfprintf_r+0x3f4>
   8e136:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
   8e13a:	9710      	str	r7, [sp, #64]	; 0x40
   8e13c:	f7ff bb56 	b.w	8d7ec <_svfprintf_r+0x230>
   8e140:	46bb      	mov	fp, r7
   8e142:	9816      	ldr	r0, [sp, #88]	; 0x58
   8e144:	ea4f 1318 	mov.w	r3, r8, lsr #4
   8e148:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
   8e14c:	ea4f 1119 	mov.w	r1, r9, lsr #4
   8e150:	f008 020f 	and.w	r2, r8, #15
   8e154:	4689      	mov	r9, r1
   8e156:	4698      	mov	r8, r3
   8e158:	5c83      	ldrb	r3, [r0, r2]
   8e15a:	f80b 3d01 	strb.w	r3, [fp, #-1]!
   8e15e:	ea58 0309 	orrs.w	r3, r8, r9
   8e162:	d1ef      	bne.n	8e144 <_svfprintf_r+0xb88>
   8e164:	465b      	mov	r3, fp
   8e166:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
   8e16a:	1afb      	subs	r3, r7, r3
   8e16c:	930d      	str	r3, [sp, #52]	; 0x34
   8e16e:	f7ff bb3d 	b.w	8d7ec <_svfprintf_r+0x230>
   8e172:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   8e174:	2d00      	cmp	r5, #0
   8e176:	f340 8200 	ble.w	8e57a <_svfprintf_r+0xfbe>
   8e17a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8e17c:	9912      	ldr	r1, [sp, #72]	; 0x48
   8e17e:	4613      	mov	r3, r2
   8e180:	428a      	cmp	r2, r1
   8e182:	bfa8      	it	ge
   8e184:	460b      	movge	r3, r1
   8e186:	461d      	mov	r5, r3
   8e188:	9910      	ldr	r1, [sp, #64]	; 0x40
   8e18a:	2d00      	cmp	r5, #0
   8e18c:	eb01 0a02 	add.w	sl, r1, r2
   8e190:	dd0c      	ble.n	8e1ac <_svfprintf_r+0xbf0>
   8e192:	460a      	mov	r2, r1
   8e194:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e196:	44ab      	add	fp, r5
   8e198:	3301      	adds	r3, #1
   8e19a:	2b07      	cmp	r3, #7
   8e19c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e1a0:	e884 0024 	stmia.w	r4, {r2, r5}
   8e1a4:	9324      	str	r3, [sp, #144]	; 0x90
   8e1a6:	f300 8348 	bgt.w	8e83a <_svfprintf_r+0x127e>
   8e1aa:	3408      	adds	r4, #8
   8e1ac:	9b12      	ldr	r3, [sp, #72]	; 0x48
   8e1ae:	2d00      	cmp	r5, #0
   8e1b0:	bfa8      	it	ge
   8e1b2:	1b5b      	subge	r3, r3, r5
   8e1b4:	2b00      	cmp	r3, #0
   8e1b6:	461d      	mov	r5, r3
   8e1b8:	f340 80c1 	ble.w	8e33e <_svfprintf_r+0xd82>
   8e1bc:	2d10      	cmp	r5, #16
   8e1be:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e1c0:	f8df 9014 	ldr.w	r9, [pc, #20]	; 8e1d8 <_svfprintf_r+0xc1c>
   8e1c4:	f340 81c0 	ble.w	8e548 <_svfprintf_r+0xf8c>
   8e1c8:	465a      	mov	r2, fp
   8e1ca:	f04f 0810 	mov.w	r8, #16
   8e1ce:	f8dd b020 	ldr.w	fp, [sp, #32]
   8e1d2:	e008      	b.n	8e1e6 <_svfprintf_r+0xc2a>
   8e1d4:	000917fc 	.word	0x000917fc
   8e1d8:	00092160 	.word	0x00092160
   8e1dc:	3408      	adds	r4, #8
   8e1de:	3d10      	subs	r5, #16
   8e1e0:	2d10      	cmp	r5, #16
   8e1e2:	f340 81b0 	ble.w	8e546 <_svfprintf_r+0xf8a>
   8e1e6:	3301      	adds	r3, #1
   8e1e8:	3210      	adds	r2, #16
   8e1ea:	2b07      	cmp	r3, #7
   8e1ec:	9225      	str	r2, [sp, #148]	; 0x94
   8e1ee:	9324      	str	r3, [sp, #144]	; 0x90
   8e1f0:	f8c4 9000 	str.w	r9, [r4]
   8e1f4:	f8c4 8004 	str.w	r8, [r4, #4]
   8e1f8:	ddf0      	ble.n	8e1dc <_svfprintf_r+0xc20>
   8e1fa:	4658      	mov	r0, fp
   8e1fc:	4631      	mov	r1, r6
   8e1fe:	aa23      	add	r2, sp, #140	; 0x8c
   8e200:	f002 f8d8 	bl	903b4 <__ssprint_r>
   8e204:	2800      	cmp	r0, #0
   8e206:	f47f aa9f 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e20a:	463c      	mov	r4, r7
   8e20c:	9a25      	ldr	r2, [sp, #148]	; 0x94
   8e20e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e210:	e7e5      	b.n	8e1de <_svfprintf_r+0xc22>
   8e212:	f103 38ff 	add.w	r8, r3, #4294967295
   8e216:	f1b8 0f00 	cmp.w	r8, #0
   8e21a:	f77f af25 	ble.w	8e068 <_svfprintf_r+0xaac>
   8e21e:	f1b8 0f10 	cmp.w	r8, #16
   8e222:	f8df 9548 	ldr.w	r9, [pc, #1352]	; 8e76c <_svfprintf_r+0x11b0>
   8e226:	dd25      	ble.n	8e274 <_svfprintf_r+0xcb8>
   8e228:	465b      	mov	r3, fp
   8e22a:	f04f 0a10 	mov.w	sl, #16
   8e22e:	f8dd b020 	ldr.w	fp, [sp, #32]
   8e232:	e006      	b.n	8e242 <_svfprintf_r+0xc86>
   8e234:	f1a8 0810 	sub.w	r8, r8, #16
   8e238:	f1b8 0f10 	cmp.w	r8, #16
   8e23c:	f104 0408 	add.w	r4, r4, #8
   8e240:	dd17      	ble.n	8e272 <_svfprintf_r+0xcb6>
   8e242:	3501      	adds	r5, #1
   8e244:	3310      	adds	r3, #16
   8e246:	2d07      	cmp	r5, #7
   8e248:	9325      	str	r3, [sp, #148]	; 0x94
   8e24a:	9524      	str	r5, [sp, #144]	; 0x90
   8e24c:	e884 0600 	stmia.w	r4, {r9, sl}
   8e250:	ddf0      	ble.n	8e234 <_svfprintf_r+0xc78>
   8e252:	4658      	mov	r0, fp
   8e254:	4631      	mov	r1, r6
   8e256:	aa23      	add	r2, sp, #140	; 0x8c
   8e258:	f002 f8ac 	bl	903b4 <__ssprint_r>
   8e25c:	2800      	cmp	r0, #0
   8e25e:	f47f aa73 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e262:	f1a8 0810 	sub.w	r8, r8, #16
   8e266:	f1b8 0f10 	cmp.w	r8, #16
   8e26a:	463c      	mov	r4, r7
   8e26c:	9b25      	ldr	r3, [sp, #148]	; 0x94
   8e26e:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8e270:	dce7      	bgt.n	8e242 <_svfprintf_r+0xc86>
   8e272:	469b      	mov	fp, r3
   8e274:	3501      	adds	r5, #1
   8e276:	44c3      	add	fp, r8
   8e278:	2d07      	cmp	r5, #7
   8e27a:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e27e:	9524      	str	r5, [sp, #144]	; 0x90
   8e280:	f8c4 9000 	str.w	r9, [r4]
   8e284:	f8c4 8004 	str.w	r8, [r4, #4]
   8e288:	f77f aeed 	ble.w	8e066 <_svfprintf_r+0xaaa>
   8e28c:	9808      	ldr	r0, [sp, #32]
   8e28e:	4631      	mov	r1, r6
   8e290:	aa23      	add	r2, sp, #140	; 0x8c
   8e292:	f002 f88f 	bl	903b4 <__ssprint_r>
   8e296:	2800      	cmp	r0, #0
   8e298:	f47f aa56 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e29c:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e2a0:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8e2a2:	463c      	mov	r4, r7
   8e2a4:	e6e0      	b.n	8e068 <_svfprintf_r+0xaac>
   8e2a6:	46bb      	mov	fp, r7
   8e2a8:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   8e2ac:	4640      	mov	r0, r8
   8e2ae:	4649      	mov	r1, r9
   8e2b0:	220a      	movs	r2, #10
   8e2b2:	2300      	movs	r3, #0
   8e2b4:	f002 fbd6 	bl	90a64 <__aeabi_uldivmod>
   8e2b8:	3230      	adds	r2, #48	; 0x30
   8e2ba:	4640      	mov	r0, r8
   8e2bc:	4649      	mov	r1, r9
   8e2be:	f80b 2d01 	strb.w	r2, [fp, #-1]!
   8e2c2:	2300      	movs	r3, #0
   8e2c4:	220a      	movs	r2, #10
   8e2c6:	f002 fbcd 	bl	90a64 <__aeabi_uldivmod>
   8e2ca:	4680      	mov	r8, r0
   8e2cc:	4689      	mov	r9, r1
   8e2ce:	ea58 0309 	orrs.w	r3, r8, r9
   8e2d2:	d1eb      	bne.n	8e2ac <_svfprintf_r+0xcf0>
   8e2d4:	465b      	mov	r3, fp
   8e2d6:	1afb      	subs	r3, r7, r3
   8e2d8:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   8e2dc:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
   8e2e0:	930d      	str	r3, [sp, #52]	; 0x34
   8e2e2:	f7ff ba83 	b.w	8d7ec <_svfprintf_r+0x230>
   8e2e6:	2b30      	cmp	r3, #48	; 0x30
   8e2e8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   8e2ea:	f43f af3e 	beq.w	8e16a <_svfprintf_r+0xbae>
   8e2ee:	3b01      	subs	r3, #1
   8e2f0:	461a      	mov	r2, r3
   8e2f2:	9310      	str	r3, [sp, #64]	; 0x40
   8e2f4:	1aba      	subs	r2, r7, r2
   8e2f6:	2330      	movs	r3, #48	; 0x30
   8e2f8:	920d      	str	r2, [sp, #52]	; 0x34
   8e2fa:	f801 3c01 	strb.w	r3, [r1, #-1]
   8e2fe:	f7ff ba75 	b.w	8d7ec <_svfprintf_r+0x230>
   8e302:	990e      	ldr	r1, [sp, #56]	; 0x38
   8e304:	f04f 0900 	mov.w	r9, #0
   8e308:	680a      	ldr	r2, [r1, #0]
   8e30a:	3104      	adds	r1, #4
   8e30c:	910e      	str	r1, [sp, #56]	; 0x38
   8e30e:	4690      	mov	r8, r2
   8e310:	f7ff ba39 	b.w	8d786 <_svfprintf_r+0x1ca>
   8e314:	990e      	ldr	r1, [sp, #56]	; 0x38
   8e316:	2301      	movs	r3, #1
   8e318:	680a      	ldr	r2, [r1, #0]
   8e31a:	3104      	adds	r1, #4
   8e31c:	910e      	str	r1, [sp, #56]	; 0x38
   8e31e:	4690      	mov	r8, r2
   8e320:	f04f 0900 	mov.w	r9, #0
   8e324:	f7ff ba2f 	b.w	8d786 <_svfprintf_r+0x1ca>
   8e328:	9808      	ldr	r0, [sp, #32]
   8e32a:	4631      	mov	r1, r6
   8e32c:	aa23      	add	r2, sp, #140	; 0x8c
   8e32e:	f002 f841 	bl	903b4 <__ssprint_r>
   8e332:	2800      	cmp	r0, #0
   8e334:	f47f aa08 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e338:	463c      	mov	r4, r7
   8e33a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e33e:	9a10      	ldr	r2, [sp, #64]	; 0x40
   8e340:	9912      	ldr	r1, [sp, #72]	; 0x48
   8e342:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8e344:	440a      	add	r2, r1
   8e346:	4690      	mov	r8, r2
   8e348:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8e34a:	4293      	cmp	r3, r2
   8e34c:	db46      	blt.n	8e3dc <_svfprintf_r+0xe20>
   8e34e:	9a07      	ldr	r2, [sp, #28]
   8e350:	07d0      	lsls	r0, r2, #31
   8e352:	d443      	bmi.n	8e3dc <_svfprintf_r+0xe20>
   8e354:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8e356:	ebc8 050a 	rsb	r5, r8, sl
   8e35a:	1ad3      	subs	r3, r2, r3
   8e35c:	429d      	cmp	r5, r3
   8e35e:	bfa8      	it	ge
   8e360:	461d      	movge	r5, r3
   8e362:	2d00      	cmp	r5, #0
   8e364:	dd0c      	ble.n	8e380 <_svfprintf_r+0xdc4>
   8e366:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8e368:	44ab      	add	fp, r5
   8e36a:	3201      	adds	r2, #1
   8e36c:	2a07      	cmp	r2, #7
   8e36e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e372:	f8c4 8000 	str.w	r8, [r4]
   8e376:	6065      	str	r5, [r4, #4]
   8e378:	9224      	str	r2, [sp, #144]	; 0x90
   8e37a:	f300 8296 	bgt.w	8e8aa <_svfprintf_r+0x12ee>
   8e37e:	3408      	adds	r4, #8
   8e380:	2d00      	cmp	r5, #0
   8e382:	bfb4      	ite	lt
   8e384:	461d      	movlt	r5, r3
   8e386:	1b5d      	subge	r5, r3, r5
   8e388:	2d00      	cmp	r5, #0
   8e38a:	f77f ab11 	ble.w	8d9b0 <_svfprintf_r+0x3f4>
   8e38e:	2d10      	cmp	r5, #16
   8e390:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e392:	f8df 93d8 	ldr.w	r9, [pc, #984]	; 8e76c <_svfprintf_r+0x11b0>
   8e396:	f77f aeb7 	ble.w	8e108 <_svfprintf_r+0xb4c>
   8e39a:	f04f 0810 	mov.w	r8, #16
   8e39e:	465a      	mov	r2, fp
   8e3a0:	f8dd a020 	ldr.w	sl, [sp, #32]
   8e3a4:	e004      	b.n	8e3b0 <_svfprintf_r+0xdf4>
   8e3a6:	3408      	adds	r4, #8
   8e3a8:	3d10      	subs	r5, #16
   8e3aa:	2d10      	cmp	r5, #16
   8e3ac:	f77f aeab 	ble.w	8e106 <_svfprintf_r+0xb4a>
   8e3b0:	3301      	adds	r3, #1
   8e3b2:	3210      	adds	r2, #16
   8e3b4:	2b07      	cmp	r3, #7
   8e3b6:	9225      	str	r2, [sp, #148]	; 0x94
   8e3b8:	9324      	str	r3, [sp, #144]	; 0x90
   8e3ba:	f8c4 9000 	str.w	r9, [r4]
   8e3be:	f8c4 8004 	str.w	r8, [r4, #4]
   8e3c2:	ddf0      	ble.n	8e3a6 <_svfprintf_r+0xdea>
   8e3c4:	4650      	mov	r0, sl
   8e3c6:	4631      	mov	r1, r6
   8e3c8:	aa23      	add	r2, sp, #140	; 0x8c
   8e3ca:	f001 fff3 	bl	903b4 <__ssprint_r>
   8e3ce:	2800      	cmp	r0, #0
   8e3d0:	f47f a9ba 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e3d4:	463c      	mov	r4, r7
   8e3d6:	9a25      	ldr	r2, [sp, #148]	; 0x94
   8e3d8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e3da:	e7e5      	b.n	8e3a8 <_svfprintf_r+0xdec>
   8e3dc:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8e3de:	9818      	ldr	r0, [sp, #96]	; 0x60
   8e3e0:	3201      	adds	r2, #1
   8e3e2:	9917      	ldr	r1, [sp, #92]	; 0x5c
   8e3e4:	4483      	add	fp, r0
   8e3e6:	2a07      	cmp	r2, #7
   8e3e8:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e3ec:	6021      	str	r1, [r4, #0]
   8e3ee:	6060      	str	r0, [r4, #4]
   8e3f0:	9224      	str	r2, [sp, #144]	; 0x90
   8e3f2:	f300 8239 	bgt.w	8e868 <_svfprintf_r+0x12ac>
   8e3f6:	3408      	adds	r4, #8
   8e3f8:	e7ac      	b.n	8e354 <_svfprintf_r+0xd98>
   8e3fa:	9b07      	ldr	r3, [sp, #28]
   8e3fc:	07d9      	lsls	r1, r3, #31
   8e3fe:	f53f ae00 	bmi.w	8e002 <_svfprintf_r+0xa46>
   8e402:	3501      	adds	r5, #1
   8e404:	9a10      	ldr	r2, [sp, #64]	; 0x40
   8e406:	f10b 0b01 	add.w	fp, fp, #1
   8e40a:	2301      	movs	r3, #1
   8e40c:	2d07      	cmp	r5, #7
   8e40e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e412:	6022      	str	r2, [r4, #0]
   8e414:	9524      	str	r5, [sp, #144]	; 0x90
   8e416:	6063      	str	r3, [r4, #4]
   8e418:	f77f ae25 	ble.w	8e066 <_svfprintf_r+0xaaa>
   8e41c:	9808      	ldr	r0, [sp, #32]
   8e41e:	4631      	mov	r1, r6
   8e420:	aa23      	add	r2, sp, #140	; 0x8c
   8e422:	f001 ffc7 	bl	903b4 <__ssprint_r>
   8e426:	2800      	cmp	r0, #0
   8e428:	f47f a98e 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e42c:	463c      	mov	r4, r7
   8e42e:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e432:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8e434:	e618      	b.n	8e068 <_svfprintf_r+0xaac>
   8e436:	9808      	ldr	r0, [sp, #32]
   8e438:	4631      	mov	r1, r6
   8e43a:	aa23      	add	r2, sp, #140	; 0x8c
   8e43c:	f001 ffba 	bl	903b4 <__ssprint_r>
   8e440:	2800      	cmp	r0, #0
   8e442:	f47f a981 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e446:	463c      	mov	r4, r7
   8e448:	9b25      	ldr	r3, [sp, #148]	; 0x94
   8e44a:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8e44c:	e5e6      	b.n	8e01c <_svfprintf_r+0xa60>
   8e44e:	9808      	ldr	r0, [sp, #32]
   8e450:	4631      	mov	r1, r6
   8e452:	aa23      	add	r2, sp, #140	; 0x8c
   8e454:	f001 ffae 	bl	903b4 <__ssprint_r>
   8e458:	2800      	cmp	r0, #0
   8e45a:	f47f a975 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e45e:	463c      	mov	r4, r7
   8e460:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e464:	9d24      	ldr	r5, [sp, #144]	; 0x90
   8e466:	e5e7      	b.n	8e038 <_svfprintf_r+0xa7c>
   8e468:	9808      	ldr	r0, [sp, #32]
   8e46a:	4631      	mov	r1, r6
   8e46c:	aa23      	add	r2, sp, #140	; 0x8c
   8e46e:	f001 ffa1 	bl	903b4 <__ssprint_r>
   8e472:	2800      	cmp	r0, #0
   8e474:	f47f a968 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e478:	463c      	mov	r4, r7
   8e47a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e47e:	f7ff ba41 	b.w	8d904 <_svfprintf_r+0x348>
   8e482:	f7fd fab3 	bl	8b9ec <__fpclassifyd>
   8e486:	2800      	cmp	r0, #0
   8e488:	f040 80dd 	bne.w	8e646 <_svfprintf_r+0x108a>
   8e48c:	4ab4      	ldr	r2, [pc, #720]	; (8e760 <_svfprintf_r+0x11a4>)
   8e48e:	4bb5      	ldr	r3, [pc, #724]	; (8e764 <_svfprintf_r+0x11a8>)
   8e490:	4686      	mov	lr, r0
   8e492:	2d47      	cmp	r5, #71	; 0x47
   8e494:	bfd8      	it	le
   8e496:	461a      	movle	r2, r3
   8e498:	9011      	str	r0, [sp, #68]	; 0x44
   8e49a:	9807      	ldr	r0, [sp, #28]
   8e49c:	2103      	movs	r1, #3
   8e49e:	f020 0080 	bic.w	r0, r0, #128	; 0x80
   8e4a2:	9109      	str	r1, [sp, #36]	; 0x24
   8e4a4:	9007      	str	r0, [sp, #28]
   8e4a6:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
   8e4aa:	9210      	str	r2, [sp, #64]	; 0x40
   8e4ac:	910d      	str	r1, [sp, #52]	; 0x34
   8e4ae:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8e4b2:	f7ff b9a3 	b.w	8d7fc <_svfprintf_r+0x240>
   8e4b6:	f029 0907 	bic.w	r9, r9, #7
   8e4ba:	f8d9 3000 	ldr.w	r3, [r9]
   8e4be:	9314      	str	r3, [sp, #80]	; 0x50
   8e4c0:	f8d9 3004 	ldr.w	r3, [r9, #4]
   8e4c4:	9315      	str	r3, [sp, #84]	; 0x54
   8e4c6:	f109 0308 	add.w	r3, r9, #8
   8e4ca:	930e      	str	r3, [sp, #56]	; 0x38
   8e4cc:	f7ff bbc5 	b.w	8dc5a <_svfprintf_r+0x69e>
   8e4d0:	9b07      	ldr	r3, [sp, #28]
   8e4d2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8e4d4:	f013 0f40 	tst.w	r3, #64	; 0x40
   8e4d8:	4613      	mov	r3, r2
   8e4da:	f43f ac40 	beq.w	8dd5e <_svfprintf_r+0x7a2>
   8e4de:	3304      	adds	r3, #4
   8e4e0:	f8b2 8000 	ldrh.w	r8, [r2]
   8e4e4:	f04f 0900 	mov.w	r9, #0
   8e4e8:	930e      	str	r3, [sp, #56]	; 0x38
   8e4ea:	f7ff bb1c 	b.w	8db26 <_svfprintf_r+0x56a>
   8e4ee:	9b07      	ldr	r3, [sp, #28]
   8e4f0:	06db      	lsls	r3, r3, #27
   8e4f2:	d40b      	bmi.n	8e50c <_svfprintf_r+0xf50>
   8e4f4:	9b07      	ldr	r3, [sp, #28]
   8e4f6:	065d      	lsls	r5, r3, #25
   8e4f8:	d508      	bpl.n	8e50c <_svfprintf_r+0xf50>
   8e4fa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8e4fc:	6813      	ldr	r3, [r2, #0]
   8e4fe:	3204      	adds	r2, #4
   8e500:	920e      	str	r2, [sp, #56]	; 0x38
   8e502:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   8e506:	801a      	strh	r2, [r3, #0]
   8e508:	f7ff b87d 	b.w	8d606 <_svfprintf_r+0x4a>
   8e50c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8e50e:	6813      	ldr	r3, [r2, #0]
   8e510:	3204      	adds	r2, #4
   8e512:	920e      	str	r2, [sp, #56]	; 0x38
   8e514:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   8e516:	601a      	str	r2, [r3, #0]
   8e518:	f7ff b875 	b.w	8d606 <_svfprintf_r+0x4a>
   8e51c:	4619      	mov	r1, r3
   8e51e:	781d      	ldrb	r5, [r3, #0]
   8e520:	f7ff b89f 	b.w	8d662 <_svfprintf_r+0xa6>
   8e524:	9b07      	ldr	r3, [sp, #28]
   8e526:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   8e528:	f013 0f40 	tst.w	r3, #64	; 0x40
   8e52c:	4613      	mov	r3, r2
   8e52e:	f43f ab3a 	beq.w	8dba6 <_svfprintf_r+0x5ea>
   8e532:	f9b2 8000 	ldrsh.w	r8, [r2]
   8e536:	3304      	adds	r3, #4
   8e538:	ea4f 79e8 	mov.w	r9, r8, asr #31
   8e53c:	930e      	str	r3, [sp, #56]	; 0x38
   8e53e:	4642      	mov	r2, r8
   8e540:	464b      	mov	r3, r9
   8e542:	f7ff bad3 	b.w	8daec <_svfprintf_r+0x530>
   8e546:	4693      	mov	fp, r2
   8e548:	3301      	adds	r3, #1
   8e54a:	44ab      	add	fp, r5
   8e54c:	2b07      	cmp	r3, #7
   8e54e:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e552:	9324      	str	r3, [sp, #144]	; 0x90
   8e554:	f8c4 9000 	str.w	r9, [r4]
   8e558:	6065      	str	r5, [r4, #4]
   8e55a:	f73f aee5 	bgt.w	8e328 <_svfprintf_r+0xd6c>
   8e55e:	3408      	adds	r4, #8
   8e560:	e6ed      	b.n	8e33e <_svfprintf_r+0xd82>
   8e562:	9808      	ldr	r0, [sp, #32]
   8e564:	4631      	mov	r1, r6
   8e566:	aa23      	add	r2, sp, #140	; 0x8c
   8e568:	f001 ff24 	bl	903b4 <__ssprint_r>
   8e56c:	2800      	cmp	r0, #0
   8e56e:	f47f a8eb 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e572:	463c      	mov	r4, r7
   8e574:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e578:	e4b6      	b.n	8dee8 <_svfprintf_r+0x92c>
   8e57a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e57c:	497a      	ldr	r1, [pc, #488]	; (8e768 <_svfprintf_r+0x11ac>)
   8e57e:	3301      	adds	r3, #1
   8e580:	f10b 0b01 	add.w	fp, fp, #1
   8e584:	2201      	movs	r2, #1
   8e586:	2b07      	cmp	r3, #7
   8e588:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e58c:	9324      	str	r3, [sp, #144]	; 0x90
   8e58e:	e884 0006 	stmia.w	r4, {r1, r2}
   8e592:	f300 80fd 	bgt.w	8e790 <_svfprintf_r+0x11d4>
   8e596:	3408      	adds	r4, #8
   8e598:	b92d      	cbnz	r5, 8e5a6 <_svfprintf_r+0xfea>
   8e59a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8e59c:	b91b      	cbnz	r3, 8e5a6 <_svfprintf_r+0xfea>
   8e59e:	9b07      	ldr	r3, [sp, #28]
   8e5a0:	07db      	lsls	r3, r3, #31
   8e5a2:	f57f aa05 	bpl.w	8d9b0 <_svfprintf_r+0x3f4>
   8e5a6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e5a8:	9818      	ldr	r0, [sp, #96]	; 0x60
   8e5aa:	3301      	adds	r3, #1
   8e5ac:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   8e5ae:	eb0b 0100 	add.w	r1, fp, r0
   8e5b2:	2b07      	cmp	r3, #7
   8e5b4:	9125      	str	r1, [sp, #148]	; 0x94
   8e5b6:	6022      	str	r2, [r4, #0]
   8e5b8:	6060      	str	r0, [r4, #4]
   8e5ba:	9324      	str	r3, [sp, #144]	; 0x90
   8e5bc:	f300 81f4 	bgt.w	8e9a8 <_svfprintf_r+0x13ec>
   8e5c0:	f104 0208 	add.w	r2, r4, #8
   8e5c4:	426d      	negs	r5, r5
   8e5c6:	2d00      	cmp	r5, #0
   8e5c8:	f340 8107 	ble.w	8e7da <_svfprintf_r+0x121e>
   8e5cc:	2d10      	cmp	r5, #16
   8e5ce:	f8df 919c 	ldr.w	r9, [pc, #412]	; 8e76c <_svfprintf_r+0x11b0>
   8e5d2:	f340 813e 	ble.w	8e852 <_svfprintf_r+0x1296>
   8e5d6:	2410      	movs	r4, #16
   8e5d8:	f8dd 8020 	ldr.w	r8, [sp, #32]
   8e5dc:	e004      	b.n	8e5e8 <_svfprintf_r+0x102c>
   8e5de:	3208      	adds	r2, #8
   8e5e0:	3d10      	subs	r5, #16
   8e5e2:	2d10      	cmp	r5, #16
   8e5e4:	f340 8135 	ble.w	8e852 <_svfprintf_r+0x1296>
   8e5e8:	3301      	adds	r3, #1
   8e5ea:	3110      	adds	r1, #16
   8e5ec:	2b07      	cmp	r3, #7
   8e5ee:	9125      	str	r1, [sp, #148]	; 0x94
   8e5f0:	9324      	str	r3, [sp, #144]	; 0x90
   8e5f2:	f8c2 9000 	str.w	r9, [r2]
   8e5f6:	6054      	str	r4, [r2, #4]
   8e5f8:	ddf1      	ble.n	8e5de <_svfprintf_r+0x1022>
   8e5fa:	4640      	mov	r0, r8
   8e5fc:	4631      	mov	r1, r6
   8e5fe:	aa23      	add	r2, sp, #140	; 0x8c
   8e600:	f001 fed8 	bl	903b4 <__ssprint_r>
   8e604:	2800      	cmp	r0, #0
   8e606:	f47f a89f 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e60a:	463a      	mov	r2, r7
   8e60c:	9925      	ldr	r1, [sp, #148]	; 0x94
   8e60e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e610:	e7e6      	b.n	8e5e0 <_svfprintf_r+0x1024>
   8e612:	9b25      	ldr	r3, [sp, #148]	; 0x94
   8e614:	46b1      	mov	r9, r6
   8e616:	2b00      	cmp	r3, #0
   8e618:	f43f a897 	beq.w	8d74a <_svfprintf_r+0x18e>
   8e61c:	9808      	ldr	r0, [sp, #32]
   8e61e:	4631      	mov	r1, r6
   8e620:	aa23      	add	r2, sp, #140	; 0x8c
   8e622:	f001 fec7 	bl	903b4 <__ssprint_r>
   8e626:	f7ff b890 	b.w	8d74a <_svfprintf_r+0x18e>
   8e62a:	f041 0120 	orr.w	r1, r1, #32
   8e62e:	9107      	str	r1, [sp, #28]
   8e630:	785d      	ldrb	r5, [r3, #1]
   8e632:	1c59      	adds	r1, r3, #1
   8e634:	f7ff b815 	b.w	8d662 <_svfprintf_r+0xa6>
   8e638:	980c      	ldr	r0, [sp, #48]	; 0x30
   8e63a:	910e      	str	r1, [sp, #56]	; 0x38
   8e63c:	4240      	negs	r0, r0
   8e63e:	900c      	str	r0, [sp, #48]	; 0x30
   8e640:	4619      	mov	r1, r3
   8e642:	f7ff ba0b 	b.w	8da5c <_svfprintf_r+0x4a0>
   8e646:	f025 0320 	bic.w	r3, r5, #32
   8e64a:	f1ba 3fff 	cmp.w	sl, #4294967295
   8e64e:	930d      	str	r3, [sp, #52]	; 0x34
   8e650:	f000 80ab 	beq.w	8e7aa <_svfprintf_r+0x11ee>
   8e654:	2b47      	cmp	r3, #71	; 0x47
   8e656:	d105      	bne.n	8e664 <_svfprintf_r+0x10a8>
   8e658:	f1ba 0f00 	cmp.w	sl, #0
   8e65c:	bf14      	ite	ne
   8e65e:	46d3      	movne	fp, sl
   8e660:	f04f 0b01 	moveq.w	fp, #1
   8e664:	9b07      	ldr	r3, [sp, #28]
   8e666:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   8e66a:	9311      	str	r3, [sp, #68]	; 0x44
   8e66c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   8e66e:	f1b3 0a00 	subs.w	sl, r3, #0
   8e672:	9b14      	ldr	r3, [sp, #80]	; 0x50
   8e674:	9309      	str	r3, [sp, #36]	; 0x24
   8e676:	bfb7      	itett	lt
   8e678:	4653      	movlt	r3, sl
   8e67a:	2300      	movge	r3, #0
   8e67c:	f103 4a00 	addlt.w	sl, r3, #2147483648	; 0x80000000
   8e680:	232d      	movlt	r3, #45	; 0x2d
   8e682:	2d66      	cmp	r5, #102	; 0x66
   8e684:	930f      	str	r3, [sp, #60]	; 0x3c
   8e686:	f000 80b9 	beq.w	8e7fc <_svfprintf_r+0x1240>
   8e68a:	2d46      	cmp	r5, #70	; 0x46
   8e68c:	f000 80b6 	beq.w	8e7fc <_svfprintf_r+0x1240>
   8e690:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8e692:	2002      	movs	r0, #2
   8e694:	2b45      	cmp	r3, #69	; 0x45
   8e696:	bf14      	ite	ne
   8e698:	46d9      	movne	r9, fp
   8e69a:	f10b 0901 	addeq.w	r9, fp, #1
   8e69e:	a91d      	add	r1, sp, #116	; 0x74
   8e6a0:	e88d 0201 	stmia.w	sp, {r0, r9}
   8e6a4:	9102      	str	r1, [sp, #8]
   8e6a6:	a81e      	add	r0, sp, #120	; 0x78
   8e6a8:	a921      	add	r1, sp, #132	; 0x84
   8e6aa:	9003      	str	r0, [sp, #12]
   8e6ac:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8e6ae:	4653      	mov	r3, sl
   8e6b0:	9104      	str	r1, [sp, #16]
   8e6b2:	9808      	ldr	r0, [sp, #32]
   8e6b4:	f000 faa4 	bl	8ec00 <_dtoa_r>
   8e6b8:	2d67      	cmp	r5, #103	; 0x67
   8e6ba:	9010      	str	r0, [sp, #64]	; 0x40
   8e6bc:	d002      	beq.n	8e6c4 <_svfprintf_r+0x1108>
   8e6be:	2d47      	cmp	r5, #71	; 0x47
   8e6c0:	f040 80ac 	bne.w	8e81c <_svfprintf_r+0x1260>
   8e6c4:	9b07      	ldr	r3, [sp, #28]
   8e6c6:	07db      	lsls	r3, r3, #31
   8e6c8:	f140 8196 	bpl.w	8e9f8 <_svfprintf_r+0x143c>
   8e6cc:	9b10      	ldr	r3, [sp, #64]	; 0x40
   8e6ce:	eb03 0809 	add.w	r8, r3, r9
   8e6d2:	9809      	ldr	r0, [sp, #36]	; 0x24
   8e6d4:	4651      	mov	r1, sl
   8e6d6:	2200      	movs	r2, #0
   8e6d8:	2300      	movs	r3, #0
   8e6da:	f7fd fe53 	bl	8c384 <__aeabi_dcmpeq>
   8e6de:	2800      	cmp	r0, #0
   8e6e0:	f040 810a 	bne.w	8e8f8 <_svfprintf_r+0x133c>
   8e6e4:	9b21      	ldr	r3, [sp, #132]	; 0x84
   8e6e6:	4598      	cmp	r8, r3
   8e6e8:	d906      	bls.n	8e6f8 <_svfprintf_r+0x113c>
   8e6ea:	2130      	movs	r1, #48	; 0x30
   8e6ec:	1c5a      	adds	r2, r3, #1
   8e6ee:	9221      	str	r2, [sp, #132]	; 0x84
   8e6f0:	7019      	strb	r1, [r3, #0]
   8e6f2:	9b21      	ldr	r3, [sp, #132]	; 0x84
   8e6f4:	4598      	cmp	r8, r3
   8e6f6:	d8f9      	bhi.n	8e6ec <_svfprintf_r+0x1130>
   8e6f8:	9a10      	ldr	r2, [sp, #64]	; 0x40
   8e6fa:	1a9b      	subs	r3, r3, r2
   8e6fc:	9313      	str	r3, [sp, #76]	; 0x4c
   8e6fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8e700:	2b47      	cmp	r3, #71	; 0x47
   8e702:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8e704:	f000 80eb 	beq.w	8e8de <_svfprintf_r+0x1322>
   8e708:	2d65      	cmp	r5, #101	; 0x65
   8e70a:	f340 8105 	ble.w	8e918 <_svfprintf_r+0x135c>
   8e70e:	2d66      	cmp	r5, #102	; 0x66
   8e710:	9312      	str	r3, [sp, #72]	; 0x48
   8e712:	f000 8164 	beq.w	8e9de <_svfprintf_r+0x1422>
   8e716:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8e718:	9a12      	ldr	r2, [sp, #72]	; 0x48
   8e71a:	4293      	cmp	r3, r2
   8e71c:	f300 8151 	bgt.w	8e9c2 <_svfprintf_r+0x1406>
   8e720:	9b07      	ldr	r3, [sp, #28]
   8e722:	07d9      	lsls	r1, r3, #31
   8e724:	f100 8188 	bmi.w	8ea38 <_svfprintf_r+0x147c>
   8e728:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
   8e72c:	920d      	str	r2, [sp, #52]	; 0x34
   8e72e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   8e730:	2a00      	cmp	r2, #0
   8e732:	f040 80c9 	bne.w	8e8c8 <_svfprintf_r+0x130c>
   8e736:	9309      	str	r3, [sp, #36]	; 0x24
   8e738:	9b11      	ldr	r3, [sp, #68]	; 0x44
   8e73a:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8e73e:	9307      	str	r3, [sp, #28]
   8e740:	9211      	str	r2, [sp, #68]	; 0x44
   8e742:	f7ff b85b 	b.w	8d7fc <_svfprintf_r+0x240>
   8e746:	9808      	ldr	r0, [sp, #32]
   8e748:	4631      	mov	r1, r6
   8e74a:	aa23      	add	r2, sp, #140	; 0x8c
   8e74c:	f001 fe32 	bl	903b4 <__ssprint_r>
   8e750:	2800      	cmp	r0, #0
   8e752:	f47e aff9 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e756:	463c      	mov	r4, r7
   8e758:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e75c:	f7ff bbda 	b.w	8df14 <_svfprintf_r+0x958>
   8e760:	0009218c 	.word	0x0009218c
   8e764:	00092188 	.word	0x00092188
   8e768:	000917fc 	.word	0x000917fc
   8e76c:	00092160 	.word	0x00092160
   8e770:	9808      	ldr	r0, [sp, #32]
   8e772:	2140      	movs	r1, #64	; 0x40
   8e774:	f7fe fa2c 	bl	8cbd0 <_malloc_r>
   8e778:	f8c9 0000 	str.w	r0, [r9]
   8e77c:	f8c9 0010 	str.w	r0, [r9, #16]
   8e780:	2800      	cmp	r0, #0
   8e782:	f000 8186 	beq.w	8ea92 <_svfprintf_r+0x14d6>
   8e786:	2340      	movs	r3, #64	; 0x40
   8e788:	f8c9 3014 	str.w	r3, [r9, #20]
   8e78c:	f7fe bf2e 	b.w	8d5ec <_svfprintf_r+0x30>
   8e790:	9808      	ldr	r0, [sp, #32]
   8e792:	4631      	mov	r1, r6
   8e794:	aa23      	add	r2, sp, #140	; 0x8c
   8e796:	f001 fe0d 	bl	903b4 <__ssprint_r>
   8e79a:	2800      	cmp	r0, #0
   8e79c:	f47e afd4 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e7a0:	463c      	mov	r4, r7
   8e7a2:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   8e7a4:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e7a8:	e6f6      	b.n	8e598 <_svfprintf_r+0xfdc>
   8e7aa:	f04f 0b06 	mov.w	fp, #6
   8e7ae:	e759      	b.n	8e664 <_svfprintf_r+0x10a8>
   8e7b0:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
   8e7b4:	f7fe fdf0 	bl	8d398 <strlen>
   8e7b8:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
   8e7bc:	900d      	str	r0, [sp, #52]	; 0x34
   8e7be:	4603      	mov	r3, r0
   8e7c0:	f7ff bb1a 	b.w	8ddf8 <_svfprintf_r+0x83c>
   8e7c4:	9808      	ldr	r0, [sp, #32]
   8e7c6:	4631      	mov	r1, r6
   8e7c8:	aa23      	add	r2, sp, #140	; 0x8c
   8e7ca:	f001 fdf3 	bl	903b4 <__ssprint_r>
   8e7ce:	2800      	cmp	r0, #0
   8e7d0:	f47e afba 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e7d4:	463a      	mov	r2, r7
   8e7d6:	9925      	ldr	r1, [sp, #148]	; 0x94
   8e7d8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e7da:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   8e7dc:	3301      	adds	r3, #1
   8e7de:	eb01 0b04 	add.w	fp, r1, r4
   8e7e2:	9910      	ldr	r1, [sp, #64]	; 0x40
   8e7e4:	2b07      	cmp	r3, #7
   8e7e6:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
   8e7ea:	9324      	str	r3, [sp, #144]	; 0x90
   8e7ec:	6011      	str	r1, [r2, #0]
   8e7ee:	6054      	str	r4, [r2, #4]
   8e7f0:	f73f ac95 	bgt.w	8e11e <_svfprintf_r+0xb62>
   8e7f4:	f102 0408 	add.w	r4, r2, #8
   8e7f8:	f7ff b8da 	b.w	8d9b0 <_svfprintf_r+0x3f4>
   8e7fc:	2003      	movs	r0, #3
   8e7fe:	a91d      	add	r1, sp, #116	; 0x74
   8e800:	e88d 0801 	stmia.w	sp, {r0, fp}
   8e804:	9102      	str	r1, [sp, #8]
   8e806:	a81e      	add	r0, sp, #120	; 0x78
   8e808:	a921      	add	r1, sp, #132	; 0x84
   8e80a:	9003      	str	r0, [sp, #12]
   8e80c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8e80e:	4653      	mov	r3, sl
   8e810:	9104      	str	r1, [sp, #16]
   8e812:	9808      	ldr	r0, [sp, #32]
   8e814:	f000 f9f4 	bl	8ec00 <_dtoa_r>
   8e818:	46d9      	mov	r9, fp
   8e81a:	9010      	str	r0, [sp, #64]	; 0x40
   8e81c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   8e81e:	eb03 0809 	add.w	r8, r3, r9
   8e822:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8e824:	2b46      	cmp	r3, #70	; 0x46
   8e826:	f47f af54 	bne.w	8e6d2 <_svfprintf_r+0x1116>
   8e82a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   8e82c:	781b      	ldrb	r3, [r3, #0]
   8e82e:	2b30      	cmp	r3, #48	; 0x30
   8e830:	f000 80e4 	beq.w	8e9fc <_svfprintf_r+0x1440>
   8e834:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8e836:	4498      	add	r8, r3
   8e838:	e74b      	b.n	8e6d2 <_svfprintf_r+0x1116>
   8e83a:	9808      	ldr	r0, [sp, #32]
   8e83c:	4631      	mov	r1, r6
   8e83e:	aa23      	add	r2, sp, #140	; 0x8c
   8e840:	f001 fdb8 	bl	903b4 <__ssprint_r>
   8e844:	2800      	cmp	r0, #0
   8e846:	f47e af7f 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e84a:	463c      	mov	r4, r7
   8e84c:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e850:	e4ac      	b.n	8e1ac <_svfprintf_r+0xbf0>
   8e852:	3301      	adds	r3, #1
   8e854:	4429      	add	r1, r5
   8e856:	2b07      	cmp	r3, #7
   8e858:	9125      	str	r1, [sp, #148]	; 0x94
   8e85a:	9324      	str	r3, [sp, #144]	; 0x90
   8e85c:	f8c2 9000 	str.w	r9, [r2]
   8e860:	6055      	str	r5, [r2, #4]
   8e862:	dcaf      	bgt.n	8e7c4 <_svfprintf_r+0x1208>
   8e864:	3208      	adds	r2, #8
   8e866:	e7b8      	b.n	8e7da <_svfprintf_r+0x121e>
   8e868:	9808      	ldr	r0, [sp, #32]
   8e86a:	4631      	mov	r1, r6
   8e86c:	aa23      	add	r2, sp, #140	; 0x8c
   8e86e:	f001 fda1 	bl	903b4 <__ssprint_r>
   8e872:	2800      	cmp	r0, #0
   8e874:	f47e af68 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e878:	463c      	mov	r4, r7
   8e87a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8e87c:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e880:	e568      	b.n	8e354 <_svfprintf_r+0xd98>
   8e882:	4653      	mov	r3, sl
   8e884:	2b06      	cmp	r3, #6
   8e886:	bf28      	it	cs
   8e888:	2306      	movcs	r3, #6
   8e88a:	930d      	str	r3, [sp, #52]	; 0x34
   8e88c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8e890:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   8e894:	9309      	str	r3, [sp, #36]	; 0x24
   8e896:	4b84      	ldr	r3, [pc, #528]	; (8eaa8 <_svfprintf_r+0x14ec>)
   8e898:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
   8e89c:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
   8e8a0:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
   8e8a4:	9310      	str	r3, [sp, #64]	; 0x40
   8e8a6:	f7fe bfa9 	b.w	8d7fc <_svfprintf_r+0x240>
   8e8aa:	9808      	ldr	r0, [sp, #32]
   8e8ac:	4631      	mov	r1, r6
   8e8ae:	aa23      	add	r2, sp, #140	; 0x8c
   8e8b0:	f001 fd80 	bl	903b4 <__ssprint_r>
   8e8b4:	2800      	cmp	r0, #0
   8e8b6:	f47e af47 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e8ba:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   8e8bc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8e8be:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
   8e8c2:	1ad3      	subs	r3, r2, r3
   8e8c4:	463c      	mov	r4, r7
   8e8c6:	e55b      	b.n	8e380 <_svfprintf_r+0xdc4>
   8e8c8:	9309      	str	r3, [sp, #36]	; 0x24
   8e8ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
   8e8cc:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
   8e8d0:	9307      	str	r3, [sp, #28]
   8e8d2:	2300      	movs	r3, #0
   8e8d4:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
   8e8d8:	9311      	str	r3, [sp, #68]	; 0x44
   8e8da:	f7fe bf92 	b.w	8d802 <_svfprintf_r+0x246>
   8e8de:	1cda      	adds	r2, r3, #3
   8e8e0:	db19      	blt.n	8e916 <_svfprintf_r+0x135a>
   8e8e2:	459b      	cmp	fp, r3
   8e8e4:	db17      	blt.n	8e916 <_svfprintf_r+0x135a>
   8e8e6:	9312      	str	r3, [sp, #72]	; 0x48
   8e8e8:	2567      	movs	r5, #103	; 0x67
   8e8ea:	e714      	b.n	8e716 <_svfprintf_r+0x115a>
   8e8ec:	232d      	movs	r3, #45	; 0x2d
   8e8ee:	469c      	mov	ip, r3
   8e8f0:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   8e8f4:	f7ff b9c3 	b.w	8dc7e <_svfprintf_r+0x6c2>
   8e8f8:	4643      	mov	r3, r8
   8e8fa:	e6fd      	b.n	8e6f8 <_svfprintf_r+0x113c>
   8e8fc:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
   8e900:	9011      	str	r0, [sp, #68]	; 0x44
   8e902:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
   8e906:	9012      	str	r0, [sp, #72]	; 0x48
   8e908:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
   8e90c:	9309      	str	r3, [sp, #36]	; 0x24
   8e90e:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
   8e912:	f7fe bf73 	b.w	8d7fc <_svfprintf_r+0x240>
   8e916:	3d02      	subs	r5, #2
   8e918:	3b01      	subs	r3, #1
   8e91a:	2b00      	cmp	r3, #0
   8e91c:	931d      	str	r3, [sp, #116]	; 0x74
   8e91e:	bfba      	itte	lt
   8e920:	425b      	neglt	r3, r3
   8e922:	222d      	movlt	r2, #45	; 0x2d
   8e924:	222b      	movge	r2, #43	; 0x2b
   8e926:	2b09      	cmp	r3, #9
   8e928:	f88d 507c 	strb.w	r5, [sp, #124]	; 0x7c
   8e92c:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
   8e930:	dd7a      	ble.n	8ea28 <_svfprintf_r+0x146c>
   8e932:	f10d 008b 	add.w	r0, sp, #139	; 0x8b
   8e936:	4601      	mov	r1, r0
   8e938:	4a5c      	ldr	r2, [pc, #368]	; (8eaac <_svfprintf_r+0x14f0>)
   8e93a:	fb82 2e03 	smull	r2, lr, r2, r3
   8e93e:	17da      	asrs	r2, r3, #31
   8e940:	ebc2 0eae 	rsb	lr, r2, lr, asr #2
   8e944:	eb0e 028e 	add.w	r2, lr, lr, lsl #2
   8e948:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
   8e94c:	4673      	mov	r3, lr
   8e94e:	3230      	adds	r2, #48	; 0x30
   8e950:	2b09      	cmp	r3, #9
   8e952:	f801 2d01 	strb.w	r2, [r1, #-1]!
   8e956:	dcef      	bgt.n	8e938 <_svfprintf_r+0x137c>
   8e958:	460a      	mov	r2, r1
   8e95a:	3330      	adds	r3, #48	; 0x30
   8e95c:	fa5f fe83 	uxtb.w	lr, r3
   8e960:	f802 ed01 	strb.w	lr, [r2, #-1]!
   8e964:	4290      	cmp	r0, r2
   8e966:	f240 809b 	bls.w	8eaa0 <_svfprintf_r+0x14e4>
   8e96a:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   8e96e:	460b      	mov	r3, r1
   8e970:	e001      	b.n	8e976 <_svfprintf_r+0x13ba>
   8e972:	f813 eb01 	ldrb.w	lr, [r3], #1
   8e976:	4283      	cmp	r3, r0
   8e978:	f802 eb01 	strb.w	lr, [r2], #1
   8e97c:	d1f9      	bne.n	8e972 <_svfprintf_r+0x13b6>
   8e97e:	ab23      	add	r3, sp, #140	; 0x8c
   8e980:	1a5b      	subs	r3, r3, r1
   8e982:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   8e986:	4413      	add	r3, r2
   8e988:	aa1f      	add	r2, sp, #124	; 0x7c
   8e98a:	1a9b      	subs	r3, r3, r2
   8e98c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   8e98e:	9319      	str	r3, [sp, #100]	; 0x64
   8e990:	2a01      	cmp	r2, #1
   8e992:	4413      	add	r3, r2
   8e994:	930d      	str	r3, [sp, #52]	; 0x34
   8e996:	dd5e      	ble.n	8ea56 <_svfprintf_r+0x149a>
   8e998:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8e99a:	2200      	movs	r2, #0
   8e99c:	3301      	adds	r3, #1
   8e99e:	930d      	str	r3, [sp, #52]	; 0x34
   8e9a0:	9212      	str	r2, [sp, #72]	; 0x48
   8e9a2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8e9a6:	e6c2      	b.n	8e72e <_svfprintf_r+0x1172>
   8e9a8:	9808      	ldr	r0, [sp, #32]
   8e9aa:	4631      	mov	r1, r6
   8e9ac:	aa23      	add	r2, sp, #140	; 0x8c
   8e9ae:	f001 fd01 	bl	903b4 <__ssprint_r>
   8e9b2:	2800      	cmp	r0, #0
   8e9b4:	f47e aec8 	bne.w	8d748 <_svfprintf_r+0x18c>
   8e9b8:	463a      	mov	r2, r7
   8e9ba:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   8e9bc:	9925      	ldr	r1, [sp, #148]	; 0x94
   8e9be:	9b24      	ldr	r3, [sp, #144]	; 0x90
   8e9c0:	e600      	b.n	8e5c4 <_svfprintf_r+0x1008>
   8e9c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   8e9c4:	2b00      	cmp	r3, #0
   8e9c6:	bfd8      	it	le
   8e9c8:	f1c3 0802 	rsble	r8, r3, #2
   8e9cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8e9ce:	bfc8      	it	gt
   8e9d0:	f04f 0801 	movgt.w	r8, #1
   8e9d4:	4443      	add	r3, r8
   8e9d6:	930d      	str	r3, [sp, #52]	; 0x34
   8e9d8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8e9dc:	e6a7      	b.n	8e72e <_svfprintf_r+0x1172>
   8e9de:	2b00      	cmp	r3, #0
   8e9e0:	dd30      	ble.n	8ea44 <_svfprintf_r+0x1488>
   8e9e2:	f1bb 0f00 	cmp.w	fp, #0
   8e9e6:	d117      	bne.n	8ea18 <_svfprintf_r+0x145c>
   8e9e8:	9b07      	ldr	r3, [sp, #28]
   8e9ea:	07db      	lsls	r3, r3, #31
   8e9ec:	d414      	bmi.n	8ea18 <_svfprintf_r+0x145c>
   8e9ee:	9a12      	ldr	r2, [sp, #72]	; 0x48
   8e9f0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
   8e9f4:	920d      	str	r2, [sp, #52]	; 0x34
   8e9f6:	e69a      	b.n	8e72e <_svfprintf_r+0x1172>
   8e9f8:	9b21      	ldr	r3, [sp, #132]	; 0x84
   8e9fa:	e67d      	b.n	8e6f8 <_svfprintf_r+0x113c>
   8e9fc:	9809      	ldr	r0, [sp, #36]	; 0x24
   8e9fe:	4651      	mov	r1, sl
   8ea00:	2200      	movs	r2, #0
   8ea02:	2300      	movs	r3, #0
   8ea04:	f7fd fcbe 	bl	8c384 <__aeabi_dcmpeq>
   8ea08:	2800      	cmp	r0, #0
   8ea0a:	f47f af13 	bne.w	8e834 <_svfprintf_r+0x1278>
   8ea0e:	f1c9 0301 	rsb	r3, r9, #1
   8ea12:	931d      	str	r3, [sp, #116]	; 0x74
   8ea14:	4498      	add	r8, r3
   8ea16:	e65c      	b.n	8e6d2 <_svfprintf_r+0x1116>
   8ea18:	9b12      	ldr	r3, [sp, #72]	; 0x48
   8ea1a:	f10b 0801 	add.w	r8, fp, #1
   8ea1e:	4443      	add	r3, r8
   8ea20:	930d      	str	r3, [sp, #52]	; 0x34
   8ea22:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8ea26:	e682      	b.n	8e72e <_svfprintf_r+0x1172>
   8ea28:	3330      	adds	r3, #48	; 0x30
   8ea2a:	2230      	movs	r2, #48	; 0x30
   8ea2c:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
   8ea30:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
   8ea34:	ab20      	add	r3, sp, #128	; 0x80
   8ea36:	e7a7      	b.n	8e988 <_svfprintf_r+0x13cc>
   8ea38:	9b12      	ldr	r3, [sp, #72]	; 0x48
   8ea3a:	3301      	adds	r3, #1
   8ea3c:	930d      	str	r3, [sp, #52]	; 0x34
   8ea3e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8ea42:	e674      	b.n	8e72e <_svfprintf_r+0x1172>
   8ea44:	f1bb 0f00 	cmp.w	fp, #0
   8ea48:	d11d      	bne.n	8ea86 <_svfprintf_r+0x14ca>
   8ea4a:	9b07      	ldr	r3, [sp, #28]
   8ea4c:	07d8      	lsls	r0, r3, #31
   8ea4e:	d41a      	bmi.n	8ea86 <_svfprintf_r+0x14ca>
   8ea50:	2301      	movs	r3, #1
   8ea52:	930d      	str	r3, [sp, #52]	; 0x34
   8ea54:	e66b      	b.n	8e72e <_svfprintf_r+0x1172>
   8ea56:	9b07      	ldr	r3, [sp, #28]
   8ea58:	f013 0301 	ands.w	r3, r3, #1
   8ea5c:	d19c      	bne.n	8e998 <_svfprintf_r+0x13dc>
   8ea5e:	9312      	str	r3, [sp, #72]	; 0x48
   8ea60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8ea62:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8ea66:	e662      	b.n	8e72e <_svfprintf_r+0x1172>
   8ea68:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   8ea6a:	4628      	mov	r0, r5
   8ea6c:	f8d5 a000 	ldr.w	sl, [r5]
   8ea70:	3004      	adds	r0, #4
   8ea72:	f1ba 0f00 	cmp.w	sl, #0
   8ea76:	785d      	ldrb	r5, [r3, #1]
   8ea78:	900e      	str	r0, [sp, #56]	; 0x38
   8ea7a:	f6be adf2 	bge.w	8d662 <_svfprintf_r+0xa6>
   8ea7e:	f04f 3aff 	mov.w	sl, #4294967295
   8ea82:	f7fe bdee 	b.w	8d662 <_svfprintf_r+0xa6>
   8ea86:	f10b 0302 	add.w	r3, fp, #2
   8ea8a:	930d      	str	r3, [sp, #52]	; 0x34
   8ea8c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   8ea90:	e64d      	b.n	8e72e <_svfprintf_r+0x1172>
   8ea92:	9a08      	ldr	r2, [sp, #32]
   8ea94:	230c      	movs	r3, #12
   8ea96:	6013      	str	r3, [r2, #0]
   8ea98:	f04f 30ff 	mov.w	r0, #4294967295
   8ea9c:	f7fe be5e 	b.w	8d75c <_svfprintf_r+0x1a0>
   8eaa0:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
   8eaa4:	e770      	b.n	8e988 <_svfprintf_r+0x13cc>
   8eaa6:	bf00      	nop
   8eaa8:	000921b8 	.word	0x000921b8
   8eaac:	66666667 	.word	0x66666667

0008eab0 <register_fini>:
   8eab0:	4b02      	ldr	r3, [pc, #8]	; (8eabc <register_fini+0xc>)
   8eab2:	b113      	cbz	r3, 8eaba <register_fini+0xa>
   8eab4:	4802      	ldr	r0, [pc, #8]	; (8eac0 <register_fini+0x10>)
   8eab6:	f000 b805 	b.w	8eac4 <atexit>
   8eaba:	4770      	bx	lr
   8eabc:	00000000 	.word	0x00000000
   8eac0:	0008faa5 	.word	0x0008faa5

0008eac4 <atexit>:
   8eac4:	4601      	mov	r1, r0
   8eac6:	2000      	movs	r0, #0
   8eac8:	4602      	mov	r2, r0
   8eaca:	4603      	mov	r3, r0
   8eacc:	f001 bcf4 	b.w	904b8 <__register_exitproc>

0008ead0 <quorem>:
   8ead0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8ead4:	6903      	ldr	r3, [r0, #16]
   8ead6:	690f      	ldr	r7, [r1, #16]
   8ead8:	b083      	sub	sp, #12
   8eada:	429f      	cmp	r7, r3
   8eadc:	f300 808b 	bgt.w	8ebf6 <quorem+0x126>
   8eae0:	3f01      	subs	r7, #1
   8eae2:	f101 0614 	add.w	r6, r1, #20
   8eae6:	f100 0a14 	add.w	sl, r0, #20
   8eaea:	f856 3027 	ldr.w	r3, [r6, r7, lsl #2]
   8eaee:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
   8eaf2:	3301      	adds	r3, #1
   8eaf4:	fbb2 f8f3 	udiv	r8, r2, r3
   8eaf8:	00bb      	lsls	r3, r7, #2
   8eafa:	9300      	str	r3, [sp, #0]
   8eafc:	eb06 0903 	add.w	r9, r6, r3
   8eb00:	4453      	add	r3, sl
   8eb02:	9301      	str	r3, [sp, #4]
   8eb04:	f1b8 0f00 	cmp.w	r8, #0
   8eb08:	d03d      	beq.n	8eb86 <quorem+0xb6>
   8eb0a:	2300      	movs	r3, #0
   8eb0c:	461c      	mov	r4, r3
   8eb0e:	46b4      	mov	ip, r6
   8eb10:	46d6      	mov	lr, sl
   8eb12:	461a      	mov	r2, r3
   8eb14:	f85c bb04 	ldr.w	fp, [ip], #4
   8eb18:	f8de 5000 	ldr.w	r5, [lr]
   8eb1c:	fa1f f38b 	uxth.w	r3, fp
   8eb20:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
   8eb24:	fb03 2208 	mla	r2, r3, r8, r2
   8eb28:	fb0b f308 	mul.w	r3, fp, r8
   8eb2c:	eb03 4312 	add.w	r3, r3, r2, lsr #16
   8eb30:	b292      	uxth	r2, r2
   8eb32:	1aa4      	subs	r4, r4, r2
   8eb34:	fa1f fb83 	uxth.w	fp, r3
   8eb38:	b2aa      	uxth	r2, r5
   8eb3a:	4422      	add	r2, r4
   8eb3c:	ebcb 4415 	rsb	r4, fp, r5, lsr #16
   8eb40:	eb04 4422 	add.w	r4, r4, r2, asr #16
   8eb44:	b292      	uxth	r2, r2
   8eb46:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
   8eb4a:	45e1      	cmp	r9, ip
   8eb4c:	f84e 2b04 	str.w	r2, [lr], #4
   8eb50:	ea4f 4424 	mov.w	r4, r4, asr #16
   8eb54:	ea4f 4213 	mov.w	r2, r3, lsr #16
   8eb58:	d2dc      	bcs.n	8eb14 <quorem+0x44>
   8eb5a:	9b00      	ldr	r3, [sp, #0]
   8eb5c:	f85a 3003 	ldr.w	r3, [sl, r3]
   8eb60:	b98b      	cbnz	r3, 8eb86 <quorem+0xb6>
   8eb62:	9c01      	ldr	r4, [sp, #4]
   8eb64:	1f23      	subs	r3, r4, #4
   8eb66:	459a      	cmp	sl, r3
   8eb68:	d20c      	bcs.n	8eb84 <quorem+0xb4>
   8eb6a:	f854 3c04 	ldr.w	r3, [r4, #-4]
   8eb6e:	b94b      	cbnz	r3, 8eb84 <quorem+0xb4>
   8eb70:	f1a4 0308 	sub.w	r3, r4, #8
   8eb74:	e002      	b.n	8eb7c <quorem+0xac>
   8eb76:	681a      	ldr	r2, [r3, #0]
   8eb78:	3b04      	subs	r3, #4
   8eb7a:	b91a      	cbnz	r2, 8eb84 <quorem+0xb4>
   8eb7c:	459a      	cmp	sl, r3
   8eb7e:	f107 37ff 	add.w	r7, r7, #4294967295
   8eb82:	d3f8      	bcc.n	8eb76 <quorem+0xa6>
   8eb84:	6107      	str	r7, [r0, #16]
   8eb86:	4604      	mov	r4, r0
   8eb88:	f001 fb2a 	bl	901e0 <__mcmp>
   8eb8c:	2800      	cmp	r0, #0
   8eb8e:	db2e      	blt.n	8ebee <quorem+0x11e>
   8eb90:	2300      	movs	r3, #0
   8eb92:	4655      	mov	r5, sl
   8eb94:	4619      	mov	r1, r3
   8eb96:	f108 0801 	add.w	r8, r8, #1
   8eb9a:	f856 2b04 	ldr.w	r2, [r6], #4
   8eb9e:	682b      	ldr	r3, [r5, #0]
   8eba0:	b290      	uxth	r0, r2
   8eba2:	1a08      	subs	r0, r1, r0
   8eba4:	0c12      	lsrs	r2, r2, #16
   8eba6:	b299      	uxth	r1, r3
   8eba8:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
   8ebac:	1842      	adds	r2, r0, r1
   8ebae:	eb03 4322 	add.w	r3, r3, r2, asr #16
   8ebb2:	b292      	uxth	r2, r2
   8ebb4:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   8ebb8:	45b1      	cmp	r9, r6
   8ebba:	f845 2b04 	str.w	r2, [r5], #4
   8ebbe:	ea4f 4123 	mov.w	r1, r3, asr #16
   8ebc2:	d2ea      	bcs.n	8eb9a <quorem+0xca>
   8ebc4:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
   8ebc8:	eb0a 0387 	add.w	r3, sl, r7, lsl #2
   8ebcc:	b97a      	cbnz	r2, 8ebee <quorem+0x11e>
   8ebce:	1f1a      	subs	r2, r3, #4
   8ebd0:	4592      	cmp	sl, r2
   8ebd2:	d20b      	bcs.n	8ebec <quorem+0x11c>
   8ebd4:	f853 2c04 	ldr.w	r2, [r3, #-4]
   8ebd8:	b942      	cbnz	r2, 8ebec <quorem+0x11c>
   8ebda:	3b08      	subs	r3, #8
   8ebdc:	e002      	b.n	8ebe4 <quorem+0x114>
   8ebde:	681a      	ldr	r2, [r3, #0]
   8ebe0:	3b04      	subs	r3, #4
   8ebe2:	b91a      	cbnz	r2, 8ebec <quorem+0x11c>
   8ebe4:	459a      	cmp	sl, r3
   8ebe6:	f107 37ff 	add.w	r7, r7, #4294967295
   8ebea:	d3f8      	bcc.n	8ebde <quorem+0x10e>
   8ebec:	6127      	str	r7, [r4, #16]
   8ebee:	4640      	mov	r0, r8
   8ebf0:	b003      	add	sp, #12
   8ebf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8ebf6:	2000      	movs	r0, #0
   8ebf8:	b003      	add	sp, #12
   8ebfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8ebfe:	bf00      	nop

0008ec00 <_dtoa_r>:
   8ec00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8ec04:	6c01      	ldr	r1, [r0, #64]	; 0x40
   8ec06:	b099      	sub	sp, #100	; 0x64
   8ec08:	4604      	mov	r4, r0
   8ec0a:	e9cd 2302 	strd	r2, r3, [sp, #8]
   8ec0e:	9d25      	ldr	r5, [sp, #148]	; 0x94
   8ec10:	b141      	cbz	r1, 8ec24 <_dtoa_r+0x24>
   8ec12:	6c42      	ldr	r2, [r0, #68]	; 0x44
   8ec14:	2301      	movs	r3, #1
   8ec16:	4093      	lsls	r3, r2
   8ec18:	608b      	str	r3, [r1, #8]
   8ec1a:	604a      	str	r2, [r1, #4]
   8ec1c:	f001 f8f4 	bl	8fe08 <_Bfree>
   8ec20:	2300      	movs	r3, #0
   8ec22:	6423      	str	r3, [r4, #64]	; 0x40
   8ec24:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8ec28:	2b00      	cmp	r3, #0
   8ec2a:	4699      	mov	r9, r3
   8ec2c:	db36      	blt.n	8ec9c <_dtoa_r+0x9c>
   8ec2e:	2300      	movs	r3, #0
   8ec30:	602b      	str	r3, [r5, #0]
   8ec32:	4ba5      	ldr	r3, [pc, #660]	; (8eec8 <_dtoa_r+0x2c8>)
   8ec34:	461a      	mov	r2, r3
   8ec36:	ea09 0303 	and.w	r3, r9, r3
   8ec3a:	4293      	cmp	r3, r2
   8ec3c:	d017      	beq.n	8ec6e <_dtoa_r+0x6e>
   8ec3e:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   8ec42:	2200      	movs	r2, #0
   8ec44:	2300      	movs	r3, #0
   8ec46:	4630      	mov	r0, r6
   8ec48:	4639      	mov	r1, r7
   8ec4a:	f7fd fb9b 	bl	8c384 <__aeabi_dcmpeq>
   8ec4e:	4680      	mov	r8, r0
   8ec50:	2800      	cmp	r0, #0
   8ec52:	d02b      	beq.n	8ecac <_dtoa_r+0xac>
   8ec54:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8ec56:	2301      	movs	r3, #1
   8ec58:	6013      	str	r3, [r2, #0]
   8ec5a:	9b26      	ldr	r3, [sp, #152]	; 0x98
   8ec5c:	2b00      	cmp	r3, #0
   8ec5e:	f000 80cb 	beq.w	8edf8 <_dtoa_r+0x1f8>
   8ec62:	489a      	ldr	r0, [pc, #616]	; (8eecc <_dtoa_r+0x2cc>)
   8ec64:	6018      	str	r0, [r3, #0]
   8ec66:	3801      	subs	r0, #1
   8ec68:	b019      	add	sp, #100	; 0x64
   8ec6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8ec6e:	f242 730f 	movw	r3, #9999	; 0x270f
   8ec72:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8ec74:	6013      	str	r3, [r2, #0]
   8ec76:	9b02      	ldr	r3, [sp, #8]
   8ec78:	2b00      	cmp	r3, #0
   8ec7a:	f000 80a6 	beq.w	8edca <_dtoa_r+0x1ca>
   8ec7e:	4894      	ldr	r0, [pc, #592]	; (8eed0 <_dtoa_r+0x2d0>)
   8ec80:	9b26      	ldr	r3, [sp, #152]	; 0x98
   8ec82:	2b00      	cmp	r3, #0
   8ec84:	d0f0      	beq.n	8ec68 <_dtoa_r+0x68>
   8ec86:	78c3      	ldrb	r3, [r0, #3]
   8ec88:	2b00      	cmp	r3, #0
   8ec8a:	f000 80b7 	beq.w	8edfc <_dtoa_r+0x1fc>
   8ec8e:	f100 0308 	add.w	r3, r0, #8
   8ec92:	9a26      	ldr	r2, [sp, #152]	; 0x98
   8ec94:	6013      	str	r3, [r2, #0]
   8ec96:	b019      	add	sp, #100	; 0x64
   8ec98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8ec9c:	9a03      	ldr	r2, [sp, #12]
   8ec9e:	2301      	movs	r3, #1
   8eca0:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
   8eca4:	602b      	str	r3, [r5, #0]
   8eca6:	f8cd 900c 	str.w	r9, [sp, #12]
   8ecaa:	e7c2      	b.n	8ec32 <_dtoa_r+0x32>
   8ecac:	aa17      	add	r2, sp, #92	; 0x5c
   8ecae:	ab16      	add	r3, sp, #88	; 0x58
   8ecb0:	e88d 000c 	stmia.w	sp, {r2, r3}
   8ecb4:	4620      	mov	r0, r4
   8ecb6:	4632      	mov	r2, r6
   8ecb8:	463b      	mov	r3, r7
   8ecba:	f001 fb27 	bl	9030c <__d2b>
   8ecbe:	ea5f 5519 	movs.w	r5, r9, lsr #20
   8ecc2:	4683      	mov	fp, r0
   8ecc4:	f040 808a 	bne.w	8eddc <_dtoa_r+0x1dc>
   8ecc8:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   8eccc:	9d17      	ldr	r5, [sp, #92]	; 0x5c
   8ecce:	f46f 6382 	mvn.w	r3, #1040	; 0x410
   8ecd2:	4445      	add	r5, r8
   8ecd4:	429d      	cmp	r5, r3
   8ecd6:	f2c0 8295 	blt.w	8f204 <_dtoa_r+0x604>
   8ecda:	4a7e      	ldr	r2, [pc, #504]	; (8eed4 <_dtoa_r+0x2d4>)
   8ecdc:	f205 4312 	addw	r3, r5, #1042	; 0x412
   8ece0:	1b52      	subs	r2, r2, r5
   8ece2:	fa09 f902 	lsl.w	r9, r9, r2
   8ece6:	9a02      	ldr	r2, [sp, #8]
   8ece8:	fa22 f003 	lsr.w	r0, r2, r3
   8ecec:	ea49 0000 	orr.w	r0, r9, r0
   8ecf0:	f7fd f86a 	bl	8bdc8 <__aeabi_ui2d>
   8ecf4:	2301      	movs	r3, #1
   8ecf6:	3d01      	subs	r5, #1
   8ecf8:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
   8ecfc:	9312      	str	r3, [sp, #72]	; 0x48
   8ecfe:	2200      	movs	r2, #0
   8ed00:	4b75      	ldr	r3, [pc, #468]	; (8eed8 <_dtoa_r+0x2d8>)
   8ed02:	f7fc ff23 	bl	8bb4c <__aeabi_dsub>
   8ed06:	a36a      	add	r3, pc, #424	; (adr r3, 8eeb0 <_dtoa_r+0x2b0>)
   8ed08:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ed0c:	f7fd f8d2 	bl	8beb4 <__aeabi_dmul>
   8ed10:	a369      	add	r3, pc, #420	; (adr r3, 8eeb8 <_dtoa_r+0x2b8>)
   8ed12:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ed16:	f7fc ff1b 	bl	8bb50 <__adddf3>
   8ed1a:	4606      	mov	r6, r0
   8ed1c:	4628      	mov	r0, r5
   8ed1e:	460f      	mov	r7, r1
   8ed20:	f7fd f862 	bl	8bde8 <__aeabi_i2d>
   8ed24:	a366      	add	r3, pc, #408	; (adr r3, 8eec0 <_dtoa_r+0x2c0>)
   8ed26:	e9d3 2300 	ldrd	r2, r3, [r3]
   8ed2a:	f7fd f8c3 	bl	8beb4 <__aeabi_dmul>
   8ed2e:	4602      	mov	r2, r0
   8ed30:	460b      	mov	r3, r1
   8ed32:	4630      	mov	r0, r6
   8ed34:	4639      	mov	r1, r7
   8ed36:	f7fc ff0b 	bl	8bb50 <__adddf3>
   8ed3a:	4606      	mov	r6, r0
   8ed3c:	460f      	mov	r7, r1
   8ed3e:	f7fd fb53 	bl	8c3e8 <__aeabi_d2iz>
   8ed42:	4639      	mov	r1, r7
   8ed44:	9005      	str	r0, [sp, #20]
   8ed46:	2200      	movs	r2, #0
   8ed48:	4630      	mov	r0, r6
   8ed4a:	2300      	movs	r3, #0
   8ed4c:	f7fd fb24 	bl	8c398 <__aeabi_dcmplt>
   8ed50:	2800      	cmp	r0, #0
   8ed52:	f040 81a4 	bne.w	8f09e <_dtoa_r+0x49e>
   8ed56:	9b05      	ldr	r3, [sp, #20]
   8ed58:	2b16      	cmp	r3, #22
   8ed5a:	f200 819d 	bhi.w	8f098 <_dtoa_r+0x498>
   8ed5e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8ed62:	9805      	ldr	r0, [sp, #20]
   8ed64:	495d      	ldr	r1, [pc, #372]	; (8eedc <_dtoa_r+0x2dc>)
   8ed66:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
   8ed6a:	e9d1 0100 	ldrd	r0, r1, [r1]
   8ed6e:	f7fd fb31 	bl	8c3d4 <__aeabi_dcmpgt>
   8ed72:	2800      	cmp	r0, #0
   8ed74:	f000 8250 	beq.w	8f218 <_dtoa_r+0x618>
   8ed78:	9b05      	ldr	r3, [sp, #20]
   8ed7a:	3b01      	subs	r3, #1
   8ed7c:	9305      	str	r3, [sp, #20]
   8ed7e:	2300      	movs	r3, #0
   8ed80:	930c      	str	r3, [sp, #48]	; 0x30
   8ed82:	ebc5 0508 	rsb	r5, r5, r8
   8ed86:	f1b5 0a01 	subs.w	sl, r5, #1
   8ed8a:	f100 819f 	bmi.w	8f0cc <_dtoa_r+0x4cc>
   8ed8e:	2300      	movs	r3, #0
   8ed90:	9306      	str	r3, [sp, #24]
   8ed92:	9b05      	ldr	r3, [sp, #20]
   8ed94:	2b00      	cmp	r3, #0
   8ed96:	f2c0 8190 	blt.w	8f0ba <_dtoa_r+0x4ba>
   8ed9a:	449a      	add	sl, r3
   8ed9c:	930b      	str	r3, [sp, #44]	; 0x2c
   8ed9e:	2300      	movs	r3, #0
   8eda0:	9309      	str	r3, [sp, #36]	; 0x24
   8eda2:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8eda4:	2b09      	cmp	r3, #9
   8eda6:	d82b      	bhi.n	8ee00 <_dtoa_r+0x200>
   8eda8:	2b05      	cmp	r3, #5
   8edaa:	f340 8677 	ble.w	8fa9c <_dtoa_r+0xe9c>
   8edae:	3b04      	subs	r3, #4
   8edb0:	9322      	str	r3, [sp, #136]	; 0x88
   8edb2:	2500      	movs	r5, #0
   8edb4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8edb6:	3b02      	subs	r3, #2
   8edb8:	2b03      	cmp	r3, #3
   8edba:	f200 8655 	bhi.w	8fa68 <_dtoa_r+0xe68>
   8edbe:	e8df f013 	tbh	[pc, r3, lsl #1]
   8edc2:	03cf      	.short	0x03cf
   8edc4:	02b003c1 	.word	0x02b003c1
   8edc8:	066a      	.short	0x066a
   8edca:	4b41      	ldr	r3, [pc, #260]	; (8eed0 <_dtoa_r+0x2d0>)
   8edcc:	4a44      	ldr	r2, [pc, #272]	; (8eee0 <_dtoa_r+0x2e0>)
   8edce:	f3c9 0013 	ubfx	r0, r9, #0, #20
   8edd2:	2800      	cmp	r0, #0
   8edd4:	bf14      	ite	ne
   8edd6:	4618      	movne	r0, r3
   8edd8:	4610      	moveq	r0, r2
   8edda:	e751      	b.n	8ec80 <_dtoa_r+0x80>
   8eddc:	f3c7 0313 	ubfx	r3, r7, #0, #20
   8ede0:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
   8ede4:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
   8ede8:	4630      	mov	r0, r6
   8edea:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
   8edee:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
   8edf2:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   8edf6:	e782      	b.n	8ecfe <_dtoa_r+0xfe>
   8edf8:	483a      	ldr	r0, [pc, #232]	; (8eee4 <_dtoa_r+0x2e4>)
   8edfa:	e735      	b.n	8ec68 <_dtoa_r+0x68>
   8edfc:	1cc3      	adds	r3, r0, #3
   8edfe:	e748      	b.n	8ec92 <_dtoa_r+0x92>
   8ee00:	2100      	movs	r1, #0
   8ee02:	6461      	str	r1, [r4, #68]	; 0x44
   8ee04:	4620      	mov	r0, r4
   8ee06:	9122      	str	r1, [sp, #136]	; 0x88
   8ee08:	f000 ffd6 	bl	8fdb8 <_Balloc>
   8ee0c:	f04f 33ff 	mov.w	r3, #4294967295
   8ee10:	9a22      	ldr	r2, [sp, #136]	; 0x88
   8ee12:	9307      	str	r3, [sp, #28]
   8ee14:	930d      	str	r3, [sp, #52]	; 0x34
   8ee16:	2301      	movs	r3, #1
   8ee18:	9008      	str	r0, [sp, #32]
   8ee1a:	9223      	str	r2, [sp, #140]	; 0x8c
   8ee1c:	6420      	str	r0, [r4, #64]	; 0x40
   8ee1e:	930a      	str	r3, [sp, #40]	; 0x28
   8ee20:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   8ee22:	2b00      	cmp	r3, #0
   8ee24:	f2c0 80d0 	blt.w	8efc8 <_dtoa_r+0x3c8>
   8ee28:	9a05      	ldr	r2, [sp, #20]
   8ee2a:	2a0e      	cmp	r2, #14
   8ee2c:	f300 80cc 	bgt.w	8efc8 <_dtoa_r+0x3c8>
   8ee30:	4b2a      	ldr	r3, [pc, #168]	; (8eedc <_dtoa_r+0x2dc>)
   8ee32:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   8ee36:	e9d3 8900 	ldrd	r8, r9, [r3]
   8ee3a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   8ee3c:	2b00      	cmp	r3, #0
   8ee3e:	f2c0 8392 	blt.w	8f566 <_dtoa_r+0x966>
   8ee42:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   8ee46:	4642      	mov	r2, r8
   8ee48:	464b      	mov	r3, r9
   8ee4a:	4630      	mov	r0, r6
   8ee4c:	4639      	mov	r1, r7
   8ee4e:	f7fd f95b 	bl	8c108 <__aeabi_ddiv>
   8ee52:	f7fd fac9 	bl	8c3e8 <__aeabi_d2iz>
   8ee56:	4682      	mov	sl, r0
   8ee58:	f7fc ffc6 	bl	8bde8 <__aeabi_i2d>
   8ee5c:	4642      	mov	r2, r8
   8ee5e:	464b      	mov	r3, r9
   8ee60:	f7fd f828 	bl	8beb4 <__aeabi_dmul>
   8ee64:	4602      	mov	r2, r0
   8ee66:	460b      	mov	r3, r1
   8ee68:	4630      	mov	r0, r6
   8ee6a:	4639      	mov	r1, r7
   8ee6c:	f7fc fe6e 	bl	8bb4c <__aeabi_dsub>
   8ee70:	9e07      	ldr	r6, [sp, #28]
   8ee72:	9f08      	ldr	r7, [sp, #32]
   8ee74:	f10a 0530 	add.w	r5, sl, #48	; 0x30
   8ee78:	2e01      	cmp	r6, #1
   8ee7a:	703d      	strb	r5, [r7, #0]
   8ee7c:	4602      	mov	r2, r0
   8ee7e:	460b      	mov	r3, r1
   8ee80:	f107 0501 	add.w	r5, r7, #1
   8ee84:	d062      	beq.n	8ef4c <_dtoa_r+0x34c>
   8ee86:	2200      	movs	r2, #0
   8ee88:	4b17      	ldr	r3, [pc, #92]	; (8eee8 <_dtoa_r+0x2e8>)
   8ee8a:	f7fd f813 	bl	8beb4 <__aeabi_dmul>
   8ee8e:	2200      	movs	r2, #0
   8ee90:	2300      	movs	r3, #0
   8ee92:	4606      	mov	r6, r0
   8ee94:	460f      	mov	r7, r1
   8ee96:	f7fd fa75 	bl	8c384 <__aeabi_dcmpeq>
   8ee9a:	2800      	cmp	r0, #0
   8ee9c:	f040 8081 	bne.w	8efa2 <_dtoa_r+0x3a2>
   8eea0:	f8cd b008 	str.w	fp, [sp, #8]
   8eea4:	f8dd a020 	ldr.w	sl, [sp, #32]
   8eea8:	f8dd b01c 	ldr.w	fp, [sp, #28]
   8eeac:	9406      	str	r4, [sp, #24]
   8eeae:	e02a      	b.n	8ef06 <_dtoa_r+0x306>
   8eeb0:	636f4361 	.word	0x636f4361
   8eeb4:	3fd287a7 	.word	0x3fd287a7
   8eeb8:	8b60c8b3 	.word	0x8b60c8b3
   8eebc:	3fc68a28 	.word	0x3fc68a28
   8eec0:	509f79fb 	.word	0x509f79fb
   8eec4:	3fd34413 	.word	0x3fd34413
   8eec8:	7ff00000 	.word	0x7ff00000
   8eecc:	000917fd 	.word	0x000917fd
   8eed0:	000922d0 	.word	0x000922d0
   8eed4:	fffffc0e 	.word	0xfffffc0e
   8eed8:	3ff80000 	.word	0x3ff80000
   8eedc:	000922e0 	.word	0x000922e0
   8eee0:	000922c4 	.word	0x000922c4
   8eee4:	000917fc 	.word	0x000917fc
   8eee8:	40240000 	.word	0x40240000
   8eeec:	2200      	movs	r2, #0
   8eeee:	4bc8      	ldr	r3, [pc, #800]	; (8f210 <_dtoa_r+0x610>)
   8eef0:	f7fc ffe0 	bl	8beb4 <__aeabi_dmul>
   8eef4:	2200      	movs	r2, #0
   8eef6:	2300      	movs	r3, #0
   8eef8:	4606      	mov	r6, r0
   8eefa:	460f      	mov	r7, r1
   8eefc:	f7fd fa42 	bl	8c384 <__aeabi_dcmpeq>
   8ef00:	2800      	cmp	r0, #0
   8ef02:	f040 83e0 	bne.w	8f6c6 <_dtoa_r+0xac6>
   8ef06:	4642      	mov	r2, r8
   8ef08:	464b      	mov	r3, r9
   8ef0a:	4630      	mov	r0, r6
   8ef0c:	4639      	mov	r1, r7
   8ef0e:	f7fd f8fb 	bl	8c108 <__aeabi_ddiv>
   8ef12:	f7fd fa69 	bl	8c3e8 <__aeabi_d2iz>
   8ef16:	4604      	mov	r4, r0
   8ef18:	f7fc ff66 	bl	8bde8 <__aeabi_i2d>
   8ef1c:	4642      	mov	r2, r8
   8ef1e:	464b      	mov	r3, r9
   8ef20:	f7fc ffc8 	bl	8beb4 <__aeabi_dmul>
   8ef24:	4602      	mov	r2, r0
   8ef26:	460b      	mov	r3, r1
   8ef28:	4630      	mov	r0, r6
   8ef2a:	4639      	mov	r1, r7
   8ef2c:	f7fc fe0e 	bl	8bb4c <__aeabi_dsub>
   8ef30:	f104 0630 	add.w	r6, r4, #48	; 0x30
   8ef34:	f805 6b01 	strb.w	r6, [r5], #1
   8ef38:	ebca 0605 	rsb	r6, sl, r5
   8ef3c:	45b3      	cmp	fp, r6
   8ef3e:	4602      	mov	r2, r0
   8ef40:	460b      	mov	r3, r1
   8ef42:	d1d3      	bne.n	8eeec <_dtoa_r+0x2ec>
   8ef44:	46a2      	mov	sl, r4
   8ef46:	f8dd b008 	ldr.w	fp, [sp, #8]
   8ef4a:	9c06      	ldr	r4, [sp, #24]
   8ef4c:	4610      	mov	r0, r2
   8ef4e:	4619      	mov	r1, r3
   8ef50:	f7fc fdfe 	bl	8bb50 <__adddf3>
   8ef54:	4606      	mov	r6, r0
   8ef56:	460f      	mov	r7, r1
   8ef58:	4640      	mov	r0, r8
   8ef5a:	4649      	mov	r1, r9
   8ef5c:	4632      	mov	r2, r6
   8ef5e:	463b      	mov	r3, r7
   8ef60:	f7fd fa1a 	bl	8c398 <__aeabi_dcmplt>
   8ef64:	b948      	cbnz	r0, 8ef7a <_dtoa_r+0x37a>
   8ef66:	4640      	mov	r0, r8
   8ef68:	4649      	mov	r1, r9
   8ef6a:	4632      	mov	r2, r6
   8ef6c:	463b      	mov	r3, r7
   8ef6e:	f7fd fa09 	bl	8c384 <__aeabi_dcmpeq>
   8ef72:	b1b0      	cbz	r0, 8efa2 <_dtoa_r+0x3a2>
   8ef74:	f01a 0f01 	tst.w	sl, #1
   8ef78:	d013      	beq.n	8efa2 <_dtoa_r+0x3a2>
   8ef7a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
   8ef7e:	1e6b      	subs	r3, r5, #1
   8ef80:	9908      	ldr	r1, [sp, #32]
   8ef82:	e004      	b.n	8ef8e <_dtoa_r+0x38e>
   8ef84:	428b      	cmp	r3, r1
   8ef86:	f000 8445 	beq.w	8f814 <_dtoa_r+0xc14>
   8ef8a:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
   8ef8e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
   8ef92:	f103 0501 	add.w	r5, r3, #1
   8ef96:	461a      	mov	r2, r3
   8ef98:	d0f4      	beq.n	8ef84 <_dtoa_r+0x384>
   8ef9a:	f108 0301 	add.w	r3, r8, #1
   8ef9e:	b2db      	uxtb	r3, r3
   8efa0:	7013      	strb	r3, [r2, #0]
   8efa2:	4620      	mov	r0, r4
   8efa4:	4659      	mov	r1, fp
   8efa6:	f000 ff2f 	bl	8fe08 <_Bfree>
   8efaa:	2200      	movs	r2, #0
   8efac:	9b05      	ldr	r3, [sp, #20]
   8efae:	702a      	strb	r2, [r5, #0]
   8efb0:	9a24      	ldr	r2, [sp, #144]	; 0x90
   8efb2:	3301      	adds	r3, #1
   8efb4:	6013      	str	r3, [r2, #0]
   8efb6:	9b26      	ldr	r3, [sp, #152]	; 0x98
   8efb8:	2b00      	cmp	r3, #0
   8efba:	f000 834a 	beq.w	8f652 <_dtoa_r+0xa52>
   8efbe:	9808      	ldr	r0, [sp, #32]
   8efc0:	601d      	str	r5, [r3, #0]
   8efc2:	b019      	add	sp, #100	; 0x64
   8efc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8efc8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   8efca:	2a00      	cmp	r2, #0
   8efcc:	f000 8084 	beq.w	8f0d8 <_dtoa_r+0x4d8>
   8efd0:	9a22      	ldr	r2, [sp, #136]	; 0x88
   8efd2:	2a01      	cmp	r2, #1
   8efd4:	f340 8309 	ble.w	8f5ea <_dtoa_r+0x9ea>
   8efd8:	9b07      	ldr	r3, [sp, #28]
   8efda:	1e5f      	subs	r7, r3, #1
   8efdc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8efde:	42bb      	cmp	r3, r7
   8efe0:	f2c0 83af 	blt.w	8f742 <_dtoa_r+0xb42>
   8efe4:	1bdf      	subs	r7, r3, r7
   8efe6:	9b07      	ldr	r3, [sp, #28]
   8efe8:	2b00      	cmp	r3, #0
   8efea:	f2c0 84a5 	blt.w	8f938 <_dtoa_r+0xd38>
   8efee:	9d06      	ldr	r5, [sp, #24]
   8eff0:	9b07      	ldr	r3, [sp, #28]
   8eff2:	9a06      	ldr	r2, [sp, #24]
   8eff4:	4620      	mov	r0, r4
   8eff6:	441a      	add	r2, r3
   8eff8:	2101      	movs	r1, #1
   8effa:	9206      	str	r2, [sp, #24]
   8effc:	449a      	add	sl, r3
   8effe:	f000 ff9d 	bl	8ff3c <__i2b>
   8f002:	4606      	mov	r6, r0
   8f004:	b165      	cbz	r5, 8f020 <_dtoa_r+0x420>
   8f006:	f1ba 0f00 	cmp.w	sl, #0
   8f00a:	dd09      	ble.n	8f020 <_dtoa_r+0x420>
   8f00c:	45aa      	cmp	sl, r5
   8f00e:	4653      	mov	r3, sl
   8f010:	bfa8      	it	ge
   8f012:	462b      	movge	r3, r5
   8f014:	9a06      	ldr	r2, [sp, #24]
   8f016:	1aed      	subs	r5, r5, r3
   8f018:	1ad2      	subs	r2, r2, r3
   8f01a:	9206      	str	r2, [sp, #24]
   8f01c:	ebc3 0a0a 	rsb	sl, r3, sl
   8f020:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8f022:	2b00      	cmp	r3, #0
   8f024:	dd1a      	ble.n	8f05c <_dtoa_r+0x45c>
   8f026:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f028:	2b00      	cmp	r3, #0
   8f02a:	f000 8383 	beq.w	8f734 <_dtoa_r+0xb34>
   8f02e:	2f00      	cmp	r7, #0
   8f030:	dd10      	ble.n	8f054 <_dtoa_r+0x454>
   8f032:	4631      	mov	r1, r6
   8f034:	463a      	mov	r2, r7
   8f036:	4620      	mov	r0, r4
   8f038:	f001 f82a 	bl	90090 <__pow5mult>
   8f03c:	4606      	mov	r6, r0
   8f03e:	465a      	mov	r2, fp
   8f040:	4631      	mov	r1, r6
   8f042:	4620      	mov	r0, r4
   8f044:	f000 ff84 	bl	8ff50 <__multiply>
   8f048:	4680      	mov	r8, r0
   8f04a:	4659      	mov	r1, fp
   8f04c:	4620      	mov	r0, r4
   8f04e:	f000 fedb 	bl	8fe08 <_Bfree>
   8f052:	46c3      	mov	fp, r8
   8f054:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8f056:	1bda      	subs	r2, r3, r7
   8f058:	f040 82a7 	bne.w	8f5aa <_dtoa_r+0x9aa>
   8f05c:	4620      	mov	r0, r4
   8f05e:	2101      	movs	r1, #1
   8f060:	f000 ff6c 	bl	8ff3c <__i2b>
   8f064:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   8f066:	4680      	mov	r8, r0
   8f068:	2b00      	cmp	r3, #0
   8f06a:	dd39      	ble.n	8f0e0 <_dtoa_r+0x4e0>
   8f06c:	4601      	mov	r1, r0
   8f06e:	461a      	mov	r2, r3
   8f070:	4620      	mov	r0, r4
   8f072:	f001 f80d 	bl	90090 <__pow5mult>
   8f076:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8f078:	4680      	mov	r8, r0
   8f07a:	2b01      	cmp	r3, #1
   8f07c:	f340 829b 	ble.w	8f5b6 <_dtoa_r+0x9b6>
   8f080:	f04f 0900 	mov.w	r9, #0
   8f084:	f8d8 3010 	ldr.w	r3, [r8, #16]
   8f088:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   8f08c:	6918      	ldr	r0, [r3, #16]
   8f08e:	f000 ff07 	bl	8fea0 <__hi0bits>
   8f092:	f1c0 0020 	rsb	r0, r0, #32
   8f096:	e02d      	b.n	8f0f4 <_dtoa_r+0x4f4>
   8f098:	2301      	movs	r3, #1
   8f09a:	930c      	str	r3, [sp, #48]	; 0x30
   8f09c:	e671      	b.n	8ed82 <_dtoa_r+0x182>
   8f09e:	9805      	ldr	r0, [sp, #20]
   8f0a0:	f7fc fea2 	bl	8bde8 <__aeabi_i2d>
   8f0a4:	4632      	mov	r2, r6
   8f0a6:	463b      	mov	r3, r7
   8f0a8:	f7fd f96c 	bl	8c384 <__aeabi_dcmpeq>
   8f0ac:	2800      	cmp	r0, #0
   8f0ae:	f47f ae52 	bne.w	8ed56 <_dtoa_r+0x156>
   8f0b2:	9b05      	ldr	r3, [sp, #20]
   8f0b4:	3b01      	subs	r3, #1
   8f0b6:	9305      	str	r3, [sp, #20]
   8f0b8:	e64d      	b.n	8ed56 <_dtoa_r+0x156>
   8f0ba:	9a06      	ldr	r2, [sp, #24]
   8f0bc:	9b05      	ldr	r3, [sp, #20]
   8f0be:	1ad2      	subs	r2, r2, r3
   8f0c0:	425b      	negs	r3, r3
   8f0c2:	9309      	str	r3, [sp, #36]	; 0x24
   8f0c4:	2300      	movs	r3, #0
   8f0c6:	9206      	str	r2, [sp, #24]
   8f0c8:	930b      	str	r3, [sp, #44]	; 0x2c
   8f0ca:	e66a      	b.n	8eda2 <_dtoa_r+0x1a2>
   8f0cc:	f1ca 0300 	rsb	r3, sl, #0
   8f0d0:	9306      	str	r3, [sp, #24]
   8f0d2:	f04f 0a00 	mov.w	sl, #0
   8f0d6:	e65c      	b.n	8ed92 <_dtoa_r+0x192>
   8f0d8:	9f09      	ldr	r7, [sp, #36]	; 0x24
   8f0da:	9d06      	ldr	r5, [sp, #24]
   8f0dc:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   8f0de:	e791      	b.n	8f004 <_dtoa_r+0x404>
   8f0e0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8f0e2:	2b01      	cmp	r3, #1
   8f0e4:	f340 82b8 	ble.w	8f658 <_dtoa_r+0xa58>
   8f0e8:	f04f 0900 	mov.w	r9, #0
   8f0ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   8f0ee:	2b00      	cmp	r3, #0
   8f0f0:	d1c8      	bne.n	8f084 <_dtoa_r+0x484>
   8f0f2:	2001      	movs	r0, #1
   8f0f4:	4450      	add	r0, sl
   8f0f6:	f010 001f 	ands.w	r0, r0, #31
   8f0fa:	f000 8081 	beq.w	8f200 <_dtoa_r+0x600>
   8f0fe:	f1c0 0320 	rsb	r3, r0, #32
   8f102:	2b04      	cmp	r3, #4
   8f104:	f340 84c1 	ble.w	8fa8a <_dtoa_r+0xe8a>
   8f108:	f1c0 001c 	rsb	r0, r0, #28
   8f10c:	9b06      	ldr	r3, [sp, #24]
   8f10e:	4405      	add	r5, r0
   8f110:	4403      	add	r3, r0
   8f112:	9306      	str	r3, [sp, #24]
   8f114:	4482      	add	sl, r0
   8f116:	9b06      	ldr	r3, [sp, #24]
   8f118:	2b00      	cmp	r3, #0
   8f11a:	dd05      	ble.n	8f128 <_dtoa_r+0x528>
   8f11c:	4659      	mov	r1, fp
   8f11e:	461a      	mov	r2, r3
   8f120:	4620      	mov	r0, r4
   8f122:	f001 f805 	bl	90130 <__lshift>
   8f126:	4683      	mov	fp, r0
   8f128:	f1ba 0f00 	cmp.w	sl, #0
   8f12c:	dd05      	ble.n	8f13a <_dtoa_r+0x53a>
   8f12e:	4641      	mov	r1, r8
   8f130:	4652      	mov	r2, sl
   8f132:	4620      	mov	r0, r4
   8f134:	f000 fffc 	bl	90130 <__lshift>
   8f138:	4680      	mov	r8, r0
   8f13a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8f13c:	2b00      	cmp	r3, #0
   8f13e:	f040 826d 	bne.w	8f61c <_dtoa_r+0xa1c>
   8f142:	9b07      	ldr	r3, [sp, #28]
   8f144:	2b00      	cmp	r3, #0
   8f146:	f340 829b 	ble.w	8f680 <_dtoa_r+0xa80>
   8f14a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f14c:	2b00      	cmp	r3, #0
   8f14e:	d171      	bne.n	8f234 <_dtoa_r+0x634>
   8f150:	f8dd 9020 	ldr.w	r9, [sp, #32]
   8f154:	9f07      	ldr	r7, [sp, #28]
   8f156:	464d      	mov	r5, r9
   8f158:	e004      	b.n	8f164 <_dtoa_r+0x564>
   8f15a:	4659      	mov	r1, fp
   8f15c:	4620      	mov	r0, r4
   8f15e:	f000 fe5d 	bl	8fe1c <__multadd>
   8f162:	4683      	mov	fp, r0
   8f164:	4658      	mov	r0, fp
   8f166:	4641      	mov	r1, r8
   8f168:	f7ff fcb2 	bl	8ead0 <quorem>
   8f16c:	3030      	adds	r0, #48	; 0x30
   8f16e:	f805 0b01 	strb.w	r0, [r5], #1
   8f172:	ebc9 0305 	rsb	r3, r9, r5
   8f176:	42bb      	cmp	r3, r7
   8f178:	f04f 020a 	mov.w	r2, #10
   8f17c:	f04f 0300 	mov.w	r3, #0
   8f180:	dbeb      	blt.n	8f15a <_dtoa_r+0x55a>
   8f182:	9b08      	ldr	r3, [sp, #32]
   8f184:	9a07      	ldr	r2, [sp, #28]
   8f186:	4684      	mov	ip, r0
   8f188:	2a01      	cmp	r2, #1
   8f18a:	bfac      	ite	ge
   8f18c:	189b      	addge	r3, r3, r2
   8f18e:	3301      	addlt	r3, #1
   8f190:	461d      	mov	r5, r3
   8f192:	f04f 0a00 	mov.w	sl, #0
   8f196:	4659      	mov	r1, fp
   8f198:	2201      	movs	r2, #1
   8f19a:	4620      	mov	r0, r4
   8f19c:	f8cd c008 	str.w	ip, [sp, #8]
   8f1a0:	f000 ffc6 	bl	90130 <__lshift>
   8f1a4:	4641      	mov	r1, r8
   8f1a6:	4683      	mov	fp, r0
   8f1a8:	f001 f81a 	bl	901e0 <__mcmp>
   8f1ac:	2800      	cmp	r0, #0
   8f1ae:	f8dd c008 	ldr.w	ip, [sp, #8]
   8f1b2:	f340 82fc 	ble.w	8f7ae <_dtoa_r+0xbae>
   8f1b6:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   8f1ba:	1e6b      	subs	r3, r5, #1
   8f1bc:	9908      	ldr	r1, [sp, #32]
   8f1be:	e004      	b.n	8f1ca <_dtoa_r+0x5ca>
   8f1c0:	428b      	cmp	r3, r1
   8f1c2:	f000 8279 	beq.w	8f6b8 <_dtoa_r+0xab8>
   8f1c6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   8f1ca:	2a39      	cmp	r2, #57	; 0x39
   8f1cc:	f103 0501 	add.w	r5, r3, #1
   8f1d0:	d0f6      	beq.n	8f1c0 <_dtoa_r+0x5c0>
   8f1d2:	3201      	adds	r2, #1
   8f1d4:	701a      	strb	r2, [r3, #0]
   8f1d6:	4641      	mov	r1, r8
   8f1d8:	4620      	mov	r0, r4
   8f1da:	f000 fe15 	bl	8fe08 <_Bfree>
   8f1de:	2e00      	cmp	r6, #0
   8f1e0:	f43f aedf 	beq.w	8efa2 <_dtoa_r+0x3a2>
   8f1e4:	f1ba 0f00 	cmp.w	sl, #0
   8f1e8:	d005      	beq.n	8f1f6 <_dtoa_r+0x5f6>
   8f1ea:	45b2      	cmp	sl, r6
   8f1ec:	d003      	beq.n	8f1f6 <_dtoa_r+0x5f6>
   8f1ee:	4651      	mov	r1, sl
   8f1f0:	4620      	mov	r0, r4
   8f1f2:	f000 fe09 	bl	8fe08 <_Bfree>
   8f1f6:	4631      	mov	r1, r6
   8f1f8:	4620      	mov	r0, r4
   8f1fa:	f000 fe05 	bl	8fe08 <_Bfree>
   8f1fe:	e6d0      	b.n	8efa2 <_dtoa_r+0x3a2>
   8f200:	201c      	movs	r0, #28
   8f202:	e783      	b.n	8f10c <_dtoa_r+0x50c>
   8f204:	4b03      	ldr	r3, [pc, #12]	; (8f214 <_dtoa_r+0x614>)
   8f206:	9a02      	ldr	r2, [sp, #8]
   8f208:	1b5b      	subs	r3, r3, r5
   8f20a:	fa02 f003 	lsl.w	r0, r2, r3
   8f20e:	e56f      	b.n	8ecf0 <_dtoa_r+0xf0>
   8f210:	40240000 	.word	0x40240000
   8f214:	fffffbee 	.word	0xfffffbee
   8f218:	900c      	str	r0, [sp, #48]	; 0x30
   8f21a:	e5b2      	b.n	8ed82 <_dtoa_r+0x182>
   8f21c:	4631      	mov	r1, r6
   8f21e:	2300      	movs	r3, #0
   8f220:	4620      	mov	r0, r4
   8f222:	220a      	movs	r2, #10
   8f224:	f000 fdfa 	bl	8fe1c <__multadd>
   8f228:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8f22a:	4606      	mov	r6, r0
   8f22c:	2b00      	cmp	r3, #0
   8f22e:	f340 8415 	ble.w	8fa5c <_dtoa_r+0xe5c>
   8f232:	9307      	str	r3, [sp, #28]
   8f234:	2d00      	cmp	r5, #0
   8f236:	dd05      	ble.n	8f244 <_dtoa_r+0x644>
   8f238:	4631      	mov	r1, r6
   8f23a:	462a      	mov	r2, r5
   8f23c:	4620      	mov	r0, r4
   8f23e:	f000 ff77 	bl	90130 <__lshift>
   8f242:	4606      	mov	r6, r0
   8f244:	f1b9 0f00 	cmp.w	r9, #0
   8f248:	f040 82ee 	bne.w	8f828 <_dtoa_r+0xc28>
   8f24c:	46b1      	mov	r9, r6
   8f24e:	9a08      	ldr	r2, [sp, #32]
   8f250:	9b07      	ldr	r3, [sp, #28]
   8f252:	4617      	mov	r7, r2
   8f254:	3b01      	subs	r3, #1
   8f256:	18d3      	adds	r3, r2, r3
   8f258:	9309      	str	r3, [sp, #36]	; 0x24
   8f25a:	9b02      	ldr	r3, [sp, #8]
   8f25c:	f003 0301 	and.w	r3, r3, #1
   8f260:	930a      	str	r3, [sp, #40]	; 0x28
   8f262:	4641      	mov	r1, r8
   8f264:	4658      	mov	r0, fp
   8f266:	f7ff fc33 	bl	8ead0 <quorem>
   8f26a:	4631      	mov	r1, r6
   8f26c:	4605      	mov	r5, r0
   8f26e:	4658      	mov	r0, fp
   8f270:	f000 ffb6 	bl	901e0 <__mcmp>
   8f274:	464a      	mov	r2, r9
   8f276:	4682      	mov	sl, r0
   8f278:	4641      	mov	r1, r8
   8f27a:	4620      	mov	r0, r4
   8f27c:	f000 ffd4 	bl	90228 <__mdiff>
   8f280:	68c2      	ldr	r2, [r0, #12]
   8f282:	4603      	mov	r3, r0
   8f284:	f105 0c30 	add.w	ip, r5, #48	; 0x30
   8f288:	2a00      	cmp	r2, #0
   8f28a:	f040 81bd 	bne.w	8f608 <_dtoa_r+0xa08>
   8f28e:	4619      	mov	r1, r3
   8f290:	4658      	mov	r0, fp
   8f292:	f8cd c01c 	str.w	ip, [sp, #28]
   8f296:	9306      	str	r3, [sp, #24]
   8f298:	f000 ffa2 	bl	901e0 <__mcmp>
   8f29c:	9b06      	ldr	r3, [sp, #24]
   8f29e:	9002      	str	r0, [sp, #8]
   8f2a0:	4619      	mov	r1, r3
   8f2a2:	4620      	mov	r0, r4
   8f2a4:	f000 fdb0 	bl	8fe08 <_Bfree>
   8f2a8:	9a02      	ldr	r2, [sp, #8]
   8f2aa:	f8dd c01c 	ldr.w	ip, [sp, #28]
   8f2ae:	b92a      	cbnz	r2, 8f2bc <_dtoa_r+0x6bc>
   8f2b0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8f2b2:	b91b      	cbnz	r3, 8f2bc <_dtoa_r+0x6bc>
   8f2b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f2b6:	2b00      	cmp	r3, #0
   8f2b8:	f000 83b0 	beq.w	8fa1c <_dtoa_r+0xe1c>
   8f2bc:	f1ba 0f00 	cmp.w	sl, #0
   8f2c0:	f2c0 8257 	blt.w	8f772 <_dtoa_r+0xb72>
   8f2c4:	d105      	bne.n	8f2d2 <_dtoa_r+0x6d2>
   8f2c6:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8f2c8:	b91b      	cbnz	r3, 8f2d2 <_dtoa_r+0x6d2>
   8f2ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f2cc:	2b00      	cmp	r3, #0
   8f2ce:	f000 8250 	beq.w	8f772 <_dtoa_r+0xb72>
   8f2d2:	2a00      	cmp	r2, #0
   8f2d4:	f300 82bc 	bgt.w	8f850 <_dtoa_r+0xc50>
   8f2d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8f2da:	f107 0a01 	add.w	sl, r7, #1
   8f2de:	429f      	cmp	r7, r3
   8f2e0:	f887 c000 	strb.w	ip, [r7]
   8f2e4:	4655      	mov	r5, sl
   8f2e6:	f000 82bf 	beq.w	8f868 <_dtoa_r+0xc68>
   8f2ea:	4659      	mov	r1, fp
   8f2ec:	220a      	movs	r2, #10
   8f2ee:	2300      	movs	r3, #0
   8f2f0:	4620      	mov	r0, r4
   8f2f2:	f000 fd93 	bl	8fe1c <__multadd>
   8f2f6:	454e      	cmp	r6, r9
   8f2f8:	4683      	mov	fp, r0
   8f2fa:	4631      	mov	r1, r6
   8f2fc:	4620      	mov	r0, r4
   8f2fe:	f04f 020a 	mov.w	r2, #10
   8f302:	f04f 0300 	mov.w	r3, #0
   8f306:	f000 8179 	beq.w	8f5fc <_dtoa_r+0x9fc>
   8f30a:	f000 fd87 	bl	8fe1c <__multadd>
   8f30e:	4649      	mov	r1, r9
   8f310:	4606      	mov	r6, r0
   8f312:	220a      	movs	r2, #10
   8f314:	4620      	mov	r0, r4
   8f316:	2300      	movs	r3, #0
   8f318:	f000 fd80 	bl	8fe1c <__multadd>
   8f31c:	4657      	mov	r7, sl
   8f31e:	4681      	mov	r9, r0
   8f320:	e79f      	b.n	8f262 <_dtoa_r+0x662>
   8f322:	2301      	movs	r3, #1
   8f324:	930a      	str	r3, [sp, #40]	; 0x28
   8f326:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   8f328:	2b00      	cmp	r3, #0
   8f32a:	f340 8219 	ble.w	8f760 <_dtoa_r+0xb60>
   8f32e:	461f      	mov	r7, r3
   8f330:	461e      	mov	r6, r3
   8f332:	930d      	str	r3, [sp, #52]	; 0x34
   8f334:	9307      	str	r3, [sp, #28]
   8f336:	2100      	movs	r1, #0
   8f338:	2f17      	cmp	r7, #23
   8f33a:	6461      	str	r1, [r4, #68]	; 0x44
   8f33c:	d90a      	bls.n	8f354 <_dtoa_r+0x754>
   8f33e:	2201      	movs	r2, #1
   8f340:	2304      	movs	r3, #4
   8f342:	005b      	lsls	r3, r3, #1
   8f344:	f103 0014 	add.w	r0, r3, #20
   8f348:	4287      	cmp	r7, r0
   8f34a:	4611      	mov	r1, r2
   8f34c:	f102 0201 	add.w	r2, r2, #1
   8f350:	d2f7      	bcs.n	8f342 <_dtoa_r+0x742>
   8f352:	6461      	str	r1, [r4, #68]	; 0x44
   8f354:	4620      	mov	r0, r4
   8f356:	f000 fd2f 	bl	8fdb8 <_Balloc>
   8f35a:	2e0e      	cmp	r6, #14
   8f35c:	9008      	str	r0, [sp, #32]
   8f35e:	6420      	str	r0, [r4, #64]	; 0x40
   8f360:	f63f ad5e 	bhi.w	8ee20 <_dtoa_r+0x220>
   8f364:	2d00      	cmp	r5, #0
   8f366:	f43f ad5b 	beq.w	8ee20 <_dtoa_r+0x220>
   8f36a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8f36e:	9905      	ldr	r1, [sp, #20]
   8f370:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   8f374:	2900      	cmp	r1, #0
   8f376:	f340 8226 	ble.w	8f7c6 <_dtoa_r+0xbc6>
   8f37a:	4bba      	ldr	r3, [pc, #744]	; (8f664 <_dtoa_r+0xa64>)
   8f37c:	f001 020f 	and.w	r2, r1, #15
   8f380:	110d      	asrs	r5, r1, #4
   8f382:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   8f386:	06e9      	lsls	r1, r5, #27
   8f388:	e9d3 6700 	ldrd	r6, r7, [r3]
   8f38c:	f140 81e1 	bpl.w	8f752 <_dtoa_r+0xb52>
   8f390:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   8f394:	4bb4      	ldr	r3, [pc, #720]	; (8f668 <_dtoa_r+0xa68>)
   8f396:	f005 050f 	and.w	r5, r5, #15
   8f39a:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   8f39e:	f7fc feb3 	bl	8c108 <__aeabi_ddiv>
   8f3a2:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8f3a6:	f04f 0803 	mov.w	r8, #3
   8f3aa:	b18d      	cbz	r5, 8f3d0 <_dtoa_r+0x7d0>
   8f3ac:	4630      	mov	r0, r6
   8f3ae:	4639      	mov	r1, r7
   8f3b0:	f8df 92b4 	ldr.w	r9, [pc, #692]	; 8f668 <_dtoa_r+0xa68>
   8f3b4:	07ea      	lsls	r2, r5, #31
   8f3b6:	d505      	bpl.n	8f3c4 <_dtoa_r+0x7c4>
   8f3b8:	e9d9 2300 	ldrd	r2, r3, [r9]
   8f3bc:	f7fc fd7a 	bl	8beb4 <__aeabi_dmul>
   8f3c0:	f108 0801 	add.w	r8, r8, #1
   8f3c4:	106d      	asrs	r5, r5, #1
   8f3c6:	f109 0908 	add.w	r9, r9, #8
   8f3ca:	d1f3      	bne.n	8f3b4 <_dtoa_r+0x7b4>
   8f3cc:	4606      	mov	r6, r0
   8f3ce:	460f      	mov	r7, r1
   8f3d0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8f3d4:	4632      	mov	r2, r6
   8f3d6:	463b      	mov	r3, r7
   8f3d8:	f7fc fe96 	bl	8c108 <__aeabi_ddiv>
   8f3dc:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8f3e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   8f3e2:	b143      	cbz	r3, 8f3f6 <_dtoa_r+0x7f6>
   8f3e4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8f3e8:	2200      	movs	r2, #0
   8f3ea:	4ba0      	ldr	r3, [pc, #640]	; (8f66c <_dtoa_r+0xa6c>)
   8f3ec:	f7fc ffd4 	bl	8c398 <__aeabi_dcmplt>
   8f3f0:	2800      	cmp	r0, #0
   8f3f2:	f040 82b5 	bne.w	8f960 <_dtoa_r+0xd60>
   8f3f6:	4640      	mov	r0, r8
   8f3f8:	f7fc fcf6 	bl	8bde8 <__aeabi_i2d>
   8f3fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8f400:	f7fc fd58 	bl	8beb4 <__aeabi_dmul>
   8f404:	4b9a      	ldr	r3, [pc, #616]	; (8f670 <_dtoa_r+0xa70>)
   8f406:	2200      	movs	r2, #0
   8f408:	f7fc fba2 	bl	8bb50 <__adddf3>
   8f40c:	9b07      	ldr	r3, [sp, #28]
   8f40e:	4606      	mov	r6, r0
   8f410:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   8f414:	2b00      	cmp	r3, #0
   8f416:	f000 8168 	beq.w	8f6ea <_dtoa_r+0xaea>
   8f41a:	9b05      	ldr	r3, [sp, #20]
   8f41c:	f8dd c01c 	ldr.w	ip, [sp, #28]
   8f420:	9313      	str	r3, [sp, #76]	; 0x4c
   8f422:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f424:	2b00      	cmp	r3, #0
   8f426:	f000 8226 	beq.w	8f876 <_dtoa_r+0xc76>
   8f42a:	4b8e      	ldr	r3, [pc, #568]	; (8f664 <_dtoa_r+0xa64>)
   8f42c:	2000      	movs	r0, #0
   8f42e:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
   8f432:	e953 2302 	ldrd	r2, r3, [r3, #-8]
   8f436:	498f      	ldr	r1, [pc, #572]	; (8f674 <_dtoa_r+0xa74>)
   8f438:	f8cd c050 	str.w	ip, [sp, #80]	; 0x50
   8f43c:	f7fc fe64 	bl	8c108 <__aeabi_ddiv>
   8f440:	4632      	mov	r2, r6
   8f442:	463b      	mov	r3, r7
   8f444:	f7fc fb82 	bl	8bb4c <__aeabi_dsub>
   8f448:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   8f44c:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   8f450:	4639      	mov	r1, r7
   8f452:	4630      	mov	r0, r6
   8f454:	f7fc ffc8 	bl	8c3e8 <__aeabi_d2iz>
   8f458:	4605      	mov	r5, r0
   8f45a:	f7fc fcc5 	bl	8bde8 <__aeabi_i2d>
   8f45e:	4602      	mov	r2, r0
   8f460:	460b      	mov	r3, r1
   8f462:	4630      	mov	r0, r6
   8f464:	4639      	mov	r1, r7
   8f466:	f7fc fb71 	bl	8bb4c <__aeabi_dsub>
   8f46a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   8f46e:	3530      	adds	r5, #48	; 0x30
   8f470:	fa5f f885 	uxtb.w	r8, r5
   8f474:	9d08      	ldr	r5, [sp, #32]
   8f476:	4606      	mov	r6, r0
   8f478:	f885 8000 	strb.w	r8, [r5]
   8f47c:	460f      	mov	r7, r1
   8f47e:	3501      	adds	r5, #1
   8f480:	f7fc ff8a 	bl	8c398 <__aeabi_dcmplt>
   8f484:	2800      	cmp	r0, #0
   8f486:	f040 82b9 	bne.w	8f9fc <_dtoa_r+0xdfc>
   8f48a:	4632      	mov	r2, r6
   8f48c:	463b      	mov	r3, r7
   8f48e:	2000      	movs	r0, #0
   8f490:	4976      	ldr	r1, [pc, #472]	; (8f66c <_dtoa_r+0xa6c>)
   8f492:	f7fc fb5b 	bl	8bb4c <__aeabi_dsub>
   8f496:	4602      	mov	r2, r0
   8f498:	460b      	mov	r3, r1
   8f49a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   8f49e:	f7fc ff99 	bl	8c3d4 <__aeabi_dcmpgt>
   8f4a2:	2800      	cmp	r0, #0
   8f4a4:	f040 82b3 	bne.w	8fa0e <_dtoa_r+0xe0e>
   8f4a8:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
   8f4ac:	f1bc 0f01 	cmp.w	ip, #1
   8f4b0:	f340 813a 	ble.w	8f728 <_dtoa_r+0xb28>
   8f4b4:	9b08      	ldr	r3, [sp, #32]
   8f4b6:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
   8f4ba:	f8cd b008 	str.w	fp, [sp, #8]
   8f4be:	eb03 090c 	add.w	r9, r3, ip
   8f4c2:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
   8f4c6:	46a0      	mov	r8, r4
   8f4c8:	e00f      	b.n	8f4ea <_dtoa_r+0x8ea>
   8f4ca:	4632      	mov	r2, r6
   8f4cc:	463b      	mov	r3, r7
   8f4ce:	2000      	movs	r0, #0
   8f4d0:	4966      	ldr	r1, [pc, #408]	; (8f66c <_dtoa_r+0xa6c>)
   8f4d2:	f7fc fb3b 	bl	8bb4c <__aeabi_dsub>
   8f4d6:	4652      	mov	r2, sl
   8f4d8:	465b      	mov	r3, fp
   8f4da:	f7fc ff5d 	bl	8c398 <__aeabi_dcmplt>
   8f4de:	2800      	cmp	r0, #0
   8f4e0:	f040 8290 	bne.w	8fa04 <_dtoa_r+0xe04>
   8f4e4:	454d      	cmp	r5, r9
   8f4e6:	f000 811a 	beq.w	8f71e <_dtoa_r+0xb1e>
   8f4ea:	4650      	mov	r0, sl
   8f4ec:	4659      	mov	r1, fp
   8f4ee:	2200      	movs	r2, #0
   8f4f0:	4b61      	ldr	r3, [pc, #388]	; (8f678 <_dtoa_r+0xa78>)
   8f4f2:	f7fc fcdf 	bl	8beb4 <__aeabi_dmul>
   8f4f6:	2200      	movs	r2, #0
   8f4f8:	4b5f      	ldr	r3, [pc, #380]	; (8f678 <_dtoa_r+0xa78>)
   8f4fa:	4682      	mov	sl, r0
   8f4fc:	468b      	mov	fp, r1
   8f4fe:	4630      	mov	r0, r6
   8f500:	4639      	mov	r1, r7
   8f502:	f7fc fcd7 	bl	8beb4 <__aeabi_dmul>
   8f506:	460f      	mov	r7, r1
   8f508:	4606      	mov	r6, r0
   8f50a:	f7fc ff6d 	bl	8c3e8 <__aeabi_d2iz>
   8f50e:	4604      	mov	r4, r0
   8f510:	f7fc fc6a 	bl	8bde8 <__aeabi_i2d>
   8f514:	4602      	mov	r2, r0
   8f516:	460b      	mov	r3, r1
   8f518:	4630      	mov	r0, r6
   8f51a:	4639      	mov	r1, r7
   8f51c:	f7fc fb16 	bl	8bb4c <__aeabi_dsub>
   8f520:	3430      	adds	r4, #48	; 0x30
   8f522:	b2e4      	uxtb	r4, r4
   8f524:	f805 4b01 	strb.w	r4, [r5], #1
   8f528:	4652      	mov	r2, sl
   8f52a:	465b      	mov	r3, fp
   8f52c:	4606      	mov	r6, r0
   8f52e:	460f      	mov	r7, r1
   8f530:	f7fc ff32 	bl	8c398 <__aeabi_dcmplt>
   8f534:	2800      	cmp	r0, #0
   8f536:	d0c8      	beq.n	8f4ca <_dtoa_r+0x8ca>
   8f538:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8f53a:	f8dd b008 	ldr.w	fp, [sp, #8]
   8f53e:	4644      	mov	r4, r8
   8f540:	9305      	str	r3, [sp, #20]
   8f542:	e52e      	b.n	8efa2 <_dtoa_r+0x3a2>
   8f544:	2300      	movs	r3, #0
   8f546:	930a      	str	r3, [sp, #40]	; 0x28
   8f548:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   8f54a:	9a05      	ldr	r2, [sp, #20]
   8f54c:	4413      	add	r3, r2
   8f54e:	930d      	str	r3, [sp, #52]	; 0x34
   8f550:	3301      	adds	r3, #1
   8f552:	2b00      	cmp	r3, #0
   8f554:	9307      	str	r3, [sp, #28]
   8f556:	f340 810a 	ble.w	8f76e <_dtoa_r+0xb6e>
   8f55a:	9e07      	ldr	r6, [sp, #28]
   8f55c:	4637      	mov	r7, r6
   8f55e:	e6ea      	b.n	8f336 <_dtoa_r+0x736>
   8f560:	2300      	movs	r3, #0
   8f562:	930a      	str	r3, [sp, #40]	; 0x28
   8f564:	e6df      	b.n	8f326 <_dtoa_r+0x726>
   8f566:	9b07      	ldr	r3, [sp, #28]
   8f568:	2b00      	cmp	r3, #0
   8f56a:	f73f ac6a 	bgt.w	8ee42 <_dtoa_r+0x242>
   8f56e:	f040 8266 	bne.w	8fa3e <_dtoa_r+0xe3e>
   8f572:	4640      	mov	r0, r8
   8f574:	2200      	movs	r2, #0
   8f576:	4b41      	ldr	r3, [pc, #260]	; (8f67c <_dtoa_r+0xa7c>)
   8f578:	4649      	mov	r1, r9
   8f57a:	f7fc fc9b 	bl	8beb4 <__aeabi_dmul>
   8f57e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8f582:	f7fc ff1d 	bl	8c3c0 <__aeabi_dcmpge>
   8f586:	f8dd 801c 	ldr.w	r8, [sp, #28]
   8f58a:	4646      	mov	r6, r8
   8f58c:	2800      	cmp	r0, #0
   8f58e:	f000 808b 	beq.w	8f6a8 <_dtoa_r+0xaa8>
   8f592:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   8f594:	9d08      	ldr	r5, [sp, #32]
   8f596:	43db      	mvns	r3, r3
   8f598:	9305      	str	r3, [sp, #20]
   8f59a:	4641      	mov	r1, r8
   8f59c:	4620      	mov	r0, r4
   8f59e:	f000 fc33 	bl	8fe08 <_Bfree>
   8f5a2:	2e00      	cmp	r6, #0
   8f5a4:	f47f ae27 	bne.w	8f1f6 <_dtoa_r+0x5f6>
   8f5a8:	e4fb      	b.n	8efa2 <_dtoa_r+0x3a2>
   8f5aa:	4659      	mov	r1, fp
   8f5ac:	4620      	mov	r0, r4
   8f5ae:	f000 fd6f 	bl	90090 <__pow5mult>
   8f5b2:	4683      	mov	fp, r0
   8f5b4:	e552      	b.n	8f05c <_dtoa_r+0x45c>
   8f5b6:	9b02      	ldr	r3, [sp, #8]
   8f5b8:	2b00      	cmp	r3, #0
   8f5ba:	f47f ad61 	bne.w	8f080 <_dtoa_r+0x480>
   8f5be:	9b03      	ldr	r3, [sp, #12]
   8f5c0:	f3c3 0313 	ubfx	r3, r3, #0, #20
   8f5c4:	2b00      	cmp	r3, #0
   8f5c6:	f47f ad8f 	bne.w	8f0e8 <_dtoa_r+0x4e8>
   8f5ca:	9b03      	ldr	r3, [sp, #12]
   8f5cc:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
   8f5d0:	0d3f      	lsrs	r7, r7, #20
   8f5d2:	053f      	lsls	r7, r7, #20
   8f5d4:	2f00      	cmp	r7, #0
   8f5d6:	f000 821e 	beq.w	8fa16 <_dtoa_r+0xe16>
   8f5da:	9b06      	ldr	r3, [sp, #24]
   8f5dc:	f10a 0a01 	add.w	sl, sl, #1
   8f5e0:	3301      	adds	r3, #1
   8f5e2:	9306      	str	r3, [sp, #24]
   8f5e4:	f04f 0901 	mov.w	r9, #1
   8f5e8:	e580      	b.n	8f0ec <_dtoa_r+0x4ec>
   8f5ea:	9a12      	ldr	r2, [sp, #72]	; 0x48
   8f5ec:	2a00      	cmp	r2, #0
   8f5ee:	f000 81a9 	beq.w	8f944 <_dtoa_r+0xd44>
   8f5f2:	f203 4333 	addw	r3, r3, #1075	; 0x433
   8f5f6:	9f09      	ldr	r7, [sp, #36]	; 0x24
   8f5f8:	9d06      	ldr	r5, [sp, #24]
   8f5fa:	e4fa      	b.n	8eff2 <_dtoa_r+0x3f2>
   8f5fc:	f000 fc0e 	bl	8fe1c <__multadd>
   8f600:	4657      	mov	r7, sl
   8f602:	4606      	mov	r6, r0
   8f604:	4681      	mov	r9, r0
   8f606:	e62c      	b.n	8f262 <_dtoa_r+0x662>
   8f608:	4601      	mov	r1, r0
   8f60a:	4620      	mov	r0, r4
   8f60c:	f8cd c008 	str.w	ip, [sp, #8]
   8f610:	f000 fbfa 	bl	8fe08 <_Bfree>
   8f614:	2201      	movs	r2, #1
   8f616:	f8dd c008 	ldr.w	ip, [sp, #8]
   8f61a:	e64f      	b.n	8f2bc <_dtoa_r+0x6bc>
   8f61c:	4658      	mov	r0, fp
   8f61e:	4641      	mov	r1, r8
   8f620:	f000 fdde 	bl	901e0 <__mcmp>
   8f624:	2800      	cmp	r0, #0
   8f626:	f6bf ad8c 	bge.w	8f142 <_dtoa_r+0x542>
   8f62a:	9f05      	ldr	r7, [sp, #20]
   8f62c:	4659      	mov	r1, fp
   8f62e:	2300      	movs	r3, #0
   8f630:	4620      	mov	r0, r4
   8f632:	220a      	movs	r2, #10
   8f634:	3f01      	subs	r7, #1
   8f636:	9705      	str	r7, [sp, #20]
   8f638:	f000 fbf0 	bl	8fe1c <__multadd>
   8f63c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   8f63e:	4683      	mov	fp, r0
   8f640:	2b00      	cmp	r3, #0
   8f642:	f47f adeb 	bne.w	8f21c <_dtoa_r+0x61c>
   8f646:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8f648:	2b00      	cmp	r3, #0
   8f64a:	f340 81fc 	ble.w	8fa46 <_dtoa_r+0xe46>
   8f64e:	9307      	str	r3, [sp, #28]
   8f650:	e57e      	b.n	8f150 <_dtoa_r+0x550>
   8f652:	9808      	ldr	r0, [sp, #32]
   8f654:	f7ff bb08 	b.w	8ec68 <_dtoa_r+0x68>
   8f658:	9b02      	ldr	r3, [sp, #8]
   8f65a:	2b00      	cmp	r3, #0
   8f65c:	f47f ad44 	bne.w	8f0e8 <_dtoa_r+0x4e8>
   8f660:	e7ad      	b.n	8f5be <_dtoa_r+0x9be>
   8f662:	bf00      	nop
   8f664:	000922e0 	.word	0x000922e0
   8f668:	000923b8 	.word	0x000923b8
   8f66c:	3ff00000 	.word	0x3ff00000
   8f670:	401c0000 	.word	0x401c0000
   8f674:	3fe00000 	.word	0x3fe00000
   8f678:	40240000 	.word	0x40240000
   8f67c:	40140000 	.word	0x40140000
   8f680:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8f682:	2b02      	cmp	r3, #2
   8f684:	f77f ad61 	ble.w	8f14a <_dtoa_r+0x54a>
   8f688:	9b07      	ldr	r3, [sp, #28]
   8f68a:	2b00      	cmp	r3, #0
   8f68c:	d181      	bne.n	8f592 <_dtoa_r+0x992>
   8f68e:	4641      	mov	r1, r8
   8f690:	2205      	movs	r2, #5
   8f692:	4620      	mov	r0, r4
   8f694:	f000 fbc2 	bl	8fe1c <__multadd>
   8f698:	4680      	mov	r8, r0
   8f69a:	4658      	mov	r0, fp
   8f69c:	4641      	mov	r1, r8
   8f69e:	f000 fd9f 	bl	901e0 <__mcmp>
   8f6a2:	2800      	cmp	r0, #0
   8f6a4:	f77f af75 	ble.w	8f592 <_dtoa_r+0x992>
   8f6a8:	9a05      	ldr	r2, [sp, #20]
   8f6aa:	9908      	ldr	r1, [sp, #32]
   8f6ac:	2331      	movs	r3, #49	; 0x31
   8f6ae:	3201      	adds	r2, #1
   8f6b0:	9205      	str	r2, [sp, #20]
   8f6b2:	700b      	strb	r3, [r1, #0]
   8f6b4:	1c4d      	adds	r5, r1, #1
   8f6b6:	e770      	b.n	8f59a <_dtoa_r+0x99a>
   8f6b8:	9a05      	ldr	r2, [sp, #20]
   8f6ba:	2331      	movs	r3, #49	; 0x31
   8f6bc:	3201      	adds	r2, #1
   8f6be:	9205      	str	r2, [sp, #20]
   8f6c0:	9a08      	ldr	r2, [sp, #32]
   8f6c2:	7013      	strb	r3, [r2, #0]
   8f6c4:	e587      	b.n	8f1d6 <_dtoa_r+0x5d6>
   8f6c6:	f8dd b008 	ldr.w	fp, [sp, #8]
   8f6ca:	9c06      	ldr	r4, [sp, #24]
   8f6cc:	e469      	b.n	8efa2 <_dtoa_r+0x3a2>
   8f6ce:	4640      	mov	r0, r8
   8f6d0:	f7fc fb8a 	bl	8bde8 <__aeabi_i2d>
   8f6d4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   8f6d8:	f7fc fbec 	bl	8beb4 <__aeabi_dmul>
   8f6dc:	2200      	movs	r2, #0
   8f6de:	4bbe      	ldr	r3, [pc, #760]	; (8f9d8 <_dtoa_r+0xdd8>)
   8f6e0:	f7fc fa36 	bl	8bb50 <__adddf3>
   8f6e4:	4606      	mov	r6, r0
   8f6e6:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   8f6ea:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8f6ee:	2200      	movs	r2, #0
   8f6f0:	4bba      	ldr	r3, [pc, #744]	; (8f9dc <_dtoa_r+0xddc>)
   8f6f2:	f7fc fa2b 	bl	8bb4c <__aeabi_dsub>
   8f6f6:	4632      	mov	r2, r6
   8f6f8:	463b      	mov	r3, r7
   8f6fa:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8f6fe:	f7fc fe69 	bl	8c3d4 <__aeabi_dcmpgt>
   8f702:	4680      	mov	r8, r0
   8f704:	2800      	cmp	r0, #0
   8f706:	f040 80b2 	bne.w	8f86e <_dtoa_r+0xc6e>
   8f70a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8f70e:	4632      	mov	r2, r6
   8f710:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   8f714:	f7fc fe40 	bl	8c398 <__aeabi_dcmplt>
   8f718:	b130      	cbz	r0, 8f728 <_dtoa_r+0xb28>
   8f71a:	4646      	mov	r6, r8
   8f71c:	e739      	b.n	8f592 <_dtoa_r+0x992>
   8f71e:	4644      	mov	r4, r8
   8f720:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
   8f724:	f8dd b008 	ldr.w	fp, [sp, #8]
   8f728:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   8f72c:	e9cd 2302 	strd	r2, r3, [sp, #8]
   8f730:	f7ff bb76 	b.w	8ee20 <_dtoa_r+0x220>
   8f734:	4659      	mov	r1, fp
   8f736:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8f738:	4620      	mov	r0, r4
   8f73a:	f000 fca9 	bl	90090 <__pow5mult>
   8f73e:	4683      	mov	fp, r0
   8f740:	e48c      	b.n	8f05c <_dtoa_r+0x45c>
   8f742:	9b09      	ldr	r3, [sp, #36]	; 0x24
   8f744:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   8f746:	1afb      	subs	r3, r7, r3
   8f748:	441a      	add	r2, r3
   8f74a:	9709      	str	r7, [sp, #36]	; 0x24
   8f74c:	920b      	str	r2, [sp, #44]	; 0x2c
   8f74e:	2700      	movs	r7, #0
   8f750:	e449      	b.n	8efe6 <_dtoa_r+0x3e6>
   8f752:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   8f756:	f04f 0802 	mov.w	r8, #2
   8f75a:	e9cd 2302 	strd	r2, r3, [sp, #8]
   8f75e:	e624      	b.n	8f3aa <_dtoa_r+0x7aa>
   8f760:	2601      	movs	r6, #1
   8f762:	9623      	str	r6, [sp, #140]	; 0x8c
   8f764:	960d      	str	r6, [sp, #52]	; 0x34
   8f766:	9607      	str	r6, [sp, #28]
   8f768:	2100      	movs	r1, #0
   8f76a:	6461      	str	r1, [r4, #68]	; 0x44
   8f76c:	e5f2      	b.n	8f354 <_dtoa_r+0x754>
   8f76e:	461e      	mov	r6, r3
   8f770:	e7fa      	b.n	8f768 <_dtoa_r+0xb68>
   8f772:	2a00      	cmp	r2, #0
   8f774:	dd15      	ble.n	8f7a2 <_dtoa_r+0xba2>
   8f776:	4659      	mov	r1, fp
   8f778:	2201      	movs	r2, #1
   8f77a:	4620      	mov	r0, r4
   8f77c:	f8cd c008 	str.w	ip, [sp, #8]
   8f780:	f000 fcd6 	bl	90130 <__lshift>
   8f784:	4641      	mov	r1, r8
   8f786:	4683      	mov	fp, r0
   8f788:	f000 fd2a 	bl	901e0 <__mcmp>
   8f78c:	2800      	cmp	r0, #0
   8f78e:	f8dd c008 	ldr.w	ip, [sp, #8]
   8f792:	f340 814d 	ble.w	8fa30 <_dtoa_r+0xe30>
   8f796:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
   8f79a:	f000 8109 	beq.w	8f9b0 <_dtoa_r+0xdb0>
   8f79e:	f10c 0c01 	add.w	ip, ip, #1
   8f7a2:	46b2      	mov	sl, r6
   8f7a4:	f887 c000 	strb.w	ip, [r7]
   8f7a8:	1c7d      	adds	r5, r7, #1
   8f7aa:	464e      	mov	r6, r9
   8f7ac:	e513      	b.n	8f1d6 <_dtoa_r+0x5d6>
   8f7ae:	d104      	bne.n	8f7ba <_dtoa_r+0xbba>
   8f7b0:	f01c 0f01 	tst.w	ip, #1
   8f7b4:	d001      	beq.n	8f7ba <_dtoa_r+0xbba>
   8f7b6:	e4fe      	b.n	8f1b6 <_dtoa_r+0x5b6>
   8f7b8:	4615      	mov	r5, r2
   8f7ba:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   8f7be:	1e6a      	subs	r2, r5, #1
   8f7c0:	2b30      	cmp	r3, #48	; 0x30
   8f7c2:	d0f9      	beq.n	8f7b8 <_dtoa_r+0xbb8>
   8f7c4:	e507      	b.n	8f1d6 <_dtoa_r+0x5d6>
   8f7c6:	9b05      	ldr	r3, [sp, #20]
   8f7c8:	425d      	negs	r5, r3
   8f7ca:	2d00      	cmp	r5, #0
   8f7cc:	f000 80c1 	beq.w	8f952 <_dtoa_r+0xd52>
   8f7d0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   8f7d4:	4b82      	ldr	r3, [pc, #520]	; (8f9e0 <_dtoa_r+0xde0>)
   8f7d6:	f005 020f 	and.w	r2, r5, #15
   8f7da:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   8f7de:	e9d3 2300 	ldrd	r2, r3, [r3]
   8f7e2:	f7fc fb67 	bl	8beb4 <__aeabi_dmul>
   8f7e6:	112d      	asrs	r5, r5, #4
   8f7e8:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8f7ec:	f000 8130 	beq.w	8fa50 <_dtoa_r+0xe50>
   8f7f0:	4e7c      	ldr	r6, [pc, #496]	; (8f9e4 <_dtoa_r+0xde4>)
   8f7f2:	f04f 0802 	mov.w	r8, #2
   8f7f6:	07eb      	lsls	r3, r5, #31
   8f7f8:	d505      	bpl.n	8f806 <_dtoa_r+0xc06>
   8f7fa:	e9d6 2300 	ldrd	r2, r3, [r6]
   8f7fe:	f7fc fb59 	bl	8beb4 <__aeabi_dmul>
   8f802:	f108 0801 	add.w	r8, r8, #1
   8f806:	106d      	asrs	r5, r5, #1
   8f808:	f106 0608 	add.w	r6, r6, #8
   8f80c:	d1f3      	bne.n	8f7f6 <_dtoa_r+0xbf6>
   8f80e:	e9cd 0102 	strd	r0, r1, [sp, #8]
   8f812:	e5e5      	b.n	8f3e0 <_dtoa_r+0x7e0>
   8f814:	9a05      	ldr	r2, [sp, #20]
   8f816:	2330      	movs	r3, #48	; 0x30
   8f818:	3201      	adds	r2, #1
   8f81a:	9205      	str	r2, [sp, #20]
   8f81c:	9a08      	ldr	r2, [sp, #32]
   8f81e:	7013      	strb	r3, [r2, #0]
   8f820:	2331      	movs	r3, #49	; 0x31
   8f822:	7013      	strb	r3, [r2, #0]
   8f824:	f7ff bbbd 	b.w	8efa2 <_dtoa_r+0x3a2>
   8f828:	6871      	ldr	r1, [r6, #4]
   8f82a:	4620      	mov	r0, r4
   8f82c:	f000 fac4 	bl	8fdb8 <_Balloc>
   8f830:	4605      	mov	r5, r0
   8f832:	6933      	ldr	r3, [r6, #16]
   8f834:	f106 010c 	add.w	r1, r6, #12
   8f838:	1c9a      	adds	r2, r3, #2
   8f83a:	0092      	lsls	r2, r2, #2
   8f83c:	300c      	adds	r0, #12
   8f83e:	f7fd fc4d 	bl	8d0dc <memcpy>
   8f842:	4620      	mov	r0, r4
   8f844:	4629      	mov	r1, r5
   8f846:	2201      	movs	r2, #1
   8f848:	f000 fc72 	bl	90130 <__lshift>
   8f84c:	4681      	mov	r9, r0
   8f84e:	e4fe      	b.n	8f24e <_dtoa_r+0x64e>
   8f850:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
   8f854:	f000 80ac 	beq.w	8f9b0 <_dtoa_r+0xdb0>
   8f858:	f10c 0c01 	add.w	ip, ip, #1
   8f85c:	46b2      	mov	sl, r6
   8f85e:	f887 c000 	strb.w	ip, [r7]
   8f862:	1c7d      	adds	r5, r7, #1
   8f864:	464e      	mov	r6, r9
   8f866:	e4b6      	b.n	8f1d6 <_dtoa_r+0x5d6>
   8f868:	46b2      	mov	sl, r6
   8f86a:	464e      	mov	r6, r9
   8f86c:	e493      	b.n	8f196 <_dtoa_r+0x596>
   8f86e:	f04f 0800 	mov.w	r8, #0
   8f872:	4646      	mov	r6, r8
   8f874:	e718      	b.n	8f6a8 <_dtoa_r+0xaa8>
   8f876:	495a      	ldr	r1, [pc, #360]	; (8f9e0 <_dtoa_r+0xde0>)
   8f878:	f10c 33ff 	add.w	r3, ip, #4294967295
   8f87c:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   8f880:	4632      	mov	r2, r6
   8f882:	e9d1 0100 	ldrd	r0, r1, [r1]
   8f886:	9314      	str	r3, [sp, #80]	; 0x50
   8f888:	463b      	mov	r3, r7
   8f88a:	f8cd c054 	str.w	ip, [sp, #84]	; 0x54
   8f88e:	f7fc fb11 	bl	8beb4 <__aeabi_dmul>
   8f892:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   8f896:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   8f89a:	4639      	mov	r1, r7
   8f89c:	4630      	mov	r0, r6
   8f89e:	f7fc fda3 	bl	8c3e8 <__aeabi_d2iz>
   8f8a2:	4605      	mov	r5, r0
   8f8a4:	f7fc faa0 	bl	8bde8 <__aeabi_i2d>
   8f8a8:	4602      	mov	r2, r0
   8f8aa:	460b      	mov	r3, r1
   8f8ac:	4630      	mov	r0, r6
   8f8ae:	4639      	mov	r1, r7
   8f8b0:	f7fc f94c 	bl	8bb4c <__aeabi_dsub>
   8f8b4:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
   8f8b8:	9a08      	ldr	r2, [sp, #32]
   8f8ba:	3530      	adds	r5, #48	; 0x30
   8f8bc:	f1bc 0f01 	cmp.w	ip, #1
   8f8c0:	7015      	strb	r5, [r2, #0]
   8f8c2:	4606      	mov	r6, r0
   8f8c4:	460f      	mov	r7, r1
   8f8c6:	f102 0501 	add.w	r5, r2, #1
   8f8ca:	d023      	beq.n	8f914 <_dtoa_r+0xd14>
   8f8cc:	9b08      	ldr	r3, [sp, #32]
   8f8ce:	f8cd a008 	str.w	sl, [sp, #8]
   8f8d2:	4463      	add	r3, ip
   8f8d4:	465e      	mov	r6, fp
   8f8d6:	469a      	mov	sl, r3
   8f8d8:	46ab      	mov	fp, r5
   8f8da:	2200      	movs	r2, #0
   8f8dc:	4b42      	ldr	r3, [pc, #264]	; (8f9e8 <_dtoa_r+0xde8>)
   8f8de:	f7fc fae9 	bl	8beb4 <__aeabi_dmul>
   8f8e2:	4689      	mov	r9, r1
   8f8e4:	4680      	mov	r8, r0
   8f8e6:	f7fc fd7f 	bl	8c3e8 <__aeabi_d2iz>
   8f8ea:	4607      	mov	r7, r0
   8f8ec:	f7fc fa7c 	bl	8bde8 <__aeabi_i2d>
   8f8f0:	3730      	adds	r7, #48	; 0x30
   8f8f2:	4602      	mov	r2, r0
   8f8f4:	460b      	mov	r3, r1
   8f8f6:	4640      	mov	r0, r8
   8f8f8:	4649      	mov	r1, r9
   8f8fa:	f7fc f927 	bl	8bb4c <__aeabi_dsub>
   8f8fe:	f80b 7b01 	strb.w	r7, [fp], #1
   8f902:	45d3      	cmp	fp, sl
   8f904:	d1e9      	bne.n	8f8da <_dtoa_r+0xcda>
   8f906:	46b3      	mov	fp, r6
   8f908:	460f      	mov	r7, r1
   8f90a:	4606      	mov	r6, r0
   8f90c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   8f90e:	f8dd a008 	ldr.w	sl, [sp, #8]
   8f912:	441d      	add	r5, r3
   8f914:	2200      	movs	r2, #0
   8f916:	4b35      	ldr	r3, [pc, #212]	; (8f9ec <_dtoa_r+0xdec>)
   8f918:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   8f91c:	f7fc f918 	bl	8bb50 <__adddf3>
   8f920:	4632      	mov	r2, r6
   8f922:	463b      	mov	r3, r7
   8f924:	f7fc fd38 	bl	8c398 <__aeabi_dcmplt>
   8f928:	2800      	cmp	r0, #0
   8f92a:	d048      	beq.n	8f9be <_dtoa_r+0xdbe>
   8f92c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8f92e:	9305      	str	r3, [sp, #20]
   8f930:	f815 8c01 	ldrb.w	r8, [r5, #-1]
   8f934:	f7ff bb23 	b.w	8ef7e <_dtoa_r+0x37e>
   8f938:	9b06      	ldr	r3, [sp, #24]
   8f93a:	9a07      	ldr	r2, [sp, #28]
   8f93c:	1a9d      	subs	r5, r3, r2
   8f93e:	2300      	movs	r3, #0
   8f940:	f7ff bb57 	b.w	8eff2 <_dtoa_r+0x3f2>
   8f944:	9b16      	ldr	r3, [sp, #88]	; 0x58
   8f946:	9f09      	ldr	r7, [sp, #36]	; 0x24
   8f948:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   8f94c:	9d06      	ldr	r5, [sp, #24]
   8f94e:	f7ff bb50 	b.w	8eff2 <_dtoa_r+0x3f2>
   8f952:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   8f956:	f04f 0802 	mov.w	r8, #2
   8f95a:	e9cd 2302 	strd	r2, r3, [sp, #8]
   8f95e:	e53f      	b.n	8f3e0 <_dtoa_r+0x7e0>
   8f960:	9b07      	ldr	r3, [sp, #28]
   8f962:	2b00      	cmp	r3, #0
   8f964:	f43f aeb3 	beq.w	8f6ce <_dtoa_r+0xace>
   8f968:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   8f96a:	2d00      	cmp	r5, #0
   8f96c:	f77f aedc 	ble.w	8f728 <_dtoa_r+0xb28>
   8f970:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   8f974:	2200      	movs	r2, #0
   8f976:	4b1c      	ldr	r3, [pc, #112]	; (8f9e8 <_dtoa_r+0xde8>)
   8f978:	f7fc fa9c 	bl	8beb4 <__aeabi_dmul>
   8f97c:	4606      	mov	r6, r0
   8f97e:	460f      	mov	r7, r1
   8f980:	f108 0001 	add.w	r0, r8, #1
   8f984:	e9cd 6702 	strd	r6, r7, [sp, #8]
   8f988:	f7fc fa2e 	bl	8bde8 <__aeabi_i2d>
   8f98c:	4602      	mov	r2, r0
   8f98e:	460b      	mov	r3, r1
   8f990:	4630      	mov	r0, r6
   8f992:	4639      	mov	r1, r7
   8f994:	f7fc fa8e 	bl	8beb4 <__aeabi_dmul>
   8f998:	4b0f      	ldr	r3, [pc, #60]	; (8f9d8 <_dtoa_r+0xdd8>)
   8f99a:	2200      	movs	r2, #0
   8f99c:	f7fc f8d8 	bl	8bb50 <__adddf3>
   8f9a0:	9b05      	ldr	r3, [sp, #20]
   8f9a2:	4606      	mov	r6, r0
   8f9a4:	3b01      	subs	r3, #1
   8f9a6:	9313      	str	r3, [sp, #76]	; 0x4c
   8f9a8:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   8f9ac:	46ac      	mov	ip, r5
   8f9ae:	e538      	b.n	8f422 <_dtoa_r+0x822>
   8f9b0:	2239      	movs	r2, #57	; 0x39
   8f9b2:	46b2      	mov	sl, r6
   8f9b4:	703a      	strb	r2, [r7, #0]
   8f9b6:	464e      	mov	r6, r9
   8f9b8:	1c7d      	adds	r5, r7, #1
   8f9ba:	f7ff bbfe 	b.w	8f1ba <_dtoa_r+0x5ba>
   8f9be:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   8f9c2:	2000      	movs	r0, #0
   8f9c4:	4909      	ldr	r1, [pc, #36]	; (8f9ec <_dtoa_r+0xdec>)
   8f9c6:	f7fc f8c1 	bl	8bb4c <__aeabi_dsub>
   8f9ca:	4632      	mov	r2, r6
   8f9cc:	463b      	mov	r3, r7
   8f9ce:	f7fc fd01 	bl	8c3d4 <__aeabi_dcmpgt>
   8f9d2:	b970      	cbnz	r0, 8f9f2 <_dtoa_r+0xdf2>
   8f9d4:	e6a8      	b.n	8f728 <_dtoa_r+0xb28>
   8f9d6:	bf00      	nop
   8f9d8:	401c0000 	.word	0x401c0000
   8f9dc:	40140000 	.word	0x40140000
   8f9e0:	000922e0 	.word	0x000922e0
   8f9e4:	000923b8 	.word	0x000923b8
   8f9e8:	40240000 	.word	0x40240000
   8f9ec:	3fe00000 	.word	0x3fe00000
   8f9f0:	4615      	mov	r5, r2
   8f9f2:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   8f9f6:	1e6a      	subs	r2, r5, #1
   8f9f8:	2b30      	cmp	r3, #48	; 0x30
   8f9fa:	d0f9      	beq.n	8f9f0 <_dtoa_r+0xdf0>
   8f9fc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8f9fe:	9305      	str	r3, [sp, #20]
   8fa00:	f7ff bacf 	b.w	8efa2 <_dtoa_r+0x3a2>
   8fa04:	4643      	mov	r3, r8
   8fa06:	46a0      	mov	r8, r4
   8fa08:	461c      	mov	r4, r3
   8fa0a:	f8dd b008 	ldr.w	fp, [sp, #8]
   8fa0e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   8fa10:	9305      	str	r3, [sp, #20]
   8fa12:	f7ff bab4 	b.w	8ef7e <_dtoa_r+0x37e>
   8fa16:	46b9      	mov	r9, r7
   8fa18:	f7ff bb68 	b.w	8f0ec <_dtoa_r+0x4ec>
   8fa1c:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
   8fa20:	d0c6      	beq.n	8f9b0 <_dtoa_r+0xdb0>
   8fa22:	f1ba 0f00 	cmp.w	sl, #0
   8fa26:	f77f aebc 	ble.w	8f7a2 <_dtoa_r+0xba2>
   8fa2a:	f105 0c31 	add.w	ip, r5, #49	; 0x31
   8fa2e:	e6b8      	b.n	8f7a2 <_dtoa_r+0xba2>
   8fa30:	f47f aeb7 	bne.w	8f7a2 <_dtoa_r+0xba2>
   8fa34:	f01c 0f01 	tst.w	ip, #1
   8fa38:	f43f aeb3 	beq.w	8f7a2 <_dtoa_r+0xba2>
   8fa3c:	e6ab      	b.n	8f796 <_dtoa_r+0xb96>
   8fa3e:	f04f 0800 	mov.w	r8, #0
   8fa42:	4646      	mov	r6, r8
   8fa44:	e5a5      	b.n	8f592 <_dtoa_r+0x992>
   8fa46:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8fa48:	2b02      	cmp	r3, #2
   8fa4a:	dc04      	bgt.n	8fa56 <_dtoa_r+0xe56>
   8fa4c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8fa4e:	e5fe      	b.n	8f64e <_dtoa_r+0xa4e>
   8fa50:	f04f 0802 	mov.w	r8, #2
   8fa54:	e4c4      	b.n	8f3e0 <_dtoa_r+0x7e0>
   8fa56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8fa58:	9307      	str	r3, [sp, #28]
   8fa5a:	e615      	b.n	8f688 <_dtoa_r+0xa88>
   8fa5c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   8fa5e:	2b02      	cmp	r3, #2
   8fa60:	dcf9      	bgt.n	8fa56 <_dtoa_r+0xe56>
   8fa62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   8fa64:	f7ff bbe5 	b.w	8f232 <_dtoa_r+0x632>
   8fa68:	2500      	movs	r5, #0
   8fa6a:	6465      	str	r5, [r4, #68]	; 0x44
   8fa6c:	4629      	mov	r1, r5
   8fa6e:	4620      	mov	r0, r4
   8fa70:	f000 f9a2 	bl	8fdb8 <_Balloc>
   8fa74:	f04f 33ff 	mov.w	r3, #4294967295
   8fa78:	9307      	str	r3, [sp, #28]
   8fa7a:	930d      	str	r3, [sp, #52]	; 0x34
   8fa7c:	2301      	movs	r3, #1
   8fa7e:	9008      	str	r0, [sp, #32]
   8fa80:	9523      	str	r5, [sp, #140]	; 0x8c
   8fa82:	6420      	str	r0, [r4, #64]	; 0x40
   8fa84:	930a      	str	r3, [sp, #40]	; 0x28
   8fa86:	f7ff b9cb 	b.w	8ee20 <_dtoa_r+0x220>
   8fa8a:	f43f ab44 	beq.w	8f116 <_dtoa_r+0x516>
   8fa8e:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
   8fa92:	f7ff bb3b 	b.w	8f10c <_dtoa_r+0x50c>
   8fa96:	2301      	movs	r3, #1
   8fa98:	930a      	str	r3, [sp, #40]	; 0x28
   8fa9a:	e555      	b.n	8f548 <_dtoa_r+0x948>
   8fa9c:	2501      	movs	r5, #1
   8fa9e:	f7ff b989 	b.w	8edb4 <_dtoa_r+0x1b4>
   8faa2:	bf00      	nop

0008faa4 <__libc_fini_array>:
   8faa4:	b538      	push	{r3, r4, r5, lr}
   8faa6:	4b08      	ldr	r3, [pc, #32]	; (8fac8 <__libc_fini_array+0x24>)
   8faa8:	4d08      	ldr	r5, [pc, #32]	; (8facc <__libc_fini_array+0x28>)
   8faaa:	1aed      	subs	r5, r5, r3
   8faac:	10ac      	asrs	r4, r5, #2
   8faae:	bf18      	it	ne
   8fab0:	18ed      	addne	r5, r5, r3
   8fab2:	d005      	beq.n	8fac0 <__libc_fini_array+0x1c>
   8fab4:	3c01      	subs	r4, #1
   8fab6:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   8faba:	4798      	blx	r3
   8fabc:	2c00      	cmp	r4, #0
   8fabe:	d1f9      	bne.n	8fab4 <__libc_fini_array+0x10>
   8fac0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   8fac4:	f002 bc96 	b.w	923f4 <_fini>
   8fac8:	00092400 	.word	0x00092400
   8facc:	00092404 	.word	0x00092404

0008fad0 <_malloc_trim_r>:
   8fad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8fad2:	460c      	mov	r4, r1
   8fad4:	4f22      	ldr	r7, [pc, #136]	; (8fb60 <_malloc_trim_r+0x90>)
   8fad6:	4606      	mov	r6, r0
   8fad8:	f7fd fbc4 	bl	8d264 <__malloc_lock>
   8fadc:	68bb      	ldr	r3, [r7, #8]
   8fade:	685d      	ldr	r5, [r3, #4]
   8fae0:	f025 0503 	bic.w	r5, r5, #3
   8fae4:	1b29      	subs	r1, r5, r4
   8fae6:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
   8faea:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
   8faee:	f021 010f 	bic.w	r1, r1, #15
   8faf2:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
   8faf6:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
   8fafa:	db07      	blt.n	8fb0c <_malloc_trim_r+0x3c>
   8fafc:	4630      	mov	r0, r6
   8fafe:	2100      	movs	r1, #0
   8fb00:	f7fd fbb4 	bl	8d26c <_sbrk_r>
   8fb04:	68bb      	ldr	r3, [r7, #8]
   8fb06:	442b      	add	r3, r5
   8fb08:	4298      	cmp	r0, r3
   8fb0a:	d004      	beq.n	8fb16 <_malloc_trim_r+0x46>
   8fb0c:	4630      	mov	r0, r6
   8fb0e:	f7fd fbab 	bl	8d268 <__malloc_unlock>
   8fb12:	2000      	movs	r0, #0
   8fb14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8fb16:	4630      	mov	r0, r6
   8fb18:	4261      	negs	r1, r4
   8fb1a:	f7fd fba7 	bl	8d26c <_sbrk_r>
   8fb1e:	3001      	adds	r0, #1
   8fb20:	d00d      	beq.n	8fb3e <_malloc_trim_r+0x6e>
   8fb22:	4b10      	ldr	r3, [pc, #64]	; (8fb64 <_malloc_trim_r+0x94>)
   8fb24:	68ba      	ldr	r2, [r7, #8]
   8fb26:	6819      	ldr	r1, [r3, #0]
   8fb28:	1b2d      	subs	r5, r5, r4
   8fb2a:	f045 0501 	orr.w	r5, r5, #1
   8fb2e:	4630      	mov	r0, r6
   8fb30:	1b09      	subs	r1, r1, r4
   8fb32:	6055      	str	r5, [r2, #4]
   8fb34:	6019      	str	r1, [r3, #0]
   8fb36:	f7fd fb97 	bl	8d268 <__malloc_unlock>
   8fb3a:	2001      	movs	r0, #1
   8fb3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8fb3e:	4630      	mov	r0, r6
   8fb40:	2100      	movs	r1, #0
   8fb42:	f7fd fb93 	bl	8d26c <_sbrk_r>
   8fb46:	68ba      	ldr	r2, [r7, #8]
   8fb48:	1a83      	subs	r3, r0, r2
   8fb4a:	2b0f      	cmp	r3, #15
   8fb4c:	ddde      	ble.n	8fb0c <_malloc_trim_r+0x3c>
   8fb4e:	4c06      	ldr	r4, [pc, #24]	; (8fb68 <_malloc_trim_r+0x98>)
   8fb50:	4904      	ldr	r1, [pc, #16]	; (8fb64 <_malloc_trim_r+0x94>)
   8fb52:	6824      	ldr	r4, [r4, #0]
   8fb54:	f043 0301 	orr.w	r3, r3, #1
   8fb58:	1b00      	subs	r0, r0, r4
   8fb5a:	6053      	str	r3, [r2, #4]
   8fb5c:	6008      	str	r0, [r1, #0]
   8fb5e:	e7d5      	b.n	8fb0c <_malloc_trim_r+0x3c>
   8fb60:	2000047c 	.word	0x2000047c
   8fb64:	2000118c 	.word	0x2000118c
   8fb68:	20000888 	.word	0x20000888

0008fb6c <_free_r>:
   8fb6c:	2900      	cmp	r1, #0
   8fb6e:	d04e      	beq.n	8fc0e <_free_r+0xa2>
   8fb70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8fb74:	460c      	mov	r4, r1
   8fb76:	4680      	mov	r8, r0
   8fb78:	f7fd fb74 	bl	8d264 <__malloc_lock>
   8fb7c:	f854 7c04 	ldr.w	r7, [r4, #-4]
   8fb80:	4962      	ldr	r1, [pc, #392]	; (8fd0c <_free_r+0x1a0>)
   8fb82:	f1a4 0508 	sub.w	r5, r4, #8
   8fb86:	f027 0201 	bic.w	r2, r7, #1
   8fb8a:	18ab      	adds	r3, r5, r2
   8fb8c:	688e      	ldr	r6, [r1, #8]
   8fb8e:	6858      	ldr	r0, [r3, #4]
   8fb90:	429e      	cmp	r6, r3
   8fb92:	f020 0003 	bic.w	r0, r0, #3
   8fb96:	d05a      	beq.n	8fc4e <_free_r+0xe2>
   8fb98:	07fe      	lsls	r6, r7, #31
   8fb9a:	6058      	str	r0, [r3, #4]
   8fb9c:	d40b      	bmi.n	8fbb6 <_free_r+0x4a>
   8fb9e:	f854 7c08 	ldr.w	r7, [r4, #-8]
   8fba2:	f101 0e08 	add.w	lr, r1, #8
   8fba6:	1bed      	subs	r5, r5, r7
   8fba8:	68ac      	ldr	r4, [r5, #8]
   8fbaa:	443a      	add	r2, r7
   8fbac:	4574      	cmp	r4, lr
   8fbae:	d067      	beq.n	8fc80 <_free_r+0x114>
   8fbb0:	68ef      	ldr	r7, [r5, #12]
   8fbb2:	60e7      	str	r7, [r4, #12]
   8fbb4:	60bc      	str	r4, [r7, #8]
   8fbb6:	181c      	adds	r4, r3, r0
   8fbb8:	6864      	ldr	r4, [r4, #4]
   8fbba:	07e4      	lsls	r4, r4, #31
   8fbbc:	d40c      	bmi.n	8fbd8 <_free_r+0x6c>
   8fbbe:	4f54      	ldr	r7, [pc, #336]	; (8fd10 <_free_r+0x1a4>)
   8fbc0:	689c      	ldr	r4, [r3, #8]
   8fbc2:	4402      	add	r2, r0
   8fbc4:	42bc      	cmp	r4, r7
   8fbc6:	d07c      	beq.n	8fcc2 <_free_r+0x156>
   8fbc8:	68d8      	ldr	r0, [r3, #12]
   8fbca:	f042 0301 	orr.w	r3, r2, #1
   8fbce:	60e0      	str	r0, [r4, #12]
   8fbd0:	6084      	str	r4, [r0, #8]
   8fbd2:	606b      	str	r3, [r5, #4]
   8fbd4:	50aa      	str	r2, [r5, r2]
   8fbd6:	e003      	b.n	8fbe0 <_free_r+0x74>
   8fbd8:	f042 0301 	orr.w	r3, r2, #1
   8fbdc:	606b      	str	r3, [r5, #4]
   8fbde:	50aa      	str	r2, [r5, r2]
   8fbe0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   8fbe4:	d214      	bcs.n	8fc10 <_free_r+0xa4>
   8fbe6:	08d2      	lsrs	r2, r2, #3
   8fbe8:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
   8fbec:	2401      	movs	r4, #1
   8fbee:	6848      	ldr	r0, [r1, #4]
   8fbf0:	1092      	asrs	r2, r2, #2
   8fbf2:	fa04 f202 	lsl.w	r2, r4, r2
   8fbf6:	689c      	ldr	r4, [r3, #8]
   8fbf8:	4310      	orrs	r0, r2
   8fbfa:	60ac      	str	r4, [r5, #8]
   8fbfc:	60eb      	str	r3, [r5, #12]
   8fbfe:	6048      	str	r0, [r1, #4]
   8fc00:	609d      	str	r5, [r3, #8]
   8fc02:	60e5      	str	r5, [r4, #12]
   8fc04:	4640      	mov	r0, r8
   8fc06:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   8fc0a:	f7fd bb2d 	b.w	8d268 <__malloc_unlock>
   8fc0e:	4770      	bx	lr
   8fc10:	0a53      	lsrs	r3, r2, #9
   8fc12:	2b04      	cmp	r3, #4
   8fc14:	d847      	bhi.n	8fca6 <_free_r+0x13a>
   8fc16:	0993      	lsrs	r3, r2, #6
   8fc18:	f103 0438 	add.w	r4, r3, #56	; 0x38
   8fc1c:	0060      	lsls	r0, r4, #1
   8fc1e:	eb01 0080 	add.w	r0, r1, r0, lsl #2
   8fc22:	6883      	ldr	r3, [r0, #8]
   8fc24:	4939      	ldr	r1, [pc, #228]	; (8fd0c <_free_r+0x1a0>)
   8fc26:	4283      	cmp	r3, r0
   8fc28:	d043      	beq.n	8fcb2 <_free_r+0x146>
   8fc2a:	6859      	ldr	r1, [r3, #4]
   8fc2c:	f021 0103 	bic.w	r1, r1, #3
   8fc30:	4291      	cmp	r1, r2
   8fc32:	d902      	bls.n	8fc3a <_free_r+0xce>
   8fc34:	689b      	ldr	r3, [r3, #8]
   8fc36:	4298      	cmp	r0, r3
   8fc38:	d1f7      	bne.n	8fc2a <_free_r+0xbe>
   8fc3a:	68da      	ldr	r2, [r3, #12]
   8fc3c:	60ea      	str	r2, [r5, #12]
   8fc3e:	60ab      	str	r3, [r5, #8]
   8fc40:	4640      	mov	r0, r8
   8fc42:	6095      	str	r5, [r2, #8]
   8fc44:	60dd      	str	r5, [r3, #12]
   8fc46:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   8fc4a:	f7fd bb0d 	b.w	8d268 <__malloc_unlock>
   8fc4e:	07ff      	lsls	r7, r7, #31
   8fc50:	4402      	add	r2, r0
   8fc52:	d407      	bmi.n	8fc64 <_free_r+0xf8>
   8fc54:	f854 4c08 	ldr.w	r4, [r4, #-8]
   8fc58:	1b2d      	subs	r5, r5, r4
   8fc5a:	68eb      	ldr	r3, [r5, #12]
   8fc5c:	68a8      	ldr	r0, [r5, #8]
   8fc5e:	4422      	add	r2, r4
   8fc60:	60c3      	str	r3, [r0, #12]
   8fc62:	6098      	str	r0, [r3, #8]
   8fc64:	4b2b      	ldr	r3, [pc, #172]	; (8fd14 <_free_r+0x1a8>)
   8fc66:	f042 0001 	orr.w	r0, r2, #1
   8fc6a:	681b      	ldr	r3, [r3, #0]
   8fc6c:	6068      	str	r0, [r5, #4]
   8fc6e:	429a      	cmp	r2, r3
   8fc70:	608d      	str	r5, [r1, #8]
   8fc72:	d3c7      	bcc.n	8fc04 <_free_r+0x98>
   8fc74:	4b28      	ldr	r3, [pc, #160]	; (8fd18 <_free_r+0x1ac>)
   8fc76:	4640      	mov	r0, r8
   8fc78:	6819      	ldr	r1, [r3, #0]
   8fc7a:	f7ff ff29 	bl	8fad0 <_malloc_trim_r>
   8fc7e:	e7c1      	b.n	8fc04 <_free_r+0x98>
   8fc80:	1819      	adds	r1, r3, r0
   8fc82:	6849      	ldr	r1, [r1, #4]
   8fc84:	07c9      	lsls	r1, r1, #31
   8fc86:	d409      	bmi.n	8fc9c <_free_r+0x130>
   8fc88:	68d9      	ldr	r1, [r3, #12]
   8fc8a:	4402      	add	r2, r0
   8fc8c:	689b      	ldr	r3, [r3, #8]
   8fc8e:	f042 0001 	orr.w	r0, r2, #1
   8fc92:	60d9      	str	r1, [r3, #12]
   8fc94:	608b      	str	r3, [r1, #8]
   8fc96:	6068      	str	r0, [r5, #4]
   8fc98:	50aa      	str	r2, [r5, r2]
   8fc9a:	e7b3      	b.n	8fc04 <_free_r+0x98>
   8fc9c:	f042 0301 	orr.w	r3, r2, #1
   8fca0:	606b      	str	r3, [r5, #4]
   8fca2:	50aa      	str	r2, [r5, r2]
   8fca4:	e7ae      	b.n	8fc04 <_free_r+0x98>
   8fca6:	2b14      	cmp	r3, #20
   8fca8:	d814      	bhi.n	8fcd4 <_free_r+0x168>
   8fcaa:	f103 045b 	add.w	r4, r3, #91	; 0x5b
   8fcae:	0060      	lsls	r0, r4, #1
   8fcb0:	e7b5      	b.n	8fc1e <_free_r+0xb2>
   8fcb2:	684a      	ldr	r2, [r1, #4]
   8fcb4:	10a4      	asrs	r4, r4, #2
   8fcb6:	2001      	movs	r0, #1
   8fcb8:	40a0      	lsls	r0, r4
   8fcba:	4302      	orrs	r2, r0
   8fcbc:	604a      	str	r2, [r1, #4]
   8fcbe:	461a      	mov	r2, r3
   8fcc0:	e7bc      	b.n	8fc3c <_free_r+0xd0>
   8fcc2:	f042 0301 	orr.w	r3, r2, #1
   8fcc6:	614d      	str	r5, [r1, #20]
   8fcc8:	610d      	str	r5, [r1, #16]
   8fcca:	60ec      	str	r4, [r5, #12]
   8fccc:	60ac      	str	r4, [r5, #8]
   8fcce:	606b      	str	r3, [r5, #4]
   8fcd0:	50aa      	str	r2, [r5, r2]
   8fcd2:	e797      	b.n	8fc04 <_free_r+0x98>
   8fcd4:	2b54      	cmp	r3, #84	; 0x54
   8fcd6:	d804      	bhi.n	8fce2 <_free_r+0x176>
   8fcd8:	0b13      	lsrs	r3, r2, #12
   8fcda:	f103 046e 	add.w	r4, r3, #110	; 0x6e
   8fcde:	0060      	lsls	r0, r4, #1
   8fce0:	e79d      	b.n	8fc1e <_free_r+0xb2>
   8fce2:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   8fce6:	d804      	bhi.n	8fcf2 <_free_r+0x186>
   8fce8:	0bd3      	lsrs	r3, r2, #15
   8fcea:	f103 0477 	add.w	r4, r3, #119	; 0x77
   8fcee:	0060      	lsls	r0, r4, #1
   8fcf0:	e795      	b.n	8fc1e <_free_r+0xb2>
   8fcf2:	f240 5054 	movw	r0, #1364	; 0x554
   8fcf6:	4283      	cmp	r3, r0
   8fcf8:	d804      	bhi.n	8fd04 <_free_r+0x198>
   8fcfa:	0c93      	lsrs	r3, r2, #18
   8fcfc:	f103 047c 	add.w	r4, r3, #124	; 0x7c
   8fd00:	0060      	lsls	r0, r4, #1
   8fd02:	e78c      	b.n	8fc1e <_free_r+0xb2>
   8fd04:	20fc      	movs	r0, #252	; 0xfc
   8fd06:	247e      	movs	r4, #126	; 0x7e
   8fd08:	e789      	b.n	8fc1e <_free_r+0xb2>
   8fd0a:	bf00      	nop
   8fd0c:	2000047c 	.word	0x2000047c
   8fd10:	20000484 	.word	0x20000484
   8fd14:	20000884 	.word	0x20000884
   8fd18:	20001188 	.word	0x20001188

0008fd1c <_localeconv_r>:
   8fd1c:	4800      	ldr	r0, [pc, #0]	; (8fd20 <_localeconv_r+0x4>)
   8fd1e:	4770      	bx	lr
   8fd20:	20000890 	.word	0x20000890

0008fd24 <memchr>:
   8fd24:	0783      	lsls	r3, r0, #30
   8fd26:	b470      	push	{r4, r5, r6}
   8fd28:	b2c9      	uxtb	r1, r1
   8fd2a:	d040      	beq.n	8fdae <memchr+0x8a>
   8fd2c:	1e54      	subs	r4, r2, #1
   8fd2e:	2a00      	cmp	r2, #0
   8fd30:	d03f      	beq.n	8fdb2 <memchr+0x8e>
   8fd32:	7803      	ldrb	r3, [r0, #0]
   8fd34:	428b      	cmp	r3, r1
   8fd36:	bf18      	it	ne
   8fd38:	1c43      	addne	r3, r0, #1
   8fd3a:	d105      	bne.n	8fd48 <memchr+0x24>
   8fd3c:	e01c      	b.n	8fd78 <memchr+0x54>
   8fd3e:	b1ec      	cbz	r4, 8fd7c <memchr+0x58>
   8fd40:	7802      	ldrb	r2, [r0, #0]
   8fd42:	3c01      	subs	r4, #1
   8fd44:	428a      	cmp	r2, r1
   8fd46:	d017      	beq.n	8fd78 <memchr+0x54>
   8fd48:	f013 0f03 	tst.w	r3, #3
   8fd4c:	4618      	mov	r0, r3
   8fd4e:	f103 0301 	add.w	r3, r3, #1
   8fd52:	d1f4      	bne.n	8fd3e <memchr+0x1a>
   8fd54:	2c03      	cmp	r4, #3
   8fd56:	d814      	bhi.n	8fd82 <memchr+0x5e>
   8fd58:	b184      	cbz	r4, 8fd7c <memchr+0x58>
   8fd5a:	7803      	ldrb	r3, [r0, #0]
   8fd5c:	428b      	cmp	r3, r1
   8fd5e:	d00b      	beq.n	8fd78 <memchr+0x54>
   8fd60:	1905      	adds	r5, r0, r4
   8fd62:	1c43      	adds	r3, r0, #1
   8fd64:	e002      	b.n	8fd6c <memchr+0x48>
   8fd66:	7802      	ldrb	r2, [r0, #0]
   8fd68:	428a      	cmp	r2, r1
   8fd6a:	d005      	beq.n	8fd78 <memchr+0x54>
   8fd6c:	42ab      	cmp	r3, r5
   8fd6e:	4618      	mov	r0, r3
   8fd70:	f103 0301 	add.w	r3, r3, #1
   8fd74:	d1f7      	bne.n	8fd66 <memchr+0x42>
   8fd76:	2000      	movs	r0, #0
   8fd78:	bc70      	pop	{r4, r5, r6}
   8fd7a:	4770      	bx	lr
   8fd7c:	4620      	mov	r0, r4
   8fd7e:	bc70      	pop	{r4, r5, r6}
   8fd80:	4770      	bx	lr
   8fd82:	4602      	mov	r2, r0
   8fd84:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
   8fd88:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   8fd8c:	6813      	ldr	r3, [r2, #0]
   8fd8e:	4610      	mov	r0, r2
   8fd90:	4073      	eors	r3, r6
   8fd92:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
   8fd96:	ea25 0303 	bic.w	r3, r5, r3
   8fd9a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   8fd9e:	f102 0204 	add.w	r2, r2, #4
   8fda2:	d1d9      	bne.n	8fd58 <memchr+0x34>
   8fda4:	3c04      	subs	r4, #4
   8fda6:	2c03      	cmp	r4, #3
   8fda8:	4610      	mov	r0, r2
   8fdaa:	d8ef      	bhi.n	8fd8c <memchr+0x68>
   8fdac:	e7d4      	b.n	8fd58 <memchr+0x34>
   8fdae:	4614      	mov	r4, r2
   8fdb0:	e7d0      	b.n	8fd54 <memchr+0x30>
   8fdb2:	4610      	mov	r0, r2
   8fdb4:	e7e0      	b.n	8fd78 <memchr+0x54>
   8fdb6:	bf00      	nop

0008fdb8 <_Balloc>:
   8fdb8:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
   8fdba:	b570      	push	{r4, r5, r6, lr}
   8fdbc:	4605      	mov	r5, r0
   8fdbe:	460c      	mov	r4, r1
   8fdc0:	b152      	cbz	r2, 8fdd8 <_Balloc+0x20>
   8fdc2:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   8fdc6:	b18b      	cbz	r3, 8fdec <_Balloc+0x34>
   8fdc8:	6819      	ldr	r1, [r3, #0]
   8fdca:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
   8fdce:	2200      	movs	r2, #0
   8fdd0:	4618      	mov	r0, r3
   8fdd2:	611a      	str	r2, [r3, #16]
   8fdd4:	60da      	str	r2, [r3, #12]
   8fdd6:	bd70      	pop	{r4, r5, r6, pc}
   8fdd8:	2221      	movs	r2, #33	; 0x21
   8fdda:	2104      	movs	r1, #4
   8fddc:	f000 fbbe 	bl	9055c <_calloc_r>
   8fde0:	64e8      	str	r0, [r5, #76]	; 0x4c
   8fde2:	4602      	mov	r2, r0
   8fde4:	2800      	cmp	r0, #0
   8fde6:	d1ec      	bne.n	8fdc2 <_Balloc+0xa>
   8fde8:	2000      	movs	r0, #0
   8fdea:	bd70      	pop	{r4, r5, r6, pc}
   8fdec:	2101      	movs	r1, #1
   8fdee:	fa01 f604 	lsl.w	r6, r1, r4
   8fdf2:	1d72      	adds	r2, r6, #5
   8fdf4:	4628      	mov	r0, r5
   8fdf6:	0092      	lsls	r2, r2, #2
   8fdf8:	f000 fbb0 	bl	9055c <_calloc_r>
   8fdfc:	4603      	mov	r3, r0
   8fdfe:	2800      	cmp	r0, #0
   8fe00:	d0f2      	beq.n	8fde8 <_Balloc+0x30>
   8fe02:	6044      	str	r4, [r0, #4]
   8fe04:	6086      	str	r6, [r0, #8]
   8fe06:	e7e2      	b.n	8fdce <_Balloc+0x16>

0008fe08 <_Bfree>:
   8fe08:	b131      	cbz	r1, 8fe18 <_Bfree+0x10>
   8fe0a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   8fe0c:	684a      	ldr	r2, [r1, #4]
   8fe0e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   8fe12:	6008      	str	r0, [r1, #0]
   8fe14:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   8fe18:	4770      	bx	lr
   8fe1a:	bf00      	nop

0008fe1c <__multadd>:
   8fe1c:	b5f0      	push	{r4, r5, r6, r7, lr}
   8fe1e:	460c      	mov	r4, r1
   8fe20:	4605      	mov	r5, r0
   8fe22:	690e      	ldr	r6, [r1, #16]
   8fe24:	b083      	sub	sp, #12
   8fe26:	f101 0e14 	add.w	lr, r1, #20
   8fe2a:	2700      	movs	r7, #0
   8fe2c:	f8de 1000 	ldr.w	r1, [lr]
   8fe30:	3701      	adds	r7, #1
   8fe32:	b288      	uxth	r0, r1
   8fe34:	0c09      	lsrs	r1, r1, #16
   8fe36:	fb02 3300 	mla	r3, r2, r0, r3
   8fe3a:	fb02 f101 	mul.w	r1, r2, r1
   8fe3e:	b298      	uxth	r0, r3
   8fe40:	eb01 4313 	add.w	r3, r1, r3, lsr #16
   8fe44:	eb00 4103 	add.w	r1, r0, r3, lsl #16
   8fe48:	42be      	cmp	r6, r7
   8fe4a:	f84e 1b04 	str.w	r1, [lr], #4
   8fe4e:	ea4f 4313 	mov.w	r3, r3, lsr #16
   8fe52:	dceb      	bgt.n	8fe2c <__multadd+0x10>
   8fe54:	b13b      	cbz	r3, 8fe66 <__multadd+0x4a>
   8fe56:	68a2      	ldr	r2, [r4, #8]
   8fe58:	4296      	cmp	r6, r2
   8fe5a:	da07      	bge.n	8fe6c <__multadd+0x50>
   8fe5c:	eb04 0286 	add.w	r2, r4, r6, lsl #2
   8fe60:	3601      	adds	r6, #1
   8fe62:	6153      	str	r3, [r2, #20]
   8fe64:	6126      	str	r6, [r4, #16]
   8fe66:	4620      	mov	r0, r4
   8fe68:	b003      	add	sp, #12
   8fe6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8fe6c:	6861      	ldr	r1, [r4, #4]
   8fe6e:	4628      	mov	r0, r5
   8fe70:	3101      	adds	r1, #1
   8fe72:	9301      	str	r3, [sp, #4]
   8fe74:	f7ff ffa0 	bl	8fdb8 <_Balloc>
   8fe78:	4607      	mov	r7, r0
   8fe7a:	6922      	ldr	r2, [r4, #16]
   8fe7c:	f104 010c 	add.w	r1, r4, #12
   8fe80:	3202      	adds	r2, #2
   8fe82:	0092      	lsls	r2, r2, #2
   8fe84:	300c      	adds	r0, #12
   8fe86:	f7fd f929 	bl	8d0dc <memcpy>
   8fe8a:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   8fe8c:	6861      	ldr	r1, [r4, #4]
   8fe8e:	9b01      	ldr	r3, [sp, #4]
   8fe90:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   8fe94:	6020      	str	r0, [r4, #0]
   8fe96:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   8fe9a:	463c      	mov	r4, r7
   8fe9c:	e7de      	b.n	8fe5c <__multadd+0x40>
   8fe9e:	bf00      	nop

0008fea0 <__hi0bits>:
   8fea0:	0c03      	lsrs	r3, r0, #16
   8fea2:	041b      	lsls	r3, r3, #16
   8fea4:	b9b3      	cbnz	r3, 8fed4 <__hi0bits+0x34>
   8fea6:	0400      	lsls	r0, r0, #16
   8fea8:	2310      	movs	r3, #16
   8feaa:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
   8feae:	bf04      	itt	eq
   8feb0:	0200      	lsleq	r0, r0, #8
   8feb2:	3308      	addeq	r3, #8
   8feb4:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
   8feb8:	bf04      	itt	eq
   8feba:	0100      	lsleq	r0, r0, #4
   8febc:	3304      	addeq	r3, #4
   8febe:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
   8fec2:	bf04      	itt	eq
   8fec4:	0080      	lsleq	r0, r0, #2
   8fec6:	3302      	addeq	r3, #2
   8fec8:	2800      	cmp	r0, #0
   8feca:	db07      	blt.n	8fedc <__hi0bits+0x3c>
   8fecc:	0042      	lsls	r2, r0, #1
   8fece:	d403      	bmi.n	8fed8 <__hi0bits+0x38>
   8fed0:	2020      	movs	r0, #32
   8fed2:	4770      	bx	lr
   8fed4:	2300      	movs	r3, #0
   8fed6:	e7e8      	b.n	8feaa <__hi0bits+0xa>
   8fed8:	1c58      	adds	r0, r3, #1
   8feda:	4770      	bx	lr
   8fedc:	4618      	mov	r0, r3
   8fede:	4770      	bx	lr

0008fee0 <__lo0bits>:
   8fee0:	6803      	ldr	r3, [r0, #0]
   8fee2:	f013 0207 	ands.w	r2, r3, #7
   8fee6:	d007      	beq.n	8fef8 <__lo0bits+0x18>
   8fee8:	07d9      	lsls	r1, r3, #31
   8feea:	d420      	bmi.n	8ff2e <__lo0bits+0x4e>
   8feec:	079a      	lsls	r2, r3, #30
   8feee:	d420      	bmi.n	8ff32 <__lo0bits+0x52>
   8fef0:	089b      	lsrs	r3, r3, #2
   8fef2:	6003      	str	r3, [r0, #0]
   8fef4:	2002      	movs	r0, #2
   8fef6:	4770      	bx	lr
   8fef8:	b299      	uxth	r1, r3
   8fefa:	b909      	cbnz	r1, 8ff00 <__lo0bits+0x20>
   8fefc:	0c1b      	lsrs	r3, r3, #16
   8fefe:	2210      	movs	r2, #16
   8ff00:	f013 0fff 	tst.w	r3, #255	; 0xff
   8ff04:	bf04      	itt	eq
   8ff06:	0a1b      	lsreq	r3, r3, #8
   8ff08:	3208      	addeq	r2, #8
   8ff0a:	0719      	lsls	r1, r3, #28
   8ff0c:	bf04      	itt	eq
   8ff0e:	091b      	lsreq	r3, r3, #4
   8ff10:	3204      	addeq	r2, #4
   8ff12:	0799      	lsls	r1, r3, #30
   8ff14:	bf04      	itt	eq
   8ff16:	089b      	lsreq	r3, r3, #2
   8ff18:	3202      	addeq	r2, #2
   8ff1a:	07d9      	lsls	r1, r3, #31
   8ff1c:	d404      	bmi.n	8ff28 <__lo0bits+0x48>
   8ff1e:	085b      	lsrs	r3, r3, #1
   8ff20:	d101      	bne.n	8ff26 <__lo0bits+0x46>
   8ff22:	2020      	movs	r0, #32
   8ff24:	4770      	bx	lr
   8ff26:	3201      	adds	r2, #1
   8ff28:	6003      	str	r3, [r0, #0]
   8ff2a:	4610      	mov	r0, r2
   8ff2c:	4770      	bx	lr
   8ff2e:	2000      	movs	r0, #0
   8ff30:	4770      	bx	lr
   8ff32:	085b      	lsrs	r3, r3, #1
   8ff34:	6003      	str	r3, [r0, #0]
   8ff36:	2001      	movs	r0, #1
   8ff38:	4770      	bx	lr
   8ff3a:	bf00      	nop

0008ff3c <__i2b>:
   8ff3c:	b510      	push	{r4, lr}
   8ff3e:	460c      	mov	r4, r1
   8ff40:	2101      	movs	r1, #1
   8ff42:	f7ff ff39 	bl	8fdb8 <_Balloc>
   8ff46:	2201      	movs	r2, #1
   8ff48:	6144      	str	r4, [r0, #20]
   8ff4a:	6102      	str	r2, [r0, #16]
   8ff4c:	bd10      	pop	{r4, pc}
   8ff4e:	bf00      	nop

0008ff50 <__multiply>:
   8ff50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8ff54:	690e      	ldr	r6, [r1, #16]
   8ff56:	6915      	ldr	r5, [r2, #16]
   8ff58:	b085      	sub	sp, #20
   8ff5a:	42ae      	cmp	r6, r5
   8ff5c:	460c      	mov	r4, r1
   8ff5e:	4691      	mov	r9, r2
   8ff60:	f2c0 8092 	blt.w	90088 <__multiply+0x138>
   8ff64:	462b      	mov	r3, r5
   8ff66:	4635      	mov	r5, r6
   8ff68:	461e      	mov	r6, r3
   8ff6a:	68a3      	ldr	r3, [r4, #8]
   8ff6c:	eb05 0806 	add.w	r8, r5, r6
   8ff70:	6861      	ldr	r1, [r4, #4]
   8ff72:	4598      	cmp	r8, r3
   8ff74:	bfc8      	it	gt
   8ff76:	3101      	addgt	r1, #1
   8ff78:	f7ff ff1e 	bl	8fdb8 <_Balloc>
   8ff7c:	f100 0a14 	add.w	sl, r0, #20
   8ff80:	eb0a 0b88 	add.w	fp, sl, r8, lsl #2
   8ff84:	45da      	cmp	sl, fp
   8ff86:	9001      	str	r0, [sp, #4]
   8ff88:	d205      	bcs.n	8ff96 <__multiply+0x46>
   8ff8a:	4653      	mov	r3, sl
   8ff8c:	2100      	movs	r1, #0
   8ff8e:	f843 1b04 	str.w	r1, [r3], #4
   8ff92:	459b      	cmp	fp, r3
   8ff94:	d8fb      	bhi.n	8ff8e <__multiply+0x3e>
   8ff96:	f109 0914 	add.w	r9, r9, #20
   8ff9a:	eb09 0386 	add.w	r3, r9, r6, lsl #2
   8ff9e:	f104 0214 	add.w	r2, r4, #20
   8ffa2:	4599      	cmp	r9, r3
   8ffa4:	eb02 0c85 	add.w	ip, r2, r5, lsl #2
   8ffa8:	d259      	bcs.n	9005e <__multiply+0x10e>
   8ffaa:	f8cd b008 	str.w	fp, [sp, #8]
   8ffae:	f8cd 800c 	str.w	r8, [sp, #12]
   8ffb2:	469b      	mov	fp, r3
   8ffb4:	4690      	mov	r8, r2
   8ffb6:	f859 7b04 	ldr.w	r7, [r9], #4
   8ffba:	fa1f fe87 	uxth.w	lr, r7
   8ffbe:	f1be 0f00 	cmp.w	lr, #0
   8ffc2:	d01f      	beq.n	90004 <__multiply+0xb4>
   8ffc4:	4647      	mov	r7, r8
   8ffc6:	4656      	mov	r6, sl
   8ffc8:	2100      	movs	r1, #0
   8ffca:	e000      	b.n	8ffce <__multiply+0x7e>
   8ffcc:	4606      	mov	r6, r0
   8ffce:	4630      	mov	r0, r6
   8ffd0:	f857 5b04 	ldr.w	r5, [r7], #4
   8ffd4:	6834      	ldr	r4, [r6, #0]
   8ffd6:	b2ab      	uxth	r3, r5
   8ffd8:	b2a2      	uxth	r2, r4
   8ffda:	fb0e 2203 	mla	r2, lr, r3, r2
   8ffde:	0c2d      	lsrs	r5, r5, #16
   8ffe0:	0c24      	lsrs	r4, r4, #16
   8ffe2:	fb0e 4405 	mla	r4, lr, r5, r4
   8ffe6:	1853      	adds	r3, r2, r1
   8ffe8:	eb04 4113 	add.w	r1, r4, r3, lsr #16
   8ffec:	b29a      	uxth	r2, r3
   8ffee:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   8fff2:	45bc      	cmp	ip, r7
   8fff4:	ea4f 4111 	mov.w	r1, r1, lsr #16
   8fff8:	f840 2b04 	str.w	r2, [r0], #4
   8fffc:	d8e6      	bhi.n	8ffcc <__multiply+0x7c>
   8fffe:	6071      	str	r1, [r6, #4]
   90000:	f859 7c04 	ldr.w	r7, [r9, #-4]
   90004:	0c3f      	lsrs	r7, r7, #16
   90006:	d022      	beq.n	9004e <__multiply+0xfe>
   90008:	f8da 3000 	ldr.w	r3, [sl]
   9000c:	2200      	movs	r2, #0
   9000e:	4655      	mov	r5, sl
   90010:	461e      	mov	r6, r3
   90012:	4640      	mov	r0, r8
   90014:	4696      	mov	lr, r2
   90016:	e000      	b.n	9001a <__multiply+0xca>
   90018:	4625      	mov	r5, r4
   9001a:	462c      	mov	r4, r5
   9001c:	8802      	ldrh	r2, [r0, #0]
   9001e:	0c36      	lsrs	r6, r6, #16
   90020:	fb07 6602 	mla	r6, r7, r2, r6
   90024:	b299      	uxth	r1, r3
   90026:	eb06 020e 	add.w	r2, r6, lr
   9002a:	ea41 4302 	orr.w	r3, r1, r2, lsl #16
   9002e:	f844 3b04 	str.w	r3, [r4], #4
   90032:	f850 1b04 	ldr.w	r1, [r0], #4
   90036:	686e      	ldr	r6, [r5, #4]
   90038:	0c09      	lsrs	r1, r1, #16
   9003a:	b2b3      	uxth	r3, r6
   9003c:	fb07 3101 	mla	r1, r7, r1, r3
   90040:	4584      	cmp	ip, r0
   90042:	eb01 4312 	add.w	r3, r1, r2, lsr #16
   90046:	ea4f 4e13 	mov.w	lr, r3, lsr #16
   9004a:	d8e5      	bhi.n	90018 <__multiply+0xc8>
   9004c:	606b      	str	r3, [r5, #4]
   9004e:	45cb      	cmp	fp, r9
   90050:	f10a 0a04 	add.w	sl, sl, #4
   90054:	d8af      	bhi.n	8ffb6 <__multiply+0x66>
   90056:	f8dd b008 	ldr.w	fp, [sp, #8]
   9005a:	f8dd 800c 	ldr.w	r8, [sp, #12]
   9005e:	f1b8 0f00 	cmp.w	r8, #0
   90062:	dd0b      	ble.n	9007c <__multiply+0x12c>
   90064:	f85b 3c04 	ldr.w	r3, [fp, #-4]
   90068:	f1ab 0b04 	sub.w	fp, fp, #4
   9006c:	b11b      	cbz	r3, 90076 <__multiply+0x126>
   9006e:	e005      	b.n	9007c <__multiply+0x12c>
   90070:	f85b 3d04 	ldr.w	r3, [fp, #-4]!
   90074:	b913      	cbnz	r3, 9007c <__multiply+0x12c>
   90076:	f1b8 0801 	subs.w	r8, r8, #1
   9007a:	d1f9      	bne.n	90070 <__multiply+0x120>
   9007c:	9801      	ldr	r0, [sp, #4]
   9007e:	f8c0 8010 	str.w	r8, [r0, #16]
   90082:	b005      	add	sp, #20
   90084:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90088:	4614      	mov	r4, r2
   9008a:	4689      	mov	r9, r1
   9008c:	e76d      	b.n	8ff6a <__multiply+0x1a>
   9008e:	bf00      	nop

00090090 <__pow5mult>:
   90090:	f012 0303 	ands.w	r3, r2, #3
   90094:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   90098:	4614      	mov	r4, r2
   9009a:	4607      	mov	r7, r0
   9009c:	460e      	mov	r6, r1
   9009e:	d12d      	bne.n	900fc <__pow5mult+0x6c>
   900a0:	10a4      	asrs	r4, r4, #2
   900a2:	d01c      	beq.n	900de <__pow5mult+0x4e>
   900a4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   900a6:	b395      	cbz	r5, 9010e <__pow5mult+0x7e>
   900a8:	07e3      	lsls	r3, r4, #31
   900aa:	f04f 0800 	mov.w	r8, #0
   900ae:	d406      	bmi.n	900be <__pow5mult+0x2e>
   900b0:	1064      	asrs	r4, r4, #1
   900b2:	d014      	beq.n	900de <__pow5mult+0x4e>
   900b4:	6828      	ldr	r0, [r5, #0]
   900b6:	b1a8      	cbz	r0, 900e4 <__pow5mult+0x54>
   900b8:	4605      	mov	r5, r0
   900ba:	07e3      	lsls	r3, r4, #31
   900bc:	d5f8      	bpl.n	900b0 <__pow5mult+0x20>
   900be:	4638      	mov	r0, r7
   900c0:	4631      	mov	r1, r6
   900c2:	462a      	mov	r2, r5
   900c4:	f7ff ff44 	bl	8ff50 <__multiply>
   900c8:	b1b6      	cbz	r6, 900f8 <__pow5mult+0x68>
   900ca:	6872      	ldr	r2, [r6, #4]
   900cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   900ce:	1064      	asrs	r4, r4, #1
   900d0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   900d4:	6031      	str	r1, [r6, #0]
   900d6:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   900da:	4606      	mov	r6, r0
   900dc:	d1ea      	bne.n	900b4 <__pow5mult+0x24>
   900de:	4630      	mov	r0, r6
   900e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   900e4:	4629      	mov	r1, r5
   900e6:	462a      	mov	r2, r5
   900e8:	4638      	mov	r0, r7
   900ea:	f7ff ff31 	bl	8ff50 <__multiply>
   900ee:	6028      	str	r0, [r5, #0]
   900f0:	f8c0 8000 	str.w	r8, [r0]
   900f4:	4605      	mov	r5, r0
   900f6:	e7e0      	b.n	900ba <__pow5mult+0x2a>
   900f8:	4606      	mov	r6, r0
   900fa:	e7d9      	b.n	900b0 <__pow5mult+0x20>
   900fc:	4a0b      	ldr	r2, [pc, #44]	; (9012c <__pow5mult+0x9c>)
   900fe:	3b01      	subs	r3, #1
   90100:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   90104:	2300      	movs	r3, #0
   90106:	f7ff fe89 	bl	8fe1c <__multadd>
   9010a:	4606      	mov	r6, r0
   9010c:	e7c8      	b.n	900a0 <__pow5mult+0x10>
   9010e:	2101      	movs	r1, #1
   90110:	4638      	mov	r0, r7
   90112:	f7ff fe51 	bl	8fdb8 <_Balloc>
   90116:	f240 2171 	movw	r1, #625	; 0x271
   9011a:	2201      	movs	r2, #1
   9011c:	2300      	movs	r3, #0
   9011e:	6141      	str	r1, [r0, #20]
   90120:	6102      	str	r2, [r0, #16]
   90122:	4605      	mov	r5, r0
   90124:	64b8      	str	r0, [r7, #72]	; 0x48
   90126:	6003      	str	r3, [r0, #0]
   90128:	e7be      	b.n	900a8 <__pow5mult+0x18>
   9012a:	bf00      	nop
   9012c:	000923a8 	.word	0x000923a8

00090130 <__lshift>:
   90130:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   90134:	690f      	ldr	r7, [r1, #16]
   90136:	ea4f 1962 	mov.w	r9, r2, asr #5
   9013a:	688b      	ldr	r3, [r1, #8]
   9013c:	444f      	add	r7, r9
   9013e:	1c7d      	adds	r5, r7, #1
   90140:	429d      	cmp	r5, r3
   90142:	460e      	mov	r6, r1
   90144:	4614      	mov	r4, r2
   90146:	4680      	mov	r8, r0
   90148:	6849      	ldr	r1, [r1, #4]
   9014a:	dd04      	ble.n	90156 <__lshift+0x26>
   9014c:	005b      	lsls	r3, r3, #1
   9014e:	429d      	cmp	r5, r3
   90150:	f101 0101 	add.w	r1, r1, #1
   90154:	dcfa      	bgt.n	9014c <__lshift+0x1c>
   90156:	4640      	mov	r0, r8
   90158:	f7ff fe2e 	bl	8fdb8 <_Balloc>
   9015c:	f1b9 0f00 	cmp.w	r9, #0
   90160:	f100 0114 	add.w	r1, r0, #20
   90164:	dd09      	ble.n	9017a <__lshift+0x4a>
   90166:	2300      	movs	r3, #0
   90168:	469e      	mov	lr, r3
   9016a:	460a      	mov	r2, r1
   9016c:	3301      	adds	r3, #1
   9016e:	454b      	cmp	r3, r9
   90170:	f842 eb04 	str.w	lr, [r2], #4
   90174:	d1fa      	bne.n	9016c <__lshift+0x3c>
   90176:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   9017a:	6932      	ldr	r2, [r6, #16]
   9017c:	f106 0314 	add.w	r3, r6, #20
   90180:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
   90184:	f014 021f 	ands.w	r2, r4, #31
   90188:	d022      	beq.n	901d0 <__lshift+0xa0>
   9018a:	f1c2 0920 	rsb	r9, r2, #32
   9018e:	f04f 0a00 	mov.w	sl, #0
   90192:	681c      	ldr	r4, [r3, #0]
   90194:	468c      	mov	ip, r1
   90196:	4094      	lsls	r4, r2
   90198:	ea4a 0404 	orr.w	r4, sl, r4
   9019c:	f841 4b04 	str.w	r4, [r1], #4
   901a0:	f853 4b04 	ldr.w	r4, [r3], #4
   901a4:	459e      	cmp	lr, r3
   901a6:	fa24 fa09 	lsr.w	sl, r4, r9
   901aa:	d8f2      	bhi.n	90192 <__lshift+0x62>
   901ac:	f8cc a004 	str.w	sl, [ip, #4]
   901b0:	f1ba 0f00 	cmp.w	sl, #0
   901b4:	d000      	beq.n	901b8 <__lshift+0x88>
   901b6:	1cbd      	adds	r5, r7, #2
   901b8:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
   901bc:	6872      	ldr	r2, [r6, #4]
   901be:	3d01      	subs	r5, #1
   901c0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   901c4:	6105      	str	r5, [r0, #16]
   901c6:	6031      	str	r1, [r6, #0]
   901c8:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   901cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   901d0:	3904      	subs	r1, #4
   901d2:	f853 2b04 	ldr.w	r2, [r3], #4
   901d6:	459e      	cmp	lr, r3
   901d8:	f841 2f04 	str.w	r2, [r1, #4]!
   901dc:	d8f9      	bhi.n	901d2 <__lshift+0xa2>
   901de:	e7eb      	b.n	901b8 <__lshift+0x88>

000901e0 <__mcmp>:
   901e0:	6902      	ldr	r2, [r0, #16]
   901e2:	690b      	ldr	r3, [r1, #16]
   901e4:	1ad2      	subs	r2, r2, r3
   901e6:	d113      	bne.n	90210 <__mcmp+0x30>
   901e8:	009b      	lsls	r3, r3, #2
   901ea:	3014      	adds	r0, #20
   901ec:	3114      	adds	r1, #20
   901ee:	4419      	add	r1, r3
   901f0:	b410      	push	{r4}
   901f2:	4403      	add	r3, r0
   901f4:	e001      	b.n	901fa <__mcmp+0x1a>
   901f6:	4298      	cmp	r0, r3
   901f8:	d20c      	bcs.n	90214 <__mcmp+0x34>
   901fa:	f853 4d04 	ldr.w	r4, [r3, #-4]!
   901fe:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   90202:	4294      	cmp	r4, r2
   90204:	d0f7      	beq.n	901f6 <__mcmp+0x16>
   90206:	d309      	bcc.n	9021c <__mcmp+0x3c>
   90208:	2001      	movs	r0, #1
   9020a:	f85d 4b04 	ldr.w	r4, [sp], #4
   9020e:	4770      	bx	lr
   90210:	4610      	mov	r0, r2
   90212:	4770      	bx	lr
   90214:	2000      	movs	r0, #0
   90216:	f85d 4b04 	ldr.w	r4, [sp], #4
   9021a:	4770      	bx	lr
   9021c:	f04f 30ff 	mov.w	r0, #4294967295
   90220:	f85d 4b04 	ldr.w	r4, [sp], #4
   90224:	4770      	bx	lr
   90226:	bf00      	nop

00090228 <__mdiff>:
   90228:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   9022c:	460c      	mov	r4, r1
   9022e:	4605      	mov	r5, r0
   90230:	4611      	mov	r1, r2
   90232:	4620      	mov	r0, r4
   90234:	4691      	mov	r9, r2
   90236:	f7ff ffd3 	bl	901e0 <__mcmp>
   9023a:	1e06      	subs	r6, r0, #0
   9023c:	d05d      	beq.n	902fa <__mdiff+0xd2>
   9023e:	db56      	blt.n	902ee <__mdiff+0xc6>
   90240:	f04f 0a00 	mov.w	sl, #0
   90244:	4628      	mov	r0, r5
   90246:	6861      	ldr	r1, [r4, #4]
   90248:	f7ff fdb6 	bl	8fdb8 <_Balloc>
   9024c:	f109 0314 	add.w	r3, r9, #20
   90250:	4680      	mov	r8, r0
   90252:	461e      	mov	r6, r3
   90254:	6927      	ldr	r7, [r4, #16]
   90256:	f8d9 2010 	ldr.w	r2, [r9, #16]
   9025a:	f104 0e14 	add.w	lr, r4, #20
   9025e:	4675      	mov	r5, lr
   90260:	f8c0 a00c 	str.w	sl, [r0, #12]
   90264:	f100 0414 	add.w	r4, r0, #20
   90268:	eb0e 0e87 	add.w	lr, lr, r7, lsl #2
   9026c:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
   90270:	f04f 0a00 	mov.w	sl, #0
   90274:	f855 2b04 	ldr.w	r2, [r5], #4
   90278:	f856 1b04 	ldr.w	r1, [r6], #4
   9027c:	b290      	uxth	r0, r2
   9027e:	eb00 030a 	add.w	r3, r0, sl
   90282:	b288      	uxth	r0, r1
   90284:	0c09      	lsrs	r1, r1, #16
   90286:	1a1b      	subs	r3, r3, r0
   90288:	ebc1 4212 	rsb	r2, r1, r2, lsr #16
   9028c:	eb02 4223 	add.w	r2, r2, r3, asr #16
   90290:	b29b      	uxth	r3, r3
   90292:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   90296:	45b4      	cmp	ip, r6
   90298:	f844 3b04 	str.w	r3, [r4], #4
   9029c:	ea4f 4a22 	mov.w	sl, r2, asr #16
   902a0:	46a9      	mov	r9, r5
   902a2:	d8e7      	bhi.n	90274 <__mdiff+0x4c>
   902a4:	45ae      	cmp	lr, r5
   902a6:	4626      	mov	r6, r4
   902a8:	d915      	bls.n	902d6 <__mdiff+0xae>
   902aa:	f859 0b04 	ldr.w	r0, [r9], #4
   902ae:	b283      	uxth	r3, r0
   902b0:	4453      	add	r3, sl
   902b2:	0c00      	lsrs	r0, r0, #16
   902b4:	eb00 4123 	add.w	r1, r0, r3, asr #16
   902b8:	b29b      	uxth	r3, r3
   902ba:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   902be:	45ce      	cmp	lr, r9
   902c0:	f844 3b04 	str.w	r3, [r4], #4
   902c4:	ea4f 4a21 	mov.w	sl, r1, asr #16
   902c8:	d8ef      	bhi.n	902aa <__mdiff+0x82>
   902ca:	43ed      	mvns	r5, r5
   902cc:	4475      	add	r5, lr
   902ce:	f025 0403 	bic.w	r4, r5, #3
   902d2:	3404      	adds	r4, #4
   902d4:	4434      	add	r4, r6
   902d6:	3c04      	subs	r4, #4
   902d8:	b923      	cbnz	r3, 902e4 <__mdiff+0xbc>
   902da:	f854 3d04 	ldr.w	r3, [r4, #-4]!
   902de:	3f01      	subs	r7, #1
   902e0:	2b00      	cmp	r3, #0
   902e2:	d0fa      	beq.n	902da <__mdiff+0xb2>
   902e4:	4640      	mov	r0, r8
   902e6:	f8c8 7010 	str.w	r7, [r8, #16]
   902ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   902ee:	4623      	mov	r3, r4
   902f0:	f04f 0a01 	mov.w	sl, #1
   902f4:	464c      	mov	r4, r9
   902f6:	4699      	mov	r9, r3
   902f8:	e7a4      	b.n	90244 <__mdiff+0x1c>
   902fa:	4628      	mov	r0, r5
   902fc:	4631      	mov	r1, r6
   902fe:	f7ff fd5b 	bl	8fdb8 <_Balloc>
   90302:	2301      	movs	r3, #1
   90304:	6146      	str	r6, [r0, #20]
   90306:	6103      	str	r3, [r0, #16]
   90308:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0009030c <__d2b>:
   9030c:	b5f0      	push	{r4, r5, r6, r7, lr}
   9030e:	2101      	movs	r1, #1
   90310:	b083      	sub	sp, #12
   90312:	461c      	mov	r4, r3
   90314:	f3c3 550a 	ubfx	r5, r3, #20, #11
   90318:	4616      	mov	r6, r2
   9031a:	f7ff fd4d 	bl	8fdb8 <_Balloc>
   9031e:	f3c4 0413 	ubfx	r4, r4, #0, #20
   90322:	4607      	mov	r7, r0
   90324:	b10d      	cbz	r5, 9032a <__d2b+0x1e>
   90326:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
   9032a:	9401      	str	r4, [sp, #4]
   9032c:	b306      	cbz	r6, 90370 <__d2b+0x64>
   9032e:	a802      	add	r0, sp, #8
   90330:	f840 6d08 	str.w	r6, [r0, #-8]!
   90334:	f7ff fdd4 	bl	8fee0 <__lo0bits>
   90338:	2800      	cmp	r0, #0
   9033a:	d130      	bne.n	9039e <__d2b+0x92>
   9033c:	e89d 000c 	ldmia.w	sp, {r2, r3}
   90340:	617a      	str	r2, [r7, #20]
   90342:	2b00      	cmp	r3, #0
   90344:	bf14      	ite	ne
   90346:	2402      	movne	r4, #2
   90348:	2401      	moveq	r4, #1
   9034a:	61bb      	str	r3, [r7, #24]
   9034c:	613c      	str	r4, [r7, #16]
   9034e:	b9d5      	cbnz	r5, 90386 <__d2b+0x7a>
   90350:	9a08      	ldr	r2, [sp, #32]
   90352:	eb07 0384 	add.w	r3, r7, r4, lsl #2
   90356:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   9035a:	6010      	str	r0, [r2, #0]
   9035c:	6918      	ldr	r0, [r3, #16]
   9035e:	f7ff fd9f 	bl	8fea0 <__hi0bits>
   90362:	9b09      	ldr	r3, [sp, #36]	; 0x24
   90364:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
   90368:	6018      	str	r0, [r3, #0]
   9036a:	4638      	mov	r0, r7
   9036c:	b003      	add	sp, #12
   9036e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   90370:	a801      	add	r0, sp, #4
   90372:	f7ff fdb5 	bl	8fee0 <__lo0bits>
   90376:	9b01      	ldr	r3, [sp, #4]
   90378:	2201      	movs	r2, #1
   9037a:	4614      	mov	r4, r2
   9037c:	3020      	adds	r0, #32
   9037e:	613a      	str	r2, [r7, #16]
   90380:	617b      	str	r3, [r7, #20]
   90382:	2d00      	cmp	r5, #0
   90384:	d0e4      	beq.n	90350 <__d2b+0x44>
   90386:	f2a5 4333 	subw	r3, r5, #1075	; 0x433
   9038a:	9a08      	ldr	r2, [sp, #32]
   9038c:	4403      	add	r3, r0
   9038e:	6013      	str	r3, [r2, #0]
   90390:	9b09      	ldr	r3, [sp, #36]	; 0x24
   90392:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   90396:	6018      	str	r0, [r3, #0]
   90398:	4638      	mov	r0, r7
   9039a:	b003      	add	sp, #12
   9039c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   9039e:	9b01      	ldr	r3, [sp, #4]
   903a0:	f1c0 0120 	rsb	r1, r0, #32
   903a4:	9a00      	ldr	r2, [sp, #0]
   903a6:	fa03 f101 	lsl.w	r1, r3, r1
   903aa:	430a      	orrs	r2, r1
   903ac:	40c3      	lsrs	r3, r0
   903ae:	9301      	str	r3, [sp, #4]
   903b0:	617a      	str	r2, [r7, #20]
   903b2:	e7c6      	b.n	90342 <__d2b+0x36>

000903b4 <__ssprint_r>:
   903b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   903b8:	6893      	ldr	r3, [r2, #8]
   903ba:	b083      	sub	sp, #12
   903bc:	4691      	mov	r9, r2
   903be:	f8d2 8000 	ldr.w	r8, [r2]
   903c2:	2b00      	cmp	r3, #0
   903c4:	d072      	beq.n	904ac <__ssprint_r+0xf8>
   903c6:	f04f 0b00 	mov.w	fp, #0
   903ca:	460d      	mov	r5, r1
   903cc:	465c      	mov	r4, fp
   903ce:	4607      	mov	r7, r0
   903d0:	688b      	ldr	r3, [r1, #8]
   903d2:	6808      	ldr	r0, [r1, #0]
   903d4:	2c00      	cmp	r4, #0
   903d6:	d045      	beq.n	90464 <__ssprint_r+0xb0>
   903d8:	429c      	cmp	r4, r3
   903da:	461e      	mov	r6, r3
   903dc:	469a      	mov	sl, r3
   903de:	d348      	bcc.n	90472 <__ssprint_r+0xbe>
   903e0:	89ab      	ldrh	r3, [r5, #12]
   903e2:	f413 6f90 	tst.w	r3, #1152	; 0x480
   903e6:	d02d      	beq.n	90444 <__ssprint_r+0x90>
   903e8:	696e      	ldr	r6, [r5, #20]
   903ea:	6929      	ldr	r1, [r5, #16]
   903ec:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   903f0:	ebc1 0a00 	rsb	sl, r1, r0
   903f4:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
   903f8:	1c60      	adds	r0, r4, #1
   903fa:	1076      	asrs	r6, r6, #1
   903fc:	4450      	add	r0, sl
   903fe:	4286      	cmp	r6, r0
   90400:	4632      	mov	r2, r6
   90402:	bf3c      	itt	cc
   90404:	4606      	movcc	r6, r0
   90406:	4632      	movcc	r2, r6
   90408:	055b      	lsls	r3, r3, #21
   9040a:	d535      	bpl.n	90478 <__ssprint_r+0xc4>
   9040c:	4611      	mov	r1, r2
   9040e:	4638      	mov	r0, r7
   90410:	f7fc fbde 	bl	8cbd0 <_malloc_r>
   90414:	2800      	cmp	r0, #0
   90416:	d039      	beq.n	9048c <__ssprint_r+0xd8>
   90418:	4652      	mov	r2, sl
   9041a:	6929      	ldr	r1, [r5, #16]
   9041c:	9001      	str	r0, [sp, #4]
   9041e:	f7fc fe5d 	bl	8d0dc <memcpy>
   90422:	89aa      	ldrh	r2, [r5, #12]
   90424:	9b01      	ldr	r3, [sp, #4]
   90426:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   9042a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   9042e:	81aa      	strh	r2, [r5, #12]
   90430:	ebca 0206 	rsb	r2, sl, r6
   90434:	eb03 000a 	add.w	r0, r3, sl
   90438:	616e      	str	r6, [r5, #20]
   9043a:	46a2      	mov	sl, r4
   9043c:	4626      	mov	r6, r4
   9043e:	612b      	str	r3, [r5, #16]
   90440:	6028      	str	r0, [r5, #0]
   90442:	60aa      	str	r2, [r5, #8]
   90444:	4652      	mov	r2, sl
   90446:	4659      	mov	r1, fp
   90448:	f000 f8b8 	bl	905bc <memmove>
   9044c:	f8d9 2008 	ldr.w	r2, [r9, #8]
   90450:	68ab      	ldr	r3, [r5, #8]
   90452:	6828      	ldr	r0, [r5, #0]
   90454:	1b9b      	subs	r3, r3, r6
   90456:	4450      	add	r0, sl
   90458:	1b14      	subs	r4, r2, r4
   9045a:	60ab      	str	r3, [r5, #8]
   9045c:	6028      	str	r0, [r5, #0]
   9045e:	f8c9 4008 	str.w	r4, [r9, #8]
   90462:	b31c      	cbz	r4, 904ac <__ssprint_r+0xf8>
   90464:	f8d8 b000 	ldr.w	fp, [r8]
   90468:	f8d8 4004 	ldr.w	r4, [r8, #4]
   9046c:	f108 0808 	add.w	r8, r8, #8
   90470:	e7b0      	b.n	903d4 <__ssprint_r+0x20>
   90472:	4626      	mov	r6, r4
   90474:	46a2      	mov	sl, r4
   90476:	e7e5      	b.n	90444 <__ssprint_r+0x90>
   90478:	4638      	mov	r0, r7
   9047a:	f000 f903 	bl	90684 <_realloc_r>
   9047e:	4603      	mov	r3, r0
   90480:	2800      	cmp	r0, #0
   90482:	d1d5      	bne.n	90430 <__ssprint_r+0x7c>
   90484:	4638      	mov	r0, r7
   90486:	6929      	ldr	r1, [r5, #16]
   90488:	f7ff fb70 	bl	8fb6c <_free_r>
   9048c:	230c      	movs	r3, #12
   9048e:	603b      	str	r3, [r7, #0]
   90490:	89ab      	ldrh	r3, [r5, #12]
   90492:	2200      	movs	r2, #0
   90494:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   90498:	f04f 30ff 	mov.w	r0, #4294967295
   9049c:	81ab      	strh	r3, [r5, #12]
   9049e:	f8c9 2008 	str.w	r2, [r9, #8]
   904a2:	f8c9 2004 	str.w	r2, [r9, #4]
   904a6:	b003      	add	sp, #12
   904a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   904ac:	2000      	movs	r0, #0
   904ae:	f8c9 0004 	str.w	r0, [r9, #4]
   904b2:	b003      	add	sp, #12
   904b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000904b8 <__register_exitproc>:
   904b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   904bc:	4c25      	ldr	r4, [pc, #148]	; (90554 <__register_exitproc+0x9c>)
   904be:	4606      	mov	r6, r0
   904c0:	6825      	ldr	r5, [r4, #0]
   904c2:	4688      	mov	r8, r1
   904c4:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
   904c8:	4692      	mov	sl, r2
   904ca:	4699      	mov	r9, r3
   904cc:	b3c4      	cbz	r4, 90540 <__register_exitproc+0x88>
   904ce:	6860      	ldr	r0, [r4, #4]
   904d0:	281f      	cmp	r0, #31
   904d2:	dc17      	bgt.n	90504 <__register_exitproc+0x4c>
   904d4:	1c41      	adds	r1, r0, #1
   904d6:	b176      	cbz	r6, 904f6 <__register_exitproc+0x3e>
   904d8:	eb04 0380 	add.w	r3, r4, r0, lsl #2
   904dc:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
   904e0:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
   904e4:	2201      	movs	r2, #1
   904e6:	4082      	lsls	r2, r0
   904e8:	4315      	orrs	r5, r2
   904ea:	2e02      	cmp	r6, #2
   904ec:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
   904f0:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
   904f4:	d01e      	beq.n	90534 <__register_exitproc+0x7c>
   904f6:	1c83      	adds	r3, r0, #2
   904f8:	6061      	str	r1, [r4, #4]
   904fa:	2000      	movs	r0, #0
   904fc:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
   90500:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   90504:	4b14      	ldr	r3, [pc, #80]	; (90558 <__register_exitproc+0xa0>)
   90506:	b303      	cbz	r3, 9054a <__register_exitproc+0x92>
   90508:	f44f 70c8 	mov.w	r0, #400	; 0x190
   9050c:	f7fc fb50 	bl	8cbb0 <malloc>
   90510:	4604      	mov	r4, r0
   90512:	b1d0      	cbz	r0, 9054a <__register_exitproc+0x92>
   90514:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
   90518:	2700      	movs	r7, #0
   9051a:	e884 0088 	stmia.w	r4, {r3, r7}
   9051e:	4638      	mov	r0, r7
   90520:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   90524:	2101      	movs	r1, #1
   90526:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
   9052a:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
   9052e:	2e00      	cmp	r6, #0
   90530:	d0e1      	beq.n	904f6 <__register_exitproc+0x3e>
   90532:	e7d1      	b.n	904d8 <__register_exitproc+0x20>
   90534:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   90538:	431a      	orrs	r2, r3
   9053a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
   9053e:	e7da      	b.n	904f6 <__register_exitproc+0x3e>
   90540:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
   90544:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   90548:	e7c1      	b.n	904ce <__register_exitproc+0x16>
   9054a:	f04f 30ff 	mov.w	r0, #4294967295
   9054e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   90552:	bf00      	nop
   90554:	0009215c 	.word	0x0009215c
   90558:	0008cbb1 	.word	0x0008cbb1

0009055c <_calloc_r>:
   9055c:	b510      	push	{r4, lr}
   9055e:	fb02 f101 	mul.w	r1, r2, r1
   90562:	f7fc fb35 	bl	8cbd0 <_malloc_r>
   90566:	4604      	mov	r4, r0
   90568:	b168      	cbz	r0, 90586 <_calloc_r+0x2a>
   9056a:	f850 2c04 	ldr.w	r2, [r0, #-4]
   9056e:	f022 0203 	bic.w	r2, r2, #3
   90572:	3a04      	subs	r2, #4
   90574:	2a24      	cmp	r2, #36	; 0x24
   90576:	d818      	bhi.n	905aa <_calloc_r+0x4e>
   90578:	2a13      	cmp	r2, #19
   9057a:	d806      	bhi.n	9058a <_calloc_r+0x2e>
   9057c:	4603      	mov	r3, r0
   9057e:	2200      	movs	r2, #0
   90580:	601a      	str	r2, [r3, #0]
   90582:	605a      	str	r2, [r3, #4]
   90584:	609a      	str	r2, [r3, #8]
   90586:	4620      	mov	r0, r4
   90588:	bd10      	pop	{r4, pc}
   9058a:	2300      	movs	r3, #0
   9058c:	2a1b      	cmp	r2, #27
   9058e:	6003      	str	r3, [r0, #0]
   90590:	6043      	str	r3, [r0, #4]
   90592:	d90f      	bls.n	905b4 <_calloc_r+0x58>
   90594:	2a24      	cmp	r2, #36	; 0x24
   90596:	6083      	str	r3, [r0, #8]
   90598:	60c3      	str	r3, [r0, #12]
   9059a:	bf05      	ittet	eq
   9059c:	6103      	streq	r3, [r0, #16]
   9059e:	6143      	streq	r3, [r0, #20]
   905a0:	f100 0310 	addne.w	r3, r0, #16
   905a4:	f100 0318 	addeq.w	r3, r0, #24
   905a8:	e7e9      	b.n	9057e <_calloc_r+0x22>
   905aa:	2100      	movs	r1, #0
   905ac:	f7fc fe0c 	bl	8d1c8 <memset>
   905b0:	4620      	mov	r0, r4
   905b2:	bd10      	pop	{r4, pc}
   905b4:	f100 0308 	add.w	r3, r0, #8
   905b8:	e7e1      	b.n	9057e <_calloc_r+0x22>
   905ba:	bf00      	nop

000905bc <memmove>:
   905bc:	4288      	cmp	r0, r1
   905be:	b5f0      	push	{r4, r5, r6, r7, lr}
   905c0:	d90d      	bls.n	905de <memmove+0x22>
   905c2:	188b      	adds	r3, r1, r2
   905c4:	4298      	cmp	r0, r3
   905c6:	d20a      	bcs.n	905de <memmove+0x22>
   905c8:	1881      	adds	r1, r0, r2
   905ca:	2a00      	cmp	r2, #0
   905cc:	d054      	beq.n	90678 <memmove+0xbc>
   905ce:	1a9a      	subs	r2, r3, r2
   905d0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   905d4:	4293      	cmp	r3, r2
   905d6:	f801 4d01 	strb.w	r4, [r1, #-1]!
   905da:	d1f9      	bne.n	905d0 <memmove+0x14>
   905dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   905de:	2a0f      	cmp	r2, #15
   905e0:	d948      	bls.n	90674 <memmove+0xb8>
   905e2:	ea40 0301 	orr.w	r3, r0, r1
   905e6:	079b      	lsls	r3, r3, #30
   905e8:	d147      	bne.n	9067a <memmove+0xbe>
   905ea:	4615      	mov	r5, r2
   905ec:	f100 0410 	add.w	r4, r0, #16
   905f0:	f101 0310 	add.w	r3, r1, #16
   905f4:	f853 6c10 	ldr.w	r6, [r3, #-16]
   905f8:	3d10      	subs	r5, #16
   905fa:	f844 6c10 	str.w	r6, [r4, #-16]
   905fe:	f853 6c0c 	ldr.w	r6, [r3, #-12]
   90602:	2d0f      	cmp	r5, #15
   90604:	f844 6c0c 	str.w	r6, [r4, #-12]
   90608:	f853 6c08 	ldr.w	r6, [r3, #-8]
   9060c:	f104 0410 	add.w	r4, r4, #16
   90610:	f844 6c18 	str.w	r6, [r4, #-24]
   90614:	f853 6c04 	ldr.w	r6, [r3, #-4]
   90618:	f103 0310 	add.w	r3, r3, #16
   9061c:	f844 6c14 	str.w	r6, [r4, #-20]
   90620:	d8e8      	bhi.n	905f4 <memmove+0x38>
   90622:	f1a2 0310 	sub.w	r3, r2, #16
   90626:	f023 030f 	bic.w	r3, r3, #15
   9062a:	f002 0e0f 	and.w	lr, r2, #15
   9062e:	3310      	adds	r3, #16
   90630:	f1be 0f03 	cmp.w	lr, #3
   90634:	4419      	add	r1, r3
   90636:	4403      	add	r3, r0
   90638:	d921      	bls.n	9067e <memmove+0xc2>
   9063a:	460e      	mov	r6, r1
   9063c:	4674      	mov	r4, lr
   9063e:	1f1d      	subs	r5, r3, #4
   90640:	f856 7b04 	ldr.w	r7, [r6], #4
   90644:	3c04      	subs	r4, #4
   90646:	2c03      	cmp	r4, #3
   90648:	f845 7f04 	str.w	r7, [r5, #4]!
   9064c:	d8f8      	bhi.n	90640 <memmove+0x84>
   9064e:	f1ae 0404 	sub.w	r4, lr, #4
   90652:	f024 0403 	bic.w	r4, r4, #3
   90656:	3404      	adds	r4, #4
   90658:	4423      	add	r3, r4
   9065a:	4421      	add	r1, r4
   9065c:	f002 0203 	and.w	r2, r2, #3
   90660:	b152      	cbz	r2, 90678 <memmove+0xbc>
   90662:	3b01      	subs	r3, #1
   90664:	440a      	add	r2, r1
   90666:	f811 4b01 	ldrb.w	r4, [r1], #1
   9066a:	4291      	cmp	r1, r2
   9066c:	f803 4f01 	strb.w	r4, [r3, #1]!
   90670:	d1f9      	bne.n	90666 <memmove+0xaa>
   90672:	bdf0      	pop	{r4, r5, r6, r7, pc}
   90674:	4603      	mov	r3, r0
   90676:	e7f3      	b.n	90660 <memmove+0xa4>
   90678:	bdf0      	pop	{r4, r5, r6, r7, pc}
   9067a:	4603      	mov	r3, r0
   9067c:	e7f1      	b.n	90662 <memmove+0xa6>
   9067e:	4672      	mov	r2, lr
   90680:	e7ee      	b.n	90660 <memmove+0xa4>
   90682:	bf00      	nop

00090684 <_realloc_r>:
   90684:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90688:	4617      	mov	r7, r2
   9068a:	b083      	sub	sp, #12
   9068c:	460d      	mov	r5, r1
   9068e:	2900      	cmp	r1, #0
   90690:	f000 80e2 	beq.w	90858 <_realloc_r+0x1d4>
   90694:	4681      	mov	r9, r0
   90696:	f107 040b 	add.w	r4, r7, #11
   9069a:	f7fc fde3 	bl	8d264 <__malloc_lock>
   9069e:	f855 3c04 	ldr.w	r3, [r5, #-4]
   906a2:	2c16      	cmp	r4, #22
   906a4:	f023 0603 	bic.w	r6, r3, #3
   906a8:	f1a5 0808 	sub.w	r8, r5, #8
   906ac:	d84b      	bhi.n	90746 <_realloc_r+0xc2>
   906ae:	2210      	movs	r2, #16
   906b0:	4614      	mov	r4, r2
   906b2:	42a7      	cmp	r7, r4
   906b4:	d84c      	bhi.n	90750 <_realloc_r+0xcc>
   906b6:	4296      	cmp	r6, r2
   906b8:	da51      	bge.n	9075e <_realloc_r+0xda>
   906ba:	f8df b3a4 	ldr.w	fp, [pc, #932]	; 90a60 <_realloc_r+0x3dc>
   906be:	eb08 0106 	add.w	r1, r8, r6
   906c2:	f8db 0008 	ldr.w	r0, [fp, #8]
   906c6:	4288      	cmp	r0, r1
   906c8:	f000 80d3 	beq.w	90872 <_realloc_r+0x1ee>
   906cc:	6848      	ldr	r0, [r1, #4]
   906ce:	f020 0e01 	bic.w	lr, r0, #1
   906d2:	448e      	add	lr, r1
   906d4:	f8de e004 	ldr.w	lr, [lr, #4]
   906d8:	f01e 0f01 	tst.w	lr, #1
   906dc:	d154      	bne.n	90788 <_realloc_r+0x104>
   906de:	f020 0003 	bic.w	r0, r0, #3
   906e2:	4430      	add	r0, r6
   906e4:	4290      	cmp	r0, r2
   906e6:	f280 80bd 	bge.w	90864 <_realloc_r+0x1e0>
   906ea:	07db      	lsls	r3, r3, #31
   906ec:	f100 8090 	bmi.w	90810 <_realloc_r+0x18c>
   906f0:	f855 3c08 	ldr.w	r3, [r5, #-8]
   906f4:	ebc3 0a08 	rsb	sl, r3, r8
   906f8:	f8da 3004 	ldr.w	r3, [sl, #4]
   906fc:	f023 0303 	bic.w	r3, r3, #3
   90700:	eb00 0e03 	add.w	lr, r0, r3
   90704:	4596      	cmp	lr, r2
   90706:	db49      	blt.n	9079c <_realloc_r+0x118>
   90708:	4657      	mov	r7, sl
   9070a:	68cb      	ldr	r3, [r1, #12]
   9070c:	6889      	ldr	r1, [r1, #8]
   9070e:	1f32      	subs	r2, r6, #4
   90710:	60cb      	str	r3, [r1, #12]
   90712:	6099      	str	r1, [r3, #8]
   90714:	f857 1f08 	ldr.w	r1, [r7, #8]!
   90718:	f8da 300c 	ldr.w	r3, [sl, #12]
   9071c:	2a24      	cmp	r2, #36	; 0x24
   9071e:	60cb      	str	r3, [r1, #12]
   90720:	6099      	str	r1, [r3, #8]
   90722:	f200 8133 	bhi.w	9098c <_realloc_r+0x308>
   90726:	2a13      	cmp	r2, #19
   90728:	f240 80fa 	bls.w	90920 <_realloc_r+0x29c>
   9072c:	682b      	ldr	r3, [r5, #0]
   9072e:	2a1b      	cmp	r2, #27
   90730:	f8ca 3008 	str.w	r3, [sl, #8]
   90734:	686b      	ldr	r3, [r5, #4]
   90736:	f8ca 300c 	str.w	r3, [sl, #12]
   9073a:	f200 813b 	bhi.w	909b4 <_realloc_r+0x330>
   9073e:	3508      	adds	r5, #8
   90740:	f10a 0310 	add.w	r3, sl, #16
   90744:	e0ed      	b.n	90922 <_realloc_r+0x29e>
   90746:	f024 0407 	bic.w	r4, r4, #7
   9074a:	2c00      	cmp	r4, #0
   9074c:	4622      	mov	r2, r4
   9074e:	dab0      	bge.n	906b2 <_realloc_r+0x2e>
   90750:	230c      	movs	r3, #12
   90752:	2000      	movs	r0, #0
   90754:	f8c9 3000 	str.w	r3, [r9]
   90758:	b003      	add	sp, #12
   9075a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9075e:	462f      	mov	r7, r5
   90760:	1b32      	subs	r2, r6, r4
   90762:	2a0f      	cmp	r2, #15
   90764:	f003 0301 	and.w	r3, r3, #1
   90768:	d840      	bhi.n	907ec <_realloc_r+0x168>
   9076a:	4333      	orrs	r3, r6
   9076c:	f8c8 3004 	str.w	r3, [r8, #4]
   90770:	4446      	add	r6, r8
   90772:	6873      	ldr	r3, [r6, #4]
   90774:	f043 0301 	orr.w	r3, r3, #1
   90778:	6073      	str	r3, [r6, #4]
   9077a:	4648      	mov	r0, r9
   9077c:	f7fc fd74 	bl	8d268 <__malloc_unlock>
   90780:	4638      	mov	r0, r7
   90782:	b003      	add	sp, #12
   90784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90788:	07d9      	lsls	r1, r3, #31
   9078a:	d441      	bmi.n	90810 <_realloc_r+0x18c>
   9078c:	f855 3c08 	ldr.w	r3, [r5, #-8]
   90790:	ebc3 0a08 	rsb	sl, r3, r8
   90794:	f8da 3004 	ldr.w	r3, [sl, #4]
   90798:	f023 0303 	bic.w	r3, r3, #3
   9079c:	4433      	add	r3, r6
   9079e:	4293      	cmp	r3, r2
   907a0:	db36      	blt.n	90810 <_realloc_r+0x18c>
   907a2:	4657      	mov	r7, sl
   907a4:	f8da 100c 	ldr.w	r1, [sl, #12]
   907a8:	f857 0f08 	ldr.w	r0, [r7, #8]!
   907ac:	1f32      	subs	r2, r6, #4
   907ae:	2a24      	cmp	r2, #36	; 0x24
   907b0:	60c1      	str	r1, [r0, #12]
   907b2:	6088      	str	r0, [r1, #8]
   907b4:	f200 80f5 	bhi.w	909a2 <_realloc_r+0x31e>
   907b8:	2a13      	cmp	r2, #19
   907ba:	f240 80f0 	bls.w	9099e <_realloc_r+0x31a>
   907be:	6829      	ldr	r1, [r5, #0]
   907c0:	2a1b      	cmp	r2, #27
   907c2:	f8ca 1008 	str.w	r1, [sl, #8]
   907c6:	6869      	ldr	r1, [r5, #4]
   907c8:	f8ca 100c 	str.w	r1, [sl, #12]
   907cc:	f200 8107 	bhi.w	909de <_realloc_r+0x35a>
   907d0:	3508      	adds	r5, #8
   907d2:	f10a 0210 	add.w	r2, sl, #16
   907d6:	6829      	ldr	r1, [r5, #0]
   907d8:	461e      	mov	r6, r3
   907da:	6011      	str	r1, [r2, #0]
   907dc:	6869      	ldr	r1, [r5, #4]
   907de:	46d0      	mov	r8, sl
   907e0:	6051      	str	r1, [r2, #4]
   907e2:	68ab      	ldr	r3, [r5, #8]
   907e4:	6093      	str	r3, [r2, #8]
   907e6:	f8da 3004 	ldr.w	r3, [sl, #4]
   907ea:	e7b9      	b.n	90760 <_realloc_r+0xdc>
   907ec:	eb08 0104 	add.w	r1, r8, r4
   907f0:	4323      	orrs	r3, r4
   907f2:	f042 0001 	orr.w	r0, r2, #1
   907f6:	f8c8 3004 	str.w	r3, [r8, #4]
   907fa:	440a      	add	r2, r1
   907fc:	6048      	str	r0, [r1, #4]
   907fe:	6853      	ldr	r3, [r2, #4]
   90800:	3108      	adds	r1, #8
   90802:	f043 0301 	orr.w	r3, r3, #1
   90806:	6053      	str	r3, [r2, #4]
   90808:	4648      	mov	r0, r9
   9080a:	f7ff f9af 	bl	8fb6c <_free_r>
   9080e:	e7b4      	b.n	9077a <_realloc_r+0xf6>
   90810:	4639      	mov	r1, r7
   90812:	4648      	mov	r0, r9
   90814:	f7fc f9dc 	bl	8cbd0 <_malloc_r>
   90818:	4607      	mov	r7, r0
   9081a:	2800      	cmp	r0, #0
   9081c:	d0ad      	beq.n	9077a <_realloc_r+0xf6>
   9081e:	f855 3c04 	ldr.w	r3, [r5, #-4]
   90822:	f1a0 0108 	sub.w	r1, r0, #8
   90826:	f023 0201 	bic.w	r2, r3, #1
   9082a:	4442      	add	r2, r8
   9082c:	4291      	cmp	r1, r2
   9082e:	f000 80a6 	beq.w	9097e <_realloc_r+0x2fa>
   90832:	1f32      	subs	r2, r6, #4
   90834:	2a24      	cmp	r2, #36	; 0x24
   90836:	f200 8093 	bhi.w	90960 <_realloc_r+0x2dc>
   9083a:	2a13      	cmp	r2, #19
   9083c:	d865      	bhi.n	9090a <_realloc_r+0x286>
   9083e:	4603      	mov	r3, r0
   90840:	462a      	mov	r2, r5
   90842:	6811      	ldr	r1, [r2, #0]
   90844:	6019      	str	r1, [r3, #0]
   90846:	6851      	ldr	r1, [r2, #4]
   90848:	6059      	str	r1, [r3, #4]
   9084a:	6892      	ldr	r2, [r2, #8]
   9084c:	609a      	str	r2, [r3, #8]
   9084e:	4629      	mov	r1, r5
   90850:	4648      	mov	r0, r9
   90852:	f7ff f98b 	bl	8fb6c <_free_r>
   90856:	e790      	b.n	9077a <_realloc_r+0xf6>
   90858:	4611      	mov	r1, r2
   9085a:	b003      	add	sp, #12
   9085c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90860:	f7fc b9b6 	b.w	8cbd0 <_malloc_r>
   90864:	68ca      	ldr	r2, [r1, #12]
   90866:	6889      	ldr	r1, [r1, #8]
   90868:	462f      	mov	r7, r5
   9086a:	60ca      	str	r2, [r1, #12]
   9086c:	4606      	mov	r6, r0
   9086e:	6091      	str	r1, [r2, #8]
   90870:	e776      	b.n	90760 <_realloc_r+0xdc>
   90872:	6841      	ldr	r1, [r0, #4]
   90874:	f104 0010 	add.w	r0, r4, #16
   90878:	f021 0103 	bic.w	r1, r1, #3
   9087c:	4431      	add	r1, r6
   9087e:	4281      	cmp	r1, r0
   90880:	da5a      	bge.n	90938 <_realloc_r+0x2b4>
   90882:	07db      	lsls	r3, r3, #31
   90884:	d4c4      	bmi.n	90810 <_realloc_r+0x18c>
   90886:	f855 3c08 	ldr.w	r3, [r5, #-8]
   9088a:	ebc3 0a08 	rsb	sl, r3, r8
   9088e:	f8da 3004 	ldr.w	r3, [sl, #4]
   90892:	f023 0303 	bic.w	r3, r3, #3
   90896:	eb01 0c03 	add.w	ip, r1, r3
   9089a:	4560      	cmp	r0, ip
   9089c:	f73f af7e 	bgt.w	9079c <_realloc_r+0x118>
   908a0:	4657      	mov	r7, sl
   908a2:	f8da 300c 	ldr.w	r3, [sl, #12]
   908a6:	f857 1f08 	ldr.w	r1, [r7, #8]!
   908aa:	1f32      	subs	r2, r6, #4
   908ac:	2a24      	cmp	r2, #36	; 0x24
   908ae:	60cb      	str	r3, [r1, #12]
   908b0:	6099      	str	r1, [r3, #8]
   908b2:	f200 80b6 	bhi.w	90a22 <_realloc_r+0x39e>
   908b6:	2a13      	cmp	r2, #19
   908b8:	f240 80a7 	bls.w	90a0a <_realloc_r+0x386>
   908bc:	682b      	ldr	r3, [r5, #0]
   908be:	2a1b      	cmp	r2, #27
   908c0:	f8ca 3008 	str.w	r3, [sl, #8]
   908c4:	686b      	ldr	r3, [r5, #4]
   908c6:	f8ca 300c 	str.w	r3, [sl, #12]
   908ca:	f200 80b3 	bhi.w	90a34 <_realloc_r+0x3b0>
   908ce:	3508      	adds	r5, #8
   908d0:	f10a 0310 	add.w	r3, sl, #16
   908d4:	682a      	ldr	r2, [r5, #0]
   908d6:	601a      	str	r2, [r3, #0]
   908d8:	686a      	ldr	r2, [r5, #4]
   908da:	605a      	str	r2, [r3, #4]
   908dc:	68aa      	ldr	r2, [r5, #8]
   908de:	609a      	str	r2, [r3, #8]
   908e0:	ebc4 030c 	rsb	r3, r4, ip
   908e4:	eb0a 0204 	add.w	r2, sl, r4
   908e8:	f043 0301 	orr.w	r3, r3, #1
   908ec:	f8cb 2008 	str.w	r2, [fp, #8]
   908f0:	6053      	str	r3, [r2, #4]
   908f2:	f8da 3004 	ldr.w	r3, [sl, #4]
   908f6:	4648      	mov	r0, r9
   908f8:	f003 0301 	and.w	r3, r3, #1
   908fc:	431c      	orrs	r4, r3
   908fe:	f8ca 4004 	str.w	r4, [sl, #4]
   90902:	f7fc fcb1 	bl	8d268 <__malloc_unlock>
   90906:	4638      	mov	r0, r7
   90908:	e73b      	b.n	90782 <_realloc_r+0xfe>
   9090a:	682b      	ldr	r3, [r5, #0]
   9090c:	2a1b      	cmp	r2, #27
   9090e:	6003      	str	r3, [r0, #0]
   90910:	686b      	ldr	r3, [r5, #4]
   90912:	6043      	str	r3, [r0, #4]
   90914:	d828      	bhi.n	90968 <_realloc_r+0x2e4>
   90916:	f100 0308 	add.w	r3, r0, #8
   9091a:	f105 0208 	add.w	r2, r5, #8
   9091e:	e790      	b.n	90842 <_realloc_r+0x1be>
   90920:	463b      	mov	r3, r7
   90922:	682a      	ldr	r2, [r5, #0]
   90924:	4676      	mov	r6, lr
   90926:	601a      	str	r2, [r3, #0]
   90928:	686a      	ldr	r2, [r5, #4]
   9092a:	46d0      	mov	r8, sl
   9092c:	605a      	str	r2, [r3, #4]
   9092e:	68aa      	ldr	r2, [r5, #8]
   90930:	609a      	str	r2, [r3, #8]
   90932:	f8da 3004 	ldr.w	r3, [sl, #4]
   90936:	e713      	b.n	90760 <_realloc_r+0xdc>
   90938:	1b0b      	subs	r3, r1, r4
   9093a:	eb08 0204 	add.w	r2, r8, r4
   9093e:	f043 0301 	orr.w	r3, r3, #1
   90942:	f8cb 2008 	str.w	r2, [fp, #8]
   90946:	6053      	str	r3, [r2, #4]
   90948:	f855 3c04 	ldr.w	r3, [r5, #-4]
   9094c:	4648      	mov	r0, r9
   9094e:	f003 0301 	and.w	r3, r3, #1
   90952:	431c      	orrs	r4, r3
   90954:	f845 4c04 	str.w	r4, [r5, #-4]
   90958:	f7fc fc86 	bl	8d268 <__malloc_unlock>
   9095c:	4628      	mov	r0, r5
   9095e:	e710      	b.n	90782 <_realloc_r+0xfe>
   90960:	4629      	mov	r1, r5
   90962:	f7ff fe2b 	bl	905bc <memmove>
   90966:	e772      	b.n	9084e <_realloc_r+0x1ca>
   90968:	68ab      	ldr	r3, [r5, #8]
   9096a:	2a24      	cmp	r2, #36	; 0x24
   9096c:	6083      	str	r3, [r0, #8]
   9096e:	68eb      	ldr	r3, [r5, #12]
   90970:	60c3      	str	r3, [r0, #12]
   90972:	d02b      	beq.n	909cc <_realloc_r+0x348>
   90974:	f100 0310 	add.w	r3, r0, #16
   90978:	f105 0210 	add.w	r2, r5, #16
   9097c:	e761      	b.n	90842 <_realloc_r+0x1be>
   9097e:	f850 2c04 	ldr.w	r2, [r0, #-4]
   90982:	462f      	mov	r7, r5
   90984:	f022 0203 	bic.w	r2, r2, #3
   90988:	4416      	add	r6, r2
   9098a:	e6e9      	b.n	90760 <_realloc_r+0xdc>
   9098c:	4629      	mov	r1, r5
   9098e:	4638      	mov	r0, r7
   90990:	4676      	mov	r6, lr
   90992:	46d0      	mov	r8, sl
   90994:	f7ff fe12 	bl	905bc <memmove>
   90998:	f8da 3004 	ldr.w	r3, [sl, #4]
   9099c:	e6e0      	b.n	90760 <_realloc_r+0xdc>
   9099e:	463a      	mov	r2, r7
   909a0:	e719      	b.n	907d6 <_realloc_r+0x152>
   909a2:	4629      	mov	r1, r5
   909a4:	4638      	mov	r0, r7
   909a6:	461e      	mov	r6, r3
   909a8:	46d0      	mov	r8, sl
   909aa:	f7ff fe07 	bl	905bc <memmove>
   909ae:	f8da 3004 	ldr.w	r3, [sl, #4]
   909b2:	e6d5      	b.n	90760 <_realloc_r+0xdc>
   909b4:	68ab      	ldr	r3, [r5, #8]
   909b6:	2a24      	cmp	r2, #36	; 0x24
   909b8:	f8ca 3010 	str.w	r3, [sl, #16]
   909bc:	68eb      	ldr	r3, [r5, #12]
   909be:	f8ca 3014 	str.w	r3, [sl, #20]
   909c2:	d018      	beq.n	909f6 <_realloc_r+0x372>
   909c4:	3510      	adds	r5, #16
   909c6:	f10a 0318 	add.w	r3, sl, #24
   909ca:	e7aa      	b.n	90922 <_realloc_r+0x29e>
   909cc:	692a      	ldr	r2, [r5, #16]
   909ce:	f100 0318 	add.w	r3, r0, #24
   909d2:	6102      	str	r2, [r0, #16]
   909d4:	6969      	ldr	r1, [r5, #20]
   909d6:	f105 0218 	add.w	r2, r5, #24
   909da:	6141      	str	r1, [r0, #20]
   909dc:	e731      	b.n	90842 <_realloc_r+0x1be>
   909de:	68a9      	ldr	r1, [r5, #8]
   909e0:	2a24      	cmp	r2, #36	; 0x24
   909e2:	f8ca 1010 	str.w	r1, [sl, #16]
   909e6:	68e9      	ldr	r1, [r5, #12]
   909e8:	f8ca 1014 	str.w	r1, [sl, #20]
   909ec:	d00f      	beq.n	90a0e <_realloc_r+0x38a>
   909ee:	3510      	adds	r5, #16
   909f0:	f10a 0218 	add.w	r2, sl, #24
   909f4:	e6ef      	b.n	907d6 <_realloc_r+0x152>
   909f6:	692a      	ldr	r2, [r5, #16]
   909f8:	f10a 0320 	add.w	r3, sl, #32
   909fc:	f8ca 2018 	str.w	r2, [sl, #24]
   90a00:	696a      	ldr	r2, [r5, #20]
   90a02:	3518      	adds	r5, #24
   90a04:	f8ca 201c 	str.w	r2, [sl, #28]
   90a08:	e78b      	b.n	90922 <_realloc_r+0x29e>
   90a0a:	463b      	mov	r3, r7
   90a0c:	e762      	b.n	908d4 <_realloc_r+0x250>
   90a0e:	6929      	ldr	r1, [r5, #16]
   90a10:	f10a 0220 	add.w	r2, sl, #32
   90a14:	f8ca 1018 	str.w	r1, [sl, #24]
   90a18:	6969      	ldr	r1, [r5, #20]
   90a1a:	3518      	adds	r5, #24
   90a1c:	f8ca 101c 	str.w	r1, [sl, #28]
   90a20:	e6d9      	b.n	907d6 <_realloc_r+0x152>
   90a22:	4629      	mov	r1, r5
   90a24:	4638      	mov	r0, r7
   90a26:	f8cd c004 	str.w	ip, [sp, #4]
   90a2a:	f7ff fdc7 	bl	905bc <memmove>
   90a2e:	f8dd c004 	ldr.w	ip, [sp, #4]
   90a32:	e755      	b.n	908e0 <_realloc_r+0x25c>
   90a34:	68ab      	ldr	r3, [r5, #8]
   90a36:	2a24      	cmp	r2, #36	; 0x24
   90a38:	f8ca 3010 	str.w	r3, [sl, #16]
   90a3c:	68eb      	ldr	r3, [r5, #12]
   90a3e:	f8ca 3014 	str.w	r3, [sl, #20]
   90a42:	d003      	beq.n	90a4c <_realloc_r+0x3c8>
   90a44:	3510      	adds	r5, #16
   90a46:	f10a 0318 	add.w	r3, sl, #24
   90a4a:	e743      	b.n	908d4 <_realloc_r+0x250>
   90a4c:	692a      	ldr	r2, [r5, #16]
   90a4e:	f10a 0320 	add.w	r3, sl, #32
   90a52:	f8ca 2018 	str.w	r2, [sl, #24]
   90a56:	696a      	ldr	r2, [r5, #20]
   90a58:	3518      	adds	r5, #24
   90a5a:	f8ca 201c 	str.w	r2, [sl, #28]
   90a5e:	e739      	b.n	908d4 <_realloc_r+0x250>
   90a60:	2000047c 	.word	0x2000047c

00090a64 <__aeabi_uldivmod>:
   90a64:	b953      	cbnz	r3, 90a7c <__aeabi_uldivmod+0x18>
   90a66:	b94a      	cbnz	r2, 90a7c <__aeabi_uldivmod+0x18>
   90a68:	2900      	cmp	r1, #0
   90a6a:	bf08      	it	eq
   90a6c:	2800      	cmpeq	r0, #0
   90a6e:	bf1c      	itt	ne
   90a70:	f04f 31ff 	movne.w	r1, #4294967295
   90a74:	f04f 30ff 	movne.w	r0, #4294967295
   90a78:	f000 b83c 	b.w	90af4 <__aeabi_idiv0>
   90a7c:	b082      	sub	sp, #8
   90a7e:	46ec      	mov	ip, sp
   90a80:	e92d 5000 	stmdb	sp!, {ip, lr}
   90a84:	f000 f81e 	bl	90ac4 <__gnu_uldivmod_helper>
   90a88:	f8dd e004 	ldr.w	lr, [sp, #4]
   90a8c:	b002      	add	sp, #8
   90a8e:	bc0c      	pop	{r2, r3}
   90a90:	4770      	bx	lr
   90a92:	bf00      	nop

00090a94 <__gnu_ldivmod_helper>:
   90a94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   90a98:	9c06      	ldr	r4, [sp, #24]
   90a9a:	4690      	mov	r8, r2
   90a9c:	4606      	mov	r6, r0
   90a9e:	460f      	mov	r7, r1
   90aa0:	461d      	mov	r5, r3
   90aa2:	f000 f829 	bl	90af8 <__divdi3>
   90aa6:	fb08 fc01 	mul.w	ip, r8, r1
   90aaa:	fba8 2300 	umull	r2, r3, r8, r0
   90aae:	fb00 c505 	mla	r5, r0, r5, ip
   90ab2:	1ab2      	subs	r2, r6, r2
   90ab4:	442b      	add	r3, r5
   90ab6:	eb67 0303 	sbc.w	r3, r7, r3
   90aba:	4686      	mov	lr, r0
   90abc:	e9c4 2300 	strd	r2, r3, [r4]
   90ac0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00090ac4 <__gnu_uldivmod_helper>:
   90ac4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   90ac8:	9e08      	ldr	r6, [sp, #32]
   90aca:	4617      	mov	r7, r2
   90acc:	4680      	mov	r8, r0
   90ace:	4689      	mov	r9, r1
   90ad0:	461d      	mov	r5, r3
   90ad2:	f000 f967 	bl	90da4 <__udivdi3>
   90ad6:	fb00 f305 	mul.w	r3, r0, r5
   90ada:	fba0 4507 	umull	r4, r5, r0, r7
   90ade:	fb07 3701 	mla	r7, r7, r1, r3
   90ae2:	ebb8 0404 	subs.w	r4, r8, r4
   90ae6:	443d      	add	r5, r7
   90ae8:	eb69 0505 	sbc.w	r5, r9, r5
   90aec:	e9c6 4500 	strd	r4, r5, [r6]
   90af0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00090af4 <__aeabi_idiv0>:
   90af4:	4770      	bx	lr
   90af6:	bf00      	nop

00090af8 <__divdi3>:
   90af8:	2900      	cmp	r1, #0
   90afa:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   90afe:	f2c0 80a8 	blt.w	90c52 <__divdi3+0x15a>
   90b02:	2600      	movs	r6, #0
   90b04:	2b00      	cmp	r3, #0
   90b06:	f2c0 809e 	blt.w	90c46 <__divdi3+0x14e>
   90b0a:	4681      	mov	r9, r0
   90b0c:	468e      	mov	lr, r1
   90b0e:	4690      	mov	r8, r2
   90b10:	469c      	mov	ip, r3
   90b12:	4617      	mov	r7, r2
   90b14:	4604      	mov	r4, r0
   90b16:	460d      	mov	r5, r1
   90b18:	2b00      	cmp	r3, #0
   90b1a:	d13d      	bne.n	90b98 <__divdi3+0xa0>
   90b1c:	428a      	cmp	r2, r1
   90b1e:	d959      	bls.n	90bd4 <__divdi3+0xdc>
   90b20:	fab2 f382 	clz	r3, r2
   90b24:	b13b      	cbz	r3, 90b36 <__divdi3+0x3e>
   90b26:	f1c3 0220 	rsb	r2, r3, #32
   90b2a:	409d      	lsls	r5, r3
   90b2c:	fa20 f202 	lsr.w	r2, r0, r2
   90b30:	409f      	lsls	r7, r3
   90b32:	4315      	orrs	r5, r2
   90b34:	409c      	lsls	r4, r3
   90b36:	0c39      	lsrs	r1, r7, #16
   90b38:	fbb5 f0f1 	udiv	r0, r5, r1
   90b3c:	fa1f fe87 	uxth.w	lr, r7
   90b40:	fb01 5510 	mls	r5, r1, r0, r5
   90b44:	fb0e f300 	mul.w	r3, lr, r0
   90b48:	0c22      	lsrs	r2, r4, #16
   90b4a:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
   90b4e:	42ab      	cmp	r3, r5
   90b50:	d909      	bls.n	90b66 <__divdi3+0x6e>
   90b52:	19ed      	adds	r5, r5, r7
   90b54:	f100 32ff 	add.w	r2, r0, #4294967295
   90b58:	f080 810b 	bcs.w	90d72 <__divdi3+0x27a>
   90b5c:	42ab      	cmp	r3, r5
   90b5e:	f240 8108 	bls.w	90d72 <__divdi3+0x27a>
   90b62:	3802      	subs	r0, #2
   90b64:	443d      	add	r5, r7
   90b66:	1aed      	subs	r5, r5, r3
   90b68:	fbb5 f3f1 	udiv	r3, r5, r1
   90b6c:	fb01 5513 	mls	r5, r1, r3, r5
   90b70:	fb0e fe03 	mul.w	lr, lr, r3
   90b74:	b2a4      	uxth	r4, r4
   90b76:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
   90b7a:	45ae      	cmp	lr, r5
   90b7c:	d908      	bls.n	90b90 <__divdi3+0x98>
   90b7e:	19ed      	adds	r5, r5, r7
   90b80:	f103 32ff 	add.w	r2, r3, #4294967295
   90b84:	f080 80f7 	bcs.w	90d76 <__divdi3+0x27e>
   90b88:	45ae      	cmp	lr, r5
   90b8a:	f240 80f4 	bls.w	90d76 <__divdi3+0x27e>
   90b8e:	3b02      	subs	r3, #2
   90b90:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   90b94:	2200      	movs	r2, #0
   90b96:	e003      	b.n	90ba0 <__divdi3+0xa8>
   90b98:	428b      	cmp	r3, r1
   90b9a:	d90f      	bls.n	90bbc <__divdi3+0xc4>
   90b9c:	2200      	movs	r2, #0
   90b9e:	4613      	mov	r3, r2
   90ba0:	1c34      	adds	r4, r6, #0
   90ba2:	bf18      	it	ne
   90ba4:	2401      	movne	r4, #1
   90ba6:	4260      	negs	r0, r4
   90ba8:	f04f 0500 	mov.w	r5, #0
   90bac:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
   90bb0:	4058      	eors	r0, r3
   90bb2:	4051      	eors	r1, r2
   90bb4:	1900      	adds	r0, r0, r4
   90bb6:	4169      	adcs	r1, r5
   90bb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   90bbc:	fab3 f283 	clz	r2, r3
   90bc0:	2a00      	cmp	r2, #0
   90bc2:	f040 8089 	bne.w	90cd8 <__divdi3+0x1e0>
   90bc6:	428b      	cmp	r3, r1
   90bc8:	d302      	bcc.n	90bd0 <__divdi3+0xd8>
   90bca:	4580      	cmp	r8, r0
   90bcc:	f200 80e2 	bhi.w	90d94 <__divdi3+0x29c>
   90bd0:	2301      	movs	r3, #1
   90bd2:	e7e5      	b.n	90ba0 <__divdi3+0xa8>
   90bd4:	b912      	cbnz	r2, 90bdc <__divdi3+0xe4>
   90bd6:	2301      	movs	r3, #1
   90bd8:	fbb3 f7f2 	udiv	r7, r3, r2
   90bdc:	fab7 f887 	clz	r8, r7
   90be0:	f1b8 0f00 	cmp.w	r8, #0
   90be4:	d13b      	bne.n	90c5e <__divdi3+0x166>
   90be6:	1bed      	subs	r5, r5, r7
   90be8:	ea4f 4c17 	mov.w	ip, r7, lsr #16
   90bec:	fa1f fe87 	uxth.w	lr, r7
   90bf0:	2201      	movs	r2, #1
   90bf2:	fbb5 f0fc 	udiv	r0, r5, ip
   90bf6:	fb0c 5510 	mls	r5, ip, r0, r5
   90bfa:	fb0e f300 	mul.w	r3, lr, r0
   90bfe:	0c21      	lsrs	r1, r4, #16
   90c00:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
   90c04:	42ab      	cmp	r3, r5
   90c06:	d907      	bls.n	90c18 <__divdi3+0x120>
   90c08:	19ed      	adds	r5, r5, r7
   90c0a:	f100 31ff 	add.w	r1, r0, #4294967295
   90c0e:	d202      	bcs.n	90c16 <__divdi3+0x11e>
   90c10:	42ab      	cmp	r3, r5
   90c12:	f200 80c3 	bhi.w	90d9c <__divdi3+0x2a4>
   90c16:	4608      	mov	r0, r1
   90c18:	1aed      	subs	r5, r5, r3
   90c1a:	fbb5 f3fc 	udiv	r3, r5, ip
   90c1e:	fb0c 5513 	mls	r5, ip, r3, r5
   90c22:	fb0e fe03 	mul.w	lr, lr, r3
   90c26:	b2a4      	uxth	r4, r4
   90c28:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
   90c2c:	45ae      	cmp	lr, r5
   90c2e:	d907      	bls.n	90c40 <__divdi3+0x148>
   90c30:	19ed      	adds	r5, r5, r7
   90c32:	f103 31ff 	add.w	r1, r3, #4294967295
   90c36:	d202      	bcs.n	90c3e <__divdi3+0x146>
   90c38:	45ae      	cmp	lr, r5
   90c3a:	f200 80ad 	bhi.w	90d98 <__divdi3+0x2a0>
   90c3e:	460b      	mov	r3, r1
   90c40:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   90c44:	e7ac      	b.n	90ba0 <__divdi3+0xa8>
   90c46:	4252      	negs	r2, r2
   90c48:	ea6f 0606 	mvn.w	r6, r6
   90c4c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   90c50:	e75b      	b.n	90b0a <__divdi3+0x12>
   90c52:	4240      	negs	r0, r0
   90c54:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   90c58:	f04f 36ff 	mov.w	r6, #4294967295
   90c5c:	e752      	b.n	90b04 <__divdi3+0xc>
   90c5e:	fa07 f708 	lsl.w	r7, r7, r8
   90c62:	f1c8 0220 	rsb	r2, r8, #32
   90c66:	fa25 f302 	lsr.w	r3, r5, r2
   90c6a:	ea4f 4c17 	mov.w	ip, r7, lsr #16
   90c6e:	fbb3 f1fc 	udiv	r1, r3, ip
   90c72:	fa1f fe87 	uxth.w	lr, r7
   90c76:	fb0c 3311 	mls	r3, ip, r1, r3
   90c7a:	fa24 f202 	lsr.w	r2, r4, r2
   90c7e:	fa05 f508 	lsl.w	r5, r5, r8
   90c82:	fb0e f901 	mul.w	r9, lr, r1
   90c86:	432a      	orrs	r2, r5
   90c88:	0c10      	lsrs	r0, r2, #16
   90c8a:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
   90c8e:	4599      	cmp	r9, r3
   90c90:	fa04 f408 	lsl.w	r4, r4, r8
   90c94:	d907      	bls.n	90ca6 <__divdi3+0x1ae>
   90c96:	19db      	adds	r3, r3, r7
   90c98:	f101 30ff 	add.w	r0, r1, #4294967295
   90c9c:	d278      	bcs.n	90d90 <__divdi3+0x298>
   90c9e:	4599      	cmp	r9, r3
   90ca0:	d976      	bls.n	90d90 <__divdi3+0x298>
   90ca2:	3902      	subs	r1, #2
   90ca4:	443b      	add	r3, r7
   90ca6:	ebc9 0303 	rsb	r3, r9, r3
   90caa:	fbb3 f0fc 	udiv	r0, r3, ip
   90cae:	fb0c 3310 	mls	r3, ip, r0, r3
   90cb2:	fb0e f500 	mul.w	r5, lr, r0
   90cb6:	b292      	uxth	r2, r2
   90cb8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
   90cbc:	429d      	cmp	r5, r3
   90cbe:	d907      	bls.n	90cd0 <__divdi3+0x1d8>
   90cc0:	19db      	adds	r3, r3, r7
   90cc2:	f100 32ff 	add.w	r2, r0, #4294967295
   90cc6:	d25f      	bcs.n	90d88 <__divdi3+0x290>
   90cc8:	429d      	cmp	r5, r3
   90cca:	d95d      	bls.n	90d88 <__divdi3+0x290>
   90ccc:	3802      	subs	r0, #2
   90cce:	443b      	add	r3, r7
   90cd0:	1b5d      	subs	r5, r3, r5
   90cd2:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
   90cd6:	e78c      	b.n	90bf2 <__divdi3+0xfa>
   90cd8:	f1c2 0320 	rsb	r3, r2, #32
   90cdc:	fa28 f103 	lsr.w	r1, r8, r3
   90ce0:	fa0c fc02 	lsl.w	ip, ip, r2
   90ce4:	ea41 0c0c 	orr.w	ip, r1, ip
   90ce8:	ea4f 401c 	mov.w	r0, ip, lsr #16
   90cec:	fa2e f103 	lsr.w	r1, lr, r3
   90cf0:	fbb1 f5f0 	udiv	r5, r1, r0
   90cf4:	fa1f f78c 	uxth.w	r7, ip
   90cf8:	fb00 1115 	mls	r1, r0, r5, r1
   90cfc:	fa29 f303 	lsr.w	r3, r9, r3
   90d00:	fa0e fe02 	lsl.w	lr, lr, r2
   90d04:	fb07 f905 	mul.w	r9, r7, r5
   90d08:	ea43 0e0e 	orr.w	lr, r3, lr
   90d0c:	ea4f 431e 	mov.w	r3, lr, lsr #16
   90d10:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   90d14:	4589      	cmp	r9, r1
   90d16:	fa08 f802 	lsl.w	r8, r8, r2
   90d1a:	d908      	bls.n	90d2e <__divdi3+0x236>
   90d1c:	eb11 010c 	adds.w	r1, r1, ip
   90d20:	f105 33ff 	add.w	r3, r5, #4294967295
   90d24:	d232      	bcs.n	90d8c <__divdi3+0x294>
   90d26:	4589      	cmp	r9, r1
   90d28:	d930      	bls.n	90d8c <__divdi3+0x294>
   90d2a:	3d02      	subs	r5, #2
   90d2c:	4461      	add	r1, ip
   90d2e:	ebc9 0101 	rsb	r1, r9, r1
   90d32:	fbb1 f3f0 	udiv	r3, r1, r0
   90d36:	fb00 1113 	mls	r1, r0, r3, r1
   90d3a:	fb07 f703 	mul.w	r7, r7, r3
   90d3e:	fa1f fe8e 	uxth.w	lr, lr
   90d42:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
   90d46:	4577      	cmp	r7, lr
   90d48:	d908      	bls.n	90d5c <__divdi3+0x264>
   90d4a:	eb1e 0e0c 	adds.w	lr, lr, ip
   90d4e:	f103 31ff 	add.w	r1, r3, #4294967295
   90d52:	d217      	bcs.n	90d84 <__divdi3+0x28c>
   90d54:	4577      	cmp	r7, lr
   90d56:	d915      	bls.n	90d84 <__divdi3+0x28c>
   90d58:	3b02      	subs	r3, #2
   90d5a:	44e6      	add	lr, ip
   90d5c:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
   90d60:	fba3 8908 	umull	r8, r9, r3, r8
   90d64:	ebc7 0e0e 	rsb	lr, r7, lr
   90d68:	45ce      	cmp	lr, r9
   90d6a:	d309      	bcc.n	90d80 <__divdi3+0x288>
   90d6c:	d005      	beq.n	90d7a <__divdi3+0x282>
   90d6e:	2200      	movs	r2, #0
   90d70:	e716      	b.n	90ba0 <__divdi3+0xa8>
   90d72:	4610      	mov	r0, r2
   90d74:	e6f7      	b.n	90b66 <__divdi3+0x6e>
   90d76:	4613      	mov	r3, r2
   90d78:	e70a      	b.n	90b90 <__divdi3+0x98>
   90d7a:	4094      	lsls	r4, r2
   90d7c:	4544      	cmp	r4, r8
   90d7e:	d2f6      	bcs.n	90d6e <__divdi3+0x276>
   90d80:	3b01      	subs	r3, #1
   90d82:	e7f4      	b.n	90d6e <__divdi3+0x276>
   90d84:	460b      	mov	r3, r1
   90d86:	e7e9      	b.n	90d5c <__divdi3+0x264>
   90d88:	4610      	mov	r0, r2
   90d8a:	e7a1      	b.n	90cd0 <__divdi3+0x1d8>
   90d8c:	461d      	mov	r5, r3
   90d8e:	e7ce      	b.n	90d2e <__divdi3+0x236>
   90d90:	4601      	mov	r1, r0
   90d92:	e788      	b.n	90ca6 <__divdi3+0x1ae>
   90d94:	4613      	mov	r3, r2
   90d96:	e703      	b.n	90ba0 <__divdi3+0xa8>
   90d98:	3b02      	subs	r3, #2
   90d9a:	e751      	b.n	90c40 <__divdi3+0x148>
   90d9c:	3802      	subs	r0, #2
   90d9e:	443d      	add	r5, r7
   90da0:	e73a      	b.n	90c18 <__divdi3+0x120>
   90da2:	bf00      	nop

00090da4 <__udivdi3>:
   90da4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   90da8:	2b00      	cmp	r3, #0
   90daa:	d144      	bne.n	90e36 <__udivdi3+0x92>
   90dac:	428a      	cmp	r2, r1
   90dae:	4615      	mov	r5, r2
   90db0:	4604      	mov	r4, r0
   90db2:	d94f      	bls.n	90e54 <__udivdi3+0xb0>
   90db4:	fab2 f782 	clz	r7, r2
   90db8:	460e      	mov	r6, r1
   90dba:	b14f      	cbz	r7, 90dd0 <__udivdi3+0x2c>
   90dbc:	f1c7 0320 	rsb	r3, r7, #32
   90dc0:	40b9      	lsls	r1, r7
   90dc2:	fa20 f603 	lsr.w	r6, r0, r3
   90dc6:	fa02 f507 	lsl.w	r5, r2, r7
   90dca:	430e      	orrs	r6, r1
   90dcc:	fa00 f407 	lsl.w	r4, r0, r7
   90dd0:	0c2f      	lsrs	r7, r5, #16
   90dd2:	fbb6 f0f7 	udiv	r0, r6, r7
   90dd6:	fa1f fe85 	uxth.w	lr, r5
   90dda:	fb07 6210 	mls	r2, r7, r0, r6
   90dde:	fb0e f100 	mul.w	r1, lr, r0
   90de2:	0c26      	lsrs	r6, r4, #16
   90de4:	ea46 4302 	orr.w	r3, r6, r2, lsl #16
   90de8:	4299      	cmp	r1, r3
   90dea:	d909      	bls.n	90e00 <__udivdi3+0x5c>
   90dec:	195b      	adds	r3, r3, r5
   90dee:	f100 32ff 	add.w	r2, r0, #4294967295
   90df2:	f080 80ee 	bcs.w	90fd2 <__udivdi3+0x22e>
   90df6:	4299      	cmp	r1, r3
   90df8:	f240 80eb 	bls.w	90fd2 <__udivdi3+0x22e>
   90dfc:	3802      	subs	r0, #2
   90dfe:	442b      	add	r3, r5
   90e00:	1a59      	subs	r1, r3, r1
   90e02:	fbb1 f3f7 	udiv	r3, r1, r7
   90e06:	fb07 1113 	mls	r1, r7, r3, r1
   90e0a:	fb0e fe03 	mul.w	lr, lr, r3
   90e0e:	b2a4      	uxth	r4, r4
   90e10:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
   90e14:	458e      	cmp	lr, r1
   90e16:	d908      	bls.n	90e2a <__udivdi3+0x86>
   90e18:	1949      	adds	r1, r1, r5
   90e1a:	f103 32ff 	add.w	r2, r3, #4294967295
   90e1e:	f080 80da 	bcs.w	90fd6 <__udivdi3+0x232>
   90e22:	458e      	cmp	lr, r1
   90e24:	f240 80d7 	bls.w	90fd6 <__udivdi3+0x232>
   90e28:	3b02      	subs	r3, #2
   90e2a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   90e2e:	2600      	movs	r6, #0
   90e30:	4631      	mov	r1, r6
   90e32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   90e36:	428b      	cmp	r3, r1
   90e38:	d847      	bhi.n	90eca <__udivdi3+0x126>
   90e3a:	fab3 f683 	clz	r6, r3
   90e3e:	2e00      	cmp	r6, #0
   90e40:	d148      	bne.n	90ed4 <__udivdi3+0x130>
   90e42:	428b      	cmp	r3, r1
   90e44:	d302      	bcc.n	90e4c <__udivdi3+0xa8>
   90e46:	4282      	cmp	r2, r0
   90e48:	f200 80cf 	bhi.w	90fea <__udivdi3+0x246>
   90e4c:	2001      	movs	r0, #1
   90e4e:	4631      	mov	r1, r6
   90e50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   90e54:	b912      	cbnz	r2, 90e5c <__udivdi3+0xb8>
   90e56:	2501      	movs	r5, #1
   90e58:	fbb5 f5f2 	udiv	r5, r5, r2
   90e5c:	fab5 fc85 	clz	ip, r5
   90e60:	f1bc 0f00 	cmp.w	ip, #0
   90e64:	d178      	bne.n	90f58 <__udivdi3+0x1b4>
   90e66:	1b49      	subs	r1, r1, r5
   90e68:	0c2f      	lsrs	r7, r5, #16
   90e6a:	fa1f fe85 	uxth.w	lr, r5
   90e6e:	2601      	movs	r6, #1
   90e70:	fbb1 f0f7 	udiv	r0, r1, r7
   90e74:	fb07 1110 	mls	r1, r7, r0, r1
   90e78:	fb0e f200 	mul.w	r2, lr, r0
   90e7c:	0c23      	lsrs	r3, r4, #16
   90e7e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   90e82:	428a      	cmp	r2, r1
   90e84:	d907      	bls.n	90e96 <__udivdi3+0xf2>
   90e86:	1949      	adds	r1, r1, r5
   90e88:	f100 33ff 	add.w	r3, r0, #4294967295
   90e8c:	d202      	bcs.n	90e94 <__udivdi3+0xf0>
   90e8e:	428a      	cmp	r2, r1
   90e90:	f200 80bc 	bhi.w	9100c <__udivdi3+0x268>
   90e94:	4618      	mov	r0, r3
   90e96:	1a89      	subs	r1, r1, r2
   90e98:	fbb1 f3f7 	udiv	r3, r1, r7
   90e9c:	fb07 1113 	mls	r1, r7, r3, r1
   90ea0:	fb0e fe03 	mul.w	lr, lr, r3
   90ea4:	b2a4      	uxth	r4, r4
   90ea6:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
   90eaa:	4596      	cmp	lr, r2
   90eac:	d908      	bls.n	90ec0 <__udivdi3+0x11c>
   90eae:	1952      	adds	r2, r2, r5
   90eb0:	f103 31ff 	add.w	r1, r3, #4294967295
   90eb4:	f080 8091 	bcs.w	90fda <__udivdi3+0x236>
   90eb8:	4596      	cmp	lr, r2
   90eba:	f240 808e 	bls.w	90fda <__udivdi3+0x236>
   90ebe:	3b02      	subs	r3, #2
   90ec0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   90ec4:	4631      	mov	r1, r6
   90ec6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   90eca:	2600      	movs	r6, #0
   90ecc:	4630      	mov	r0, r6
   90ece:	4631      	mov	r1, r6
   90ed0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   90ed4:	f1c6 0420 	rsb	r4, r6, #32
   90ed8:	fa22 f504 	lsr.w	r5, r2, r4
   90edc:	40b3      	lsls	r3, r6
   90ede:	432b      	orrs	r3, r5
   90ee0:	fa21 f704 	lsr.w	r7, r1, r4
   90ee4:	ea4f 4813 	mov.w	r8, r3, lsr #16
   90ee8:	fbb7 fcf8 	udiv	ip, r7, r8
   90eec:	fa1f f983 	uxth.w	r9, r3
   90ef0:	fb08 771c 	mls	r7, r8, ip, r7
   90ef4:	fa20 fe04 	lsr.w	lr, r0, r4
   90ef8:	fa01 f506 	lsl.w	r5, r1, r6
   90efc:	fb09 f40c 	mul.w	r4, r9, ip
   90f00:	ea4e 0505 	orr.w	r5, lr, r5
   90f04:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   90f08:	ea4e 4707 	orr.w	r7, lr, r7, lsl #16
   90f0c:	42bc      	cmp	r4, r7
   90f0e:	fa02 f206 	lsl.w	r2, r2, r6
   90f12:	d904      	bls.n	90f1e <__udivdi3+0x17a>
   90f14:	18ff      	adds	r7, r7, r3
   90f16:	f10c 31ff 	add.w	r1, ip, #4294967295
   90f1a:	d368      	bcc.n	90fee <__udivdi3+0x24a>
   90f1c:	468c      	mov	ip, r1
   90f1e:	1b3f      	subs	r7, r7, r4
   90f20:	fbb7 f4f8 	udiv	r4, r7, r8
   90f24:	fb08 7714 	mls	r7, r8, r4, r7
   90f28:	fb09 f904 	mul.w	r9, r9, r4
   90f2c:	b2ad      	uxth	r5, r5
   90f2e:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
   90f32:	4589      	cmp	r9, r1
   90f34:	d904      	bls.n	90f40 <__udivdi3+0x19c>
   90f36:	18c9      	adds	r1, r1, r3
   90f38:	f104 35ff 	add.w	r5, r4, #4294967295
   90f3c:	d35d      	bcc.n	90ffa <__udivdi3+0x256>
   90f3e:	462c      	mov	r4, r5
   90f40:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
   90f44:	fba4 2302 	umull	r2, r3, r4, r2
   90f48:	ebc9 0101 	rsb	r1, r9, r1
   90f4c:	4299      	cmp	r1, r3
   90f4e:	d349      	bcc.n	90fe4 <__udivdi3+0x240>
   90f50:	d045      	beq.n	90fde <__udivdi3+0x23a>
   90f52:	4620      	mov	r0, r4
   90f54:	2600      	movs	r6, #0
   90f56:	e76b      	b.n	90e30 <__udivdi3+0x8c>
   90f58:	f1cc 0420 	rsb	r4, ip, #32
   90f5c:	fa05 f50c 	lsl.w	r5, r5, ip
   90f60:	fa21 f304 	lsr.w	r3, r1, r4
   90f64:	0c2a      	lsrs	r2, r5, #16
   90f66:	fbb3 f6f2 	udiv	r6, r3, r2
   90f6a:	fa1f fe85 	uxth.w	lr, r5
   90f6e:	fb02 3816 	mls	r8, r2, r6, r3
   90f72:	fa20 f704 	lsr.w	r7, r0, r4
   90f76:	fa01 f10c 	lsl.w	r1, r1, ip
   90f7a:	fb0e f906 	mul.w	r9, lr, r6
   90f7e:	430f      	orrs	r7, r1
   90f80:	0c3c      	lsrs	r4, r7, #16
   90f82:	ea44 4308 	orr.w	r3, r4, r8, lsl #16
   90f86:	4599      	cmp	r9, r3
   90f88:	fa00 f40c 	lsl.w	r4, r0, ip
   90f8c:	d907      	bls.n	90f9e <__udivdi3+0x1fa>
   90f8e:	195b      	adds	r3, r3, r5
   90f90:	f106 31ff 	add.w	r1, r6, #4294967295
   90f94:	d238      	bcs.n	91008 <__udivdi3+0x264>
   90f96:	4599      	cmp	r9, r3
   90f98:	d936      	bls.n	91008 <__udivdi3+0x264>
   90f9a:	3e02      	subs	r6, #2
   90f9c:	442b      	add	r3, r5
   90f9e:	ebc9 0303 	rsb	r3, r9, r3
   90fa2:	fbb3 f0f2 	udiv	r0, r3, r2
   90fa6:	fb02 3310 	mls	r3, r2, r0, r3
   90faa:	fb0e f100 	mul.w	r1, lr, r0
   90fae:	b2bf      	uxth	r7, r7
   90fb0:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
   90fb4:	4299      	cmp	r1, r3
   90fb6:	d907      	bls.n	90fc8 <__udivdi3+0x224>
   90fb8:	195b      	adds	r3, r3, r5
   90fba:	f100 37ff 	add.w	r7, r0, #4294967295
   90fbe:	d221      	bcs.n	91004 <__udivdi3+0x260>
   90fc0:	4299      	cmp	r1, r3
   90fc2:	d91f      	bls.n	91004 <__udivdi3+0x260>
   90fc4:	3802      	subs	r0, #2
   90fc6:	442b      	add	r3, r5
   90fc8:	4617      	mov	r7, r2
   90fca:	1a59      	subs	r1, r3, r1
   90fcc:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
   90fd0:	e74e      	b.n	90e70 <__udivdi3+0xcc>
   90fd2:	4610      	mov	r0, r2
   90fd4:	e714      	b.n	90e00 <__udivdi3+0x5c>
   90fd6:	4613      	mov	r3, r2
   90fd8:	e727      	b.n	90e2a <__udivdi3+0x86>
   90fda:	460b      	mov	r3, r1
   90fdc:	e770      	b.n	90ec0 <__udivdi3+0x11c>
   90fde:	40b0      	lsls	r0, r6
   90fe0:	4290      	cmp	r0, r2
   90fe2:	d2b6      	bcs.n	90f52 <__udivdi3+0x1ae>
   90fe4:	1e60      	subs	r0, r4, #1
   90fe6:	2600      	movs	r6, #0
   90fe8:	e722      	b.n	90e30 <__udivdi3+0x8c>
   90fea:	4630      	mov	r0, r6
   90fec:	e720      	b.n	90e30 <__udivdi3+0x8c>
   90fee:	42bc      	cmp	r4, r7
   90ff0:	d994      	bls.n	90f1c <__udivdi3+0x178>
   90ff2:	f1ac 0c02 	sub.w	ip, ip, #2
   90ff6:	441f      	add	r7, r3
   90ff8:	e791      	b.n	90f1e <__udivdi3+0x17a>
   90ffa:	4589      	cmp	r9, r1
   90ffc:	d99f      	bls.n	90f3e <__udivdi3+0x19a>
   90ffe:	3c02      	subs	r4, #2
   91000:	4419      	add	r1, r3
   91002:	e79d      	b.n	90f40 <__udivdi3+0x19c>
   91004:	4638      	mov	r0, r7
   91006:	e7df      	b.n	90fc8 <__udivdi3+0x224>
   91008:	460e      	mov	r6, r1
   9100a:	e7c8      	b.n	90f9e <__udivdi3+0x1fa>
   9100c:	3802      	subs	r0, #2
   9100e:	4429      	add	r1, r5
   91010:	e741      	b.n	90e96 <__udivdi3+0xf2>
   91012:	bf00      	nop

00091014 <LfnOfs>:
   91014:	0301 0705 0e09 1210 1614 1c18 001e 0000     ................

00091024 <tbl_lower.4466>:
   91024:	0061 0062 0063 0064 0065 0066 0067 0068     a.b.c.d.e.f.g.h.
   91034:	0069 006a 006b 006c 006d 006e 006f 0070     i.j.k.l.m.n.o.p.
   91044:	0071 0072 0073 0074 0075 0076 0077 0078     q.r.s.t.u.v.w.x.
   91054:	0079 007a 00a1 00a2 00a3 00a5 00ac 00af     y.z.............
   91064:	00e0 00e1 00e2 00e3 00e4 00e5 00e6 00e7     ................
   91074:	00e8 00e9 00ea 00eb 00ec 00ed 00ee 00ef     ................
   91084:	00f0 00f1 00f2 00f3 00f4 00f5 00f6 00f8     ................
   91094:	00f9 00fa 00fb 00fc 00fd 00fe 00ff 0101     ................
   910a4:	0103 0105 0107 0109 010b 010d 010f 0111     ................
   910b4:	0113 0115 0117 0119 011b 011d 011f 0121     ..............!.
   910c4:	0123 0125 0127 0129 012b 012d 012f 0131     #.%.'.).+.-./.1.
   910d4:	0133 0135 0137 013a 013c 013e 0140 0142     3.5.7.:.<.>.@.B.
   910e4:	0144 0146 0148 014b 014d 014f 0151 0153     D.F.H.K.M.O.Q.S.
   910f4:	0155 0157 0159 015b 015d 015f 0161 0163     U.W.Y.[.]._.a.c.
   91104:	0165 0167 0169 016b 016d 016f 0171 0173     e.g.i.k.m.o.q.s.
   91114:	0175 0177 017a 017c 017e 0192 03b1 03b2     u.w.z.|.~.......
   91124:	03b3 03b4 03b5 03b6 03b7 03b8 03b9 03ba     ................
   91134:	03bb 03bc 03bd 03be 03bf 03c0 03c1 03c3     ................
   91144:	03c4 03c5 03c6 03c7 03c8 03c9 03ca 0430     ..............0.
   91154:	0431 0432 0433 0434 0435 0436 0437 0438     1.2.3.4.5.6.7.8.
   91164:	0439 043a 043b 043c 043d 043e 043f 0440     9.:.;.<.=.>.?.@.
   91174:	0441 0442 0443 0444 0445 0446 0447 0448     A.B.C.D.E.F.G.H.
   91184:	0449 044a 044b 044c 044d 044e 044f 0451     I.J.K.L.M.N.O.Q.
   91194:	0452 0453 0454 0455 0456 0457 0458 0459     R.S.T.U.V.W.X.Y.
   911a4:	045a 045b 045c 045e 045f 2170 2171 2172     Z.[.\.^._.p!q!r!
   911b4:	2173 2174 2175 2176 2177 2178 2179 217a     s!t!u!v!w!x!y!z!
   911c4:	217b 217c 217d 217e 217f ff41 ff42 ff43     {!|!}!~!.!A.B.C.
   911d4:	ff44 ff45 ff46 ff47 ff48 ff49 ff4a ff4b     D.E.F.G.H.I.J.K.
   911e4:	ff4c ff4d ff4e ff4f ff50 ff51 ff52 ff53     L.M.N.O.P.Q.R.S.
   911f4:	ff54 ff55 ff56 ff57 ff58 ff59 ff5a 0000     T.U.V.W.X.Y.Z...

00091204 <tbl_upper.4467>:
   91204:	0041 0042 0043 0044 0045 0046 0047 0048     A.B.C.D.E.F.G.H.
   91214:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
   91224:	0051 0052 0053 0054 0055 0056 0057 0058     Q.R.S.T.U.V.W.X.
   91234:	0059 005a 0021 ffe0 ffe1 ffe5 ffe2 ffe3     Y.Z.!...........
   91244:	00c0 00c1 00c2 00c3 00c4 00c5 00c6 00c7     ................
   91254:	00c8 00c9 00ca 00cb 00cc 00cd 00ce 00cf     ................
   91264:	00d0 00d1 00d2 00d3 00d4 00d5 00d6 00d8     ................
   91274:	00d9 00da 00db 00dc 00dd 00de 0178 0100     ............x...
   91284:	0102 0104 0106 0108 010a 010c 010e 0110     ................
   91294:	0112 0114 0116 0118 011a 011c 011e 0120     .............. .
   912a4:	0122 0124 0126 0128 012a 012c 012e 0130     ".$.&.(.*.,...0.
   912b4:	0132 0134 0136 0139 013b 013d 013f 0141     2.4.6.9.;.=.?.A.
   912c4:	0143 0145 0147 014a 014c 014e 0150 0152     C.E.G.J.L.N.P.R.
   912d4:	0154 0156 0158 015a 015c 015e 0160 0162     T.V.X.Z.\.^.`.b.
   912e4:	0164 0166 0168 016a 016c 016e 0170 0172     d.f.h.j.l.n.p.r.
   912f4:	0174 0176 0179 017b 017d 0191 0391 0392     t.v.y.{.}.......
   91304:	0393 0394 0395 0396 0397 0398 0399 039a     ................
   91314:	039b 039c 039d 039e 039f 03a0 03a1 03a3     ................
   91324:	03a4 03a5 03a6 03a7 03a8 03a9 03aa 0410     ................
   91334:	0411 0412 0413 0414 0415 0416 0417 0418     ................
   91344:	0419 041a 041b 041c 041d 041e 041f 0420     .............. .
   91354:	0421 0422 0423 0424 0425 0426 0427 0428     !.".#.$.%.&.'.(.
   91364:	0429 042a 042b 042c 042d 042e 042f 0401     ).*.+.,.-.../...
   91374:	0402 0403 0404 0405 0406 0407 0408 0409     ................
   91384:	040a 040b 040c 040e 040f 2160 2161 2162     ..........`!a!b!
   91394:	2163 2164 2165 2166 2167 2168 2169 216a     c!d!e!f!g!h!i!j!
   913a4:	216b 216c 216d 216e 216f ff21 ff22 ff23     k!l!m!n!o!!.".#.
   913b4:	ff24 ff25 ff26 ff27 ff28 ff29 ff2a ff2b     $.%.&.'.(.).*.+.
   913c4:	ff2c ff2d ff2e ff2f ff30 ff31 ff32 ff33     ,.-.../.0.1.2.3.
   913d4:	ff34 ff35 ff36 ff37 ff38 ff39 ff3a 0000     4.5.6.7.8.9.:...

000913e4 <excvt.4536>:
   913e4:	9a80 b690 de8e 808f d39d 8a8a 8dd7 8f8e     ................
   913f4:	9190 e291 9599 9795 9997 9b9a 9d9b 9f9e     ................
   91404:	d6b5 e9e0 a4a4 a6a6 a8a8 8daa b8ac afae     ................
   91414:	b1b0 b3b2 b5b4 b7b6 b9b8 bbba bdbc bfbd     ................
   91424:	c1c0 c3c2 c5c4 c6c6 c9c8 cbca cdcc cfce     ................
   91434:	d1d1 d3d2 d5d2 d7d6 d9b7 dbda dddc dfde     ................
   91444:	e1e0 e3e2 d5e3 e6e6 e9e8 ebe8 eded efdd     ................
   91454:	f1f0 f3f2 f5f4 f7f6 f9f8 ebfa fcfc fffe     ................
   91464:	2a22 3c3a 3f3e 7f7c 0000 0000 2c2b 3d3b     "*:<>?|.....+,;=
   91474:	5d5b 0000 4548 5041 253d 6c38 0064 0000     []..HEAP=%8ld...
   91484:	3147 2558 0064 0000 6877 6c69 2865 2931     G1X%d...while(1)
   91494:	0000 0000 6573 2074 7073 6565 0064 0000     ....set speed...
   914a4:	6573 2074 2058 6973 657a 0000 6573 2074     set X size..set 
   914b4:	6361 6563 006c 0000 6553 656c 7463 6620     accel...Select f
   914c4:	6c69 0065 002f 0000 4453 4520 7272 726f     ile./...SD Error
   914d4:	0000 0000 3147 2558 4664 6425 0000 0000     ....G1X%dF%d....
   914e4:	3147 3058 4630 6425 0000 0000 3147 3058     G1X00F%d....G1X0
   914f4:	2546 0064 aaaa abaa aaaa aaaa aaaa abaa     F%d.............
   91504:	aaaa aaaa aaaa abaa aaaa aaaa aaaa abaa     ................
   91514:	aaaa aaaa aaaa bfaa aafa aaaa aaaa ebab     ................
   91524:	aaaf aaaa aaaa abbe faaa aaaa aaaa abea     ................
   91534:	aeaa aaaa abaa abaa abaa aaaa abaa abaa     ................
   91544:	abaa aaaa aeaa abaa aaaa aaea aeaa abaa     ................
   91554:	aaaa aaea baaa abaa aaaa aaba baaa abaa     ................
   91564:	aaaa aaba ffff ffff ffff ffff baaa abaa     ................
   91574:	aaaa aaba baaa abaa aaaa aaba baaa abaa     ................
   91584:	aaaa aaba aeaa abaa aaaa aaea aeaa abaa     ................
   91594:	aaaa aaea abaa abaa abaa aaaa abaa abaa     ................
   915a4:	abaa aaaa aaaa abea aeaa aaaa aaaa abbe     ................
   915b4:	faaa aaaa aaaa ebab aaaf aaaa aaaa bfaa     ................
   915c4:	aafa aaaa aaaa abaa aaaa aaaa aaaa abaa     ................
   915d4:	aaaa aaaa aaaa abaa aaaa aaaa aaaa abaa     ................
   915e4:	aaaa aaaa aaaa abaa aaaa aaaa aaaa aaaa     ................
   915f4:	aaaa aaaa aaea aaaa aaaa aaaa aafa aaaa     ................
   91604:	aaaa aaaa aace aaaa aaaa aaaa aac3 aaaa     ................
   91614:	aaaa aaaa eac0 aaaa aaaa aaaa 3ac0 aaaa     .............:..
   91624:	aaaa aaaa 0ec0 aaaa aaaa aaaa 03c0 aaaa     ................
   91634:	aaaa aaaa 00c0 aaea aaaa aaaa 00c0 aa3a     ..............:.
   91644:	aaaa aaaa 00c0 aa0e aaaa aaaa 00c0 aa03     ................
   91654:	aaaa aaaa 00c0 ea00 aaaa aaaa 00c0 3a00     ...............:
   91664:	aaaa aaaa 00c0 feff aaaa aaaa 30c0 aaea     .............0..
   91674:	aaaa aaaa f0c0 aa3a aaaa aaaa acc3 aa3a     ......:.......:.
   91684:	aaaa aaaa acce aa0e aaaa aaaa abfa aa0e     ................
   91694:	aaaa aaaa abea aa03 aaaa aaaa aaaa aac3     ................
   916a4:	aaaa aaaa aaaa aac3 aaaa aaaa aaaa aabf     ................
   916b4:	aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa     ................
   916c4:	aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa     ................
   916d4:	aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa     ................
   916e4:	aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa     ................
   916f4:	aaaa aaaa 001e 0000 001e 0000 0302 0000     ................
   91704:	00f0 0000 0190 0000 01c2 0000 7325 2a25     ............%s%*
   91714:	0073 0000 447e 574f 004e 0000 557e 0050     s...~DOWN...~UP.
   91724:	527e 4749 5448 0000 4c7e 4645 0054 0000     ~RIGHT..~LEFT...
   91734:	437e 0057 437e 5743 0000 0000 616d 6c6c     ~CW.~CCW....mall
   91744:	636f 2928 6520 7272 726f 202e 6f4e 5320     oc() error. No S
   91754:	6170 6563 0000 0000 2d3c 0000 0031 0000     pace....<-..1...
   91764:	0032 0000 0033 0000 0034 0000 0035 0000     2...3...4...5...
   91774:	0036 0000 0037 0000 0038 0000 0039 0000     6...7...8...9...
   91784:	4b4f 0000 725a 9a75 9d69 0000 002c 0000     OK..Zru.i...,...
   91794:	002d 0000 3625 332e 0066 0000 6425 0000     -...%6.3f...%d..
   917a4:	6b6f 0a0d 0000 0000 7265 6f72 3a72 0020     ok......error: .
   917b4:	7845 6570 7463 6465 6320 6d6f 616d 646e     Expected command
   917c4:	6c20 7465 6574 0072 6142 2064 756e 626d      letter.Bad numb
   917d4:	7265 6620 726f 616d 0074 0000 6e49 6176     er format...Inva
   917e4:	696c 2064 7473 7461 6d65 6e65 0074 0000     lid statement...
   917f4:	6156 756c 2065 203c 0030 0000 6553 7474     Value < 0...Sett
   91804:	6e69 2067 6964 6173 6c62 6465 0000 0000     ing disabled....
   91814:	6156 756c 2065 203c 2033 7375 6365 0000     Value < 3 usec..
   91824:	4545 5250 4d4f 7220 6165 2064 6166 6c69     EEPROM read fail
   91834:	202e 7355 6e69 2067 6564 6166 6c75 7374     . Using defaults
   91844:	0000 0000 6f4e 2074 6469 656c 0000 0000     ....Not idle....
   91854:	6c41 7261 206d 6f6c 6b63 0000 6f48 696d     Alarm lock..Homi
   91864:	676e 6e20 746f 6520 616e 6c62 6465 0000     ng not enabled..
   91874:	694c 656e 6f20 6576 6672 6f6c 0077 0000     Line overflow...
   91884:	6f4d 6164 206c 7267 756f 2070 6976 6c6f     Modal group viol
   91894:	7461 6f69 006e 0000 6e55 7573 7070 726f     ation...Unsuppor
   918a4:	6574 2064 6f63 6d6d 6e61 0064 6e55 6564     ted command.Unde
   918b4:	6966 656e 2064 6566 6465 7220 7461 0065     fined feed rate.
   918c4:	6e49 6176 696c 2064 6367 646f 2065 4449     Invalid gcode ID
   918d4:	003a 0000 0a0d 0000 4c41 5241 3a4d 0020     :.......ALARM: .
   918e4:	6148 6472 6c20 6d69 7469 0000 6f53 7466     Hard limit..Soft
   918f4:	6c20 6d69 7469 0000 6241 726f 2074 7564      limit..Abort du
   91904:	6972 676e 6320 6379 656c 0000 7250 626f     ring cycle..Prob
   91914:	2065 6166 6c69 0000 6f48 696d 676e 6620     e fail..Homing f
   91924:	6961 006c 005b 0000 6552 6573 2074 6f74     ail.[...Reset to
   91934:	6320 6e6f 6974 756e 0065 0000 2427 2748      continue...'$H'
   91944:	277c 5824 2027 6f74 7520 6c6e 636f 006b     |'$X' to unlock.
   91954:	6143 7475 6f69 3a6e 5520 6c6e 636f 656b     Caution: Unlocke
   91964:	0064 0000 6e45 6261 656c 0064 6944 6173     d...Enabled.Disa
   91974:	6c62 6465 0000 0000 6843 6365 206b 6f44     bled....Check Do
   91984:	726f 0000 6750 206d 6e45 0064 6552 7473     or..Pgm End.Rest
   91994:	726f 6e69 2067 6564 6166 6c75 7374 0000     oring defaults..
   919a4:	0d5d 000a 0a0d 7247 6c62 3020 392e 206a     ].....Grbl 0.9j 
   919b4:	275b 2724 6620 726f 6820 6c65 5d70 0a0d     ['$' for help]..
   919c4:	0000 0000 2424 2820 6976 7765 4720 6272     ....$$ (view Grb
   919d4:	206c 6573 7474 6e69 7367 0d29 240a 2023     l settings)..$# 
   919e4:	7628 6569 2077 2023 6170 6172 656d 6574     (view # paramete
   919f4:	7372 0d29 240a 2047 7628 6569 2077 6170     rs)..$G (view pa
   91a04:	7372 7265 7320 6174 6574 0d29 240a 2049     rser state)..$I 
   91a14:	7628 6569 2077 7562 6c69 2064 6e69 6f66     (view build info
   91a24:	0d29 240a 204e 7628 6569 2077 7473 7261     )..$N (view star
   91a34:	7574 2070 6c62 636f 736b 0d29 240a 3d78     tup blocks)..$x=
   91a44:	6176 756c 2065 7328 7661 2065 7247 6c62     value (save Grbl
   91a54:	7320 7465 6974 676e 0d29 240a 784e 6c3d      setting)..$Nx=l
   91a64:	6e69 2065 7328 7661 2065 7473 7261 7574     ine (save startu
   91a74:	2070 6c62 636f 296b 0a0d 4324 2820 6863     p block)..$C (ch
   91a84:	6365 206b 6367 646f 2065 6f6d 6564 0d29     eck gcode mode).
   91a94:	240a 2058 6b28 6c69 206c 6c61 7261 206d     .$X (kill alarm 
   91aa4:	6f6c 6b63 0d29 240a 2048 7228 6e75 6820     lock)..$H (run h
   91ab4:	6d6f 6e69 2067 7963 6c63 2965 0a0d 207e     oming cycle)..~ 
   91ac4:	6328 6379 656c 7320 6174 7472 0d29 210a     (cycle start)..!
   91ad4:	2820 6566 6465 6820 6c6f 2964 0a0d 203f      (feed hold)..? 
   91ae4:	6328 7275 6572 746e 7320 6174 7574 2973     (current status)
   91af4:	0a0d 7463 6c72 782d 2820 6572 6573 2074     ..ctrl-x (reset 
   91b04:	7247 6c62 0d29 000a 3024 003d 2820 7473     Grbl)...$0=. (st
   91b14:	7065 7020 6c75 6573 202c 7375 6365 0d29     ep pulse, usec).
   91b24:	240a 3d31 0000 0000 2820 7473 7065 6920     .$1=.... (step i
   91b34:	6c64 2065 6564 616c 2c79 6d20 6573 2963     dle delay, msec)
   91b44:	0a0d 3224 003d 0000 2820 7473 7065 7020     ..$2=... (step p
   91b54:	726f 2074 6e69 6576 7472 6d20 7361 3a6b     ort invert mask:
   91b64:	0000 0000 0d29 240a 3d33 0000 2820 6964     ....)..$3=.. (di
   91b74:	2072 6f70 7472 6920 766e 7265 2074 616d     r port invert ma
   91b84:	6b73 003a 0d29 240a 3d34 0000 2820 7473     sk:.)..$4=.. (st
   91b94:	7065 6520 616e 6c62 2065 6e69 6576 7472     ep enable invert
   91ba4:	202c 6f62 6c6f 0d29 240a 3d35 0000 0000     , bool)..$5=....
   91bb4:	2820 696c 696d 2074 6970 736e 6920 766e      (limit pins inv
   91bc4:	7265 2c74 6220 6f6f 296c 0a0d 3624 003d     ert, bool)..$6=.
   91bd4:	2820 7270 626f 2065 6970 206e 6e69 6576      (probe pin inve
   91be4:	7472 202c 6f62 6c6f 0d29 240a 3031 003d     rt, bool)..$10=.
   91bf4:	2820 7473 7461 7375 7220 7065 726f 2074      (status report 
   91c04:	616d 6b73 003a 0000 0d29 240a 3131 003d     mask:...)..$11=.
   91c14:	2820 756a 636e 6974 6e6f 6420 7665 6169      (junction devia
   91c24:	6974 6e6f 202c 6d6d 0d29 240a 3231 003d     tion, mm)..$12=.
   91c34:	2820 7261 2063 6f74 656c 6172 636e 2c65      (arc tolerance,
   91c44:	6d20 296d 0a0d 3124 3d33 0000 2820 6572      mm)..$13=.. (re
   91c54:	6f70 7472 6920 636e 6568 2c73 6220 6f6f     port inches, boo
   91c64:	296c 0a0d 3224 3d30 0000 0000 2820 6f73     l)..$20=.... (so
   91c74:	7466 6c20 6d69 7469 2c73 6220 6f6f 296c     ft limits, bool)
   91c84:	0a0d 3224 3d31 0000 2820 6168 6472 6c20     ..$21=.. (hard l
   91c94:	6d69 7469 2c73 6220 6f6f 296c 0a0d 3224     imits, bool)..$2
   91ca4:	3d32 0000 2820 6f68 696d 676e 6320 6379     2=.. (homing cyc
   91cb4:	656c 202c 6f62 6c6f 0d29 240a 3332 003d     le, bool)..$23=.
   91cc4:	2820 6f68 696d 676e 6420 7269 6920 766e      (homing dir inv
   91cd4:	7265 2074 616d 6b73 003a 0000 0d29 240a     ert mask:...)..$
   91ce4:	3432 003d 2820 6f68 696d 676e 6620 6565     24=. (homing fee
   91cf4:	2c64 6d20 2f6d 696d 296e 0a0d 3224 3d35     d, mm/min)..$25=
   91d04:	0000 0000 2820 6f68 696d 676e 7320 6565     .... (homing see
   91d14:	2c6b 6d20 2f6d 696d 296e 0a0d 3224 3d36     k, mm/min)..$26=
   91d24:	0000 0000 2820 6f68 696d 676e 6420 6265     .... (homing deb
   91d34:	756f 636e 2c65 6d20 6573 2963 0a0d 3224     ounce, msec)..$2
   91d44:	3d37 0000 2820 6f68 696d 676e 7020 6c75     7=.. (homing pul
   91d54:	2d6c 666f 2c66 6d20 296d 0a0d 0000 0000     l-off, mm)......
   91d64:	0024 0000 2820 0000 0078 0000 0079 0000     $... (..x...y...
   91d74:	007a 0000 202c 7473 7065 6d2f 006d 0000     z..., step/mm...
   91d84:	6d20 7861 7220 7461 2c65 6d20 2f6d 696d      max rate, mm/mi
   91d94:	006e 0000 6120 6363 6c65 202c 6d6d 732f     n... accel, mm/s
   91da4:	6365 325e 0000 0000 6d20 7861 7420 6172     ec^2.... max tra
   91db4:	6576 2c6c 6d20 006d 505b 4252 003a 0000     vel, mm.[PRB:...
   91dc4:	475b 0000 3832 0000 3033 0000 475b 3239     [G..28..30..[G92
   91dd4:	003a 0000 545b 4f4c 003a 0000 3047 0000     :...[TLO:...G0..
   91de4:	3147 0000 3247 0000 3347 0000 3847 0030     G1..G2..G3..G80.
   91df4:	3347 2e38 0000 0000 4720 0000 4720 3731     G38..... G.. G17
   91e04:	0000 0000 4720 3831 0000 0000 4720 3931     .... G18.... G19
   91e14:	0000 0000 4720 3132 0000 0000 4720 3032     .... G21.... G20
   91e24:	0000 0000 4720 3039 0000 0000 4720 3139     .... G90.... G91
   91e34:	0000 0000 4720 3339 0000 0000 4720 3439     .... G93.... G94
   91e44:	0000 0000 4d20 0030 4d20 0031 4d20 0032     .... M0. M1. M2.
   91e54:	4d20 0033 4d20 0034 4d20 0035 4d20 0039      M3. M4. M5. M9.
   91e64:	4d20 0038 5420 0000 4620 0000 4e24 0000      M8. T.. F..$N..
   91e74:	305b 392e 2e6a 3032 3531 3231 3831 003a     [0.9j.20151218:.
   91e84:	655b 6863 3a6f 0020 493c 6c64 0065 0000     [echo: .<Idle...
   91e94:	523c 6e75 0000 0000 483c 6c6f 0064 0000     <Run....<Hold...
   91ea4:	483c 6d6f 0065 0000 413c 616c 6d72 0000     <Home...<Alarm..
   91eb4:	433c 6568 6b63 0000 443c 6f6f 0072 0000     <Check..<Door...
   91ec4:	572c 6f50 3a73 0000 422c 6675 003a 0000     ,WPos:..,Buf:...
   91ed4:	522c 3a58 0000 0000 4c2c 6d69 003a 0000     ,RX:....,Lim:...
   91ee4:	0d3e 000a 4d2c 6f50 3a73 0000 5820 253d     >...,MPos:.. X=%
   91ef4:	3031 332e 2066 3d59 3125 2e30 6633 5a20     10.3f Y=%10.3f Z
   91f04:	253d 3031 332e 0066 2520 0073 4f4e 4620     =%10.3f. %s.NO F
   91f14:	4c49 5345 5359 4554 004d 0000 2e20 002e     ILESYSTEM... ...
   91f24:	4143 434e 4c45 0000 7325 252f 0073 0000     CANCEL..%s/%s...
   91f34:	7173 7472 0000 0000                         sqrt....

00091f3c <npio2_hw>:
   91f3c:	21fb 3ff9 21fb 4009 d97c 4012 21fb 4019     .!.?.!.@|..@.!.@
   91f4c:	6a7a 401f d97c 4022 fdbb 4025 21fb 4029     zj.@|."@..%@.!)@
   91f5c:	463a 402c 6a7a 402f 475c 4031 d97c 4032     :F,@zj/@\G1@|.2@
   91f6c:	6b9c 4034 fdbb 4035 8fdb 4037 21fb 4039     .k4@..5@..7@.!9@
   91f7c:	b41b 403a 463a 403c d85a 403d 6a7a 403f     ..:@:F<@Z.=@zj?@
   91f8c:	7e4c 4040 475c 4041 106c 4042 d97c 4042     L~@@\GA@l.B@|.B@
   91f9c:	a28c 4043 6b9c 4044 34ac 4045 fdbb 4045     ..C@.kD@.4E@..E@
   91fac:	c6cb 4046 8fdb 4047 58eb 4048 21fb 4049     ..F@..G@.XH@.!I@

00091fbc <two_over_pi>:
   91fbc:	f983 00a2 4e44 006e 29fc 0015 57d1 0027     ....DNn..)...W'.
   91fcc:	34dd 00f5 db62 00c0 993c 0095 9041 0043     .4..b...<...A.C.
   91fdc:	5163 00fe debb 00ab 61b7 00c5 6e3a 0024     cQ.......a..:n$.
   91fec:	4dd2 0042 0649 00e0 ea09 002e 921c 00d1     .MB.I...........
   91ffc:	1deb 00fe b129 001c 3ee8 00a7 35f5 0082     ....)....>...5..
   9200c:	bb44 002e e99c 0084 26b4 0070 7e41 005f     D........&p.A~_.
   9201c:	91d6 0039 8353 0039 f49c 0039 5f8b 0084     ..9.S.9...9.._..
   9202c:	f928 00bd 1ff8 003b ffde 0097 980f 0005     (.....;.........
   9203c:	2f11 00ef 5a0a 008b 1f6d 006d 7ecf 0036     ./...Z..m.m..~6.
   9204c:	cb09 0027 4f46 00b7 669e 003f ea2d 005f     ..'.FO...f?.-._.
   9205c:	27ba 0075 ebe5 00c7 7b3d 00f1 39f7 0007     .'u.....={...9..
   9206c:	5292 008a 6bfb 00ea b11f 005f 5d08 008d     .R...k...._..]..
   9207c:	0330 0056 fc7b 0046 abf0 006b bc20 00cf     0.V.{.F...k. ...
   9208c:	f436 009a a9e3 001d 615e 0091 1b08 00e6     6.......^a......
   9209c:	9985 0065 14a0 005f 408d 0068 d880 00ff     ..e..._..@h.....
   920ac:	7327 004d 0606 0031 56ca 0015 a8c9 0073     'sM...1..V....s.
   920bc:	e27b 0060 8c6b 00c0                         {.`.k...

000920c4 <init_jk>:
   920c4:	0002 0000 0003 0000 0004 0000 0006 0000     ................
   920d4:	0000 0000                                   ....

000920d8 <PIo2>:
   920d8:	0000 4000 21fb 3ff9 0000 0000 442d 3e74     ...@.!.?....-Dt>
   920e8:	0000 8000 4698 3cf8 0000 6000 cc51 3b78     .....F.<...`Q.x;
   920f8:	0000 8000 1b83 39f0 0000 4000 2520 387a     .......9...@ %z8
   92108:	0000 8000 8222 36e3 0000 0000 f31d 3569     ...."..6......i5

00092118 <atanlo>:
   92118:	65e2 222f 2b7f 3c7a 5c07 3314 a626 3c81     .e/".+z<.\.3&..<
   92128:	cbbd 7af0 0788 3c70 5c07 3314 a626 3c91     ...z..p<.\.3&..<

00092138 <atanhi>:
   92138:	bb4f 0561 ac67 3fdd 2d18 5444 21fb 3fe9     O.a.g..?.-DT.!.?
   92148:	f69b d281 730b 3fef 2d18 5444 21fb 3ff9     .....s.?.-DT.!.?
   92158:	0043 0000                                   C...

0009215c <_global_impure_ptr>:
   9215c:	0050 2000                                   P.. 

00092160 <zeroes.6911>:
   92160:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

00092170 <blanks.6910>:
   92170:	2020 2020 2020 2020 2020 2020 2020 2020                     
   92180:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
   92190:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
   921a0:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
   921b0:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..

000921c0 <_ctype_>:
   921c0:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   921d0:	2020 2020 2020 2020 2020 2020 2020 2020                     
   921e0:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   921f0:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   92200:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   92210:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   92220:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   92230:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   92240:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
   922c4:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
   922d4:	4f50 4953 0058 0000 002e 0000               POSIX.......

000922e0 <__mprec_tens>:
   922e0:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   922f0:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   92300:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   92310:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   92320:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   92330:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   92340:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   92350:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   92360:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   92370:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   92380:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   92390:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   923a0:	9db4 79d9 7843 44ea                         ...yCx.D

000923a8 <p05.5302>:
   923a8:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

000923b8 <__mprec_bigtens>:
   923b8:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
   923c8:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
   923d8:	bf3c 7f73 4fdd 7515                         <.s..O.u

000923e0 <_init>:
   923e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   923e2:	bf00      	nop
   923e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   923e6:	bc08      	pop	{r3}
   923e8:	469e      	mov	lr, r3
   923ea:	4770      	bx	lr

000923ec <__init_array_start>:
   923ec:	0008eab1 	.word	0x0008eab1

000923f0 <__frame_dummy_init_array_entry>:
   923f0:	00080119                                ....

000923f4 <_fini>:
   923f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   923f6:	bf00      	nop
   923f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   923fa:	bc08      	pop	{r3}
   923fc:	469e      	mov	lr, r3
   923fe:	4770      	bx	lr

00092400 <__fini_array_start>:
   92400:	000800f5 	.word	0x000800f5
